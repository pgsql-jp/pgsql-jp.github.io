<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.15. XML Functions</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-uuid.html" title="9.14. UUID Functions" /><link rel="next" href="functions-json.html" title="9.16. JSON Functions and Operators" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 13.1文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 13.1 &#10;                      functions-xml.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-uuid.html" title="9.14. UUID Functions">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.15. XML Functions</td><td width="20%" align="right"> <a accesskey="n" href="functions-json.html" title="9.16. JSON Functions and Operators">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-XML"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.15. XML Functions</h2></div></div></div><a id="id-1.5.8.21.2" class="indexterm"></a><p>
   The functions and function-like expressions described in this
   section operate on values of type <code class="type">xml</code>.  See <a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a> for information about the <code class="type">xml</code>
   type.  The function-like expressions <code class="function">xmlparse</code>
   and <code class="function">xmlserialize</code> for converting to and from
   type <code class="type">xml</code> are documented there, not in this section.
  </p><p>
   Use of most of these functions
   requires <span class="productname">PostgreSQL</span> to have been built
   with <code class="command">configure --with-libxml</code>.
  </p><div class="sect2" id="FUNCTIONS-PRODUCING-XML"><div class="titlepage"><div><div><h3 class="title">9.15.1. Producing XML Content</h3></div></div></div><p>
    A set of functions and function-like expressions is available for
    producing XML content from SQL data.  As such, they are
    particularly suitable for formatting query results into XML
    documents for processing in client applications.
   </p><div class="sect3" id="id-1.5.8.21.5.3"><div class="titlepage"><div><div><h4 class="title">9.15.1.1. <code class="literal">xmlcomment</code></h4></div></div></div><a id="id-1.5.8.21.5.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlcomment</code> ( <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
     The function <code class="function">xmlcomment</code> creates an XML value
     containing an XML comment with the specified text as content.
     The text cannot contain <span class="quote">「<span class="quote"><code class="literal">--</code></span>」</span> or end with a
     <span class="quote">「<span class="quote"><code class="literal">-</code></span>」</span>, otherwise the resulting construct
     would not be a valid XML comment.
     If the argument is null, the result is null.
    </p><p>
     Example:
</p><pre class="screen">
SELECT xmlcomment('hello');

  xmlcomment
--------------
 &lt;!--hello--&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.21.5.4"><div class="titlepage"><div><div><h4 class="title">9.15.1.2. <code class="literal">xmlconcat</code></h4></div></div></div><a id="id-1.5.8.21.5.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlconcat</code> ( <code class="type">xml</code> [<span class="optional">, ...</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlconcat&lt;/function&gt; concatenates a list
     of individual XML values to create a single value containing an
     XML content fragment.  Null values are omitted; the result is
     only null if there are no nonnull arguments.
</span>
関数<code class="function">xmlconcat</code>は、個々のXML値のリストを結合し、XMLの内容断片を含む単一の値を作成します。
NULL値は削除され、NULL以外の引数が存在しないときのみ結果はNULLになります。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;abc/&gt;', '&lt;bar&gt;foo&lt;/bar&gt;');

      xmlconcat
----------------------
 &lt;abc/&gt;&lt;bar&gt;foo&lt;/bar&gt;
</pre><p>
    </p><p>
<span class="original">
     XML declarations, if present, are combined as follows.  If all
     argument values have the same XML version declaration, that
     version is used in the result, else no version is used.  If all
     argument values have the standalone declaration value
     &lt;quote&gt;yes&lt;/quote&gt;, then that value is used in the result.  If
     all argument values have a standalone declaration value and at
     least one is &lt;quote&gt;no&lt;/quote&gt;, then that is used in the result.
     Else the result will have no standalone declaration.  If the
     result is determined to require a standalone declaration but no
     version declaration, a version declaration with version 1.0 will
     be used because XML requires an XML declaration to contain a
     version declaration.  Encoding declarations are ignored and
     removed in all cases.
</span>
XML宣言が提示されている場合は次のように組み合わされます。
全ての引数の値が同一のXMLversion宣言を持っていれば、そのversionが結果に使用されます。さもなければversionは使用されません。
全ての引数の値でstandaloneの宣言値が<span class="quote">「<span class="quote">yes</span>」</span>であれば、その値が結果に使用されます。
全ての引数の値にstandalone宣言値があり、その中で１つでも<span class="quote">「<span class="quote">no</span>」</span>がある場合、それが結果に使用されます。
それ以外の場合は、結果はstandalone宣言を持ちません。
standalone宣言を必要とするが、standalone宣言がないという結果になった場合には、version 1.0のversion宣言が使用されます。
これはXMLがXML宣言においてversion宣言を含むことを要求するためです。
encoding宣言は無視され、全ての場合で削除されます。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xmlconcat('&lt;?xml version="1.1"?&gt;&lt;foo/&gt;', '&lt;?xml version="1.1" standalone="no"?&gt;&lt;bar/&gt;');

             xmlconcat
-----------------------------------
 &lt;?xml version="1.1"?&gt;&lt;foo/&gt;&lt;bar/&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.21.5.5"><div class="titlepage"><div><div><h4 class="title">9.15.1.3. <code class="literal">xmlelement</code></h4></div></div></div><a id="id-1.5.8.21.5.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlelement</code> ( <code class="literal">NAME</code> <em class="replaceable"><code>name</code></em> [<span class="optional">, <code class="literal">XMLATTRIBUTES</code> ( <em class="replaceable"><code>attvalue</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>attname</code></em> </span>] [<span class="optional">, ...</span>] ) </span>] [<span class="optional">, <em class="replaceable"><code>content</code></em> [<span class="optional">, ...</span>]</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
     The <code class="function">xmlelement</code> expression produces an XML
     element with the given name, attributes, and content.
     The <em class="replaceable"><code>name</code></em>
     and <em class="replaceable"><code>attname</code></em> items shown in the syntax are
     simple identifiers, not values.  The <em class="replaceable"><code>attvalue</code></em>
     and <em class="replaceable"><code>content</code></em> items are expressions, which can
     yield any <span class="productname">PostgreSQL</span> data type.  The
     argument(s) within <code class="literal">XMLATTRIBUTES</code> generate attributes
     of the XML element; the <em class="replaceable"><code>content</code></em> value(s) are
     concatenated to form its content.
    </p><p>
     Examples:
</p><pre class="screen">
SELECT xmlelement(name foo);

 xmlelement
------------
 &lt;foo/&gt;

SELECT xmlelement(name foo, xmlattributes('xyz' as bar));

    xmlelement
------------------
 &lt;foo bar="xyz"/&gt;

SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', 'ent');

             xmlelement
-------------------------------------
 &lt;foo bar="2007-01-26"&gt;content&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     Element and attribute names that are not valid XML names are
     escaped by replacing the offending characters by the sequence
     &lt;literal&gt;_x&lt;replaceable&gt;HHHH&lt;/replaceable&gt;_&lt;/literal&gt;, where
     &lt;replaceable&gt;HHHH&lt;/replaceable&gt; is the character's Unicode
     codepoint in hexadecimal notation.  For example:
</span>
有効なXML名ではない要素名と属性名は、シーケンス<code class="literal">_x<em class="replaceable"><code>HHHH</code></em>_</code>により障害となる文字を置換することでエスケープされます。ここで、<em class="replaceable"><code>HHHH</code></em>は16進数によるその文字のUnicode文字コード番号です。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name "foo$bar", xmlattributes('xyz' as "a&amp;b"));

            xmlelement
----------------------------------
 &lt;foo_x0024_bar a_x0026_b="xyz"/&gt;
</pre><p>
    </p><p>
<span class="original">
     An explicit attribute name need not be specified if the attribute
     value is a column reference, in which case the column's name will
     be used as the attribute name by default.  In other cases, the
     attribute must be given an explicit name.  So this example is
     valid:
</span>
属性値が列参照の場合、明示的な属性名を指定する必要はありません。この場合、デフォルトで列名が属性名として使用されます。
その他の場合には、属性は明示的な名前で与えられなければなりません。
従って、以下の例は有効です。
</p><pre class="screen">
CREATE TABLE test (a xml, b xml);
SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;
</pre><p>
<span class="original">
     But these are not:
</span>
しかし、以下の例は有効ではありません。
</p><pre class="screen">
SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;
SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;
</pre><p>
    </p><p>
<span class="original">
     Element content, if specified, will be formatted according to
     its data type.  If the content is itself of type &lt;type&gt;xml&lt;/type&gt;,
     complex XML documents can be constructed.  For example:
</span>
もし要素内容が指定されればそのデータ型に従って書式化されます。
もし内容そのものが<code class="type">xml</code>型であれば、複合XML文書が構築されます。
例をあげます。
</p><pre class="screen">
SELECT xmlelement(name foo, xmlattributes('xyz' as bar),
                            xmlelement(name abc),
                            xmlcomment('test'),
                            xmlelement(name xyz));

                  xmlelement
----------------------------------------------
 &lt;foo bar="xyz"&gt;&lt;abc/&gt;&lt;!--test--&gt;&lt;xyz/&gt;&lt;/foo&gt;
</pre><p>

<span class="original">
     Content of other types will be formatted into valid XML character
     data.  This means in particular that the characters &amp;lt;, &amp;gt;,
     and &amp;amp; will be converted to entities.  Binary data (data type
     &lt;type&gt;bytea&lt;/type&gt;) will be represented in base64 or hex
     encoding, depending on the setting of the configuration parameter
     &lt;xref linkend="guc-xmlbinary"/&gt;.  The particular behavior for
     individual data types is expected to evolve in order to align the
     PostgreSQL mappings with those specified in SQL:2006 and later,
     as discussed in &lt;xref linkend="functions-xml-limits-casts"/&gt;.
</span>
そのほかの型の内容は有効なXML文字データにフォーマットされます。
これは特に文字&lt;、&gt;、および&amp;がエンティティに変換されることを意味します。
バイナリデータ（データ型は<code class="type">bytea</code>）は、設定パラメータ<a class="xref" href="runtime-config-client.html#GUC-XMLBINARY">xmlbinary</a>の設定にしたがって、base64もしくは16進符号化方式で表現されます。
個々のデータ型に対する特定の動作は、XMLスキーマ仕様でのSQLおよびPostgreSQLデータ型に調整するため発展すると期待されます。
その時点で記述がより詳細になるでしょう。
    </p></div><div class="sect3" id="id-1.5.8.21.5.6"><div class="titlepage"><div><div><h4 class="title">9.15.1.4. <code class="literal">xmlforest</code></h4></div></div></div><a id="id-1.5.8.21.5.6.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlforest</code> ( <em class="replaceable"><code>content</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>name</code></em> </span>] [<span class="optional">, ...</span>] ) → <code class="returnvalue">xml</code>
</pre><p>
     The <code class="function">xmlforest</code> expression produces an XML
     forest (sequence) of elements using the given names and content.
     As for <code class="function">xmlelement</code>,
     each <em class="replaceable"><code>name</code></em> must be a simple identifier, while
     the <em class="replaceable"><code>content</code></em> expressions can have any data
     type.
    </p><p>
     Examples:
</p><pre class="screen">
SELECT xmlforest('abc' AS foo, 123 AS bar);

          xmlforest
------------------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar&gt;123&lt;/bar&gt;


SELECT xmlforest(table_name, column_name)
FROM information_schema.columns
WHERE table_schema = 'pg_catalog';

                                xmlforest
------------------------------------​-----------------------------------
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;​&lt;column_name&gt;rolname&lt;/column_name&gt;
 &lt;table_name&gt;pg_authid&lt;/table_name&gt;​&lt;column_name&gt;rolsuper&lt;/column_name&gt;
 ...
</pre><p>

<span class="original">
     As seen in the second example, the element name can be omitted if
     the content value is a column reference, in which case the column
     name is used by default.  Otherwise, a name must be specified.
</span>
第２の例に見られるように、内容の値が列参照の場合、要素名は省略可能です。この時は、列名がデフォルトで使用されます。
そうでない時は、名前が指定されなければなりません。
    </p><p>
<span class="original">
     Element names that are not valid XML names are escaped as shown
     for &lt;function&gt;xmlelement&lt;/function&gt; above.  Similarly, content
     data is escaped to make valid XML content, unless it is already
     of type &lt;type&gt;xml&lt;/type&gt;.
</span>
有効なXML名ではない要素名は上の<code class="function">xmlelement</code>で説明した通りエスケープされます。
同様にして、既に<code class="type">xml</code>型であるものを除き、内容データは有効なXML内容になるようにエスケープされます。
    </p><p>
<span class="original">
     Note that XML forests are not valid XML documents if they consist
     of more than one element, so it might be useful to wrap
     &lt;function&gt;xmlforest&lt;/function&gt; expressions in
     &lt;function&gt;xmlelement&lt;/function&gt;.
</span>
XMLフォレストは２つ以上の要素からなる場合、有効なXML文書ではないことに注意してください。
したがって、<code class="function">xmlelement</code>内に<code class="function">xmlforest</code>式をラップすることが有用なことがあります。
    </p></div><div class="sect3" id="id-1.5.8.21.5.7"><div class="titlepage"><div><div><h4 class="title">9.15.1.5. <code class="literal">xmlpi</code></h4></div></div></div><a id="id-1.5.8.21.5.7.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlpi</code> ( <code class="literal">NAME</code> <em class="replaceable"><code>name</code></em> [<span class="optional">, <em class="replaceable"><code>content</code></em> </span>] ) → <code class="returnvalue">xml</code>
</pre><p>
     The <code class="function">xmlpi</code> expression creates an XML
     processing instruction.
     As for <code class="function">xmlelement</code>,
     the <em class="replaceable"><code>name</code></em> must be a simple identifier, while
     the <em class="replaceable"><code>content</code></em> expression can have any data type.
     The <em class="replaceable"><code>content</code></em>, if present, must not contain the
     character sequence <code class="literal">?&gt;</code>.
    </p><p>
     Example:
</p><pre class="screen">
SELECT xmlpi(name php, 'echo "hello world";');

            xmlpi
-----------------------------
 &lt;?php echo "hello world";?&gt;
</pre><p>
    </p></div><div class="sect3" id="id-1.5.8.21.5.8"><div class="titlepage"><div><div><h4 class="title">9.15.1.6. <code class="literal">xmlroot</code></h4></div></div></div><a id="id-1.5.8.21.5.8.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlroot</code> ( <code class="type">xml</code>, <code class="literal">VERSION</code> {<code class="type">text</code>|<code class="literal">NO VALUE</code>} [<span class="optional">, <code class="literal">STANDALONE</code> {<code class="literal">YES</code>|<code class="literal">NO</code>|<code class="literal">NO VALUE</code>} </span>] ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The &lt;function&gt;xmlroot&lt;/function&gt; expression alters the properties
     of the root node of an XML value.  If a version is specified,
     it replaces the value in the root node's version declaration; if a
     standalone setting is specified, it replaces the value in the
     root node's standalone declaration.
</span>
<code class="function">xmlroot</code>式はXML値のルートノードの属性を変更します。
versionが指定されていると、ルートノードのversion宣言での値を変更し、standalone設定が指定されていると、ルートノードのstandalone宣言での値を変更します。
    </p><p>
</p><pre class="screen">
SELECT xmlroot(xmlparse(document '&lt;?xml version="1.1"?&gt;&lt;content&gt;abc&lt;/content&gt;'),
               version '1.0', standalone yes);

                xmlroot
----------------------------------------
 &lt;?xml version="1.0" standalone="yes"?&gt;
 &lt;content&gt;abc&lt;/content&gt;
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-XMLAGG"><div class="titlepage"><div><div><h4 class="title">9.15.1.7. <code class="literal">xmlagg</code></h4></div></div></div><a id="id-1.5.8.21.5.9.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xmlagg</code> ( <code class="type">xml</code> ) → <code class="returnvalue">xml</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlagg&lt;/function&gt; is, unlike the other
     functions described here, an aggregate function.  It concatenates the
     input values to the aggregate function call,
     much like &lt;function&gt;xmlconcat&lt;/function&gt; does, except that concatenation
     occurs across rows rather than across expressions in a single row.
     See &lt;xref linkend="functions-aggregate"/&gt; for additional information
     about aggregate functions.
</span>
ここで説明している他の関数とは異なり、<code class="function">xmlagg</code>関数は集約関数です。
これは<code class="function">xmlconcat</code>が行うように、入力値を連結する集約関数ですが、単一行内の複数の式にまたがった連結ではなく、複数行にまたがった連結を行います。
集約関数についての追加情報は<a class="xref" href="functions-aggregate.html" title="9.21. Aggregate Functions">9.21</a>を参照してください。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
CREATE TABLE test (y int, x xml);
INSERT INTO test VALUES (1, '&lt;foo&gt;abc&lt;/foo&gt;');
INSERT INTO test VALUES (2, '&lt;bar/&gt;');
SELECT xmlagg(x) FROM test;
        xmlagg
----------------------
 &lt;foo&gt;abc&lt;/foo&gt;&lt;bar/&gt;
</pre><p>
    </p><p>
<span class="original">
     To determine the order of the concatenation, an &lt;literal&gt;ORDER BY&lt;/literal&gt;
     clause may be added to the aggregate call as described in
     &lt;xref linkend="syntax-aggregates"/&gt;. For example:
</span>
連結の順序を決定するため、<a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 集約式">4.2.7</a>に記述されているように<code class="literal">ORDER BY</code>句を集計呼び出しに追加することができます。
以下は例です。

</p><pre class="screen">
SELECT xmlagg(x ORDER BY y DESC) FROM test;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p><p>
<span class="original">
     The following non-standard approach used to be recommended
     in previous versions, and may still be useful in specific
     cases:
</span>
下記は以前のバージョンで推奨されていた、非標準的な方法例です。特定のケースでは有用かもしれません。

</p><pre class="screen">
SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;
        xmlagg
----------------------
 &lt;bar/&gt;&lt;foo&gt;abc&lt;/foo&gt;
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PREDICATES"><div class="titlepage"><div><div><h3 class="title">9.15.2. XML述語</h3></div></div></div><span class="original">
    &lt;title&gt;XML Predicates&lt;/title&gt;
</span><p>
<span class="original">
     The expressions described in this section check properties
     of &lt;type&gt;xml&lt;/type&gt; values.
</span>
この節で記述されている式は、<code class="type">xml</code>値の属性をチェックします。
    </p><div class="sect3" id="id-1.5.8.21.6.3"><div class="titlepage"><div><div><h4 class="title">9.15.2.1. <code class="literal">IS DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.21.6.3.2" class="indexterm"></a><pre class="synopsis">
<code class="type">xml</code> <code class="literal">IS DOCUMENT</code> → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS DOCUMENT&lt;/literal&gt; returns true if the
     argument XML value is a proper XML document, false if it is not
     (that is, it is a content fragment), or null if the argument is
     null.  See &lt;xref linkend="datatype-xml"/&gt; about the difference
     between documents and content fragments.
</span>
式<code class="literal">IS DOCUMENT</code>は引数XML値が適切なXML文書であれば真を返し、そうでなければ（つまり、内容の断片）偽を返すか、もしくは引数がNULLであればNULLを返します。
文書と内容の断片の差異については<a class="xref" href="datatype-xml.html" title="8.13. XML型">8.13</a>を参照してください。
    </p></div><div class="sect3" id="id-1.5.8.21.6.4"><div class="titlepage"><div><div><h4 class="title">9.15.2.2. <code class="literal">IS NOT DOCUMENT</code></h4></div></div></div><a id="id-1.5.8.21.6.4.2" class="indexterm"></a><pre class="synopsis">
<code class="type">xml</code> <code class="literal">IS NOT DOCUMENT</code> → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The expression &lt;literal&gt;IS NOT DOCUMENT&lt;/literal&gt; returns false if the
     argument XML value is a proper XML document, true if it is not (that is,
     it is a content fragment), or null if the argument is null.
</span>
式<code class="literal">IS NOT DOCUMENT</code>は引数XML値が適切なXML文書であれば偽を返し、そうでなければ（つまり、内容の断片）真を返すか、もしくは引数がNULLであればNULLを返します。
    </p></div><div class="sect3" id="XML-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.15.2.3. <code class="literal">XMLEXISTS</code></h4></div></div></div><a id="id-1.5.8.21.6.5.2" class="indexterm"></a><pre class="synopsis">
<code class="function">XMLEXISTS</code> ( <code class="type">text</code> <code class="literal">PASSING</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] <code class="type">xml</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] ) → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xmlexists&lt;/function&gt; evaluates an XPath 1.0
     expression (the first argument), with the passed XML value as its context
     item.  The function returns false if the result of that evaluation
     yields an empty node-set, true if it yields any other value.  The
     function returns null if any argument is null.  A nonnull value
     passed as the context item must be an XML document, not a content
     fragment or any non-XML value.
</span>
関数<code class="function">xmlexists</code>は渡されたXML値をコンテキスト項目としてXPath 1.0式（第一引数）を評価します。
この関数は評価が空のノード集合を生成する場合には偽を返し、それ以外の値を返すならば真を返します。
もしどれかの引数がNULLであった場合はNULLを返します。
コンテキスト項目として渡される非NULLの値は、内容の断片や非XML値ではなく、XML文書でなければなりません。
    </p><p>
<span class="original">
     Example:
</span>
例:
     </p><pre class="screen">
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY VALUE '&lt;towns&gt;&lt;town&gt;Toronto&lt;/town&gt;&lt;town&gt;Ottawa&lt;/town&gt;&lt;/towns&gt;');

 xmlexists
------------
 t
(1 row)
</pre><p>
    </p><p>
<span class="original">
     The &lt;literal&gt;BY REF&lt;/literal&gt; and &lt;literal&gt;BY VALUE&lt;/literal&gt; clauses
     are accepted in &lt;productname&gt;PostgreSQL&lt;/productname&gt;, but are ignored,
     as discussed in &lt;xref linkend="functions-xml-limits-postgresql"/&gt;.
    &lt;/para&gt;

    &lt;para&gt;
     In the SQL standard, the &lt;function&gt;xmlexists&lt;/function&gt; function
     evaluates an expression in the XML Query language,
     but &lt;productname&gt;PostgreSQL&lt;/productname&gt; allows only an XPath 1.0
     expression, as discussed in
     &lt;xref linkend="functions-xml-limits-xpath1"/&gt;.
</span>
<span class="productname">PostgreSQL</span>は<code class="literal">BY REF</code>句と<code class="literal">BY VALUE</code>句を受け付けますが、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-POSTGRESQL" title="D.3.2. その他の実装の制限">D.3.2</a>で議論されているように無視します。
SQL標準では<code class="function">xmlexists</code>関数はXML問い合わせ言語における式を評価しますが、<a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-XPATH1" title="D.3.1. 問い合わせはXPath 1.0に限定される">D.3.1</a>で議論されているように、<span class="productname">PostgreSQL</span>はXPath 1.0の式だけを受け付けます。
    </p></div><div class="sect3" id="XML-IS-WELL-FORMED"><div class="titlepage"><div><div><h4 class="title">9.15.2.4. <code class="literal">xml_is_well_formed</code></h4></div></div></div><a id="id-1.5.8.21.6.6.2" class="indexterm"></a><a id="id-1.5.8.21.6.6.3" class="indexterm"></a><a id="id-1.5.8.21.6.6.4" class="indexterm"></a><pre class="synopsis">
<code class="function">xml_is_well_formed</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
<code class="function">xml_is_well_formed_document</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
<code class="function">xml_is_well_formed_content</code> ( <code class="type">text</code> ) → <code class="returnvalue">boolean</code>
</pre><p>
     These functions check whether a <code class="type">text</code> string represents
     well-formed XML, returning a Boolean result.
     <code class="function">xml_is_well_formed_document</code> checks for a well-formed
     document, while <code class="function">xml_is_well_formed_content</code> checks
     for well-formed content.  <code class="function">xml_is_well_formed</code> does
     the former if the <a class="xref" href="runtime-config-client.html#GUC-XMLOPTION">xmloption</a> configuration
     parameter is set to <code class="literal">DOCUMENT</code>, or the latter if it is set to
     <code class="literal">CONTENT</code>.  This means that
     <code class="function">xml_is_well_formed</code> is useful for seeing whether
     a simple cast to type <code class="type">xml</code> will succeed, whereas the other two
     functions are useful for seeing whether the corresponding variants of
     <code class="function">XMLPARSE</code> will succeed.
--&gt;
これらの関数は<code class="type">text</code>文字列が整形式かどうかをチェックし、論理値で結果を返します。
<code class="function">xml_is_well_formed_document</code>は文書が整形式かをチェックし、一方<code class="function">xml_is_well_formed_content</code>は内容が整形式かをチェックします。
<code class="function">xml_is_well_formed</code>は、<a class="xref" href="runtime-config-client.html#GUC-XMLOPTION">xmloption</a>パラメータ値が<code class="literal">DOCUMENT</code>に設定されていれば前者を、<code class="literal">CONTENT</code>が設定されていれば後者のチェックを実施します。
これは、<code class="function">xml_is_well_formed</code>は単純な<code class="type">xml</code>型へのキャストが成功するかの判断に有用であり、その他の２つの関数は<code class="function">XMLPARSE</code>の対応による変換が成功するかの判断に有用であることを意味します。
    </p><p>
<span class="original">
     Examples:
</span>
例:

</p><pre class="screen">
SET xmloption TO DOCUMENT;
SELECT xml_is_well_formed('&lt;&gt;');
 xml_is_well_formed 
--------------------
 f
(1 row)

SELECT xml_is_well_formed('&lt;abc/&gt;');
 xml_is_well_formed 
--------------------
 t
(1 row)

SET xmloption TO CONTENT;
SELECT xml_is_well_formed('abc');
 xml_is_well_formed 
--------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/pg:foo&gt;');
 xml_is_well_formed_document 
-----------------------------
 t
(1 row)

SELECT xml_is_well_formed_document('&lt;pg:foo xmlns:pg="http://postgresql.org/stuff"&gt;bar&lt;/my:foo&gt;');
 xml_is_well_formed_document 
-----------------------------
 f
(1 row)
</pre><p>

<span class="original">
     The last example shows that the checks include whether
     namespaces are correctly matched.
</span>
最後の例は、名前空間が正しく一致しているかのチェックも含むことを示しています。
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.15.3. XMLの処理</h3></div></div></div><span class="original">
   &lt;title&gt;Processing XML&lt;/title&gt;
</span><p>
<span class="original">
    To process values of data type &lt;type&gt;xml&lt;/type&gt;, PostgreSQL offers
    the functions &lt;function&gt;xpath&lt;/function&gt; and
    &lt;function&gt;xpath_exists&lt;/function&gt;, which evaluate XPath 1.0
    expressions, and the &lt;function&gt;XMLTABLE&lt;/function&gt;
    table function.
</span>
データ型<code class="type">xml</code>の値を処理するため、PostgreSQLはXPath 1.0式を評価する関数<code class="function">xpath</code>および<code class="function">xpath_exists</code>と、テーブル関数<code class="function">XMLTABLE</code>を提供しています。
   </p><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH"><div class="titlepage"><div><div><h4 class="title">9.15.3.1. <code class="literal">xpath</code></h4></div></div></div><a id="id-1.5.8.21.7.3.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath</code> ( <em class="parameter"><code>xpath</code></em> <code class="type">text</code>, <em class="parameter"><code>xml</code></em> <code class="type">xml</code> [<span class="optional">, <em class="parameter"><code>nsarray</code></em> <code class="type">text[]</code> </span>] ) → <code class="returnvalue">xml[]</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath&lt;/function&gt; evaluates the XPath 1.0
     expression &lt;parameter&gt;xpath&lt;/parameter&gt; (given as text)
     against the XML value
     &lt;parameter&gt;xml&lt;/parameter&gt;.  It returns an array of XML values
     corresponding to the node-set produced by the XPath expression.
     If the XPath expression returns a scalar value rather than a node-set,
     a single-element array is returned.
</span>
関数<code class="function">xpath</code>は、XML値<em class="replaceable"><code>xml</code></em>に対し、XPath 1.0式<em class="replaceable"><code>xpath</code></em>(ひとつの<code class="type">text</code>値)を評価します。
そして、XPath式で作成されたノード集合に対応するXML値の配列を返します。
もし、XPath式がノード集合ではなくスカラー値を返す場合、単一要素の配列が返されます。
    </p><p>
<span class="original">
     The second argument must be a well formed XML document. In particular,
     it must have a single root node element.
</span>
2番目の引数は整形済XML文書でなければなりません。特に、単一のルートノード要素を持たなければなりません。
    </p><p>
<span class="original">
     The optional third argument of the function is an array of namespace
     mappings.  This array should be a two-dimensional &lt;type&gt;text&lt;/type&gt; array with
     the length of the second axis being equal to 2 (i.e., it should be an
     array of arrays, each of which consists of exactly 2 elements).
     The first element of each array entry is the namespace name (alias), the
     second the namespace URI. It is not required that aliases provided in
     this array be the same as those being used in the XML document itself (in
     other words, both in the XML document and in the &lt;function&gt;xpath&lt;/function&gt;
     function context, aliases are &lt;emphasis&gt;local&lt;/emphasis&gt;).
</span>
オプショナルな関数の３番目の引数は名前空間マッピング配列です。
この配列は、第２軸が２に等しい長さをもつ２次元<code class="type">text</code>配列です（つまり、それは配列の配列で、それぞれは正確に２つの要素からなります）。
それぞれの配列のエントリの最初の要素は名前空間の名前（別名）で、２番目は名前空間のURIです。
この配列内で提供される別名がXML文書自身で使用されるものと同じであることは必要ではありません（言い換えると、XML文書内および<code class="function">xpath</code>関数の両方の文脈の中で、別名は<span class="emphasis"><em>ローカル</em></span>です）。
    </p><p>
<span class="original">
     Example:
</span>
例：
</p><pre class="screen">
SELECT xpath('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
             ARRAY[ARRAY['my', 'http://example.com']]);

 xpath  
--------
 {test}
(1 row)
</pre><p>
    </p><p>
<span class="original">
     To deal with default (anonymous) namespaces, do something like this:
</span>
デフォルト(匿名)名前空間を取り扱うためには、以下のようなことを実施してください。
</p><pre class="screen">
SELECT xpath('//mydefns:b/text()', '&lt;a xmlns="http://example.com"&gt;&lt;b&gt;test&lt;/b&gt;&lt;/a&gt;',
             ARRAY[ARRAY['mydefns', 'http://example.com']]);

 xpath
--------
 {test}
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XPATH-EXISTS"><div class="titlepage"><div><div><h4 class="title">9.15.3.2. <code class="literal">xpath_exists</code></h4></div></div></div><a id="id-1.5.8.21.7.4.2" class="indexterm"></a><pre class="synopsis">
<code class="function">xpath_exists</code> ( <em class="parameter"><code>xpath</code></em> <code class="type">text</code>, <em class="parameter"><code>xml</code></em> <code class="type">xml</code> [<span class="optional">, <em class="parameter"><code>nsarray</code></em> <code class="type">text[]</code> </span>] ) → <code class="returnvalue">boolean</code>
</pre><p>
<span class="original">
     The function &lt;function&gt;xpath_exists&lt;/function&gt; is a specialized form
     of the &lt;function&gt;xpath&lt;/function&gt; function.  Instead of returning the
     individual XML values that satisfy the XPath 1.0 expression, this function
     returns a Boolean indicating whether the query was satisfied or not
     (specifically, whether it produced any value other than an empty node-set).
     This function is equivalent to the &lt;literal&gt;XMLEXISTS&lt;/literal&gt; predicate,
     except that it also offers support for a namespace mapping argument.
</span>
関数<code class="function">xpath_exists</code>は、<code class="function">xpath</code>関数の特別な形式です。
この関数は、XPath 1.0を満足する個別のXML値を返す代わりに、問い合わせがそれを満足するかどうか（具体的には空のノード集合以外の値を返すかどうか）を論理値で返します。
この関数は、名前空間にマッピングされた引数をもサポートする点を除き、標準の<code class="literal">XMLEXISTS</code>述語と同じです。
    </p><p>
<span class="original">
     Example:
</span>
例:
</p><pre class="screen">
SELECT xpath_exists('/my:a/text()', '&lt;my:a xmlns:my="http://example.com"&gt;test&lt;/my:a&gt;',
                     ARRAY[ARRAY['my', 'http://example.com']]);

 xpath_exists  
--------------
 t
(1 row)
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-XML-PROCESSING-XMLTABLE"><div class="titlepage"><div><div><h4 class="title">9.15.3.3. <code class="literal">xmltable</code></h4></div></div></div><a id="id-1.5.8.21.7.5.2" class="indexterm"></a><a id="id-1.5.8.21.7.5.3" class="indexterm"></a><pre class="synopsis">
<code class="function">XMLTABLE</code> (
    [<span class="optional"> <code class="literal">XMLNAMESPACES</code> ( <em class="replaceable"><code>namespace_uri</code></em> <code class="literal">AS</code> <em class="replaceable"><code>namespace_name</code></em> [<span class="optional">, ...</span>] ), </span>]
    <em class="replaceable"><code>row_expression</code></em> <code class="literal">PASSING</code> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>] <em class="replaceable"><code>document_expression</code></em> [<span class="optional"><code class="literal">BY</code> {<code class="literal">REF</code>|<code class="literal">VALUE</code>}</span>]
    <code class="literal">COLUMNS</code> <em class="replaceable"><code>name</code></em> { <em class="replaceable"><code>type</code></em> [<span class="optional"><code class="literal">PATH</code> <em class="replaceable"><code>column_expression</code></em></span>] [<span class="optional"><code class="literal">DEFAULT</code> <em class="replaceable"><code>default_expression</code></em></span>] [<span class="optional"><code class="literal">NOT NULL</code> | <code class="literal">NULL</code></span>]
                  | <code class="literal">FOR ORDINALITY</code> }
            [<span class="optional">, ...</span>]
) → <code class="returnvalue">setof record</code>
</pre><p>
     The <code class="function">xmltable</code> expression produces a table based
     on an XML value, an XPath filter to extract rows, and a
     set of column definitions.
     Although it syntactically resembles a function, it can only appear
     as a table in a query's <code class="literal">FROM</code> clause.
    </p><p>
     The optional <code class="literal">XMLNAMESPACES</code> clause gives a
     comma-separated list of namespace definitions, where
     each <em class="replaceable"><code>namespace_uri</code></em> is a <code class="type">text</code>
     expression and each <em class="replaceable"><code>namespace_name</code></em> is a simple
     identifier.  It specifies the XML namespaces used in the document and
     their aliases. A default namespace specification is not currently
     supported.
    </p><p>
     The required <em class="replaceable"><code>row_expression</code></em> argument is an
     XPath 1.0 expression (given as <code class="type">text</code>) that is evaluated,
     passing the XML value <em class="replaceable"><code>document_expression</code></em> as
     its context item, to obtain a set of XML nodes. These nodes are what
     <code class="function">xmltable</code> transforms into output rows. No rows
     will be produced if the <em class="replaceable"><code>document_expression</code></em>
     is null, nor if the <em class="replaceable"><code>row_expression</code></em> produces
     an empty node-set or any value other than a node-set.
--&gt;
必須の<em class="replaceable"><code>row_expression</code></em>引数は評価されるXPath 1.0式で、XMLノード集合を得るために<em class="replaceable"><code>document_expression</code></em>をそのコンテキスト項目として渡します。
このノードは<code class="function">xmltable</code>が出力行に変換します。
<em class="replaceable"><code>document_expression</code></em>がNULLであるか、<em class="replaceable"><code>row_expression</code></em>が空のノード集合あるいはノード集合以外の値を生成するなら行は出力されません。
    </p><p>
     <em class="replaceable"><code>document_expression</code></em> provides the context
     item for the <em class="replaceable"><code>row_expression</code></em>. It must be a
     well-formed XML document; fragments/forests are not accepted.
     The <code class="literal">BY REF</code> and <code class="literal">BY VALUE</code> clauses
     are accepted but ignored, as discussed in
     <a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-POSTGRESQL" title="D.3.2. その他の実装の制限">D.3.2</a>.
    </p><p>
     In the SQL standard, the <code class="function">xmltable</code> function
     evaluates expressions in the XML Query language,
     but <span class="productname">PostgreSQL</span> allows only XPath 1.0
     expressions, as discussed in
     <a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-XPATH1" title="D.3.1. 問い合わせはXPath 1.0に限定される">D.3.1</a>.
    </p><p>
     The required <code class="literal">COLUMNS</code> clause specifies the
     column(s) that will be produced in the output table.
     See the syntax summary above for the format.
     A name is required for each column, as is a data type
     (unless <code class="literal">FOR ORDINALITY</code> is specified, in which case
     type <code class="type">integer</code> is implicit).  The path, default and
     nullability clauses are optional.
    </p><p>
     A column marked <code class="literal">FOR ORDINALITY</code> will be populated
     with row numbers, starting with 1, in the order of nodes retrieved from
     the <em class="replaceable"><code>row_expression</code></em>'s result node-set.
     At most one column may be marked <code class="literal">FOR ORDINALITY</code>.
    </p><div class="note"><h3 class="title">注記</h3><p>
      XPath 1.0 does not specify an order for nodes in a node-set, so code
      that relies on a particular order of the results will be
      implementation-dependent.  Details can be found in
      <a class="xref" href="xml-limits-conformance.html#XML-XPATH-1-SPECIFICS" title="D.3.1.2. XPathが1.0であることによる制限">D.3.1.2</a>.
     </p></div><p>
     The <em class="replaceable"><code>column_expression</code></em> for a column is an
     XPath 1.0 expression that is evaluated for each row, with the current
     node from the <em class="replaceable"><code>row_expression</code></em> result as its
     context item, to find the value of the column.  If
     no <em class="replaceable"><code>column_expression</code></em> is given, then the
     column name is used as an implicit path.
    </p><p>
<span class="original">
     If a column's XPath expression returns a non-XML value (which is limited
     to string, boolean, or double in XPath 1.0) and the column has a
     PostgreSQL type other than &lt;type&gt;xml&lt;/type&gt;, the column will be set
     as if by assigning the value's string representation to the PostgreSQL
     type.  (If the value is a boolean, its string representation is taken
     to be &lt;literal&gt;1&lt;/literal&gt; or &lt;literal&gt;0&lt;/literal&gt; if the output
     column's type category is numeric, otherwise &lt;literal&gt;true&lt;/literal&gt; or
     &lt;literal&gt;false&lt;/literal&gt;.)
</span>
列のXPath式が非XML値（XPath 1.0における文字列、真偽値、倍精度浮動小数点数に限られます）を返し、その列が<code class="type">xml</code>以外のPostgreSQL型なら、あたかも値の文字列表現をPostgreSQL型にアサインしたように列に値がセットされます。
（値が真偽値の場合、出力列型が数値カテゴリに属するならその文字列表現は<code class="literal">1</code>または<code class="literal">0</code>になり、それ外なら<code class="literal">true</code>または<code class="literal">false</code>になります。）
    </p><p>
<span class="original">
     If a column's XPath expression returns a non-empty set of XML nodes
     and the column's PostgreSQL type is &lt;type&gt;xml&lt;/type&gt;, the column will
     be assigned the expression result exactly, if it is of document or
     content form.
</span>
列のXPath表現が空ではないXMLノードの集合を返し、列のPostgreSQL型が<code class="type">xml</code>である場合には、式が文書あるいはフォームの内容なら、列には正確に式の結果がアサインされます。
     <a href="#ftn.id-1.5.8.21.7.5.15.2" class="footnote"><sup class="footnote" id="id-1.5.8.21.7.5.15.2">[7]</sup></a>
    </p><p>
<span class="original">
     A non-XML result assigned to an &lt;type&gt;xml&lt;/type&gt; output column produces
     content, a single text node with the string value of the result.
     An XML result assigned to a column of any other type may not have more than
     one node, or an error is raised. If there is exactly one node, the column
     will be set as if by assigning the node's string
     value (as defined for the XPath 1.0 &lt;function&gt;string&lt;/function&gt; function)
     to the PostgreSQL type.
</span>
<code class="type">xml</code>出力列にアサインされた非XMLの結果は、結果の値が文字列値となる単一のテキストノードであるコンテントを生成します。
それ以外の型の列にアサインされたXMLの結果は複数のノードを持たないかも知れませんし、エラーを生じするかも知れません。
正確に一つのノードだけが存在するなら、列にはあたかもノードの文字列値（XPath 1.0 <code class="function">string</code>関数の定義されているように） がPostgreSQL型にアサインされたように設定されます。
    </p><p>
     The string value of an XML element is the concatenation, in document order,
     of all text nodes contained in that element and its descendants. The string
     value of an element with no descendant text nodes is an
     empty string (not <code class="literal">NULL</code>).
     Any <code class="literal">xsi:nil</code> attributes are ignored.
     Note that the whitespace-only <code class="literal">text()</code> node between two non-text
     elements is preserved, and that leading whitespace on a <code class="literal">text()</code>
     node is not flattened.
     The XPath 1.0 <code class="function">string</code> function may be consulted for the
     rules defining the string value of other XML node types and non-XML values.
    </p><p>
     The conversion rules presented here are not exactly those of the SQL
     standard, as discussed in <a class="xref" href="xml-limits-conformance.html#FUNCTIONS-XML-LIMITS-CASTS" title="D.3.1.3. SQLとXMLのデータ型および値のマッピング">D.3.1.3</a>.
    </p><p>
     If the path expression returns an empty node-set
     (typically, when it does not match)
     for a given row, the column will be set to <code class="literal">NULL</code>, unless
     a <em class="replaceable"><code>default_expression</code></em> is specified; then the
     value resulting from evaluating that expression is used.
    </p><p>
     A <em class="replaceable"><code>default_expression</code></em>, rather than being
     evaluated immediately when <code class="function">xmltable</code> is called,
     is evaluated each time a default is needed for the column.
     If the expression qualifies as stable or immutable, the repeat
     evaluation may be skipped.
     This means that you can usefully use volatile functions like
     <code class="function">nextval</code> in
     <em class="replaceable"><code>default_expression</code></em>.
    </p><p>
     Columns may be marked <code class="literal">NOT NULL</code>. If the
     <em class="replaceable"><code>column_expression</code></em> for a <code class="literal">NOT
     NULL</code> column does not match anything and there is
     no <code class="literal">DEFAULT</code> or
     the <em class="replaceable"><code>default_expression</code></em> also evaluates to null,
     an error is reported.
    </p><p>
     Examples:
  </p><pre class="screen">
CREATE TABLE xmldata AS SELECT
xml $$
&lt;ROWS&gt;
  &lt;ROW id="1"&gt;
    &lt;COUNTRY_ID&gt;AU&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Australia&lt;/COUNTRY_NAME&gt;
  &lt;/ROW&gt;
  &lt;ROW id="5"&gt;
    &lt;COUNTRY_ID&gt;JP&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Japan&lt;/COUNTRY_NAME&gt;
    &lt;PREMIER_NAME&gt;Shinzo Abe&lt;/PREMIER_NAME&gt;
    &lt;SIZE unit="sq_mi"&gt;145935&lt;/SIZE&gt;
  &lt;/ROW&gt;
  &lt;ROW id="6"&gt;
    &lt;COUNTRY_ID&gt;SG&lt;/COUNTRY_ID&gt;
    &lt;COUNTRY_NAME&gt;Singapore&lt;/COUNTRY_NAME&gt;
    &lt;SIZE unit="sq_km"&gt;697&lt;/SIZE&gt;
  &lt;/ROW&gt;
&lt;/ROWS&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmldata,
       XMLTABLE('//ROWS/ROW'
                PASSING data
                COLUMNS id int PATH '@id',
                        ordinality FOR ORDINALITY,
                        "COUNTRY_NAME" text,
                        country_id text PATH 'COUNTRY_ID',
                        size_sq_km float PATH 'SIZE[@unit = "sq_km"]',
                        size_other text PATH
                             'concat(SIZE[@unit!="sq_km"], " ", SIZE[@unit!="sq_km"]/@unit)',
                        premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified');

 id | ordinality | COUNTRY_NAME | country_id | size_sq_km |  size_other  | premier_name  
----+------------+--------------+------------+------------+--------------+---------------
  1 |          1 | Australia    | AU         |            |              | not specified
  5 |          2 | Japan        | JP         |            | 145935 sq_mi | Shinzo Abe
  6 |          3 | Singapore    | SG         |        697 |              | not specified
</pre><p>

<span class="original">
     The following example shows concatenation of multiple text() nodes,
     usage of the column name as XPath filter, and the treatment of whitespace,
     XML comments and processing instructions:
</span>
以下の例では、複数のtext()ノードの結合、列名のXPathフィルターとしての使用、空白文字、XMLコメント、処理命令の取扱いを示します。

  </p><pre class="screen">
CREATE TABLE xmlelements AS SELECT
xml $$
  &lt;root&gt;
   &lt;element&gt;  Hello&lt;!-- xyxxz --&gt;2a2&lt;?aaaaa?&gt; &lt;!--x--&gt;  bbb&lt;x&gt;xxx&lt;/x&gt;CC  &lt;/element&gt;
  &lt;/root&gt;
$$ AS data;

SELECT xmltable.*
  FROM xmlelements, XMLTABLE('/root' PASSING data COLUMNS element text);
         element         
-------------------------
   Hello2a2   bbbxxxCC  
</pre><p>
    </p><p>
<span class="original">
     The following example illustrates how
     the &lt;literal&gt;XMLNAMESPACES&lt;/literal&gt; clause can be used to specify
     a list of namespaces
     used in the XML document as well as in the XPath expressions:
</span>
以下の例では、<code class="literal">XMLNAMESPACES</code>句を使ってXMLドキュメントやXPath式で使われる追加の名前空間のリストを指定する方法を示します。

  </p><pre class="screen">
WITH xmldata(data) AS (VALUES ('
&lt;example xmlns="http://example.com/myns" xmlns:B="http://example.com/b"&gt;
 &lt;item foo="1" B:bar="2"/&gt;
 &lt;item foo="3" B:bar="4"/&gt;
 &lt;item foo="4" B:bar="5"/&gt;
&lt;/example&gt;'::xml)
)
SELECT xmltable.*
  FROM XMLTABLE(XMLNAMESPACES('http://example.com/myns' AS x,
                              'http://example.com/b' AS "B"),
             '/x:example/x:item'
                PASSING (SELECT data FROM xmldata)
                COLUMNS foo int PATH '@foo',
                  bar int PATH '@B:bar');
 foo | bar
-----+-----
   1 |   2
   3 |   4
   4 |   5
(3 rows)
</pre><p>
    </p></div></div><div class="sect2" id="FUNCTIONS-XML-MAPPING"><div class="titlepage"><div><div><h3 class="title">9.15.4. Mapping Tables to XML</h3></div></div></div><a id="id-1.5.8.21.8.2" class="indexterm"></a><p>
    The following functions map the contents of relational tables to
    XML values.  They can be thought of as XML export functionality:
</p><pre class="synopsis">
<code class="function">table_to_xml</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
               <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xml</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
               <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">cursor_to_xml</code> ( <em class="parameter"><code>cursor</code></em> <code class="type">refcursor</code>, <em class="parameter"><code>count</code></em> <code class="type">integer</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
   </p><p>
    <code class="function">table_to_xml</code> maps the content of the named
    table, passed as parameter <em class="parameter"><code>table</code></em>.  The
    <code class="type">regclass</code> type accepts strings identifying tables using the
    usual notation, including optional schema qualifications and
    double quotes.  <code class="function">query_to_xml</code> executes the
    query whose text is passed as parameter
    <em class="parameter"><code>query</code></em> and maps the result set.
    <code class="function">cursor_to_xml</code> fetches the indicated number of
    rows from the cursor specified by the parameter
    <em class="parameter"><code>cursor</code></em>.  This variant is recommended if
    large tables have to be mapped, because the result value is built
    up in memory by each function.
--&gt;
<code class="function">table_to_xml</code>は、パラメータ<em class="parameter"><code>tbl</code></em>として渡された名前付きのテーブルの内容をマップします。
<code class="type">regclass</code>型はオプションのスキーマ修飾と二重引用符を含む、通常の表記法を使用しテーブルを特定する文字列を受け付けます。
<code class="function">query_to_xml</code>は、パラメータ<em class="parameter"><code>query</code></em>としてテキストが渡された問い合わせを実行し、結果セットをマップします。
<code class="function">cursor_to_xml</code>は、パラメータ<em class="parameter"><code>cursor</code></em>で指定されたカーソルから提示された行数を取得します。
それぞれの関数により結果値がメモリーに構築されるため、この異形は巨大なテーブルをマップする必要がある場合推奨されます。
   </p><p>
<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is false, then the resulting
    XML document looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が偽であれば、結果のXML文書は以下のようになります。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;row&gt;
    &lt;columnname1&gt;data&lt;/columnname1&gt;
    &lt;columnname2&gt;data&lt;/columnname2&gt;
  &lt;/row&gt;

  &lt;row&gt;
    ...
  &lt;/row&gt;

  ...
&lt;/tablename&gt;
</pre><p>

<span class="original">
    If &lt;parameter&gt;tableforest&lt;/parameter&gt; is true, the result is an
    XML content fragment that looks like this:
</span>
<em class="parameter"><code>tableforest</code></em>が真であれば、結果は以下のようなXML文書の断片です。
</p><pre class="screen">
&lt;tablename&gt;
  &lt;columnname1&gt;data&lt;/columnname1&gt;
  &lt;columnname2&gt;data&lt;/columnname2&gt;
&lt;/tablename&gt;

&lt;tablename&gt;
  ...
&lt;/tablename&gt;

...
</pre><p>

<span class="original">
    If no table name is available, that is, when mapping a query or a
    cursor, the string &lt;literal&gt;table&lt;/literal&gt; is used in the first
    format, &lt;literal&gt;row&lt;/literal&gt; in the second format.
</span>
テーブル名が利用できないとき、つまり、問い合わせ、またはカーソルをマップする時は、最初の書式では文字列<code class="literal">table</code>が使用され、２番目の書式では<code class="literal">row</code>が使用されます。
   </p><p>
    The choice between these formats is up to the user.  The first
    format is a proper XML document, which will be important in many
    applications.  The second format tends to be more useful in the
    <code class="function">cursor_to_xml</code> function if the result values are to be
    reassembled into one document later on.  The functions for
    producing XML content discussed above, in particular
    <code class="function">xmlelement</code>, can be used to alter the results
    to taste.
   </p><p>
    The data values are mapped in the same way as described for the
    function <code class="function">xmlelement</code> above.
   </p><p>
    The parameter <em class="parameter"><code>nulls</code></em> determines whether null
    values should be included in the output.  If true, null values in
    columns are represented as:
</p><pre class="screen">
&lt;columnname xsi:nil="true"/&gt;
</pre><p>
    where <code class="literal">xsi</code> is the XML namespace prefix for XML
    Schema Instance.  An appropriate namespace declaration will be
    added to the result value.  If false, columns containing null
    values are simply omitted from the output.
   </p><p>
    The parameter <em class="parameter"><code>targetns</code></em> specifies the
    desired XML namespace of the result.  If no particular namespace
    is wanted, an empty string should be passed.
   </p><p>
    The following functions return XML Schema documents describing the
    mappings performed by the corresponding functions above:
</p><pre class="synopsis">
<code class="function">table_to_xmlschema</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                     <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xmlschema</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                     <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">cursor_to_xmlschema</code> ( <em class="parameter"><code>cursor</code></em> <code class="type">refcursor</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                      <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
    It is essential that the same parameters are passed in order to
    obtain matching XML data mappings and XML Schema documents.
   </p><p>
    The following functions produce XML data mappings and the
    corresponding XML Schema in one document (or forest), linked
    together.  They can be useful where self-contained and
    self-describing results are wanted:
</p><pre class="synopsis">
<code class="function">table_to_xml_and_xmlschema</code> ( <em class="parameter"><code>table</code></em> <code class="type">regclass</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                             <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">query_to_xml_and_xmlschema</code> ( <em class="parameter"><code>query</code></em> <code class="type">text</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                             <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>
   </p><p>
<span class="original">
    In addition, the following functions are available to produce
    analogous mappings of entire schemas or the entire current
    database:
</span>
さらに、以下の関数がスキーマ全体、または現在のデータベース全体の類似マッピングを作成するため利用できます。
</p><pre class="synopsis">
<code class="function">schema_to_xml</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">schema_to_xmlschema</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                      <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">schema_to_xml_and_xmlschema</code> ( <em class="parameter"><code>schema</code></em> <code class="type">name</code>, <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                              <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>

<code class="function">database_to_xml</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                  <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">database_to_xmlschema</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                        <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
<code class="function">database_to_xml_and_xmlschema</code> ( <em class="parameter"><code>nulls</code></em> <code class="type">boolean</code>,
                                <em class="parameter"><code>tableforest</code></em> <code class="type">boolean</code>, <em class="parameter"><code>targetns</code></em> <code class="type">text</code> ) → <code class="returnvalue">xml</code>
</pre><p>

    These functions ignore tables that are not readable by the current user.
    The database-wide functions additionally ignore schemas that the current
    user does not have <code class="literal">USAGE</code> (lookup) privilege for.
   </p><p>
    Note that these potentially produce a lot of data, which needs to
    be built up in memory.  When requesting content mappings of large
    schemas or databases, it might be worthwhile to consider mapping the
    tables separately instead, possibly even through a cursor.
   </p><p>
    The result of a schema content mapping looks like this:

</p><pre class="screen">
&lt;schemaname&gt;

table1-mapping

table2-mapping

...

&lt;/schemaname&gt;</pre><p>

<span class="original">
    where the format of a table mapping depends on the
    &lt;parameter&gt;tableforest&lt;/parameter&gt; parameter as explained above.
</span>
ここで、テーブルマッピング書式は上で説明したとおり<em class="parameter"><code>tableforest</code></em>パラメータに依存します。
   </p><p>
<span class="original">
    The result of a database content mapping looks like this:
</span>
データベース内容マッピング書式は以下のようになります。

</p><pre class="screen">
&lt;dbname&gt;

&lt;schema1name&gt;
  ...
&lt;/schema1name&gt;

&lt;schema2name&gt;
  ...
&lt;/schema2name&gt;

...

&lt;/dbname&gt;</pre><p>

<span class="original">
    where the schema mapping is as above.
</span>
ここで、スキーママッピングは上記のとおりです。
   </p><p>
<span class="original">
    As an example of using the output produced by these functions,
    &lt;xref linkend="xslt-xml-html"/&gt; shows an XSLT stylesheet that
    converts the output of
    &lt;function&gt;table_to_xml_and_xmlschema&lt;/function&gt; to an HTML
    document containing a tabular rendition of the table data.  In a
    similar manner, the results from these functions can be
    converted into other XML-based formats.
</span>
これらの関数で作成された出力を使用する１つの例として、<a class="xref" href="functions-xml.html#XSLT-XML-HTML" title="例9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート">例 9.1</a>は、テーブルデータの表形式への翻訳を含む<code class="function">table_to_xml_and_xmlschema</code>からHTML文書への出力の変換をおこなうXSLTスタイルシートを示します。
同じようにして、これらの関数の結果は他のXML基準書式に変換されます。
   </p><div class="example" id="XSLT-XML-HTML"><p class="title"><strong>例9.1 SQL/XML出力をHTMLに変換するXSLTスタイルシート</strong></p><div class="example-contents"><span class="original">
    &lt;title&gt;XSLT Stylesheet for Converting SQL/XML Output to HTML&lt;/title&gt;
</span><pre class="programlisting">
&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
&gt;

  &lt;xsl:output method="xml"
      doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
      doctype-public="-//W3C/DTD XHTML 1.0 Strict//EN"
      indent="yes"/&gt;

  &lt;xsl:template match="/*"&gt;
    &lt;xsl:variable name="schema" select="//xsd:schema"/&gt;
    &lt;xsl:variable name="tabletypename"
                  select="$schema/xsd:element[@name=name(current())]/@type"/&gt;
    &lt;xsl:variable name="rowtypename"
                  select="$schema/xsd:complexType[@name=$tabletypename]/xsd:sequence/xsd:element[@name='row']/@type"/&gt;

    &lt;html&gt;
      &lt;head&gt;
        &lt;title&gt;&lt;xsl:value-of select="name(current())"/&gt;&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;table&gt;
          &lt;tr&gt;
            &lt;xsl:for-each select="$schema/xsd:complexType[@name=$rowtypename]/xsd:sequence/xsd:element/@name"&gt;
              &lt;th&gt;&lt;xsl:value-of select="."/&gt;&lt;/th&gt;
            &lt;/xsl:for-each&gt;
          &lt;/tr&gt;

          &lt;xsl:for-each select="row"&gt;
            &lt;tr&gt;
              &lt;xsl:for-each select="*"&gt;
                &lt;td&gt;&lt;xsl:value-of select="."/&gt;&lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/table&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre></div></div><br class="example-break" /></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.8.21.7.5.15.2" class="footnote"><p><a href="#id-1.5.8.21.7.5.15.2" class="para"><sup class="para">[7] </sup></a>
<span class="original">
       A result containing more than one element node at the top level, or
       non-whitespace text outside of an element, is an example of content form.
       An XPath result can be of neither form, for example if it returns an
       attribute node selected from the element that contains it. Such a result
       will be put into content form with each such disallowed node replaced by
       its string value, as defined for the XPath 1.0
       &lt;function&gt;string&lt;/function&gt; function.
</span>
トップレベルにおいて複数の要素ノードを含むか、あるいは要素の外側の非空白テキストであるような結果は、コンテントフォームの例です。
XPathの結果はそのどちらでもないフォームであることがあり得ます。
たとえば、それを含む要素から選択された属性ノードを返す場合です。
XPath 1.0の<code class="function">string</code>関数で定義されているように、そうした結果は、許可されないノードを文字列値で置き換えたコンテントフォームに設定されます。
      </p></div></div></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-uuid.html" title="9.14. UUID Functions">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-json.html" title="9.16. JSON Functions and Operators">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.14. UUID Functions </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 13.1文書">ホーム</a></td><td width="40%" align="right" valign="top"> 9.16. JSON Functions and Operators</td></tr></table></div></body></html>