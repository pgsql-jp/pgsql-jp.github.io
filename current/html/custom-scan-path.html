<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>61.1. カスタムスキャンパスの作成</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成" /><link rel="next" href="custom-scan-plan.html" title="61.2. カスタムスキャン計画の作成" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 15.4文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成">第61章 カスタムスキャンプロバイダの作成</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 15.4 : custom-scan-path.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成">上へ</a></td><td width="60%" align="center">61.1. カスタムスキャンパスの作成</td><td width="20%" align="right"> <a accesskey="n" href="custom-scan-plan.html" title="61.2. カスタムスキャン計画の作成">次へ</a></td></tr></table><hr /></div><div class="sect1" id="CUSTOM-SCAN-PATH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">61.1. カスタムスキャンパスの作成</h2></div></div></div><span class="original">
  &lt;title&gt;Creating Custom Scan Paths&lt;/title&gt;
</span><p>
<span class="original">
    A custom scan provider will typically add paths for a base relation by
    setting the following hook, which is called after the core code has
    generated all the access paths it can for the relation (except for
    Gather paths, which are made after this call so that they can use
    partial paths added by the hook):
</span>
カスタムスキャンプロバイダは、典型的には、以下のフックを設定することでベースリレーションのためのパスを追加します。
このフックはコアのコードがそのリレーションへのすべてのアクセスパスを生成した後で呼び出されます。
（フックの呼び出しの後に作成されるギャザーパス(Gather path)を除きます。フックが追加した部分パスをギャザーパスが利用できるようにするためです。）
</p><pre class="programlisting">
typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;
</pre><p>
  </p><p>
<span class="original">
    Although this hook function can be used to examine, modify, or remove
    paths generated by the core system, a custom scan provider will typically
    confine itself to generating &lt;structname&gt;CustomPath&lt;/structname&gt; objects and adding
    them to &lt;literal&gt;rel&lt;/literal&gt; using &lt;function&gt;add_path&lt;/function&gt;.  The custom scan
    provider is responsible for initializing the &lt;structname&gt;CustomPath&lt;/structname&gt;
    object, which is declared like this:
</span>
このフックはコアシステムが生成したパスを検査し、修正し、あるいは削除するために使うことができますが、カスタムスキャンプロバイダは、典型的には<code class="structname">CustomPath</code>オブジェクトを生成し、<code class="function">add_path</code>を使ってそれを<code class="literal">rel</code>に追加することのみを行います。
カスタムスキャンプロバイダは<code class="structname">CustomPath</code>オブジェクトの初期化を担当します。
このオブジェクトは以下のように宣言されています。
</p><pre class="programlisting">
typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;
</pre><p>
  </p><p>
    <code class="structfield">path</code> must be initialized as for any other path, including
    the row-count estimate, start and total cost, and sort ordering provided
    by this path.  <code class="structfield">flags</code> is a bit mask, which
    specifies whether the scan provider can support certain optional
    capabilities.  <code class="structfield">flags</code> should include
    <code class="literal">CUSTOMPATH_SUPPORT_BACKWARD_SCAN</code> if the custom path can support
    a backward scan, <code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code> if it
    can support mark and restore,
    and <code class="literal">CUSTOMPATH_SUPPORT_PROJECTION</code> if it can perform
    projections.  (If <code class="literal">CUSTOMPATH_SUPPORT_PROJECTION</code> is not
    set, the scan node will only be asked to produce Vars of the scanned
    relation; while if that flag is set, the scan node must be able to
    evaluate scalar expressions over these Vars.)
    An optional <code class="structfield">custom_paths</code> is a list of <code class="structname">Path</code>
    nodes used by this custom-path node; these will be transformed into
    <code class="structname">Plan</code> nodes by planner.
    <code class="structfield">custom_private</code> can be used to store the custom path's
    private data.  Private data should be stored in a form that can be handled
    by <code class="literal">nodeToString</code>, so that debugging routines that attempt to
    print the custom path will work as designed.  <code class="structfield">methods</code> must
    point to a (usually statically allocated) object implementing the required
    custom path methods, which are further detailed below.
  </p><p>
<span class="original">
   A custom scan provider can also provide join paths.  Just as for base
   relations, such a path must produce the same output as would normally be
   produced by the join it replaces.  To do this, the join provider should
   set the following hook, and then within the hook function,
   create &lt;structname&gt;CustomPath&lt;/structname&gt; path(s) for the join relation.
</span>
カスタムスキャンプロバイダは結合(join)のパスを提供することもできます。
ベースのリレーションの場合と同様、そのようなパスは置換される結合が普通に生成したであろうものと同じ結果を生成しなければなりません。
そのために、結合のプロバイダは以下のフックをセットし、フック関数内で結合リレーション用に<code class="structname">CustomPath</code>のパスを作成します。
</p><pre class="programlisting">
typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;
</pre><p>

<span class="original">
   This hook will be invoked repeatedly for the same join relation, with
   different combinations of inner and outer relations; it is the
   responsibility of the hook to minimize duplicated work.
</span>
このフックは、同じ結合リレーションについて、内側あるいは外側のリレーションとの様々な組み合わせで繰り返し呼び出されます。
繰り返しの作業を最小化するのはフック側の責任です。
  </p><div class="sect2" id="CUSTOM-SCAN-PATH-CALLBACKS"><div class="titlepage"><div><div><h3 class="title">61.1.1. カスタムスキャンパスのコールバック</h3></div></div></div><span class="original">
  &lt;title&gt;Custom Scan Path Callbacks&lt;/title&gt;
</span><p>
</p><pre class="programlisting">
Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);
</pre><p>
<span class="original">
    Convert a custom path to a finished plan.  The return value will generally
    be a &lt;literal&gt;CustomScan&lt;/literal&gt; object, which the callback must allocate and
    initialize.  See &lt;xref linkend="custom-scan-plan"/&gt; for more details.
</span>
カスタムパスを完成した計画に変換します。
戻り値は一般的には<code class="literal">CustomScan</code>オブジェクトで、その領域はコールバックが割り当てて初期化しなければなりません。
詳しくは<a class="xref" href="custom-scan-plan.html" title="61.2. カスタムスキャン計画の作成">61.2</a>を参照してください。
   </p><p>
</p><pre class="programlisting">
List *(*ReparameterizeCustomPathByChild) (PlannerInfo *root,
                                          List *custom_private,
                                          RelOptInfo *child_rel);
</pre><p>
    This callback is called while converting a path parameterized by the
    top-most parent of the given child relation <code class="literal">child_rel</code>
    to be parameterized by the child relation.  The callback is used to
    reparameterize any paths or translate any expression nodes saved in the
    given <code class="literal">custom_private</code> member of a
    <code class="structname">CustomPath</code>.  The callback may use
    <code class="literal">reparameterize_path_by_child</code>,
    <code class="literal">adjust_appendrel_attrs</code> or
    <code class="literal">adjust_appendrel_attrs_multilevel</code> as required.
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="custom-scan.html" title="第61章 カスタムスキャンプロバイダの作成">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="custom-scan-plan.html" title="61.2. カスタムスキャン計画の作成">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第61章 カスタムスキャンプロバイダの作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 15.4文書">ホーム</a></td><td width="40%" align="right" valign="top"> 61.2. カスタムスキャン計画の作成</td></tr></table></div></body></html>