<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.3. 複数列インデックス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-types.html" title="11.2. インデックスの種類" /><link rel="next" href="indexes-ordering.html" title="11.4. インデックスとORDER BY" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.2文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="indexes.html" title="第11章 インデックス">第11章 インデックス</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.2 : indexes-multicolumn.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. インデックスの種類">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="第11章 インデックス">上へ</a></td><td width="60%" align="center">11.3. 複数列インデックス</td><td width="20%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. インデックスとORDER BY">次へ</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-MULTICOLUMN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.3. 複数列インデックス <a href="#INDEXES-MULTICOLUMN" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;Multicolumn Indexes&lt;/title&gt;
</span><a id="id-1.5.10.7.2" class="indexterm"></a><a id="id-1.5.10.7.3" class="indexterm"></a><p>
<span class="original">
   An index can be defined on more than one column of a table.  For example, if
   you have a table of this form:
</span>
インデックスは、テーブルの2つ以上の列に定義することができます。
例えば、以下のようなテーブルがあるとします。
</p><pre class="programlisting">
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</pre><p>
<span class="original">
   (say, you keep your &lt;filename class="directory"&gt;/dev&lt;/filename&gt;
   directory in a database...) and you frequently issue queries like:
</span>
（例えば、<code class="filename">/dev</code>ディレクトリの内容をデータベースに保持していて）頻繁に下記のような問い合わせを発行するとします。
</p><pre class="programlisting">
SELECT name FROM test2 WHERE major = <em class="replaceable"><code>constant</code></em> AND minor = <em class="replaceable"><code>constant</code></em>;
</pre><p>
<span class="original">
   then it might be appropriate to define an index on the columns
   &lt;structfield&gt;major&lt;/structfield&gt; and
   &lt;structfield&gt;minor&lt;/structfield&gt; together, e.g.:
</span>
このような場合、<code class="structfield">major</code>および<code class="structfield">minor</code>という２つの列に1つのインデックスを定義する方が適切かもしれません。
</p><pre class="programlisting">
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</pre><p>
  </p><p>
<span class="original">
   Currently, only the B-tree, GiST, GIN, and BRIN index types support
   multiple-key-column indexes.  Whether there can be multiple key
   columns is independent of whether &lt;literal&gt;INCLUDE&lt;/literal&gt; columns
   can be added to the index.  Indexes can have up to 32 columns,
   including &lt;literal&gt;INCLUDE&lt;/literal&gt; columns.  (This limit can be
   altered when building &lt;productname&gt;PostgreSQL&lt;/productname&gt;; see the
   file &lt;filename&gt;pg_config_manual.h&lt;/filename&gt;.)
</span>
現在、B-tree、GiST、GINおよびBRINインデックス型でのみ、複数キー列インデックスをサポートしています。
複数キー列を持つことができるかどうかは、<code class="literal">INCLUDE</code>列をインデックスに追加できるかどうかとは無関係です。
インデックスは<code class="literal">INCLUDE</code>列を含めて最大32列まで持つことができます。
（この上限は、<span class="productname">PostgreSQL</span>を構築する際に変更可能です。
<code class="filename">pg_config_manual.h</code>ファイルを参照してください。）
  </p><p>
<span class="original">
   A multicolumn B-tree index can be used with query conditions that
   involve any subset of the index's columns, but the index is most
   efficient when there are constraints on the leading (leftmost) columns.
   The exact rule is that equality constraints on leading columns, plus
   any inequality constraints on the first column that does not have an
   equality constraint, will always be used to limit the portion of the index
   that is scanned.  Constraints on columns to the right of these columns
   are checked in the index, so they'll always save visits to the table
   proper, but they do not necessarily reduce the portion of the index that
   has to be scanned.  If a B-tree index scan can apply the skip scan
   optimization effectively, it will apply every column constraint when
   navigating through the index via repeated index searches.  This can reduce
   the portion of the index that has to be read, even though one or more
   columns (prior to the least significant index column from the query
   predicate) lacks a conventional equality constraint.  Skip scan works by
   generating a dynamic equality constraint internally, that matches every
   possible value in an index column (though only given a column that lacks
   an equality constraint that comes from the query predicate, and only when
   the generated constraint can be used in conjunction with a later column
   constraint from the query predicate).
</span>
複数列に対するB-treeインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用できますが、もっともインデックスの効率が良いのは、先頭（左側）の列に制約がある場合です。
正確な規則は、先頭の列に対する等価制約、および等価制約を持たない先頭の列に対する不等式制約は、常にスキャン対象のインデックス範囲を制限するために使用されるということです。
これらの列の右側の列に対する制約はインデックスで検査されるため、常にテーブルへのアクセスを適切に抑えますが、必ずしもスキャンしなければならないインデックスの範囲を減らすわけではありません。
B-treeインデックススキャンでスキップスキャン最適化を効果的に適用できる場合は、インデックス検索を繰り返してインデックスを辿るときに、すべての列制約が適用されます。
これにより、（問い合わせの述語に含まれるもっとも重要度の低いインデックス列より前に位置する）1つまたは複数の列に従来の等価制約がない場合でも、読まなければならないインデックスの範囲を減らすことができます。
スキップスキャンは、インデックス列において取り得るすべての値と一致する動的な等価制約を内部的に生成することで機能しています（ただし、問い合わせの述語に含まれる等価制約のない列に対してのみ適用され、かつ生成された制約が問い合わせの述語に含まれる後続の列制約と組み合わせて使用できる場合に限ります）。
  </p><p>
<span class="original">
   For example, given an index on &lt;literal&gt;(x, y)&lt;/literal&gt;, and a query
   condition &lt;literal&gt;WHERE y = 7700&lt;/literal&gt;, a B-tree index scan might be
   able to apply the skip scan optimization.  This generally happens when the
   query planner expects that repeated &lt;literal&gt;WHERE x = N AND y = 7700&lt;/literal&gt;
   searches for every possible value of &lt;literal&gt;N&lt;/literal&gt; (or for every
   &lt;literal&gt;x&lt;/literal&gt; value that is actually stored in the index) is the
   fastest possible approach, given the available indexes on the table.  This
   approach is generally only taken when there are so few distinct
   &lt;literal&gt;x&lt;/literal&gt; values that the planner expects the scan to skip over
   most of the index (because most of its leaf pages cannot possibly contain
   relevant tuples).  If there are many distinct &lt;literal&gt;x&lt;/literal&gt; values,
   then the entire index will have to be scanned, so in most cases the planner
   will prefer a sequential table scan over using the index.
</span>
たとえば、<code class="literal">(x, y)</code>に対するインデックスと問い合わせ条件<code class="literal">WHERE y = 7700</code>では、B-treeインデックススキャンでスキップスキャン最適化を適用できる場合があります。
これは通常、問い合わせプランナがそのテーブルで使用可能なインデックスを考慮した時に、<code class="literal">WHERE x = N AND y = 7700</code>の検索を、<code class="literal">N</code>で取り得るすべての値（または実際にインデックスに格納されているすべての<code class="literal">x</code>の値）に対して繰り返す方法が最速であると想定している場合に発生します。
この方法は通常、<code class="literal">x</code>の個別値が非常に少なく、ほとんどのインデックスをスキップしてスキャンする（ほとんどのリーフページには関連するタプルが含まれないため）とプランナが期待する場合にのみ採用されます。
<code class="literal">x</code>の個別値が多い場合、インデックス全体のスキャンが必要になる状況になりうるため、ほとんどの場合プランナはインデックスを使用するよりもシーケンシャルスキャンを好みます。
  </p><p>
<span class="original">
   The skip scan optimization can also be applied selectively, during B-tree
   scans that have at least some useful constraints from the query predicate.
   For example, given an index on &lt;literal&gt;(a, b, c)&lt;/literal&gt; and a
   query condition &lt;literal&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/literal&gt;,
   the index might have to be scanned from the first entry with
   &lt;literal&gt;a&lt;/literal&gt; = 5 and &lt;literal&gt;b&lt;/literal&gt; = 42 up through the last
   entry with &lt;literal&gt;a&lt;/literal&gt; = 5.  Index entries with
   &lt;literal&gt;c&lt;/literal&gt; &amp;gt;= 77 will never need to be filtered at the table
   level, but it may or may not be profitable to skip over them within the
   index.  When skipping takes place, the scan starts a new index search to
   reposition itself from the end of the current &lt;literal&gt;a&lt;/literal&gt; = 5 and
   &lt;literal&gt;b&lt;/literal&gt; = N grouping (i.e. from the position in the index
   where the first tuple &lt;literal&gt;a = 5 AND b = N AND c &amp;gt;= 77&lt;/literal&gt;
   appears), to the start of the next such grouping (i.e. the position in the
   index where the first tuple &lt;literal&gt;a = 5 AND b = N + 1&lt;/literal&gt;
   appears).
</span>
スキップスキャンの最適化は、問い合わせの述語に有用な制約が少なくともいくつかあるB-treeスキャン中に、選択的に適用することもできます。
たとえば、<code class="literal">(a, b, c)</code>にインデックスがあり、<code class="literal">WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</code>という問い合わせ条件がある場合、インデックスは<code class="literal">a</code> = 5および<code class="literal">b</code> = 42の最初のエントリから<code class="literal">a</code> = 5の最後のエントリまでスキャンする必要があるかもしれません。
<code class="literal">c</code> &gt;= 77のインデックスエントリはテーブルレベルでフィルタリングする必要はありませんが、インデックス内でスキップすると効果がある場合とない場合があります。
スキップが行われると、スキャンは新しいインデックス検索を開始し、現在の<code class="literal">a</code> = 5と<code class="literal">b</code> = Nのグループの末尾（つまり、<code class="literal">a = 5 AND b = N AND c &gt;= 77</code>の最初のタプルが現れるインデックスの位置）から、次のグルーピングの開始位置（つまり、<code class="literal">a = 5 AND b = N + 1</code>の最初のタプルが現れるインデックスの位置）まで位置を変更します。
  </p><p>
<span class="original">
   A multicolumn GiST index can be used with query conditions that
   involve any subset of the index's columns. Conditions on additional
   columns restrict the entries returned by the index, but the condition on
   the first column is the most important one for determining how much of
   the index needs to be scanned.  A GiST index will be relatively
   ineffective if its first column has only a few distinct values, even if
   there are many distinct values in additional columns.
</span>
複数列GiSTインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
他の列に対する条件は、インデックスで返される項目を制限します。
しかし、先頭列に対する条件が、インデックスのスキャン量を決定するもっとも重要なものです。
先頭列の個別値がわずかな場合、他の列が多くの個別値を持っていたとしても、相対的にGiSTインデックスは非効率的になります。
  </p><p>
<span class="original">
   A multicolumn GIN index can be used with query conditions that
   involve any subset of the index's columns. Unlike B-tree or GiST,
   index search effectiveness is the same regardless of which index column(s)
   the query conditions use.
</span>
複数列GINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
B-treeやGiSTと異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
  </p><p>
<span class="original">
   A multicolumn BRIN index can be used with query conditions that
   involve any subset of the index's columns. Like GIN and unlike B-tree or
   GiST, index search effectiveness is the same regardless of which index
   column(s) the query conditions use. The only reason to have multiple BRIN
   indexes instead of one multicolumn BRIN index on a single table is to have
   a different &lt;literal&gt;pages_per_range&lt;/literal&gt; storage parameter.
</span>
複数列BRINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
GINと同様に、またB-treeやGiSTとは異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
一つのテーブルに対して複数列BRINインデックスを一つ持つ代わりに複数のBRINインデックスを持つ唯一の理由は、異なる<code class="literal">pages_per_range</code>ストレージパラメータを持つためです。
  </p><p>
<span class="original">
   Of course, each column must be used with operators appropriate to the index
   type; clauses that involve other operators will not be considered.
</span>
当然ながら、インデックス種類に対して適切な演算子を各列に使用しなければなりません。
他の演算子を含む句は考慮されません。
  </p><p>
<span class="original">
   Multicolumn indexes should be used sparingly.  In most situations,
   an index on a single column is sufficient and saves space and time.
   Indexes with more than three columns are unlikely to be helpful
   unless the usage of the table is extremely stylized.  See also
   &lt;xref linkend="indexes-bitmap-scans"/&gt; and
   &lt;xref linkend="indexes-index-only-scans"/&gt; for some discussion of the
   merits of different index configurations.
</span>
複数列インデックスは慎重に使用する必要があります。
多くの場合、単一列のインデックスで十分であり、また、その方がディスク領域と時間を節約できます。
テーブルの使用方法が極端に様式化されていない限り、4つ以上の列を使用しているインデックスは、不適切である可能性が高いでしょう。
異なるインデックス構成の利点に関するこの他の説明について<a class="xref" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ">11.5</a>および<a class="xref" href="indexes-index-only-scans.html" title="11.9. インデックスオンリースキャンとカバリングインデックス">11.9</a>も参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. インデックスの種類">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="第11章 インデックス">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. インデックスとORDER BY">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">11.2. インデックスの種類 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.2文書">ホーム</a></td><td width="40%" align="right" valign="top"> 11.4. インデックスと<code class="literal">ORDER BY</code></td></tr></table></div></body></html>