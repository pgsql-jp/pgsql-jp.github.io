<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.3. 複数列インデックス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="indexes-types.html" title="11.2. インデックスの種類" /><link rel="next" href="indexes-ordering.html" title="11.4. インデックスとORDER BY" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="indexes.html" title="第11章 インデックス">第11章 インデックス</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.0 : indexes-multicolumn.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. インデックスの種類">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="第11章 インデックス">上へ</a></td><td width="60%" align="center">11.3. 複数列インデックス</td><td width="20%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. インデックスとORDER BY">次へ</a></td></tr></table><hr /></div><div class="sect1" id="INDEXES-MULTICOLUMN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.3. 複数列インデックス <a href="#INDEXES-MULTICOLUMN" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;Multicolumn Indexes&lt;/title&gt;
</span><a id="id-1.5.10.7.2" class="indexterm"></a><a id="id-1.5.10.7.3" class="indexterm"></a><p>
<span class="original">
   An index can be defined on more than one column of a table.  For example, if
   you have a table of this form:
</span>
インデックスは、テーブルの2つ以上の列に定義することができます。
例えば、以下のようなテーブルがあるとします。
</p><pre class="programlisting">
CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);
</pre><p>
<span class="original">
   (say, you keep your &lt;filename class="directory"&gt;/dev&lt;/filename&gt;
   directory in a database...) and you frequently issue queries like:
</span>
（例えば、<code class="filename">/dev</code>ディレクトリの内容をデータベースに保持していて）頻繁に下記のような問い合わせを発行するとします。
</p><pre class="programlisting">
SELECT name FROM test2 WHERE major = <em class="replaceable"><code>constant</code></em> AND minor = <em class="replaceable"><code>constant</code></em>;
</pre><p>
<span class="original">
   then it might be appropriate to define an index on the columns
   &lt;structfield&gt;major&lt;/structfield&gt; and
   &lt;structfield&gt;minor&lt;/structfield&gt; together, e.g.:
</span>
このような場合、<code class="structfield">major</code>および<code class="structfield">minor</code>という２つの列に1つのインデックスを定義する方が適切かもしれません。
</p><pre class="programlisting">
CREATE INDEX test2_mm_idx ON test2 (major, minor);
</pre><p>
  </p><p>
<span class="original">
   Currently, only the B-tree, GiST, GIN, and BRIN index types support
   multiple-key-column indexes.  Whether there can be multiple key
   columns is independent of whether &lt;literal&gt;INCLUDE&lt;/literal&gt; columns
   can be added to the index.  Indexes can have up to 32 columns,
   including &lt;literal&gt;INCLUDE&lt;/literal&gt; columns.  (This limit can be
   altered when building &lt;productname&gt;PostgreSQL&lt;/productname&gt;; see the
   file &lt;filename&gt;pg_config_manual.h&lt;/filename&gt;.)
</span>
現在、B-tree、GiST、GINおよびBRINインデックス型でのみ、複数キー列インデックスをサポートしています。
複数キー列を持つことができるかどうかは、<code class="literal">INCLUDE</code>列をインデックスに追加できるかどうかとは無関係です。
インデックスは<code class="literal">INCLUDE</code>列を含めて最大32列まで持つことができます。
（この上限は、<span class="productname">PostgreSQL</span>を構築する際に変更可能です。
<code class="filename">pg_config_manual.h</code>ファイルを参照してください。）
  </p><p>
<span class="original">
   A multicolumn B-tree index can be used with query conditions that
   involve any subset of the index's columns, but the index is most
   efficient when there are constraints on the leading (leftmost) columns.
   The exact rule is that equality constraints on leading columns, plus
   any inequality constraints on the first column that does not have an
   equality constraint, will always be used to limit the portion of the index
   that is scanned.  Constraints on columns to the right of these columns
   are checked in the index, so they'll always save visits to the table
   proper, but they do not necessarily reduce the portion of the index that
   has to be scanned.  If a B-tree index scan can apply the skip scan
   optimization effectively, it will apply every column constraint when
   navigating through the index via repeated index searches.  This can reduce
   the portion of the index that has to be read, even though one or more
   columns (prior to the least significant index column from the query
   predicate) lacks a conventional equality constraint.  Skip scan works by
   generating a dynamic equality constraint internally, that matches every
   possible value in an index column (though only given a column that lacks
   an equality constraint that comes from the query predicate, and only when
   the generated constraint can be used in conjunction with a later column
   constraint from the query predicate).
</span>
《マッチ度[52.363636]》複数列に対するB-treeインデックスをインデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
しかし、先頭側の（左側）列に制約がある場合に、このインデックスはもっとも効率的になります。
正確な規則は、先頭側の列への等価制約、および、等価制約を持たない先頭列への不等号制約がスキャン対象のインデックス範囲を制限するために使用されます。
これらの列の右側の列に対する制約は、このインデックス内から検査されます。
ですので、テーブルアクセスを適切に抑えますが、スキャンされるインデックスの範囲を減らしません。
例えば、<code class="literal">(a, b, c)</code>に対するインデックスがあり、<code class="literal">WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</code>という問い合わせ条件があったとすると、
<code class="literal">a</code> = 5かつ<code class="literal">b</code> = 42を持つ項目を先頭に、<code class="literal">a</code> = 5となる最後の項目までのインデックスをスキャンしなければなりません。
<code class="literal">c</code> &gt;= 77を持つインデックス項目は飛ばされますが、スキャンを行わなければなりません。
このインデックスは原理上、 <code class="literal">a</code>に対する制約を持たず、<code class="literal">b</code>あるいは<code class="literal">c</code>に制約に持つ問い合わせでも使用することができます。
しかし、インデックス全体がスキャンされますので、ほとんどの場合、プランナはインデックスの使用よりもシーケンシャルテーブルスキャンを選択します。
《機械翻訳》複数列B-ツリーインデックスは、問い合わせの列の任意のサブセットを含むインデックス条件で使用できますが、インデックスは先頭（左端）の列に制約がある場合に最も効率的です。
正確なルールは、先頭の列に対する等式制約、つまり等式制約を持たない最初のカラムに対するプラスの不等式制約が、スキャンされるインデックスの部分を制限するために常に使用されるということです。
これらの列の右側の列に対する制約はインデックスでチェックされるため、常にテーブルへの訪問を適切に保存しますが、スキャンする必要のあるインデックスの部分を必ずしも減らすとは限りません。
B-ツリーインデックススキャンがスキップスキャン最適化を効果的に適用できる場合は、インデックス検索を繰り返してインデックスをナビゲートするときに、すべてのカラム制約を適用します。
これにより、1つまたは複数の列（インデックスからの最下位のの前）に従来の等式がない場合でも、読み取られるインデックスの部分を減らすことができます。
は、内部的に動的等式を生成することによって機能します。
これは、内のすべての可能な値に一致します（ただし、に由来する等式を持たないが与えられた場合にのみ、生成されたが単位からの後の割引とともにで使用できる場合にのみ）。
インデックスカラムスキップ制約問い合わせ述語制約問い合わせ制約問い合わせ制約スキャンカラム制約カラム論理積述語述語カラム
  </p><p>
<span class="original">
   For example, given an index on &lt;literal&gt;(x, y)&lt;/literal&gt;, and a query
   condition &lt;literal&gt;WHERE y = 7700&lt;/literal&gt;, a B-tree index scan might be
   able to apply the skip scan optimization.  This generally happens when the
   query planner expects that repeated &lt;literal&gt;WHERE x = N AND y = 7700&lt;/literal&gt;
   searches for every possible value of &lt;literal&gt;N&lt;/literal&gt; (or for every
   &lt;literal&gt;x&lt;/literal&gt; value that is actually stored in the index) is the
   fastest possible approach, given the available indexes on the table.  This
   approach is generally only taken when there are so few distinct
   &lt;literal&gt;x&lt;/literal&gt; values that the planner expects the scan to skip over
   most of the index (because most of its leaf pages cannot possibly contain
   relevant tuples).  If there are many distinct &lt;literal&gt;x&lt;/literal&gt; values,
   then the entire index will have to be scanned, so in most cases the planner
   will prefer a sequential table scan over using the index.
</span>
《機械翻訳》例では、インデックスon <code class="literal">(x, y)</code>、および問い合わせ条件<code class="literal">WHERE y = 7700</code>、B-ツリーインデックススキャンはスキップスキャン最適化を適用できる場合があります。
これは一般に、問い合わせプランナが、テーブルで利用可能なインデックスが与えられた場合、反復<code class="literal">WHERE x = N AND y = 7700</code>可能性のあるすべての値<code class="literal">N</code>または実際にインデックスに格納されているすべて<code class="literal">x</code>の値の検索が可能な最速のアプローチであると想定している場合に発生します。
このアプローチは一般に、明確な<code class="literal">x</code>値が非常に少ないため、プランナがインデックスの大部分に対してスキャンからスキップを想定している場合にのみ使用されます（リーフページの大部分には関連するタプルが含まれていない可能性があるため）。
明確な<code class="literal">x</code>値が多数ある場合は、インデックス全体をスキャンする必要があるため、ほとんどの場合、プランナはインデックスよりシーケンシャルテーブルスキャンを優先します。
  </p><p>
<span class="original">
   The skip scan optimization can also be applied selectively, during B-tree
   scans that have at least some useful constraints from the query predicate.
   For example, given an index on &lt;literal&gt;(a, b, c)&lt;/literal&gt; and a
   query condition &lt;literal&gt;WHERE a = 5 AND b &amp;gt;= 42 AND c &amp;lt; 77&lt;/literal&gt;,
   the index might have to be scanned from the first entry with
   &lt;literal&gt;a&lt;/literal&gt; = 5 and &lt;literal&gt;b&lt;/literal&gt; = 42 up through the last
   entry with &lt;literal&gt;a&lt;/literal&gt; = 5.  Index entries with
   &lt;literal&gt;c&lt;/literal&gt; &amp;gt;= 77 will never need to be filtered at the table
   level, but it may or may not be profitable to skip over them within the
   index.  When skipping takes place, the scan starts a new index search to
   reposition itself from the end of the current &lt;literal&gt;a&lt;/literal&gt; = 5 and
   &lt;literal&gt;b&lt;/literal&gt; = N grouping (i.e. from the position in the index
   where the first tuple &lt;literal&gt;a = 5 AND b = N AND c &amp;gt;= 77&lt;/literal&gt;
   appears), to the start of the next such grouping (i.e. the position in the
   index where the first tuple &lt;literal&gt;a = 5 AND b = N + 1&lt;/literal&gt;
   appears).
</span>
《機械翻訳》スキップスキャン最適化は、問い合わせツリーからの少なくともいくつかの有用な制約を有するB-述語スキャン中に選択的に適用することもできる。
例の場合、インデックスon <code class="literal">(a, b, c)</code>および問い合わせ条件が指定されている場合、インデックスは<code class="literal">a</code>=5および<code class="literal">b</code>=42の最初のエントリから<code class="literal">a</code>=5の最後のエントリまでスキャンする必要がある場合があります。
<code class="literal">c</code>&gt;=77のインデックスエントリはテーブルレベルでフィルタする必要はありませんが、インデックス内でスキップに利益をもたらす場合とそうでない場合があります。
スキップが行われると、スキャンは新しいインデックス検索を開始して、現在<code class="literal">a</code>=5および<code class="literal">b</code>=Nグループ化の末尾（つまり、最初のタプル<code class="literal">a = 5 AND b = N AND c &gt;= 77</code>が表示されるインデックス内の位置）から、次のそのような（つまり、最初の<code class="literal">a = 5 AND b = N + 1</code>が表示される内の位置）に自分自身を再配置します。
タプルグループ化スタートインデックス<code class="literal">WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</code>
  </p><p>
<span class="original">
   A multicolumn GiST index can be used with query conditions that
   involve any subset of the index's columns. Conditions on additional
   columns restrict the entries returned by the index, but the condition on
   the first column is the most important one for determining how much of
   the index needs to be scanned.  A GiST index will be relatively
   ineffective if its first column has only a few distinct values, even if
   there are many distinct values in additional columns.
</span>
複数列GiSTインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
他の列に対する条件は、インデックスで返される項目を制限します。
しかし、先頭列に対する条件が、インデックスのスキャン量を決定するもっとも重要なものです。
先頭列の個別値がわずかな場合、他の列が多くの個別値を持っていたとしても、相対的にGiSTインデックスは非効率的になります。
  </p><p>
<span class="original">
   A multicolumn GIN index can be used with query conditions that
   involve any subset of the index's columns. Unlike B-tree or GiST,
   index search effectiveness is the same regardless of which index column(s)
   the query conditions use.
</span>
複数列GINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
B-treeやGiSTと異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
  </p><p>
<span class="original">
   A multicolumn BRIN index can be used with query conditions that
   involve any subset of the index's columns. Like GIN and unlike B-tree or
   GiST, index search effectiveness is the same regardless of which index
   column(s) the query conditions use. The only reason to have multiple BRIN
   indexes instead of one multicolumn BRIN index on a single table is to have
   a different &lt;literal&gt;pages_per_range&lt;/literal&gt; storage parameter.
</span>
複数列BRINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
GINと同様に、またB-treeやGiSTとは異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
一つのテーブルに対して複数列BRINインデックスを一つ持つ代わりに複数のBRINインデックスを持つ唯一の理由は、異なる<code class="literal">pages_per_range</code>ストレージパラメータを持つためです。
  </p><p>
<span class="original">
   Of course, each column must be used with operators appropriate to the index
   type; clauses that involve other operators will not be considered.
</span>
当然ながら、インデックス種類に対して適切な演算子を各列に使用しなければなりません。
他の演算子を含む句は考慮されません。
  </p><p>
<span class="original">
   Multicolumn indexes should be used sparingly.  In most situations,
   an index on a single column is sufficient and saves space and time.
   Indexes with more than three columns are unlikely to be helpful
   unless the usage of the table is extremely stylized.  See also
   &lt;xref linkend="indexes-bitmap-scans"/&gt; and
   &lt;xref linkend="indexes-index-only-scans"/&gt; for some discussion of the
   merits of different index configurations.
</span>
複数列インデックスは慎重に使用する必要があります。
多くの場合、単一列のインデックスで十分であり、また、その方がディスク領域と時間を節約できます。
テーブルの使用方法が極端に様式化されていない限り、4つ以上の列を使用しているインデックスは、不適切である可能性が高いでしょう。
異なるインデックス構成の利点に関するこの他の説明について<a class="xref" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ">11.5</a>および<a class="xref" href="indexes-index-only-scans.html" title="11.9. インデックスオンリースキャンとカバリングインデックス">11.9</a>も参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. インデックスの種類">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html" title="第11章 インデックス">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. インデックスとORDER BY">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">11.2. インデックスの種類 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 11.4. インデックスと<code class="literal">ORDER BY</code></td></tr></table></div></body></html>