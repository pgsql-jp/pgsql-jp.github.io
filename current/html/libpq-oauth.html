<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>32.20. OAuthサポート</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-ssl.html" title="32.19. SSLサポート" /><link rel="next" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.2文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="libpq.html" title="第32章 libpq — C ライブラリ">第32章 <span class="application">libpq</span> — C ライブラリ</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.2 : libpq-oauth.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-ssl.html" title="32.19. SSLサポート">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="第32章 libpq — C ライブラリ">上へ</a></td><td width="60%" align="center">32.20. OAuthサポート</td><td width="20%" align="right"> <a accesskey="n" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い">次へ</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-OAUTH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">32.20. OAuthサポート <a href="#LIBPQ-OAUTH" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;OAuth Support&lt;/title&gt;
</span><p>
<span class="original">
   &lt;application&gt;libpq&lt;/application&gt; implements support for the OAuth v2 Device Authorization client flow,
   documented in
   &lt;ulink url="https://datatracker.ietf.org/doc/html/rfc8628"&gt;RFC 8628&lt;/ulink&gt;,
   as an optional module. See the &lt;link linkend="configure-option-with-libcurl"&gt;
   installation documentation&lt;/link&gt; for information on how to enable support
   for Device Authorization as a builtin flow.
</span>
<span class="application">libpq</span>は、<a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc8628" target="_top">RFC 8628</a>に記載されているOAuth v2デバイス認証クライアントフローのサポートを、オプションのモジュールとして実装しています。
組み込みフローとしてデバイス認証のサポートを有効にする方法については、<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">インストール文書</a>を参照してください。
  </p><p>
<span class="original">
   When support is enabled and the optional module installed, &lt;application&gt;libpq&lt;/application&gt;
   will use the builtin flow by default if the server
   &lt;link linkend="auth-oauth"&gt;requests a bearer token&lt;/link&gt; during
   authentication. This flow can be utilized even if the system running the
   client application does not have a usable web browser, for example when
   running a client via &lt;acronym&gt;SSH&lt;/acronym&gt;.
</span>
サポートが有効化されておりオプションのモジュールがインストールされている場合、認証中にサーバが<a class="link" href="auth-oauth.html" title="20.15. OAuth認可／認証">ベアラトークンを要求</a>すると、<span class="application">libpq</span>はデフォルトで組み込みフローを使用します。
このフローは、たとえば<acronym class="acronym">SSH</acronym>経由でクライアントを実行している場合など、クライアントアプリケーションを実行しているシステムに使用可能なWebブラウザがない場合でも利用できます。
  </p><p>
<span class="original">
   The builtin flow will, by default, print a URL to visit and a user code to
   enter there:
</span>
組み込みフローでは、デフォルトでアクセス先のURLとそこで入力するユーザコードを表示します。
</p><pre class="programlisting">
$ psql 'dbname=postgres oauth_issuer=https://example.com oauth_client_id=...'
Visit https://example.com/device and enter the code: ABCD-EFGH
</pre><p>
<span class="original">
   (This prompt may be
   &lt;link linkend="libpq-oauth-authdata-prompt-oauth-device"&gt;customized&lt;/link&gt;.)
   The user will then log into their OAuth provider, which will ask whether
   to allow libpq and the server to perform actions on their behalf. It is always
   a good idea to carefully review the URL and permissions displayed, to ensure
   they match expectations, before continuing. Permissions should not be given
   to untrusted third parties.
</span>
（このプロンプトは<a class="link" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE">カスタマイズ</a>されているかもしれません。）
ユーザがOAuthプロバイダにログインすると、OAuthプロバイダはlibpqとサーバがユーザの代わりにアクションを実行することを許可するかどうかを尋ねます。
続行する前に、表示されたURLと権限を注意深く確認し、期待通りであることを確認することをお勧めします。
信頼できない第三者に許可を与えてはいけません。
  </p><p>
<span class="original">
   Client applications may implement their own flows to customize interaction
   and integration with applications. See &lt;xref linkend="libpq-oauth-authdata-hooks"/&gt;
   for more information on how add a custom flow to &lt;application&gt;libpq&lt;/application&gt;.
</span>
クライアントアプリケーションは、独自のフローを実装してアプリケーションとの対話や統合をカスタマイズできます。
<span class="application">libpq</span>に独自のフローを追加する方法の詳細については、<a class="xref" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-HOOKS" title="32.20.1. 認証データフック">32.20.1</a>を参照してください。
  </p><p>
<span class="original">
   For an OAuth client flow to be usable, the connection string must at minimum
   contain &lt;xref linkend="libpq-connect-oauth-issuer"/&gt; and
   &lt;xref linkend="libpq-connect-oauth-client-id"/&gt;. (These settings are
   determined by your organization's OAuth provider.) The builtin flow
   additionally requires the OAuth authorization server to publish a device
   authorization endpoint.
</span>
OAuthクライアントフローを使用できるようにするには、接続文字列に少なくとも<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-ISSUER">oauth_issuer</a>と<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-CLIENT-ID">oauth_client_id</a>が含まれている必要があります。
（これらの設定は、利用者の組織のOAuthプロバイダによって決定されます。）
さらに組み込みフローでは、OAuth認証サーバがデバイス認証エンドポイントを公開する必要があります。
  </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    The builtin Device Authorization flow is not currently supported on Windows.
    Custom client flows may still be implemented.
</span>
組み込みデバイス認証フローは、現在Windowsではサポートされていません。
カスタムクライアントフローは引き続き実装できます。
   </p></div><div class="sect2" id="LIBPQ-OAUTH-AUTHDATA-HOOKS"><div class="titlepage"><div><div><h3 class="title">32.20.1. 認証データフック <a href="#LIBPQ-OAUTH-AUTHDATA-HOOKS" class="id_link">#</a></h3></div></div></div><span class="original">
   &lt;title&gt;Authdata Hooks&lt;/title&gt;
</span><p>
<span class="original">
    The behavior of the OAuth flow may be modified or replaced by a client using
    the following hook API:
</span>
《マッチ度[92.000000]》OAuthフローの動作は、次のフックAPIを使用するクライアントにより変更または置き換えることができます。

    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSETAUTHDATAHOOK"><span class="term"><code class="function">PQsetAuthDataHook</code><a id="id-1.7.3.27.8.2.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETAUTHDATAHOOK" class="id_link">#</a></dt><dd><p>
<span class="original">
        Sets the &lt;symbol&gt;PGauthDataHook&lt;/symbol&gt;, overriding
        &lt;application&gt;libpq&lt;/application&gt;'s handling of one or more aspects of
        its OAuth client flow.
</span>
<code class="symbol">PGauthDataHook</code>を設定し、<span class="application">libpq</span>によるOAuthクライアントフローの1つ以上の処理を上書きします。
</p><pre class="synopsis">
void PQsetAuthDataHook(PQauthDataHook_type hook);
</pre><p>
<span class="original">
        If &lt;replaceable&gt;hook&lt;/replaceable&gt; is &lt;literal&gt;NULL&lt;/literal&gt;, the
        default handler will be reinstalled. Otherwise, the application passes
        a pointer to a callback function with the signature:
</span>
<em class="replaceable"><code>hook</code></em>が<code class="literal">NULL</code>の場合、デフォルトのハンドラが再インストールされます。
それ以外の場合、アプリケーションは次のシグネチャを持つコールバック関数へのポインタを渡します。
</p><pre class="programlisting">
int hook_fn(PGauthData type, PGconn *conn, void *data);
</pre><p>
<span class="original">
        which &lt;application&gt;libpq&lt;/application&gt; will call when an action is
        required of the application. &lt;replaceable&gt;type&lt;/replaceable&gt; describes
        the request being made, &lt;replaceable&gt;conn&lt;/replaceable&gt; is the
        connection handle being authenticated, and &lt;replaceable&gt;data&lt;/replaceable&gt;
        points to request-specific metadata. The contents of this pointer are
        determined by &lt;replaceable&gt;type&lt;/replaceable&gt;; see
        &lt;xref linkend="libpq-oauth-authdata-hooks-types"/&gt; for the supported
        list.
</span>
これは、アプリケーションでアクションが必要なときに<span class="application">libpq</span>が呼び出すものです。
<em class="replaceable"><code>type</code></em>はリクエストの種類を示し、<em class="replaceable"><code>conn</code></em>は認証中の接続ハンドルを示し、<em class="replaceable"><code>data</code></em>はリクエスト固有のメタデータを指します。
このポインタの内容は<em class="replaceable"><code>type</code></em>によって決まります。
サポートされている一覧については<a class="xref" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES" title="32.20.1.1. フック型">32.20.1.1</a>を参照してください。
       </p><p>
<span class="original">
        Hooks can be chained together to allow cooperative and/or fallback
        behavior. In general, a hook implementation should examine the incoming
        &lt;replaceable&gt;type&lt;/replaceable&gt; (and, potentially, the request metadata
        and/or the settings for the particular &lt;replaceable&gt;conn&lt;/replaceable&gt;
        in use) to decide whether or not to handle a specific piece of authdata.
        If not, it should delegate to the previous hook in the chain
        (retrievable via &lt;function&gt;PQgetAuthDataHook&lt;/function&gt;).
</span>
フックをつなぎ合わせることで、連携動作や代替動作を実現できます。
一般的に、フックの実装では、入力の<em class="replaceable"><code>type</code></em>（および、場合によってはリクエストのメタデータや使用中の<em class="replaceable"><code>conn</code></em>の設定）を調べて、特定の認証データを処理するかどうかを判断する必要があります。
処理しない場合は、チェーン内の前のフック（<code class="function">PQgetAuthDataHook</code>経由で取得可能）に委任する必要があります。
       </p><p>
<span class="original">
        Success is indicated by returning an integer greater than zero.
        Returning a negative integer signals an error condition and abandons the
        connection attempt. (A zero value is reserved for the default
        implementation.)
</span>
0より大きい整数を返すと、成功していることを示します。
負の整数を返すとエラー状態であることを示しており、接続試行が中止されます。
（デフォルトの実装では0の値は予約されています。）
       </p></dd><dt id="LIBPQ-PQGETAUTHDATAHOOK"><span class="term"><code class="function">PQgetAuthDataHook</code><a id="id-1.7.3.27.8.2.1.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETAUTHDATAHOOK" class="id_link">#</a></dt><dd><p>
<span class="original">
        Retrieves the current value of &lt;symbol&gt;PGauthDataHook&lt;/symbol&gt;.
</span>
現在の<code class="symbol">PGauthDataHook</code>の値を取得します。
</p><pre class="synopsis">
PQauthDataHook_type PQgetAuthDataHook(void);
</pre><p>
<span class="original">
        At initialization time (before the first call to
        &lt;function&gt;PQsetAuthDataHook&lt;/function&gt;), this function will return
        &lt;symbol&gt;PQdefaultAuthDataHook&lt;/symbol&gt;.
</span>
初期化時（<code class="function">PQsetAuthDataHook</code>を最初に呼び出す前）には、この関数は<code class="symbol">PQdefaultAuthDataHook</code>を返します。
       </p></dd></dl></div><p>
   </p><div class="sect3" id="LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES"><div class="titlepage"><div><div><h4 class="title">32.20.1.1. フック型 <a href="#LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES" class="id_link">#</a></h4></div></div></div><span class="original">
    &lt;title&gt;Hook Types&lt;/title&gt;
</span><p>
<span class="original">
     The following &lt;symbol&gt;PGauthData&lt;/symbol&gt; types and their corresponding
     &lt;replaceable&gt;data&lt;/replaceable&gt; structures are defined:
</span>
《マッチ度[92.125984]》次の<code class="symbol">PGauthData</code>型とそれに対応する<em class="replaceable"><code>data</code></em>構造体が定義されています。

     </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE"><span class="term">
        <code class="symbol">PQAUTHDATA_PROMPT_OAUTH_DEVICE</code>
        <a id="id-1.7.3.27.8.3.2.3.1.1.2" class="indexterm"></a>
       </span> <a href="#LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE" class="id_link">#</a></dt><dd><p>
<span class="original">
         Replaces the default user prompt during the builtin device
         authorization client flow. &lt;replaceable&gt;data&lt;/replaceable&gt; points to
         an instance of &lt;symbol&gt;PGpromptOAuthDevice&lt;/symbol&gt;:
</span>
組み込みデバイス認証クライアントフロー中の、デフォルトのユーザプロンプトを置き換えます。
<em class="replaceable"><code>data</code></em>は<code class="symbol">PGpromptOAuthDevice</code>のインスタンスを指しています。
</p><pre class="synopsis">
typedef struct _PGpromptOAuthDevice
{
<span class="original">
    const char *verification_uri;   /* verification URI to visit */
    const char *user_code;          /* user code to enter */
    const char *verification_uri_complete;  /* optional combination of URI and
                                             * code, or NULL */
    int         expires_in;         /* seconds until user code expires */
</span>
    const char *verification_uri;   /* アクセスする検証URI */
    const char *user_code;          /* 入力するユーザコード */
    const char *verification_uri_complete;  /* URIとコードのオプションの組み合わせ、
                                             * またはNULL */
    int         expires_in;         /* ユーザコードの有効期限が切れるまでの秒数 */
} PGpromptOAuthDevice;
</pre><p>
        </p><p>
<span class="original">
         The OAuth Device Authorization flow which
         &lt;link linkend="configure-option-with-libcurl"&gt;can be included&lt;/link&gt;
         in &lt;application&gt;libpq&lt;/application&gt;
         requires the end user to visit a URL with a browser, then enter a code
         which permits &lt;application&gt;libpq&lt;/application&gt; to connect to the server
         on their behalf. The default prompt simply prints the
         &lt;literal&gt;verification_uri&lt;/literal&gt; and &lt;literal&gt;user_code&lt;/literal&gt;
         on standard error. Replacement implementations may display this
         information using any preferred method, for example with a GUI.
</span>
<span class="application">libpq</span>に<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">含めることができる</a>OAuthデバイス認証フローでは、エンドユーザがブラウザでURLにアクセスし、<span class="application">libpq</span>がユーザに代わってサーバに接続することを許可するコードを入力する必要があります。
デフォルトのプロンプトは、標準エラーに<code class="literal">verification_uri</code>と<code class="literal">user_code</code>を出力するだけです。
代替の実装では、この情報をGUIなど好みの方法を使用して表示できます。
        </p><p>
<span class="original">
         This callback is only invoked during the builtin device
         authorization flow. If the application installs a
         &lt;link linkend="libpq-oauth-authdata-oauth-bearer-token"&gt;custom OAuth
         flow&lt;/link&gt;, or &lt;application&gt;libpq&lt;/application&gt; was not built with
         support for the builtin flow, this authdata type will not be used.
</span>
このコールバックは、組み込みデバイス認証フロー中にのみ呼び出されます。
アプリケーションが<a class="link" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN">カスタムOAuthフロー</a>をインストールしている場合や、<span class="application">libpq</span>が組み込みフローをサポートするようにビルドされていない場合、この認証データ型は使用されません。
        </p><p>
<span class="original">
         If a non-NULL &lt;structfield&gt;verification_uri_complete&lt;/structfield&gt; is
         provided, it may optionally be used for non-textual verification (for
         example, by displaying a QR code). The URL and user code should still
         be displayed to the end user in this case, because the code will be
         manually confirmed by the provider, and the URL lets users continue
         even if they can't use the non-textual method. For more information,
         see section 3.3.1 in
         &lt;ulink url="https://datatracker.ietf.org/doc/html/rfc8628#section-3.3.1"&gt;RFC 8628&lt;/ulink&gt;.
</span>
非NULLの<code class="structfield">verification_uri_complete</code>が提供されている場合は、テキスト以外の検証（QRコードの表示など）にも使用できます。
この場合でも、URLとユーザコードは引き続きエンドユーザに表示する必要があります。
これは、そのコードがプロバイダによって手動で確認されるため、またユーザがテキスト以外の方法を使用できない場合でもURLを使用して続行できるようにするためです。
詳細については、<a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc8628#section-3.3.1" target="_top">RFC 8628</a>のセクション3.3.1を参照してください。
        </p></dd><dt id="LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN"><span class="term">
        <code class="symbol">PQAUTHDATA_OAUTH_BEARER_TOKEN</code>
        <a id="id-1.7.3.27.8.3.2.3.2.1.2" class="indexterm"></a>
       </span> <a href="#LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN" class="id_link">#</a></dt><dd><p>
<span class="original">
         Adds a custom implementation of a flow, replacing the builtin flow if
         it is &lt;link linkend="configure-option-with-libcurl"&gt;installed&lt;/link&gt;.
         The hook should either directly return a Bearer token for the current
         user/issuer/scope combination, if one is available without blocking, or
         else set up an asynchronous callback to retrieve one.
</span>
独自実装したフローを追加し、組み込みフローが<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">インストールされている</a>場合はそれを置き換えます。
フックは、ブロッキングなしで使用可能な場合は現在のユーザ/発行者/スコープの組み合わせのベアラトークンを直接返すか、それ以外の場合は非同期コールバックを設定してベアラトークンを取得する必要があります。
        </p><p>
<span class="original">
         &lt;replaceable&gt;data&lt;/replaceable&gt; points to an instance
         of &lt;symbol&gt;PGoauthBearerRequest&lt;/symbol&gt;, which should be filled in
         by the implementation:
</span>
<em class="replaceable"><code>data</code></em>は<code class="symbol">PGoauthBearerRequest</code>のインスタンスを指しています。
このインスタンスは実装側で入力する必要があります。
</p><pre class="synopsis">
typedef struct PGoauthBearerRequest
{
<span class="original">
    /* Hook inputs (constant across all calls) */
    const char *openid_configuration; /* OIDC discovery URL */
    const char *scope;                /* required scope(s), or NULL */
</span>
    /* フックの入力（全ての呼び出しで一定） */
    const char *openid_configuration; /* OIDCディスカバリーURL */
    const char *scope;                /* 必要なスコープ、またはNULL */

<span class="original">
    /* Hook outputs */
</span>
    /* フックの出力 */

    /*
     * Callback implementing a custom asynchronous OAuth flow. The signature is
     * platform-dependent: PQ_SOCKTYPE is SOCKET on Windows, and int everywhere
     * else.
     */
    PostgresPollingStatusType (*async) (PGconn *conn,
                                        struct PGoauthBearerRequest *request,
                                        PQ_SOCKTYPE *altsock);

<span class="original">
    /* Callback to clean up custom allocations. */
</span>
    /* カスタム割り当てをクリーンアップするためのコールバック。 */
    void        (*cleanup) (PGconn *conn, struct PGoauthBearerRequest *request);

<span class="original">
    char       *token;   /* acquired Bearer token */
    void       *user;    /* hook-defined allocated data */
</span>
    char       *token;   /* 取得したベアラトークン */
    void       *user;    /* フックで定義される割り当てデータ */
} PGoauthBearerRequest;
</pre><p>
        </p><p>
<span class="original">
         Two pieces of information are provided to the hook by
         &lt;application&gt;libpq&lt;/application&gt;:
         &lt;replaceable&gt;openid_configuration&lt;/replaceable&gt; contains the URL of an
         OAuth discovery document describing the authorization server's
         supported flows, and &lt;replaceable&gt;scope&lt;/replaceable&gt; contains a
         (possibly empty) space-separated list of OAuth scopes which are
         required to access the server. Either or both may be
         &lt;literal&gt;NULL&lt;/literal&gt; to indicate that the information was not
         discoverable. (In this case, implementations may be able to establish
         the requirements using some other preconfigured knowledge, or they may
         choose to fail.)
</span>
<span class="application">libpq</span>では、このフックで2つの情報を提供しています。
<em class="replaceable"><code>openid_configuration</code></em>には、認証サーバがサポートするフローを説明するOAuthディスカバリー文書のURLが含まれ、<em class="replaceable"><code>scope</code></em>には、サーバへのアクセスに必要なOAuthスコープの一覧（空の場合もあります）がスペースで区切られて含まれています。
どちらか一方または両方が<code class="literal">NULL</code>の場合は、情報が検出できなかったことを示します。
（この場合、実装側で事前に設定された他の知識を使用して要件を確立できる場合もあれば、失敗を選択する場合もあります。）
        </p><p>
<span class="original">
         The final output of the hook is &lt;replaceable&gt;token&lt;/replaceable&gt;, which
         must point to a valid Bearer token for use on the connection. (This
         token should be issued by the
         &lt;xref linkend="libpq-connect-oauth-issuer"/&gt; and hold the requested
         scopes, or the connection will be rejected by the server's validator
         module.) The allocated token string must remain valid until
         &lt;application&gt;libpq&lt;/application&gt; is finished connecting; the hook
         should set a &lt;replaceable&gt;cleanup&lt;/replaceable&gt; callback which will be
         called when &lt;application&gt;libpq&lt;/application&gt; no longer requires it.
</span>
フックの最終出力は<em class="replaceable"><code>token</code></em>であり、これは接続で使用できる有効なベアラトークンを指している必要があります。
（このトークンは<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-ISSUER">oauth_issuer</a>によって発行され、要求されたスコープを保持する必要があります。
そうしないと、サーバの検証モジュールによって接続が拒否されます。）
割り当てられたトークン文字列は、<span class="application">libpq</span>が接続を終了するまで有効なままでなければなりません。
フックは、<span class="application">libpq</span>が接続を必要としなくなったときに呼び出される<em class="replaceable"><code>cleanup</code></em>コールバックを設定する必要があります。
        </p><p>
<span class="original">
         If an implementation cannot immediately produce a
         &lt;replaceable&gt;token&lt;/replaceable&gt; during the initial call to the hook,
         it should set the &lt;replaceable&gt;async&lt;/replaceable&gt; callback to handle
         nonblocking communication with the authorization server.
</span>
実装上フックの最初の呼び出し中にすぐに<em class="replaceable"><code>token</code></em>を生成できない場合は、認証サーバとの非ブロッキング通信を処理するように<em class="replaceable"><code>非同期</code></em>コールバックを設定する必要があります。
         <a href="#ftn.id-1.7.3.27.8.3.2.3.2.2.5.3" class="footnote"><sup class="footnote" id="id-1.7.3.27.8.3.2.3.2.2.5.3">[16]</sup></a>
         This will be called to begin the flow immediately upon return from the
         hook. When the callback cannot make further progress without blocking,
         it should return either <code class="symbol">PGRES_POLLING_READING</code> or
         <code class="symbol">PGRES_POLLING_WRITING</code> after setting
         <code class="literal">*altsock</code> to the file descriptor that will be marked
         ready to read/write when progress can be made again. (This descriptor
         is then provided to the top-level polling loop via
         <code class="function">PQsocket()</code>.) Return <code class="symbol">PGRES_POLLING_OK</code>
         after setting <em class="replaceable"><code>token</code></em> when the flow is
         complete, or <code class="symbol">PGRES_POLLING_FAILED</code> to indicate failure.
        </p><p>
<span class="original">
         Implementations may wish to store additional data for bookkeeping
         across calls to the &lt;replaceable&gt;async&lt;/replaceable&gt; and
         &lt;replaceable&gt;cleanup&lt;/replaceable&gt; callbacks. The
         &lt;replaceable&gt;user&lt;/replaceable&gt; pointer is provided for this purpose;
         &lt;application&gt;libpq&lt;/application&gt; will not touch its contents and the
         application may use it at its convenience. (Remember to free any
         allocations during token cleanup.)
</span>
実装によっては、<em class="replaceable"><code>async</code></em>コールバックと<em class="replaceable"><code>cleanup</code></em>コールバックの呼び出しをまたぐ情報に対し、追加のデータを格納したい場合があります。
<em class="replaceable"><code>user</code></em>ポインタはこの目的のために提供されています。
<span class="application">libpq</span>はその内容に触れることはなく、アプリケーションは都合の良いときにこの追加のデータを使用できます。
（トークンのクリーンアップ中に割り当てを解放することを忘れないでください。）
        </p></dd></dl></div><p>
    </p></div></div><div class="sect2" id="LIBPQ-OAUTH-DEBUGGING"><div class="titlepage"><div><div><h3 class="title">32.20.2. デバッグと開発者用の設定 <a href="#LIBPQ-OAUTH-DEBUGGING" class="id_link">#</a></h3></div></div></div><span class="original">
   &lt;title&gt;Debugging and Developer Settings&lt;/title&gt;
</span><p>
<span class="original">
    A "dangerous debugging mode" may be enabled by setting the environment
    variable &lt;envar&gt;PGOAUTHDEBUG=UNSAFE&lt;/envar&gt;. This functionality is provided
    for ease of local development and testing only. It does several things that
    you will not want a production system to do:
</span>
環境変数<code class="envar">PGOAUTHDEBUG=UNSAFE</code>を設定することで、「危険なデバッグモード」を有効にできます。
この機能は、ローカルでの開発とテストを容易にするためにのみ提供されています。
この機能は、本番システムでは実行したくないいくつかのことを実行します。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       permits the use of unencrypted HTTP during the OAuth provider exchange
</span>
OAuthプロバイダの交換中に暗号化されていないHTTPを使用することを許可します
      </p></li><li class="listitem"><p>
<span class="original">
       allows the system's trusted CA list to be completely replaced using the
       &lt;envar&gt;PGOAUTHCAFILE&lt;/envar&gt; environment variable
</span>
<code class="envar">PGOAUTHCAFILE</code>環境変数を使用して、システムの信頼するCAリストを完全に置き換えることができます
      </p></li><li class="listitem"><p>
<span class="original">
       prints HTTP traffic (containing several critical secrets) to standard
       error during the OAuth flow
</span>
OAuthフロー中にHTTPトラフィック（いくつかの重要なシークレットを含む）を標準エラーに出力します
      </p></li><li class="listitem"><p>
<span class="original">
       permits the use of zero-second retry intervals, which can cause the
       client to busy-loop and pointlessly consume CPU
</span>
0秒の再試行間隔の使用を許可します。
これにより、クライアントはビジーループ状態になり、CPUを無意味に消費する可能性があります
      </p></li></ul></div><p>
   </p><div class="warning"><h3 class="title">警告</h3><p>
<span class="original">
     Do not share the output of the OAuth flow traffic with third parties. It
     contains secrets that can be used to attack your clients and servers.
</span>
OAuthフロートラフィックの出力を第三者と共有しないでください。
クライアントやサーバを攻撃するために使用できるシークレットが含まれています。
    </p></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.7.3.27.8.3.2.3.2.2.5.3" class="footnote"><p><a href="#id-1.7.3.27.8.3.2.3.2.2.5.3" class="para"><sup class="para">[16] </sup></a>
<span class="original">
           Performing blocking operations during the
           &lt;symbol&gt;PQAUTHDATA_OAUTH_BEARER_TOKEN&lt;/symbol&gt; hook callback will
           interfere with nonblocking connection APIs such as
           &lt;function&gt;PQconnectPoll&lt;/function&gt; and prevent concurrent connections
           from making progress. Applications which only ever use the
           synchronous connection primitives, such as
           &lt;function&gt;PQconnectdb&lt;/function&gt;, may synchronously retrieve a token
           during the hook instead of implementing the
           &lt;replaceable&gt;async&lt;/replaceable&gt; callback, but they will necessarily
           be limited to one connection at a time.
</span>
<code class="symbol">PQAUTHDATA_OAUTH_BEARER_TOKEN</code>フックコールバック中にブロッキング操作を実行すると、<code class="function">PQconnectPoll</code>などの非ブロッキングな接続APIが妨害され、同時接続の進行が妨げられます。
<code class="function">PQconnectdb</code>のように同期接続プリミティブのみを使用するアプリケーションでは、<em class="replaceable"><code>async</code></em>コールバックを実装する代わりにフック中にトークンを同期的に取得できますが、一度に1つの接続に制限される必要があります。
          </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-ssl.html" title="32.19. SSLサポート">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="第32章 libpq — C ライブラリ">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">32.19. SSLサポート </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.2文書">ホーム</a></td><td width="40%" align="right" valign="top"> 32.21. スレッド化プログラムの振舞い</td></tr></table></div></body></html>