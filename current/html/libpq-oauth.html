<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>32.20. OAuth Support</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="libpq-ssl.html" title="32.19. SSLサポート" /><link rel="next" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="libpq.html" title="第32章 libpq — C ライブラリ">第32章 <span class="application">libpq</span> — C ライブラリ</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.0 : libpq-oauth.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-ssl.html" title="32.19. SSLサポート">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="第32章 libpq — C ライブラリ">上へ</a></td><td width="60%" align="center">32.20. OAuth Support</td><td width="20%" align="right"> <a accesskey="n" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い">次へ</a></td></tr></table><hr /></div><div class="sect1" id="LIBPQ-OAUTH"><div class="titlepage"><div><div><h2 class="title" style="clear: both">32.20. OAuth Support <a href="#LIBPQ-OAUTH" class="id_link">#</a></h2></div></div></div><p>
<span class="original">
   &lt;application&gt;libpq&lt;/application&gt; implements support for the OAuth v2 Device Authorization client flow,
   documented in
   &lt;ulink url="https://datatracker.ietf.org/doc/html/rfc8628"&gt;RFC 8628&lt;/ulink&gt;,
   as an optional module. See the &lt;link linkend="configure-option-with-libcurl"&gt;
   installation documentation&lt;/link&gt; for information on how to enable support
   for Device Authorization as a builtin flow.
</span>
《機械翻訳》<span class="application">libpq</span><a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc8628" target="_top">RFC 8628に記載されている、OAuth v2サポート認証のためのデバイスをクライアントモジュールとして実装しています</a>。
組み込みフローとしてデバイス認証のためのサポートを有効にする方法については、<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">インストール文書</a>を参照してください。
オプショナルフロー
  </p><p>
<span class="original">
   When support is enabled and the optional module installed, &lt;application&gt;libpq&lt;/application&gt;
   will use the builtin flow by default if the server
   &lt;link linkend="auth-oauth"&gt;requests a bearer token&lt;/link&gt; during
   authentication. This flow can be utilized even if the system running the
   client application does not have a usable web browser, for example when
   running a client via &lt;acronym&gt;SSH&lt;/acronym&gt;.
</span>
《機械翻訳》サポートが有効でオプショナルモジュールがインストールされている場合、フロー中にデフォルトが<a class="link" href="auth-oauth.html" title="20.15. OAuth Authorization/Authentication">ベアラトークンを要求</a>すると、<span class="application">libpq</span>は組み込みのサーバby認証を使用します。
このフローは、クライアントアプリケーションを実行しているシステムに使用可能なWebブラウザがない場合でも、<acronym class="acronym">SSH</acronym>経由でクライアントを実行している場合の例に使用できます。
  </p><p>
<span class="original">
   The builtin flow will, by default, print a URL to visit and a user code to
   enter there:
</span>
《機械翻訳》組み込みのフローでは、デフォルト、プリント別に、訪問するURLと、そこに入力するユーザコードが表示されます。
</p><pre class="programlisting">
$ psql 'dbname=postgres oauth_issuer=https://example.com oauth_client_id=...'
Visit https://example.com/device and enter the code: ABCD-EFGH
</pre><p>
<span class="original">
   (This prompt may be
   &lt;link linkend="libpq-oauth-authdata-prompt-oauth-device"&gt;customized&lt;/link&gt;.)
   The user will then log into their OAuth provider, which will ask whether
   to allow libpq and the server to perform actions on their behalf. It is always
   a good idea to carefully review the URL and permissions displayed, to ensure
   they match expectations, before continuing. Permissions should not be given
   to untrusted third parties.
</span>
《機械翻訳》（このプロンプトは<a class="link" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE">カスタマイズされている</a>可能性があります。）
その後、ユーザはログをOAuthプロバイダに入れ、libpqとサーバが彼らに代わってアクションを実行することを許可するかどうかを尋ねます。
表示されたURLと権限を慎重にレビューし、保証に期待をマッチさせ、前を続けることは、常に良いアイディアです。
信頼できないサードパーティに権限を与えるべきではありません。
  </p><p>
<span class="original">
   Client applications may implement their own flows to customize interaction
   and integration with applications. See &lt;xref linkend="libpq-oauth-authdata-hooks"/&gt;
   for more information on how add a custom flow to &lt;application&gt;libpq&lt;/application&gt;.
</span>
《機械翻訳》クライアントアプリケーションは、カスタマイズとの対話およびアプリケーションとの統合に独自のフローを実装する場合があります。
カスタムフローを<span class="application">libpq</span>に追加する方法の詳細は、<a class="xref" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-HOOKS" title="32.20.1. Authdata Hooks">32.20.1</a>を参照してください。
  </p><p>
<span class="original">
   For an OAuth client flow to be usable, the connection string must at minimum
   contain &lt;xref linkend="libpq-connect-oauth-issuer"/&gt; and
   &lt;xref linkend="libpq-connect-oauth-client-id"/&gt;. (These settings are
   determined by your organization's OAuth provider.) The builtin flow
   additionally requires the OAuth authorization server to publish a device
   authorization endpoint.
</span>
《機械翻訳》OAuthクライアントフローを使用するには、コネクション文字列に少なくとも<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-ISSUER">oauth_issuer</a>と<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-CLIENT-ID">oauth_client_id</a>が含まれている必要があります。
（これらの設定は、組織のOAuthプロバイダによって決定されます。）
組み込みのフローには、デバイス認証エンドポイントをパブリッシュするためのOAuth認証サーバも必要です。
  </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    The builtin Device Authorization flow is not currently supported on Windows.
    Custom client flows may still be implemented.
</span>
《機械翻訳》組み込みのデバイス許可フローは現在、Windowsではサポートされていません。
カスタムクライアントフローはまだ実装されている可能性があります。
   </p></div><div class="sect2" id="LIBPQ-OAUTH-AUTHDATA-HOOKS"><div class="titlepage"><div><div><h3 class="title">32.20.1. Authdata Hooks <a href="#LIBPQ-OAUTH-AUTHDATA-HOOKS" class="id_link">#</a></h3></div></div></div><p>
<span class="original">
    The behavior of the OAuth flow may be modified or replaced by a client using
    the following hook API:
</span>
《機械翻訳》OAuthフローの動作は、次のクライアントAPIを使用して変更またはフックに置き換えることができます。

    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSETAUTHDATAHOOK"><span class="term"><code class="function">PQsetAuthDataHook</code><a id="id-1.7.3.27.8.2.1.1.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQSETAUTHDATAHOOK" class="id_link">#</a></dt><dd><p>
<span class="original">
        Sets the &lt;symbol&gt;PGauthDataHook&lt;/symbol&gt;, overriding
        &lt;application&gt;libpq&lt;/application&gt;'s handling of one or more aspects of
        its OAuth client flow.
</span>
《機械翻訳》OAuthハンドリングフローの1つ以上のアスペクトの<code class="symbol">PGauthDataHook</code>,overriding <span class="application">libpq</span>のクライアントを設定します。
</p><pre class="synopsis">
void PQsetAuthDataHook(PQauthDataHook_type hook);
</pre><p>
<span class="original">
        If &lt;replaceable&gt;hook&lt;/replaceable&gt; is &lt;literal&gt;NULL&lt;/literal&gt;, the
        default handler will be reinstalled. Otherwise, the application passes
        a pointer to a callback function with the signature:
</span>
《機械翻訳》<em class="replaceable"><code>フック</code></em>が<code class="literal">NULL</code>の場合、デフォルトハンドラは再インストールされます。
それ以外の場合、アプリケーションはポインタをシグネチャ:とともにコールバック機能に渡します。
</p><pre class="programlisting">
int hook_fn(PGauthData type, PGconn *conn, void *data);
</pre><p>
<span class="original">
        which &lt;application&gt;libpq&lt;/application&gt; will call when an action is
        required of the application. &lt;replaceable&gt;type&lt;/replaceable&gt; describes
        the request being made, &lt;replaceable&gt;conn&lt;/replaceable&gt; is the
        connection handle being authenticated, and &lt;replaceable&gt;data&lt;/replaceable&gt;
        points to request-specific metadata. The contents of this pointer are
        determined by &lt;replaceable&gt;type&lt;/replaceable&gt;; see
        &lt;xref linkend="libpq-oauth-authdata-hooks-types"/&gt; for the supported
        list.
</span>
《機械翻訳》この<span class="application">libpq</span>は、アプリケーションに対してアクションが要求されたときに呼び出しを行います。
<em class="replaceable"><code>type</code></em>は作成されるリクエストを記述し、<em class="replaceable"><code>conn</code></em>は認証されるコネクションハンドルであり、<em class="replaceable"><code>data</code></em>はリクエスト固有のメタデータを指します。
このポインタの内容は<em class="replaceable"><code>type</code></em>によって決定されます。
サポートされるリストについては<a class="xref" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES" title="32.20.1.1. Hook Types">32.20.1.1</a>を参照してください。
       </p><p>
<span class="original">
        Hooks can be chained together to allow cooperative and/or fallback
        behavior. In general, a hook implementation should examine the incoming
        &lt;replaceable&gt;type&lt;/replaceable&gt; (and, potentially, the request metadata
        and/or the settings for the particular &lt;replaceable&gt;conn&lt;/replaceable&gt;
        in use) to decide whether or not to handle a specific piece of authdata.
        If not, it should delegate to the previous hook in the chain
        (retrievable via &lt;function&gt;PQgetAuthDataHook&lt;/function&gt;).
</span>
《機械翻訳》フックは、連携動作や代替動作を可能にするために連鎖させることができます。
一般に、フック実装は、特定のauthdataをハンドルするかどうかを決定するために、着信<em class="replaceable"><code>タイプ</code></em>を調べる必要があります（場合によっては、リクエストメタデータや、使用中の特定の<em class="replaceable"><code>conn</code></em>の設定も調べる必要があります）。
そうでない場合は、チェーン内の前のフックに委任する必要があります（<code class="function">PQgetAuthDataHook</code>を使用して取得可能）。
       </p><p>
<span class="original">
        Success is indicated by returning an integer greater than zero.
        Returning a negative integer signals an error condition and abandons the
        connection attempt. (A zero value is reserved for the default
        implementation.)
</span>
《機械翻訳》成功は、整数より大きいゼロを戻すことで示されます。
負の整数を戻すと、エラー条件が通知され、コネクション試行が中止されます（デフォルト実装のゼロ値は予約です）。
       </p></dd><dt id="LIBPQ-PQGETAUTHDATAHOOK"><span class="term"><code class="function">PQgetAuthDataHook</code><a id="id-1.7.3.27.8.2.1.2.1.2" class="indexterm"></a></span> <a href="#LIBPQ-PQGETAUTHDATAHOOK" class="id_link">#</a></dt><dd><p>
<span class="original">
        Retrieves the current value of &lt;symbol&gt;PGauthDataHook&lt;/symbol&gt;.
</span>
《機械翻訳》現在の<code class="symbol">PGauthDataHook</code>.
</p><pre class="synopsis">
PQauthDataHook_type PQgetAuthDataHook(void);
</pre><p>
<span class="original">
        At initialization time (before the first call to
        &lt;function&gt;PQsetAuthDataHook&lt;/function&gt;), this function will return
        &lt;symbol&gt;PQdefaultAuthDataHook&lt;/symbol&gt;.
</span>
《機械翻訳》初期設定時に<code class="function">PQsetAuthDataHook</code>前はへの最初の呼び出しで、この関数は結果<code class="symbol">PQdefaultAuthDataHook</code>。
       </p></dd></dl></div><p>
   </p><div class="sect3" id="LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES"><div class="titlepage"><div><div><h4 class="title">32.20.1.1. Hook Types <a href="#LIBPQ-OAUTH-AUTHDATA-HOOKS-TYPES" class="id_link">#</a></h4></div></div></div><p>
<span class="original">
     The following &lt;symbol&gt;PGauthData&lt;/symbol&gt; types and their corresponding
     &lt;replaceable&gt;data&lt;/replaceable&gt; structures are defined:
</span>
《機械翻訳》以下の<code class="symbol">PGauthData</code>型とそれに対応する<em class="replaceable"><code>data</code></em>構造体が定義されています。

     </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE"><span class="term">
        <code class="symbol">PQAUTHDATA_PROMPT_OAUTH_DEVICE</code>
        <a id="id-1.7.3.27.8.3.2.3.1.1.2" class="indexterm"></a>
       </span> <a href="#LIBPQ-OAUTH-AUTHDATA-PROMPT-OAUTH-DEVICE" class="id_link">#</a></dt><dd><p>
<span class="original">
         Replaces the default user prompt during the builtin device
         authorization client flow. &lt;replaceable&gt;data&lt;/replaceable&gt; points to
         an instance of &lt;symbol&gt;PGpromptOAuthDevice&lt;/symbol&gt;:
</span>
《機械翻訳》組み込みデフォルト許可クライアントプロンプト中にユーザフローデバイスを置き換えます。
<em class="replaceable"><code>data</code></em>は<code class="symbol">PGpromptOAuthDevice</code>:のインスタンスを指します。
</p><pre class="synopsis">
typedef struct _PGpromptOAuthDevice
{
    const char *verification_uri;   /* verification URI to visit */
    const char *user_code;          /* user code to enter */
    const char *verification_uri_complete;  /* optional combination of URI and
                                             * code, or NULL */
    int         expires_in;         /* seconds until user code expires */
} PGpromptOAuthDevice;
</pre><p>
        </p><p>
<span class="original">
         The OAuth Device Authorization flow which
         &lt;link linkend="configure-option-with-libcurl"&gt;can be included&lt;/link&gt;
         in &lt;application&gt;libpq&lt;/application&gt;
         requires the end user to visit a URL with a browser, then enter a code
         which permits &lt;application&gt;libpq&lt;/application&gt; to connect to the server
         on their behalf. The default prompt simply prints the
         &lt;literal&gt;verification_uri&lt;/literal&gt; and &lt;literal&gt;user_code&lt;/literal&gt;
         on standard error. Replacement implementations may display this
         information using any preferred method, for example with a GUI.
</span>
《機械翻訳》<span class="application">libpq</span>に<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">含めることができる</a>OAuthデバイス認証フローは、エンドユーザがブラウザのあるURLにアクセスし、<span class="application">libpq</span>がサーバに接続することを許可するコードを入力する必要があります。
デフォルトプロンプトは、単に<code class="literal">verification_uri</code>および<code class="literal">user_code</code>標準エラーのを出力します。
置換実装では、GUIのある例に対して、任意の優先メソッドを使用してこの情報をディスプレイする場合があります。
        </p><p>
<span class="original">
         This callback is only invoked during the builtin device
         authorization flow. If the application installs a
         &lt;link linkend="libpq-oauth-authdata-oauth-bearer-token"&gt;custom OAuth
         flow&lt;/link&gt;, or &lt;application&gt;libpq&lt;/application&gt; was not built with
         support for the builtin flow, this authdata type will not be used.
</span>
《機械翻訳》このコールバックは、組み込みのデバイス許可フロー中にのみ呼び出されます。
アプリケーションが<a class="link" href="libpq-oauth.html#LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN">カスタムOAuthフロー</a>をインストールする場合、または<span class="application">libpq</span>組み込みのフロー用にサポートで構築されていない場合、このauthdataタイプは使用されません。
        </p><p>
<span class="original">
         If a non-NULL &lt;structfield&gt;verification_uri_complete&lt;/structfield&gt; is
         provided, it may optionally be used for non-textual verification (for
         example, by displaying a QR code). The URL and user code should still
         be displayed to the end user in this case, because the code will be
         manually confirmed by the provider, and the URL lets users continue
         even if they can't use the non-textual method. For more information,
         see section 3.3.1 in
         &lt;ulink url="https://datatracker.ietf.org/doc/html/rfc8628#section-3.3.1"&gt;RFC 8628&lt;/ulink&gt;.
</span>
《機械翻訳》非NULL <code class="structfield">verification_uri_complete</code>が提供されている場合は、オプションで非テキストの確認例の場合はQRコードの表示に使用できます。
コードはプロバイダによって手動で確認されるため、URLとユーザコードはこのケースのエンドユーザに表示される必要があります。
URLを使用すると、ユーザは非テキストメソッドを使用できない場合でも続行できます。
詳細は、<a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc8628#section-3.3.1" target="_top">RFC 8628</a>のセクション3.3.1を参照してください。
        </p></dd><dt id="LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN"><span class="term">
        <code class="symbol">PQAUTHDATA_OAUTH_BEARER_TOKEN</code>
        <a id="id-1.7.3.27.8.3.2.3.2.1.2" class="indexterm"></a>
       </span> <a href="#LIBPQ-OAUTH-AUTHDATA-OAUTH-BEARER-TOKEN" class="id_link">#</a></dt><dd><p>
<span class="original">
         Adds a custom implementation of a flow, replacing the builtin flow if
         it is &lt;link linkend="configure-option-with-libcurl"&gt;installed&lt;/link&gt;.
         The hook should either directly return a Bearer token for the current
         user/issuer/scope combination, if one is available without blocking, or
         else set up an asynchronous callback to retrieve one.
</span>
《機械翻訳》フローのカスタム実装を追加し、組込みフロー<a class="link" href="install-make.html#CONFIGURE-OPTION-WITH-LIBCURL">インストールされている場合</a>を置き換えます。
フックは、ブロッキングなしで使用可能な場合は、現在ユーザ/発行者/スコープの組合せのベアラトークンを直接結果するか、それを取得するための非同期コールバックを設定する必要があります。
        </p><p>
<span class="original">
         &lt;replaceable&gt;data&lt;/replaceable&gt; points to an instance
         of &lt;symbol&gt;PGoauthBearerRequest&lt;/symbol&gt;, which should be filled in
         by the implementation:
</span>
《機械翻訳》<em class="replaceable"><code>data</code></em>は<code class="symbol">PGoauthBearerRequest</code>のインスタンスを指し、これは実装:によって記入されるべきである。
</p><pre class="synopsis">
typedef struct PGoauthBearerRequest
{
    /* Hook inputs (constant across all calls) */
    const char *openid_configuration; /* OIDC discovery URL */
    const char *scope;                /* required scope(s), or NULL */

    /* Hook outputs */

    /* Callback implementing a custom asynchronous OAuth flow. */
    PostgresPollingStatusType (*async) (PGconn *conn,
                                        struct PGoauthBearerRequest *request,
                                        SOCKTYPE *altsock);

    /* Callback to clean up custom allocations. */
    void        (*cleanup) (PGconn *conn, struct PGoauthBearerRequest *request);

    char       *token;   /* acquired Bearer token */
    void       *user;    /* hook-defined allocated data */
} PGoauthBearerRequest;
</pre><p>
        </p><p>
<span class="original">
         Two pieces of information are provided to the hook by
         &lt;application&gt;libpq&lt;/application&gt;:
         &lt;replaceable&gt;openid_configuration&lt;/replaceable&gt; contains the URL of an
         OAuth discovery document describing the authorization server's
         supported flows, and &lt;replaceable&gt;scope&lt;/replaceable&gt; contains a
         (possibly empty) space-separated list of OAuth scopes which are
         required to access the server. Either or both may be
         &lt;literal&gt;NULL&lt;/literal&gt; to indicate that the information was not
         discoverable. (In this case, implementations may be able to establish
         the requirements using some other preconfigured knowledge, or they may
         choose to fail.)
</span>
《機械翻訳》次の2つの情報が<span class="application">libpq</span>によってフックに提供されます。
<em class="replaceable"><code>openid_設定</code></em>包含は、認可サーバがサポートするフローを記述するOAuthディスカバリドキュメントのURLであり、<em class="replaceable"><code>スコープ</code></em>包含は、サーバをアクセス化するために必要なOAuthスコープのスペースで区切られた（空の場合もある）リストです。
いずれかまたは両方が<code class="literal">NULL</code>情報が検出できなかったことを示すためである可能性があります。
（このケースでは、実装は他の事前設定された知識を使用して要件を確立できる場合もあれば、失敗することを選択する場合もあります。）
        </p><p>
<span class="original">
         The final output of the hook is &lt;replaceable&gt;token&lt;/replaceable&gt;, which
         must point to a valid Bearer token for use on the connection. (This
         token should be issued by the
         &lt;xref linkend="libpq-connect-oauth-issuer"/&gt; and hold the requested
         scopes, or the connection will be rejected by the server's validator
         module.) The allocated token string must remain valid until
         &lt;application&gt;libpq&lt;/application&gt; is finished connecting; the hook
         should set a &lt;replaceable&gt;cleanup&lt;/replaceable&gt; callback which will be
         called when &lt;application&gt;libpq&lt;/application&gt; no longer requires it.
</span>
《機械翻訳》フックの最終出力は<em class="replaceable"><code>token</code></em>です。
これは、コネクションで使用するために有効なベアラトークンにポイントする必要があります。
（このトークンは<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-OAUTH-ISSUER">oauth_issuer</a>によって発行され、要求されたスコープを保持する必要があります。
そうしないと、コネクションはサーバのバリデータモジュールによって拒否されます。）
割り当てられたトークン文字列は、<span class="application">libpq</span>が接続を完了するまで有効である必要があります。
フックは、<span class="application">libpq</span>必要としなくなったときに呼び出されるコールバックを設定する必要があります。
<em class="replaceable"><code>cleanup</code></em>
        </p><p>
         If an implementation cannot immediately produce a
         <em class="replaceable"><code>token</code></em> during the initial call to the hook,
         it should set the <em class="replaceable"><code>async</code></em> callback to handle
         nonblocking communication with the authorization server.
         <a href="#ftn.id-1.7.3.27.8.3.2.3.2.2.5.3" class="footnote"><sup class="footnote" id="id-1.7.3.27.8.3.2.3.2.2.5.3">[16]</sup></a>
         This will be called to begin the flow immediately upon return from the
         hook. When the callback cannot make further progress without blocking,
         it should return either <code class="symbol">PGRES_POLLING_READING</code> or
         <code class="symbol">PGRES_POLLING_WRITING</code> after setting
         <code class="literal">*pgsocket</code> to the file descriptor that will be marked
         ready to read/write when progress can be made again. (This descriptor
         is then provided to the top-level polling loop via
         <code class="function">PQsocket()</code>.) Return <code class="symbol">PGRES_POLLING_OK</code>
         after setting <em class="replaceable"><code>token</code></em> when the flow is
         complete, or <code class="symbol">PGRES_POLLING_FAILED</code> to indicate failure.
        </p><p>
<span class="original">
         Implementations may wish to store additional data for bookkeeping
         across calls to the &lt;replaceable&gt;async&lt;/replaceable&gt; and
         &lt;replaceable&gt;cleanup&lt;/replaceable&gt; callbacks. The
         &lt;replaceable&gt;user&lt;/replaceable&gt; pointer is provided for this purpose;
         &lt;application&gt;libpq&lt;/application&gt; will not touch its contents and the
         application may use it at its convenience. (Remember to free any
         allocations during token cleanup.)
</span>
《機械翻訳》実装によっては、<em class="replaceable"><code>async</code></em>および<em class="replaceable"><code>cleanup</code></em> callbacks. <em class="replaceable"><code>user</code></em>データはこの目的のために提供されています。
<span class="application">libpq</span>はその内容に触れることはなく、ポインタは都合のよいときにそれを使用することができます。
アプリケーションクリーンアップ中に割り当てられたものをフリーすることを忘れないでください。
への呼び出し全体にわたって簿記のために追加のトークンを格納することを望む場合があります。
        </p></dd></dl></div><p>
    </p></div></div><div class="sect2" id="LIBPQ-OAUTH-DEBUGGING"><div class="titlepage"><div><div><h3 class="title">32.20.2. Debugging and Developer Settings <a href="#LIBPQ-OAUTH-DEBUGGING" class="id_link">#</a></h3></div></div></div><p>
<span class="original">
    A "dangerous debugging mode" may be enabled by setting the environment
    variable &lt;envar&gt;PGOAUTHDEBUG=UNSAFE&lt;/envar&gt;. This functionality is provided
    for ease of local development and testing only. It does several things that
    you will not want a production system to do:
</span>
《機械翻訳》「危険なデバッグモード」は、環境変数<code class="envar">PGOAUTHDEBUG=UNSAFE</code>を設定することで有効にできます。
この機能は、ローカルの開発とテストを容易にするためにのみ提供されています。
この機能は、本番システムでは実行したくないいくつかのことを実行します。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       permits the use of unencrypted HTTP during the OAuth provider exchange
</span>
《機械翻訳》は、OAuthプロバイダの交換中に暗号化されていないHTTPの使用を許可します。
      </p></li><li class="listitem"><p>
<span class="original">
       allows the system's trusted CA list to be completely replaced using the
       &lt;envar&gt;PGOAUTHCAFILE&lt;/envar&gt; environment variable
</span>
《機械翻訳》<code class="envar">PGOAUTHCAFILE</code>リストを使用して、このシステムのカリフォルニア州トラステッド環境変数を完全に置き換えることができます。
      </p></li><li class="listitem"><p>
<span class="original">
       prints HTTP traffic (containing several critical secrets) to standard
       error during the OAuth flow
</span>
《機械翻訳》はOAuthトラフィック中にHTTPフロー（いくつかの重要な秘密情報を含む）を標準エラーに出力する。
      </p></li><li class="listitem"><p>
<span class="original">
       permits the use of zero-second retry intervals, which can cause the
       client to busy-loop and pointlessly consume CPU
</span>
《機械翻訳》では、ゼロ秒のリトライ間隔を使用できます。
これにより、クライアントがビジー-ループになり、CPU使用率が無意味に消費される可能性があります。
      </p></li></ul></div><p>
   </p><div class="warning"><h3 class="title">警告</h3><p>
<span class="original">
     Do not share the output of the OAuth flow traffic with third parties. It
     contains secrets that can be used to attack your clients and servers.
</span>
《機械翻訳》OAuthフロートラフィックの出力を第三者と共有しないでください。
クライアントやサーバを攻撃するために使用できる包含シークレットです。
    </p></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.7.3.27.8.3.2.3.2.2.5.3" class="footnote"><p><a href="#id-1.7.3.27.8.3.2.3.2.2.5.3" class="para"><sup class="para">[16] </sup></a>
<span class="original">
           Performing blocking operations during the
           &lt;symbol&gt;PQAUTHDATA_OAUTH_BEARER_TOKEN&lt;/symbol&gt; hook callback will
           interfere with nonblocking connection APIs such as
           &lt;function&gt;PQconnectPoll&lt;/function&gt; and prevent concurrent connections
           from making progress. Applications which only ever use the
           synchronous connection primitives, such as
           &lt;function&gt;PQconnectdb&lt;/function&gt;, may synchronously retrieve a token
           during the hook instead of implementing the
           &lt;replaceable&gt;async&lt;/replaceable&gt; callback, but they will necessarily
           be limited to one connection at a time.
</span>
《機械翻訳》<code class="symbol">PQAUTHDATA_OAUTH_BEARER_TOKEN</code>のブロッキング中にフック操作を実行すると、<code class="function">PQconnectPoll</code>などの非ブロッキング接続APIに干渉し、同時接続が進行しなくなります。
<code class="function">PQconnectdb</code>などの同期的コネクションプリミティブのみを使用するアプリケーションは、<em class="replaceable"><code>async</code></em>コールバックを実装するフック代わり中にトークンを同期的に取得できますが、一度に取得できるコネクションは1つに制限されます。
          </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-ssl.html" title="32.19. SSLサポート">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html" title="第32章 libpq — C ライブラリ">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-threading.html" title="32.21. スレッド化プログラムの振舞い">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">32.19. SSLサポート </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 32.21. スレッド化プログラムの振舞い</td></tr></table></div></body></html>