<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.2. 比較関数および演算子</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-logical.html" title="9.1. 論理演算子" /><link rel="next" href="functions-math.html" title="9.3. 算術関数と演算子" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 13.1文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 13.1 &#10;                      functions-comparison.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-logical.html" title="9.1. 論理演算子">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.2. 比較関数および演算子</td><td width="20%" align="right"> <a accesskey="n" href="functions-math.html" title="9.3. 算術関数と演算子">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-COMPARISON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.2. 比較関数および演算子</h2></div></div></div><span class="original">
   &lt;title&gt;Comparison Functions and Operators&lt;/title&gt;
</span><a id="id-1.5.8.8.2" class="indexterm"></a><p>
<span class="original">
    The usual comparison operators are available, as shown in &lt;xref
    linkend="functions-comparison-op-table"/&gt;.
</span>
<a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="表9.1 比較演算子">表 9.1</a>に示すように、通常の比較演算子が使用可能です。
   </p><div class="table" id="FUNCTIONS-COMPARISON-OP-TABLE"><p class="title"><strong>表9.1 比較演算子</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Comparison Operators&lt;/title&gt;
</span><table class="table" summary="比較演算子" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算子</th><th>説明</th></tr></thead><tbody><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Less than</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Greater than</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Less than or equal to</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Greater than or equal to</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">=</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Equal</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">&lt;&gt;</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Not equal</td></tr><tr><td>
        <em class="replaceable"><code>datatype</code></em> <code class="literal">!=</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </td><td>Not equal</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
     <code class="literal">&lt;&gt;</code> is the standard SQL notation for <span class="quote">「<span class="quote">not
     equal</span>」</span>.  <code class="literal">!=</code> is an alias, which is converted
     to <code class="literal">&lt;&gt;</code> at a very early stage of parsing.
     Hence, it is not possible to implement <code class="literal">!=</code>
     and <code class="literal">&lt;&gt;</code> operators that do different things.
    </p></div><p>
    These comparison operators are available for all built-in data types
    that have a natural ordering, including numeric, string, and date/time
    types.  In addition, arrays, composite types, and ranges can be compared
    if their component data types are comparable.
   </p><p>
    It is usually possible to compare values of related data
    types as well; for example <code class="type">integer</code> <code class="literal">&gt;</code>
    <code class="type">bigint</code> will work.  Some cases of this sort are implemented
    directly by <span class="quote">「<span class="quote">cross-type</span>」</span> comparison operators, but if no
    such operator is available, the parser will coerce the less-general type
    to the more-general type and apply the latter's comparison operator.
   </p><p>
    As shown above, all comparison operators are binary operators that
    return values of type <code class="type">boolean</code>.  Thus, expressions like
    <code class="literal">1 &lt; 2 &lt; 3</code> are not valid (because there is
    no <code class="literal">&lt;</code> operator to compare a Boolean value with
    <code class="literal">3</code>).  Use the <code class="literal">BETWEEN</code> predicates
    shown below to perform range tests.
   </p><p>
<span class="original">
    There are also some comparison predicates, as shown in &lt;xref
    linkend="functions-comparison-pred-table"/&gt;.  These behave much like
    operators, but have special syntax mandated by the SQL standard.
</span>
<a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-PRED-TABLE" title="表9.2 Comparison Predicates">表 9.2</a>に示すように、比較の述語がいくつかあります。
これらは演算子と同様に振る舞いますが、標準SQLによって強制される特別の構文があります。
   </p><div class="table" id="FUNCTIONS-COMPARISON-PRED-TABLE"><p class="title"><strong>表9.2 Comparison Predicates</strong></p><div class="table-contents"><table class="table" summary="Comparison Predicates" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
        Predicate
       </p>
       <p>
        Description
       </p>
       <p>
        Example(s)
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">BETWEEN</code> <em class="replaceable"><code>datatype</code></em> <code class="literal">AND</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Between (inclusive of the range endpoints).
       </p>
       <p>
        <code class="literal">2 BETWEEN 1 AND 3</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">2 BETWEEN 3 AND 1</code>
        → <code class="returnvalue">f</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">NOT BETWEEN</code> <em class="replaceable"><code>datatype</code></em> <code class="literal">AND</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Not between (the negation of <code class="literal">BETWEEN</code>).
       </p>
       <p>
        <code class="literal">2 NOT BETWEEN 1 AND 3</code>
        → <code class="returnvalue">f</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">BETWEEN SYMMETRIC</code> <em class="replaceable"><code>datatype</code></em> <code class="literal">AND</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Between, after sorting the two endpoint values.
       </p>
       <p>
        <code class="literal">2 BETWEEN SYMMETRIC 3 AND 1</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">NOT BETWEEN SYMMETRIC</code> <em class="replaceable"><code>datatype</code></em> <code class="literal">AND</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Not between, after sorting the two endpoint values.
       </p>
       <p>
        <code class="literal">2 NOT BETWEEN SYMMETRIC 3 AND 1</code>
        → <code class="returnvalue">f</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">IS DISTINCT FROM</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Not equal, treating null as a comparable value.
       </p>
       <p>
        <code class="literal">1 IS DISTINCT FROM NULL</code>
        → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)
       </p>
       <p>
        <code class="literal">NULL IS DISTINCT FROM NULL</code>
        → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">IS NOT DISTINCT FROM</code> <em class="replaceable"><code>datatype</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Equal, treating null as a comparable value.
       </p>
       <p>
        <code class="literal">1 IS NOT DISTINCT FROM NULL</code>
        → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)
       </p>
       <p>
        <code class="literal">NULL IS NOT DISTINCT FROM NULL</code>
        → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">IS NULL</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether value is null.
       </p>
       <p>
        <code class="literal">1.5 IS NULL</code>
        → <code class="returnvalue">f</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">IS NOT NULL</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether value is not null.
       </p>
       <p>
        <code class="literal">'null' IS NOT NULL</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">ISNULL</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether value is null (nonstandard syntax).
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>datatype</code></em> <code class="literal">NOTNULL</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether value is not null (nonstandard syntax).
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS TRUE</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields true.
       </p>
       <p>
        <code class="literal">true IS TRUE</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS TRUE</code>
        → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS NOT TRUE</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields false or unknown.
       </p>
       <p>
        <code class="literal">true IS NOT TRUE</code>
        → <code class="returnvalue">f</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS NOT TRUE</code>
        → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS FALSE</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields false.
       </p>
       <p>
        <code class="literal">true IS FALSE</code>
        → <code class="returnvalue">f</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS FALSE</code>
        → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS NOT FALSE</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields true or unknown.
       </p>
       <p>
        <code class="literal">true IS NOT FALSE</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS NOT FALSE</code>
        → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS UNKNOWN</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields unknown.
       </p>
       <p>
        <code class="literal">true IS UNKNOWN</code>
        → <code class="returnvalue">f</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS UNKNOWN</code>
        → <code class="returnvalue">t</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">boolean</code> <code class="literal">IS NOT UNKNOWN</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
        Test whether boolean expression yields true or false.
       </p>
       <p>
        <code class="literal">true IS NOT UNKNOWN</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">NULL::boolean IS NOT UNKNOWN</code>
        → <code class="returnvalue">f</code> (rather than <code class="literal">NULL</code>)
       </p></td></tr></tbody></table></div></div><br class="table-break" /><p>
    <a id="id-1.5.8.8.11.1" class="indexterm"></a>
    <a id="id-1.5.8.8.11.2" class="indexterm"></a>
    The <code class="token">BETWEEN</code> predicate simplifies range tests:
--&gt;
<code class="token">BETWEEN</code>述語は範囲の検査を次のように単純にします。
</p><pre class="synopsis">
<em class="replaceable"><code>a</code></em> BETWEEN <em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>y</code></em>
</pre><p>
<span class="original">
    is equivalent to
</span>
は
</p><pre class="synopsis">
<em class="replaceable"><code>a</code></em> &gt;= <em class="replaceable"><code>x</code></em> AND <em class="replaceable"><code>a</code></em> &lt;= <em class="replaceable"><code>y</code></em>
</pre><p>
と同じです。
<span class="original">
    Notice that &lt;token&gt;BETWEEN&lt;/token&gt; treats the endpoint values as included
    in the range.
    &lt;literal&gt;BETWEEN SYMMETRIC&lt;/literal&gt; is like &lt;literal&gt;BETWEEN&lt;/literal&gt;
    except there is no requirement that the argument to the left of
    &lt;literal&gt;AND&lt;/literal&gt; be less than or equal to the argument on the right.
    If it is not, those two arguments are automatically swapped, so that
    a nonempty range is always implied.
</span>
<code class="literal">BETWEEN SYMMETRIC</code>は、<code class="literal">AND</code>の左側の引数が右側の引数より小さいか、もしくは等しいという必要性が無い点を除き<code class="literal">BETWEEN</code>と同様です。
この条件を満たしていない場合、2つの引数は自動的に交換されますので、常に空ではない範囲となります。
   </p><p>
    The various variants of <code class="literal">BETWEEN</code> are implemented in
    terms of the ordinary comparison operators, and therefore will work for
    any data type(s) that can be compared.
   </p><div class="note"><h3 class="title">注記</h3><p>
     The use of <code class="literal">AND</code> in the <code class="literal">BETWEEN</code>
     syntax creates an ambiguity with the use of <code class="literal">AND</code> as a
     logical operator.  To resolve this, only a limited set of expression
     types are allowed as the second argument of a <code class="literal">BETWEEN</code>
     clause.  If you need to write a more complex sub-expression
     in <code class="literal">BETWEEN</code>, write parentheses around the
     sub-expression.
    </p></div><p>
    <a id="id-1.5.8.8.14.1" class="indexterm"></a>
    <a id="id-1.5.8.8.14.2" class="indexterm"></a>
<span class="original">
    Ordinary comparison operators yield null (signifying &lt;quote&gt;unknown&lt;/quote&gt;),
    not true or false, when either input is null.  For example,
    &lt;literal&gt;7 = NULL&lt;/literal&gt; yields null, as does &lt;literal&gt;7 &amp;lt;&amp;gt; NULL&lt;/literal&gt;.  When
    this behavior is not suitable, use the
    &lt;literal&gt;IS &lt;optional&gt; NOT &lt;/optional&gt; DISTINCT FROM&lt;/literal&gt; predicates:
</span>
入力のどちらかがNULLの場合、通常の比較演算子は真や偽ではなく（<span class="quote">「<span class="quote">不明</span>」</span>を意味する）nullを生成します。
例えば<code class="literal">7 = NULL</code>はnullになります。<code class="literal">7 &lt;&gt; NULL</code>も同様です。
この動作が適切でない場合は、<code class="literal">IS [<span class="optional"> NOT </span>] DISTINCT FROM</code>述語を使用してください。
</p><pre class="synopsis">
<em class="replaceable"><code>a</code></em> IS DISTINCT FROM <em class="replaceable"><code>b</code></em>
<em class="replaceable"><code>a</code></em> IS NOT DISTINCT FROM <em class="replaceable"><code>b</code></em>
</pre><p>
<span class="original">
    For non-null inputs, &lt;literal&gt;IS DISTINCT FROM&lt;/literal&gt; is
    the same as the &lt;literal&gt;&amp;lt;&amp;gt;&lt;/literal&gt; operator.  However, if both
    inputs are null it returns false, and if only one input is
    null it returns true.  Similarly, &lt;literal&gt;IS NOT DISTINCT
    FROM&lt;/literal&gt; is identical to &lt;literal&gt;=&lt;/literal&gt; for non-null
    inputs, but it returns true when both inputs are null, and false when only
    one input is null. Thus, these predicates effectively act as though null
    were a normal data value, rather than &lt;quote&gt;unknown&lt;/quote&gt;.
</span>
非NULLの入力では、<code class="literal">IS DISTINCT FROM</code>は<code class="literal">&lt;&gt;</code>演算子と同じです。
しかし、入力がどちらもNULLの場合、これは偽を返し、片方の入力のみがNULLの場合は真を返します。
同様に、<code class="literal">IS NOT DISTINCT FROM</code>は非NULL入力では<code class="literal">=</code>と同じですが、両方の入力がNULLであれば真を、片方のみがNULLの場合は偽を返します。
このように、これらの述語はNULLを<span class="quote">「<span class="quote">不明な値</span>」</span>ではなく、通常の値かのように動作します。
   </p><p>
    <a id="id-1.5.8.8.15.1" class="indexterm"></a>
    <a id="id-1.5.8.8.15.2" class="indexterm"></a>
    <a id="id-1.5.8.8.15.3" class="indexterm"></a>
    <a id="id-1.5.8.8.15.4" class="indexterm"></a>
<span class="original">
    To check whether a value is or is not null, use the predicates:
</span>
値がNULLかNULLでないかを検証するには次の述語を使います。
</p><pre class="synopsis">
<em class="replaceable"><code>expression</code></em> IS NULL
<em class="replaceable"><code>expression</code></em> IS NOT NULL
</pre><p>
<span class="original">
    or the equivalent, but nonstandard, predicates:
</span>
あるいは、これと同等の、非標準の述語も使えます。
</p><pre class="synopsis">
<em class="replaceable"><code>expression</code></em> ISNULL
<em class="replaceable"><code>expression</code></em> NOTNULL
</pre><p>
<span class="original">
    &lt;indexterm&gt;&lt;primary&gt;null value&lt;/primary&gt;&lt;secondary&gt;comparing&lt;/secondary&gt;&lt;/indexterm&gt;
</span>
    <a id="id-1.5.8.8.15.7" class="indexterm"></a>
   </p><p>
<span class="original">
    Do &lt;emphasis&gt;not&lt;/emphasis&gt; write
    &lt;literal&gt;&lt;replaceable&gt;expression&lt;/replaceable&gt; = NULL&lt;/literal&gt;
    because &lt;literal&gt;NULL&lt;/literal&gt; is not &lt;quote&gt;equal to&lt;/quote&gt;
    &lt;literal&gt;NULL&lt;/literal&gt;.  (The null value represents an unknown value,
    and it is not known whether two unknown values are equal.)
</span>
<code class="literal">NULL</code>と<code class="literal">NULL</code>とは<span class="quote">「<span class="quote">等しい</span>」</span>関係にはありませんので、<code class="literal"><em class="replaceable"><code>expression</code></em> = NULL</code>と記述しては<span class="emphasis"><em>いけません</em></span>
（NULL値は不明の値を表しているため、不明な値同士が同じかどうかは識別できません）。
   </p><div class="tip"><h3 class="title">ヒント</h3><p>
<span class="original">
    Some applications might expect that
    &lt;literal&gt;&lt;replaceable&gt;expression&lt;/replaceable&gt; = NULL&lt;/literal&gt;
    returns true if &lt;replaceable&gt;expression&lt;/replaceable&gt; evaluates to
    the null value.  It is highly recommended that these applications
    be modified to comply with the SQL standard. However, if that
    cannot be done the &lt;xref linkend="guc-transform-null-equals"/&gt;
    configuration variable is available. If it is enabled,
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; will convert &lt;literal&gt;x =
    NULL&lt;/literal&gt; clauses to &lt;literal&gt;x IS NULL&lt;/literal&gt;.
</span>
アプリケーションによっては、<code class="literal"><em class="replaceable"><code>expression</code></em> = NULL</code>が、<em class="replaceable"><code>expression</code></em>がNULL値と評価されるのであれば真を返すことを期待することがあります。
こうしたアプリケーションは標準SQLに従うように改修することを強く推奨します。
しかし、それができなければ<a class="xref" href="runtime-config-compatible.html#GUC-TRANSFORM-NULL-EQUALS">transform_null_equals</a>を使用することで対応することができます。
これを有効にした場合、<span class="productname">PostgreSQL</span>は<code class="literal">x = NULL</code>句を<code class="literal">x IS NULL</code>に変換します。
   </p></div><p>
<span class="original">
    If the &lt;replaceable&gt;expression&lt;/replaceable&gt; is row-valued, then
    &lt;literal&gt;IS NULL&lt;/literal&gt; is true when the row expression itself is null
    or when all the row's fields are null, while
    &lt;literal&gt;IS NOT NULL&lt;/literal&gt; is true when the row expression itself is non-null
    and all the row's fields are non-null.  Because of this behavior,
    &lt;literal&gt;IS NULL&lt;/literal&gt; and &lt;literal&gt;IS NOT NULL&lt;/literal&gt; do not always return
    inverse results for row-valued expressions; in particular, a row-valued
    expression that contains both null and non-null fields will return false
    for both tests.  In some cases, it may be preferable to
    write &lt;replaceable&gt;row&lt;/replaceable&gt; &lt;literal&gt;IS DISTINCT FROM NULL&lt;/literal&gt;
    or &lt;replaceable&gt;row&lt;/replaceable&gt; &lt;literal&gt;IS NOT DISTINCT FROM NULL&lt;/literal&gt;,
    which will simply check whether the overall row value is null without any
    additional tests on the row fields.
</span>
<em class="replaceable"><code>expression</code></em>が行値の場合、行式自体がNULLまたは、行のフィールドすべてがNULLの場合に<code class="literal">IS NULL</code>は真となります。
一方<code class="literal">IS NOT NULL</code>は、行式自体が非NULLかつ、行のフィールドすべてが非NULLの場合に真となります。
この動作により、<code class="literal">IS NULL</code>および<code class="literal">IS NOT NULL</code>は行値評価式に対し常に反対の結果を返すわけではありません。
特に、NULLと非NULLの値の両方を含む行値式はどちらの試験でも偽を返します。
場合によっては、<em class="replaceable"><code>row</code></em> <code class="literal">IS DISTINCT FROM NULL</code>あるいは<em class="replaceable"><code>row</code></em> <code class="literal">IS NOT DISTINCT FROM NULL</code>と記述する方が望ましいことがあるでしょう。
これらは単に行全体の値がNULLかどうかを検査し、行のフィールドについての追加的検査を全く行わないからです。
   </p><p>
    <a id="id-1.5.8.8.19.1" class="indexterm"></a>
    <a id="id-1.5.8.8.19.2" class="indexterm"></a>
    <a id="id-1.5.8.8.19.3" class="indexterm"></a>
    <a id="id-1.5.8.8.19.4" class="indexterm"></a>
    <a id="id-1.5.8.8.19.5" class="indexterm"></a>
    <a id="id-1.5.8.8.19.6" class="indexterm"></a>
<span class="original">
    Boolean values can also be tested using the predicates
</span>
論理値も次の述語で検証できます。
</p><pre class="synopsis">
<em class="replaceable"><code>boolean_expression</code></em> IS TRUE
<em class="replaceable"><code>boolean_expression</code></em> IS NOT TRUE
<em class="replaceable"><code>boolean_expression</code></em> IS FALSE
<em class="replaceable"><code>boolean_expression</code></em> IS NOT FALSE
<em class="replaceable"><code>boolean_expression</code></em> IS UNKNOWN
<em class="replaceable"><code>boolean_expression</code></em> IS NOT UNKNOWN
</pre><p>
<span class="original">
    These will always return true or false, never a null value, even when the
    operand is null.
    A null input is treated as the logical value &lt;quote&gt;unknown&lt;/quote&gt;.
    Notice that &lt;literal&gt;IS UNKNOWN&lt;/literal&gt; and &lt;literal&gt;IS NOT UNKNOWN&lt;/literal&gt; are
    effectively the same as &lt;literal&gt;IS NULL&lt;/literal&gt; and
    &lt;literal&gt;IS NOT NULL&lt;/literal&gt;, respectively, except that the input
    expression must be of Boolean type.
</span>
これらは、常に真か偽を返し、演算項目がNULLであってもNULL値を返すことはありません。
NULL値が入力されると、<span class="quote">「<span class="quote">不明</span>」</span>という論理値として扱われます。
<code class="literal">IS UNKNOWN</code>と<code class="literal">IS NOT UNKNOWN</code>が、入力式が論理値型でなければならないという点を除き、それぞれ実質的に<code class="literal">IS NULL</code>と<code class="literal">IS NOT NULL</code>と同じであることに注意してください。
   </p><span class="original"> IS OF does not conform to the ISO SQL behavior, so it is undocumented here
   &lt;para&gt;
    &lt;indexterm&gt;
     &lt;primary&gt;IS OF&lt;/primary&gt;
    &lt;/indexterm&gt;
    &lt;indexterm&gt;
     &lt;primary&gt;IS NOT OF&lt;/primary&gt;
    &lt;/indexterm&gt;
    It is possible to check the data type of an expression using the
    predicates
&lt;synopsis&gt;
&lt;replaceable&gt;expression&lt;/replaceable&gt; IS OF (typename, ...)
&lt;replaceable&gt;expression&lt;/replaceable&gt; IS NOT OF (typename, ...)
&lt;/synopsis&gt;
    They return a boolean value based on whether the expression's data
    type is one of the listed data types.
   &lt;/para&gt;
</span><p>
<span class="original">
    Some comparison-related functions are also available, as shown in &lt;xref
    linkend="functions-comparison-func-table"/&gt;.
</span>
<a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-FUNC-TABLE" title="表9.3 Comparison Functions">表 9.3</a>に示すように、比較に関連した関数がいくつか使用可能です。
   </p><div class="table" id="FUNCTIONS-COMPARISON-FUNC-TABLE"><p class="title"><strong>表9.3 Comparison Functions</strong></p><div class="table-contents"><table class="table" summary="Comparison Functions" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
        Function
       </p>
       <p>
        Description
       </p>
       <p>
        Example(s)
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.8.21.2.2.1.1.1.1" class="indexterm"></a>
        <code class="function">num_nonnulls</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">integer</code>
       </p>
       <p>
        Returns the number of non-null arguments.
       </p>
       <p>
        <code class="literal">num_nonnulls(1, NULL, 2)</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.8.21.2.2.2.1.1.1" class="indexterm"></a>
        <code class="function">num_nulls</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">integer</code>
       </p>
       <p>
        Returns the number of null arguments.
       </p>
       <p>
        <code class="literal">num_nulls(1, NULL, 2)</code>
        → <code class="returnvalue">1</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navfooter"><hr></hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-logical.html" title="9.1. 論理演算子">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-math.html" title="9.3. 算術関数と演算子">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.1. 論理演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 13.1文書">ホーム</a></td><td width="40%" align="right" valign="top"> 9.3. 算術関数と演算子</td></tr></table></div></body></html>