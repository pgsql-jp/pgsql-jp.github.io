<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>29.7. コンフリクト</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="logical-replication-gencols.html" title="29.6. 生成列のレプリケーション" /><link rel="next" href="logical-replication-restrictions.html" title="29.8. 制限事項" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.2文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="logical-replication.html" title="第29章 論理レプリケーション">第29章 論理レプリケーション</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.2 : logical-replication-conflicts.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="logical-replication-gencols.html" title="29.6. 生成列のレプリケーション">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="logical-replication.html" title="第29章 論理レプリケーション">上へ</a></td><td width="60%" align="center">29.7. コンフリクト</td><td width="20%" align="right"> <a accesskey="n" href="logical-replication-restrictions.html" title="29.8. 制限事項">次へ</a></td></tr></table><hr /></div><div class="sect1" id="LOGICAL-REPLICATION-CONFLICTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">29.7. コンフリクト <a href="#LOGICAL-REPLICATION-CONFLICTS" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;Conflicts&lt;/title&gt;
</span><p>
<span class="original">
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a &lt;firstterm&gt;conflict&lt;/firstterm&gt;.  When
   replicating &lt;command&gt;UPDATE&lt;/command&gt; or &lt;command&gt;DELETE&lt;/command&gt;
   operations, missing data is also considered as a
   &lt;firstterm&gt;conflict&lt;/firstterm&gt;, but does not result in an error and such
   operations will simply be skipped.
</span>
サブスクライバーノードでローカルにデータが変更された場合でも、データが更新されるという点では、論理レプリケーションは通常のDML操作と同じように振る舞います。
到着したデータが制約に違反すると、レプリケーションは停止します。
これは、<em class="firstterm">コンフリクト</em>と呼ばれます。
<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>操作をレプリケーションする場合は、存在しないデータも<em class="firstterm">コンフリクト</em>とみなされますが、エラーにはならずそのような操作は単にスキップされます。
  </p><p>
<span class="original">
   Additional logging is triggered, and the conflict statistics are collected (displayed in the
   &lt;link linkend="monitoring-pg-stat-subscription-stats"&gt;&lt;structname&gt;pg_stat_subscription_stats&lt;/structname&gt;&lt;/link&gt; view)
   in the following &lt;firstterm&gt;conflict&lt;/firstterm&gt; cases:
</span>
次の<em class="firstterm">コンフリクト</em>の場合、追加のログが出力され、統計情報が収集されます（<a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION-STATS" title="27.2.9. pg_stat_subscription_stats"><code class="structname">pg_stat_subscription_stats</code></a>ビューに出力されます）。
   </p><div class="variablelist"><dl class="variablelist"><dt id="CONFLICT-INSERT-EXISTS"><span class="term"><code class="literal">insert_exists</code></span> <a href="#CONFLICT-INSERT-EXISTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Inserting a row that violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt;
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually.
</span>
<code class="literal">NOT DEFERRABLE</code>な一意性制約に違反する行を挿入しています。
競合するキーのオリジンやコミットタイムスタンプの詳細をログ出力するためには、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>を有効にする必要があります。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
      </p></dd><dt id="CONFLICT-UPDATE-ORIGIN-DIFFERS"><span class="term"><code class="literal">update_origin_differs</code></span> <a href="#CONFLICT-UPDATE-ORIGIN-DIFFERS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Updating a row that was previously modified by another origin.
       Note that this conflict can only be detected when
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. Currently, the update is always applied
       regardless of the origin of the local row.
</span>
以前別のオリジンによって変更された行を更新しています。
このコンフリクトは、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>を有効にしている場合にのみ検出されます。
現在のところ、更新はローカル行のオリジンに関係なく常に適用されます。
      </p></dd><dt id="CONFLICT-UPDATE-EXISTS"><span class="term"><code class="literal">update_exists</code></span> <a href="#CONFLICT-UPDATE-EXISTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       The updated value of a row violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt;
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually. Note that when updating a
       partitioned table, if the updated row value satisfies another partition
       constraint resulting in the row being inserted into a new partition, the
       &lt;literal&gt;insert_exists&lt;/literal&gt; conflict may arise if the new row
       violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt; unique constraint.
</span>
行の更新された値が<code class="literal">NOT DEFERRABLE</code>な一意性制約に違反しています。
競合するキーのオリジンやコミットタイムスタンプの詳細をログ出力するためには、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>を有効にする必要があります。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
パーティションテーブルを更新するときに、更新した行が別のパーティション制約を満たし、その結果行が別のパーティションに挿入される場合、新しい行が<code class="literal">NOT DEFERRABLE</code>な一意性制約に違反すると、<code class="literal">insert_exists</code>コンフリクトが検出される可能性があることに注意してください。
      </p></dd><dt id="CONFLICT-UPDATE-MISSING"><span class="term"><code class="literal">update_missing</code></span> <a href="#CONFLICT-UPDATE-MISSING" class="id_link">#</a></dt><dd><p>
<span class="original">
       The row to be updated was not found. The update will simply be
       skipped in this scenario.
</span>
更新対象の行が見つかりませんでした。
このシナリオでは更新は単純にスキップされます。
      </p></dd><dt id="CONFLICT-DELETE-ORIGIN-DIFFERS"><span class="term"><code class="literal">delete_origin_differs</code></span> <a href="#CONFLICT-DELETE-ORIGIN-DIFFERS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Deleting a row that was previously modified by another origin. Note that
       this conflict can only be detected when
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. Currently, the delete is always applied
       regardless of the origin of the local row.
</span>
以前別のオリジンによって変更された行を削除しています。
このコンフリクトは、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>を有効にしている場合にのみ検出されます。
現在のところ、削除はローカル行のオリジンに関係なく常に適用されます。
      </p></dd><dt id="CONFLICT-DELETE-MISSING"><span class="term"><code class="literal">delete_missing</code></span> <a href="#CONFLICT-DELETE-MISSING" class="id_link">#</a></dt><dd><p>
<span class="original">
       The row to be deleted was not found. The delete will simply be
       skipped in this scenario.
</span>
削除対象の行が見つかりませんでした。
このシナリオでは削除は単純にスキップされます。
      </p></dd><dt id="CONFLICT-MULTIPLE-UNIQUE-CONFLICTS"><span class="term"><code class="literal">multiple_unique_conflicts</code></span> <a href="#CONFLICT-MULTIPLE-UNIQUE-CONFLICTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Inserting or updating a row violates multiple
       &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt; unique constraints. Note that to log
       the origin and commit timestamp details of conflicting keys, ensure
       that &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. In this case, an error will be raised until
       the conflict is resolved manually.
</span>
挿入または更新行が、複数の<code class="literal">NOT DEFERRABLE</code>な一意性制約に違反しています。
このコンフリクトは、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>を有効にしている場合にのみ検出されます。
この場合、コンフリクトが手動で解決されるまで、エラーが報告されます。
      </p></dd></dl></div><p>
<span class="original">
    Note that there are other conflict scenarios, such as exclusion constraint
    violations. Currently, we do not provide additional details for them in the
    log.
</span>
排他制約違反など、他にもコンフリクトのシナリオが存在することに注意してください。
現在のところ、ログにはこれらのコンフリクトに関する詳細情報は出力されません。
  </p><p>
<span class="original">
   The log format for logical replication conflicts is as follows:
</span>
論理レプリケーションコンフリクトのログフォーマットは以下の通りです。
</p><pre class="synopsis">
LOG:  conflict detected on relation "<em class="replaceable"><code>schemaname</code></em>.<em class="replaceable"><code>tablename</code></em>": conflict=<em class="replaceable"><code>conflict_type</code></em>
DETAIL:  <em class="replaceable"><code>detailed_explanation</code></em>.
{<em class="replaceable"><code>detail_values</code></em> [; ... ]}.

<span class="phrase">where <em class="replaceable"><code>detail_values</code></em> is one of:</span>

    <code class="literal">Key</code> (<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=(<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">existing local row</code> [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">remote row</code> [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">replica identity</code> {(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=(<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>]) | full [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])}
</pre><p>

<span class="original">
   The log provides the following information:
</span>
ログには次の情報が提供されます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LOG</code></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         &lt;replaceable&gt;schemaname&lt;/replaceable&gt;.&lt;replaceable&gt;tablename&lt;/replaceable&gt;
         identifies the local relation involved in the conflict.
</span>
<em class="replaceable"><code>schemaname</code></em>.<em class="replaceable"><code>tablename</code></em>は、コンフリクトに関係するローカルリレーションを識別します。
         </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable&gt;conflict_type&lt;/replaceable&gt; is the type of conflict that occurred
         (e.g., &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt;).
</span>
<em class="replaceable"><code>conflict_type</code></em>は発生したコンフリクトの種類です（例：<code class="literal">insert_exists</code>、<code class="literal">update_exists</code>）。
         </p></li></ul></div></dd><dt><span class="term"><code class="literal">DETAIL</code></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;detailed_explanation&lt;/replaceable&gt; includes
         the origin, transaction ID, and commit timestamp of the transaction that
         modified the existing local row, if available.
</span>
<em class="replaceable"><code>detailed_explanation</code></em>には、既存のローカル行を変更したトランザクションのオリジンとトランザクションID、そしてコミットタイムスタンプ（利用可能であれば）が含まれます。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;Key&lt;/literal&gt; section includes the key values of the local
         row that violated a unique constraint for
         &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt; or
         &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflicts.
</span>
<code class="literal">Key</code>セクションには、<code class="literal">insert_exists</code>、<code class="literal">update_exists</code>または<code class="literal">multiple_unique_conflicts</code>コンフリクトの一意性制約に違反したローカル行のキー値が含まれます。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;existing local row&lt;/literal&gt; section includes the local
         row if its origin differs from the remote row for
         &lt;literal&gt;update_origin_differs&lt;/literal&gt; or &lt;literal&gt;delete_origin_differs&lt;/literal&gt;
         conflicts, or if the key value conflicts with the remote row for
         &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt; or
         &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflicts.
</span>
<code class="literal">existing local row</code>セクションにはローカル行が含まれます。
ただし、<code class="literal">update_origin_differs</code>または<code class="literal">delete_origin_differs</code>コンフリクトではローカル行のオリジンがリモートと異なる場合、<code class="literal">insert_exists</code>、<code class="literal">update_exists</code>または<code class="literal">multiple_unique_conflicts</code>ではキー値がリモート行と競合する場合です。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;remote row&lt;/literal&gt; section includes the new row from
         the remote insert or update operation that caused the conflict. Note that
         for an update operation, the column value of the new row will be null
         if the value is unchanged and toasted.
</span>
<code class="literal">remote row</code>セクションには、競合の原因となったリモート挿入または更新操作による新しい行が含まれます。
更新操作の場合、変更されなかった列やTOASTされた列の値はNULLとなることに注意してください。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;replica identity&lt;/literal&gt; section includes the replica
         identity key values that were used to search for the existing local
         row to be updated or deleted. This may include the full row value
         if the local relation is marked with
         &lt;link linkend="sql-altertable-replica-identity-full"&gt;&lt;literal&gt;REPLICA IDENTITY FULL&lt;/literal&gt;&lt;/link&gt;.
</span>
<code class="literal">replica identity</code>セクションには、更新または削除対象となったローカル行の検索に使用されたレプリカアイデンティティが含まれます。
ローカルリレーションに<a class="link" href="sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY-FULL"><code class="literal">REPLICA IDENTITY FULL</code></a>が指定されている場合は、行全体の値が含まれることがあります。
        </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;column_name&lt;/replaceable&gt; is the column name.
         For &lt;literal&gt;existing local row&lt;/literal&gt;, &lt;literal&gt;remote row&lt;/literal&gt;,
         and &lt;literal&gt;replica identity full&lt;/literal&gt; cases, column names are
         logged only if the user lacks the privilege to access all columns of
         the table. If column names are present, they appear in the same order
         as the corresponding column values.
</span>
<em class="replaceable"><code>column_name</code></em>は列名です。
<code class="literal">existing local row</code>, <code class="literal">remote row</code>、および<code class="literal">replica identity full</code>の場合、ユーザがテーブルのすべての列に対するアクセス権限を持っていない場合にのみ列名が記録されます。
列名が存在する場合は、対応する列の値と同じ順に表示されます。
        </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;column_value&lt;/replaceable&gt; is the column value.
         The large column values are truncated to 64 bytes.
</span>
<em class="replaceable"><code>column_value</code></em>は列の値です。
長い列の値は64バイトに切り詰められます。
        </p></li><li class="listitem"><p>
<span class="original">
         Note that in case of &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflict,
         multiple &lt;replaceable class="parameter"&gt;detailed_explanation&lt;/replaceable&gt;
         and &lt;replaceable class="parameter"&gt;detail_values&lt;/replaceable&gt; lines
         will be generated, each detailing the conflict information associated
         with distinct unique
         constraints.
</span>
<code class="literal">multiple_unique_conflicts</code>コンフリクトの場合は、複数の<em class="replaceable"><code>detailed_explanation</code></em>および<em class="replaceable"><code>detail_values</code></em>が生成され、それぞれが異なる一意性制約に関連付けられたコンフリクト情報を詳述することに注意してください。
        </p></li></ul></div></dd></dl></div><p>
  </p><p>
<span class="original">
   Logical replication operations are performed with the privileges of the role
   which owns the subscription.  Permissions failures on target tables will
   cause replication conflicts, as will enabled
   &lt;link linkend="ddl-rowsecurity"&gt;row-level security&lt;/link&gt; on target tables
   that the subscription owner is subject to, without regard to whether any
   policy would ordinarily reject the &lt;command&gt;INSERT&lt;/command&gt;,
   &lt;command&gt;UPDATE&lt;/command&gt;, &lt;command&gt;DELETE&lt;/command&gt; or
   &lt;command&gt;TRUNCATE&lt;/command&gt; which is being replicated.  This restriction on
   row-level security may be lifted in a future version of
   &lt;productname&gt;PostgreSQL&lt;/productname&gt;.
</span>
論理レプリケーション操作は、サブスクリプションを所有するロールの権限を使用して実行されます。
対象テーブルで権限違反が起こると、レプリケーション競合が発生します。
これは、サブスクリプション所有者が従う、対象テーブルで有効な<a class="link" href="ddl-rowsecurity.html" title="5.9. 行セキュリティポリシー">行レベルセキュリティ</a>と同じですが、レプリケーションされている<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>または<code class="command">TRUNCATE</code>をポリシーが通常拒否するかどうかには関係ありません。
行レベルセキュリティに対するこの制限は、<span class="productname">PostgreSQL</span>の将来のバージョンで解除される可能性があります。
  </p><p>
<span class="original">
   A conflict that produces an error will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
</span>
コンフリクトはエラーを生じさせ、レプリケーションを停止させます。
コンフリクトはユーザが手動で解消しなければなりません。
コンフリクトの詳細は、サブスクライバーのサーバログに出力されます。
  </p><p>
<span class="original">
   The resolution can be done either by changing data or permissions on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  When a conflict produces
   an error, the replication won't proceed, and the logical replication worker will
   emit the following kind of message to the subscriber's server log:
</span>
この問題を解決するには、データを変更するか、サブスクライバーに対する権限を変更して、既存の変更でコンフリクトしないようにするか、既存のトランザクションと競合するデータをスキップします。
コンフリクトよってエラーが発生した場合、レプリケーションは処理を続行せず、論理レプリケーションワーカーは次のようなメッセージをサブスクライバーのサーバログに送信します。
</p><pre class="screen">
ERROR:  conflict detected on relation "public.test": conflict=insert_exists
DETAIL:  Key already exists in unique index "t_pkey", which was modified locally in transaction 740 at 2024-06-26 10:47:04.727375+08.
Key (c)=(1); existing local row (1, 'local'); remote row (1, 'remote').
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</pre><p>
<span class="original">
   The LSN of the transaction that contains the change violating the constraint and
   the replication origin name can be found from the server log (LSN 0/14C0378 and
   replication origin &lt;literal&gt;pg_16395&lt;/literal&gt; in the above case).  The
   transaction that produced the conflict can be skipped by using
   &lt;link linkend="sql-altersubscription-params-skip"&gt;&lt;command&gt;ALTER SUBSCRIPTION ... SKIP&lt;/command&gt;&lt;/link&gt;
   with the finish LSN
   (i.e., LSN 0/14C0378).  The finish LSN could be an LSN at which the transaction
   is committed or prepared on the publisher.  Alternatively, the transaction can
   also be skipped by calling the &lt;link linkend="pg-replication-origin-advance"&gt;
   &lt;function&gt;pg_replication_origin_advance()&lt;/function&gt;&lt;/link&gt; function.
   Before using this function, the subscription needs to be disabled temporarily
   either by &lt;link linkend="sql-altersubscription-params-disable"&gt;
   &lt;command&gt;ALTER SUBSCRIPTION ... DISABLE&lt;/command&gt;&lt;/link&gt; or, the
   subscription can be used with the
   &lt;link linkend="sql-createsubscription-params-with-disable-on-error"&gt;&lt;literal&gt;disable_on_error&lt;/literal&gt;&lt;/link&gt;
   option. Then, you can use &lt;function&gt;pg_replication_origin_advance()&lt;/function&gt;
   function with the &lt;parameter&gt;node_name&lt;/parameter&gt; (i.e., &lt;literal&gt;pg_16395&lt;/literal&gt;)
   and the next LSN of the finish LSN (i.e., 0/14C0379).  The current position of
   origins can be seen in the &lt;link linkend="view-pg-replication-origin-status"&gt;
   &lt;structname&gt;pg_replication_origin_status&lt;/structname&gt;&lt;/link&gt; system view.
   Please note that skipping the whole transaction includes skipping changes that
   might not violate any constraint.  This can easily make the subscriber
   inconsistent.
   The additional details regarding conflicting rows, such as their origin and
   commit timestamp can be seen in the &lt;literal&gt;DETAIL&lt;/literal&gt; line of the
   log. But note that this information is only available when
   &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
   is enabled on the subscriber. Users can use this information to decide
   whether to retain the local change or adopt the remote alteration. For
   instance, the &lt;literal&gt;DETAIL&lt;/literal&gt; line in the above log indicates that
   the existing row was modified locally. Users can manually perform a
   remote-change-win.
</span>
制約とレプリケーションの起点名に違反する変更を含むトランザクションのLSNは、サーバログ(LSN 0/14C0378とレプリケーション起点<code class="literal">pg_16395</code>)から見つけることができます。
競合を発生させたトランザクションは、終了LSN(LSN 0/14C0378)で<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-SKIP"><code class="command">ALTER SUBSCRIPTION ... SKIP</code></a>を使用してスキップできます。
終了LSNは、パブリッシャーでトランザクションがコミットまたは準備されたLSNにすることができます。
あるいは、<a class="link" href="functions-admin.html#PG-REPLICATION-ORIGIN-ADVANCE"><code class="function">pg_replication_origin_advance()</code></a>関数を呼び出して、トランザクションをスキップすることもできます。
この関数を使用する前に、<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-DISABLE"><code class="command">ALTER SUBSCRIPTION ... DISABLE</code></a>を使用してサブスクリプションを一時的に無効にするか、
<a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-PARAMS-WITH-DISABLE-ON-ERROR"><code class="literal">disable_on_error</code></a>オプションを使用します。
次に、<code class="function">pg_replication_origin_advance()</code>関数を<em class="parameter"><code>node_name</code></em>(<code class="literal">pg_16395</code>)と終了LSNの次のLSN(0/14C0379)と共に使用します。
現在の起点の位置は、<a class="link" href="view-pg-replication-origin-status.html" title="53.19. pg_replication_origin_status"><code class="structname">pg_replication_origin_status</code></a> システムビューで確認できます。
トランザクション全体をスキップすることは、いかなる制約にも違反しない可能性のある変更をスキップすることを含むことに注意してください。
これは容易にサブスクライバーを不整合にする可能性があります。
オリジンやコミットタイムスタンプのようなコンフリクト行に関する詳細は、ログの<code class="literal">DETAIL</code>行で確認できます。
しかし、これらの情報は、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>が有効な場合にのみ表示されます。
この情報はローカルの変更を保持するか、リモートの変更を採用するかを決定する際に使用できます。
例えば上記ログの<code class="literal">DETAIL</code>は、既存の行がローカルで変更されたことを示しています。
ユーザは手動でリモート変更優先を実行できます。
  </p><p>
<span class="original">
   When the
   &lt;link linkend="sql-createsubscription-params-with-streaming"&gt;&lt;literal&gt;streaming&lt;/literal&gt;&lt;/link&gt;
   mode is &lt;literal&gt;parallel&lt;/literal&gt;, the finish LSN of failed transactions
   may not be logged. In that case, it may be necessary to change the streaming
   mode to &lt;literal&gt;on&lt;/literal&gt; or &lt;literal&gt;off&lt;/literal&gt; and cause the same
   conflicts again so the finish LSN of the failed transaction will be written
   to the server log. For the usage of finish LSN, please refer to &lt;link
   linkend="sql-altersubscription"&gt;&lt;command&gt;ALTER SUBSCRIPTION ...
   SKIP&lt;/command&gt;&lt;/link&gt;.
</span>
<a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-PARAMS-WITH-STREAMING"><code class="literal">streaming</code></a>モードが<code class="literal">parallel</code>の場合、失敗したトランザクションの終了LSNはログに書き込まれないことがあります。
その場合、ストリーミングモードを<code class="literal">on</code>または<code class="literal">off</code>に変更し、再度同じコンフリクトを起こすことで、失敗したトランザクションの終了LSNをサーバのログに書き込むようにする必要があるかもしれません。
終了LSNの使用方法については、<a class="link" href="sql-altersubscription.html" title="ALTER SUBSCRIPTION"><code class="command">ALTER SUBSCRIPTION ... SKIP</code></a>を参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="logical-replication-gencols.html" title="29.6. 生成列のレプリケーション">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="logical-replication.html" title="第29章 論理レプリケーション">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="logical-replication-restrictions.html" title="29.8. 制限事項">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">29.6. 生成列のレプリケーション </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.2文書">ホーム</a></td><td width="40%" align="right" valign="top"> 29.8. 制限事項</td></tr></table></div></body></html>