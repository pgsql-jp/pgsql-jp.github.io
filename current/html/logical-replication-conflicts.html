<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>29.7. コンフリクト</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="logical-replication-gencols.html" title="29.6. 《機械翻訳》生成された列のレプリケーション" /><link rel="next" href="logical-replication-restrictions.html" title="29.8. 制限事項" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 18.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="logical-replication.html" title="第29章 論理レプリケーション">第29章 論理レプリケーション</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 18.0 : logical-replication-conflicts.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="logical-replication-gencols.html" title="29.6. 《機械翻訳》生成された列のレプリケーション">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="logical-replication.html" title="第29章 論理レプリケーション">上へ</a></td><td width="60%" align="center">29.7. コンフリクト</td><td width="20%" align="right"> <a accesskey="n" href="logical-replication-restrictions.html" title="29.8. 制限事項">次へ</a></td></tr></table><hr /></div><div class="sect1" id="LOGICAL-REPLICATION-CONFLICTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">29.7. コンフリクト <a href="#LOGICAL-REPLICATION-CONFLICTS" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;Conflicts&lt;/title&gt;
</span><p>
<span class="original">
   Logical replication behaves similarly to normal DML operations in that
   the data will be updated even if it was changed locally on the subscriber
   node.  If incoming data violates any constraints the replication will
   stop.  This is referred to as a &lt;firstterm&gt;conflict&lt;/firstterm&gt;.  When
   replicating &lt;command&gt;UPDATE&lt;/command&gt; or &lt;command&gt;DELETE&lt;/command&gt;
   operations, missing data is also considered as a
   &lt;firstterm&gt;conflict&lt;/firstterm&gt;, but does not result in an error and such
   operations will simply be skipped.
</span>
《マッチ度[81.065089]》サブスクライバーノードでローカルにデータが変更された場合でも、データが更新されるという点では、論理レプリケーションは通常のDML操作と同じように振る舞います。
到着したデータが制約に違反すると、レプリケーションは停止します。
これは、<em class="firstterm">コンフリクト</em>と呼ばれます。
<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>操作をレプリケーションする場合は、存在しないデータによってコンフリクトは起こらず、そのような操作は単にスキップされます。
《機械翻訳》論理レプリケーションは、サブスクライバーノードでローカルに変更された場合でもデータが更新されるという点で、通常のDML操作と同様に動作します。
着信データが制約に違反する場合、レプリケーションは停止します。
これは<em class="firstterm">コンフリクト</em>と呼ばれます。
レプリケーション<code class="command">UPDATE</code>または<code class="command">DELETE</code>操作の場合、データがないことも<em class="firstterm">コンフリクト</em>とみなされますが、エラーにはならず、このような操作は単純にスキップされたになります。
  </p><p>
<span class="original">
   Additional logging is triggered, and the conflict statistics are collected (displayed in the
   &lt;link linkend="monitoring-pg-stat-subscription-stats"&gt;&lt;structname&gt;pg_stat_subscription_stats&lt;/structname&gt;&lt;/link&gt; view)
   in the following &lt;firstterm&gt;conflict&lt;/firstterm&gt; cases:
</span>
《機械翻訳》次の<em class="firstterm">ロギング</em>の場合は、追加のコンフリクトがトリガされ、統計処理のビューが徴収されます<a class="link" href="monitoring-stats.html#MONITORING-PG-STAT-SUBSCRIPTION-STATS" title="27.2.9. pg_stat_subscription_stats"><code class="structname">pg_stat_subscription_stats</code>コンフリクトに表示されます</a>。
   </p><div class="variablelist"><dl class="variablelist"><dt id="CONFLICT-INSERT-EXISTS"><span class="term"><code class="literal">insert_exists</code></span> <a href="#CONFLICT-INSERT-EXISTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Inserting a row that violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt;
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually.
</span>
《機械翻訳》挿入競合する行の一意性制約とコミットノートの詳細<code class="literal">NOT DEFERRABLE</code> <a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>をログに伝えるオリジン.タイムスタンプに違反するキーは、サブスクライバーで使用可能にする必要があります。
このケースでは、コンフリクトが手動で解決されるまでエラーが発生します。
      </p></dd><dt id="CONFLICT-UPDATE-ORIGIN-DIFFERS"><span class="term"><code class="literal">update_origin_differs</code></span> <a href="#CONFLICT-UPDATE-ORIGIN-DIFFERS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Updating a row that was previously modified by another origin.
       Note that this conflict can only be detected when
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. Currently, the update is always applied
       regardless of the origin of the local row.
</span>
《機械翻訳》更新以前に別の行によって変更されたオリジン。
このノートは、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code>が有効になっている場合にのみ検出できます。
現在、更新は、ローカル行のオリジンに関係なく常に適用されます。
コンフリクト</a>
      </p></dd><dt id="CONFLICT-UPDATE-EXISTS"><span class="term"><code class="literal">update_exists</code></span> <a href="#CONFLICT-UPDATE-EXISTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       The updated value of a row violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt;
       unique constraint. Note that to log the origin and commit
       timestamp details of the conflicting key,
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       should be enabled on the subscriber. In this case, an error will be
       raised until the conflict is resolved manually. Note that when updating a
       partitioned table, if the updated row value satisfies another partition
       constraint resulting in the row being inserted into a new partition, the
       &lt;literal&gt;insert_exists&lt;/literal&gt; conflict may arise if the new row
       violates a &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt; unique constraint.
</span>
《機械翻訳》行違反の更新された値は、一意性制約で有効にする必要があります<code class="literal">NOT DEFERRABLE</code>競合するノートのオリジンとコミットタイムスタンプの詳細をログに伝えるには、<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>。
このケースでは、コンフリクトが手動で解決されるまでエラーが発生します。
ノートでは、更新がテーブルを分割した場合、更新された行値が別のパーティション制約を満たし、行が新しいパーティションに挿入されると、新しい行が<code class="literal">NOT DEFERRABLE</code>一意性制約に違反すると<code class="literal">insert_exists</code>コンフリクトが発生する可能性があります。
キーサブスクライバー
      </p></dd><dt id="CONFLICT-UPDATE-MISSING"><span class="term"><code class="literal">update_missing</code></span> <a href="#CONFLICT-UPDATE-MISSING" class="id_link">#</a></dt><dd><p>
<span class="original">
       The row to be updated was not found. The update will simply be
       skipped in this scenario.
</span>
《機械翻訳》更新される行が見つかりませんでした。
更新はこのシナリオのスキップされたになります。
      </p></dd><dt id="CONFLICT-DELETE-ORIGIN-DIFFERS"><span class="term"><code class="literal">delete_origin_differs</code></span> <a href="#CONFLICT-DELETE-ORIGIN-DIFFERS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Deleting a row that was previously modified by another origin. Note that
       this conflict can only be detected when
       &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. Currently, the delete is always applied
       regardless of the origin of the local row.
</span>
《機械翻訳》削除以前に別の行によって変更されたオリジン。
このノートは、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code>が有効になっている場合にのみ検出できます。
現在、削除は、ローカル行のオリジンに関係なく常に適用されます。
コンフリクト</a>
      </p></dd><dt id="CONFLICT-DELETE-MISSING"><span class="term"><code class="literal">delete_missing</code></span> <a href="#CONFLICT-DELETE-MISSING" class="id_link">#</a></dt><dd><p>
<span class="original">
       The row to be deleted was not found. The delete will simply be
       skipped in this scenario.
</span>
《機械翻訳》削除する行が見つかりませんでした。
削除は単にこのシナリオのスキップされたになります。
      </p></dd><dt id="CONFLICT-MULTIPLE-UNIQUE-CONFLICTS"><span class="term"><code class="literal">multiple_unique_conflicts</code></span> <a href="#CONFLICT-MULTIPLE-UNIQUE-CONFLICTS" class="id_link">#</a></dt><dd><p>
<span class="original">
       Inserting or updating a row violates multiple
       &lt;literal&gt;NOT DEFERRABLE&lt;/literal&gt; unique constraints. Note that to log
       the origin and commit timestamp details of conflicting keys, ensure
       that &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
       is enabled on the subscriber. In this case, an error will be raised until
       the conflict is resolved manually.
</span>
《機械翻訳》挿入または更新行がマルチプルに違反しています<code class="literal">NOT DEFERRABLE</code>一意制約。
オリジンおよびコミットタイムスタンプに競合するキーの詳細をログに通知するノート、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>が有効になっている保証。
このケースでは、コンフリクトが手動で解決されるまでエラーが発生します。
      </p></dd></dl></div><p>
    Note that there are other conflict scenarios, such as exclusion constraint
    violations. Currently, we do not provide additional details for them in the
    log.
  </p><p>
<span class="original">
   The log format for logical replication conflicts is as follows:
</span>
《機械翻訳》論理レプリケーション紛争のログフォーマットは以下の通りである。
</p><pre class="synopsis">
LOG:  conflict detected on relation "<em class="replaceable"><code>schemaname</code></em>.<em class="replaceable"><code>tablename</code></em>": conflict=<em class="replaceable"><code>conflict_type</code></em>
DETAIL:  <em class="replaceable"><code>detailed_explanation</code></em>.
{<em class="replaceable"><code>detail_values</code></em> [; ... ]}.

<span class="phrase">where <em class="replaceable"><code>detail_values</code></em> is one of:</span>

    <code class="literal">Key</code> (<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=(<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">existing local row</code> [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">remote row</code> [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])
    <code class="literal">replica identity</code> {(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=(<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>]) | full [<span class="optional">(<em class="replaceable"><code>column_name</code></em> [<span class="optional">, ...</span>])=</span>](<em class="replaceable"><code>column_value</code></em> [<span class="optional">, ...</span>])}
</pre><p>

<span class="original">
   The log provides the following information:
</span>
《機械翻訳》ログでは、次の情報が提供されます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LOG</code></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         &lt;replaceable&gt;schemaname&lt;/replaceable&gt;.&lt;replaceable&gt;tablename&lt;/replaceable&gt;
         identifies the local relation involved in the conflict.
</span>
《機械翻訳》<em class="replaceable"><code>schemaname</code></em>.<em class="replaceable"><code>tablename</code></em>は、コンフリクトに含まれるローカルリレーションを識別する。
         </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable&gt;conflict_type&lt;/replaceable&gt; is the type of conflict that occurred
         (e.g., &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt;).
</span>
《機械翻訳》<em class="replaceable"><code>conflict_type</code></em>は、発生したコンフリクトのタイプである<code class="literal">insert_exists</code>例:,<code class="literal">update_exists</code>。
         </p></li></ul></div></dd><dt><span class="term"><code class="literal">DETAIL</code></span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;detailed_explanation&lt;/replaceable&gt; includes
         the origin, transaction ID, and commit timestamp of the transaction that
         modified the existing local row, if available.
</span>
《機械翻訳》<em class="replaceable"><code>detailed_explanation</code></em>ローカルタイムスタンプを変更したトランザクションのオリジン、トランザクションID及びコミット行がある場合は、それを含む。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;Key&lt;/literal&gt; section includes the key values of the local
         row that violated a unique constraint for
         &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt; or
         &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflicts.
</span>
《機械翻訳》<code class="literal">Key</code>セクションには、<code class="literal">insert_exists</code>、<code class="literal">update_exists</code>または<code class="literal">multiple_unique_conflicts</code>紛争のキーに違反したローカル行の一意性制約値が含まれる。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;existing local row&lt;/literal&gt; section includes the local
         row if its origin differs from the remote row for
         &lt;literal&gt;update_origin_differs&lt;/literal&gt; or &lt;literal&gt;delete_origin_differs&lt;/literal&gt;
         conflicts, or if the key value conflicts with the remote row for
         &lt;literal&gt;insert_exists&lt;/literal&gt;, &lt;literal&gt;update_exists&lt;/literal&gt; or
         &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflicts.
</span>
《機械翻訳》<code class="literal">existing local row</code>セクションにはローカル行が含まれます。
ただし、そのオリジンが<code class="literal">update_origin_differs</code>または<code class="literal">delete_origin_differs</code>競合する場合のリモート行と異なる場合、またはキーの値が<code class="literal">insert_exists</code>、<code class="literal">update_exists</code>または<code class="literal">multiple_unique_conflicts</code>競合する場合のリモート行と競合する場合です。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;remote row&lt;/literal&gt; section includes the new row from
         the remote insert or update operation that caused the conflict. Note that
         for an update operation, the column value of the new row will be null
         if the value is unchanged and toasted.
</span>
《機械翻訳》<code class="literal">remote row</code>セクションには、行を発生させたリモート挿入または更新オペレーションからの新しいコンフリクトが含まれます。
ノート更新オペレーションの場合、値が変更されず、TOAST化されている場合、新しい行のカラム値はNULLになります。
        </p></li><li class="listitem"><p>
<span class="original">
         The &lt;literal&gt;replica identity&lt;/literal&gt; section includes the replica
         identity key values that were used to search for the existing local
         row to be updated or deleted. This may include the full row value
         if the local relation is marked with
         &lt;link linkend="sql-altertable-replica-identity-full"&gt;&lt;literal&gt;REPLICA IDENTITY FULL&lt;/literal&gt;&lt;/link&gt;.
</span>
《機械翻訳》<code class="literal">replica identity</code>セクションには、更新または削除される既存のレプリカアイデンティティキーの検索に使用されたローカル行値が含まれます。
ローカルリレーションが<a class="link" href="sql-altertable.html#SQL-ALTERTABLE-REPLICA-IDENTITY-FULL"><code class="literal">REPLICA IDENTITY FULL</code></a>でマークされている場合は、行値全体がincludeされることがあります。
        </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;column_name&lt;/replaceable&gt; is the column name.
         For &lt;literal&gt;existing local row&lt;/literal&gt;, &lt;literal&gt;remote row&lt;/literal&gt;,
         and &lt;literal&gt;replica identity full&lt;/literal&gt; cases, column names are
         logged only if the user lacks the privilege to access all columns of
         the table. If column names are present, they appear in the same order
         as the corresponding column values.
</span>
《機械翻訳》<em class="replaceable"><code>column_name</code></em>はカラム名前です。
<code class="literal">existing local row</code>、<code class="literal">remote row</code>、および<code class="literal">replica identity full</code>の場合、カラム名はユーザにテーブルの権限からアクセスまでのすべての列がない場合にのみログに記録されます。
カラム名が存在する場合は、対応するカラム値と同じオーダーに表示されます。
        </p></li><li class="listitem"><p>
<span class="original">
         &lt;replaceable class="parameter"&gt;column_value&lt;/replaceable&gt; is the column value.
         The large column values are truncated to 64 bytes.
</span>
《機械翻訳》<em class="replaceable"><code>column_value</code></em>はカラムの値です。
ラージのカラムの値は64バイトに切り捨てられます。
        </p></li><li class="listitem"><p>
<span class="original">
         Note that in case of &lt;literal&gt;multiple_unique_conflicts&lt;/literal&gt; conflict,
         multiple &lt;replaceable class="parameter"&gt;detailed_explanation&lt;/replaceable&gt;
         and &lt;replaceable class="parameter"&gt;detail_values&lt;/replaceable&gt; lines
         will be generated, each detailing the conflict information associated
         with distinct unique
         constraints.
</span>
《機械翻訳》ケースのノート<code class="literal">multiple_unique_conflicts</code>コンフリクト、マルチプル<em class="replaceable"><code>detailed_explanation</code></em>および<em class="replaceable"><code>detail_values</code></em>線が生成され、各線には個別の一意性制約に関連付けられたコンフリクト情報が詳述されます。
        </p></li></ul></div></dd></dl></div><p>
  </p><p>
<span class="original">
   Logical replication operations are performed with the privileges of the role
   which owns the subscription.  Permissions failures on target tables will
   cause replication conflicts, as will enabled
   &lt;link linkend="ddl-rowsecurity"&gt;row-level security&lt;/link&gt; on target tables
   that the subscription owner is subject to, without regard to whether any
   policy would ordinarily reject the &lt;command&gt;INSERT&lt;/command&gt;,
   &lt;command&gt;UPDATE&lt;/command&gt;, &lt;command&gt;DELETE&lt;/command&gt; or
   &lt;command&gt;TRUNCATE&lt;/command&gt; which is being replicated.  This restriction on
   row-level security may be lifted in a future version of
   &lt;productname&gt;PostgreSQL&lt;/productname&gt;.
</span>
論理レプリケーション操作は、サブスクリプションを所有するロールの権限を使用して実行されます。
対象テーブルで権限違反が起こると、レプリケーション競合が発生します。
これは、サブスクリプション所有者が従う、対象テーブルで有効な<a class="link" href="ddl-rowsecurity.html" title="5.9. 行セキュリティポリシー">行レベルセキュリティ</a>と同じですが、レプリケーションされている<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>または<code class="command">TRUNCATE</code>をポリシーが通常拒否するかどうかには関係ありません。
行レベルセキュリティに対するこの制限は、<span class="productname">PostgreSQL</span>の将来のバージョンで解除される可能性があります。
  </p><p>
<span class="original">
   A conflict that produces an error will stop the replication; it must be
   resolved manually by the user.  Details about the conflict can be found in
   the subscriber's server log.
</span>
《マッチ度[89.080460]》コンフリクトはエラーを生じさせ、レプリケーションを停止させます。
コンフリクトはユーザが手動で解消しなければなりません。
コンフリクトの詳細は、サブスクライバーのサーバログに出力されます。
《機械翻訳》コンフリクトがエラーを発生させると、レプリケーションが停止します。
これは、ユーザが手動で解決する必要があります。
コンフリクトの詳細は、サブスクライバーのサーバログを参照してください。
  </p><p>
<span class="original">
   The resolution can be done either by changing data or permissions on the subscriber so
   that it does not conflict with the incoming change or by skipping the
   transaction that conflicts with the existing data.  When a conflict produces
   an error, the replication won't proceed, and the logical replication worker will
   emit the following kind of message to the subscriber's server log:
</span>
この問題を解決するには、データを変更するか、サブスクライバーに対する権限を変更して、既存の変更でコンフリクトしないようにするか、既存のトランザクションと競合するデータをスキップします。
コンフリクトよってエラーが発生した場合、レプリケーションは処理を続行せず、論理レプリケーションワーカーは次のようなメッセージをサブスクライバーのサーバログに送信します。
</p><pre class="screen">
ERROR:  conflict detected on relation "public.test": conflict=insert_exists
DETAIL:  Key already exists in unique index "t_pkey", which was modified locally in transaction 740 at 2024-06-26 10:47:04.727375+08.
Key (c)=(1); existing local row (1, 'local'); remote row (1, 'remote').
CONTEXT:  processing remote data for replication origin "pg_16395" during "INSERT" for replication target relation "public.test" in transaction 725 finished at 0/14C0378
</pre><p>
<span class="original">
   The LSN of the transaction that contains the change violating the constraint and
   the replication origin name can be found from the server log (LSN 0/14C0378 and
   replication origin &lt;literal&gt;pg_16395&lt;/literal&gt; in the above case).  The
   transaction that produced the conflict can be skipped by using
   &lt;link linkend="sql-altersubscription-params-skip"&gt;&lt;command&gt;ALTER SUBSCRIPTION ... SKIP&lt;/command&gt;&lt;/link&gt;
   with the finish LSN
   (i.e., LSN 0/14C0378).  The finish LSN could be an LSN at which the transaction
   is committed or prepared on the publisher.  Alternatively, the transaction can
   also be skipped by calling the &lt;link linkend="pg-replication-origin-advance"&gt;
   &lt;function&gt;pg_replication_origin_advance()&lt;/function&gt;&lt;/link&gt; function.
   Before using this function, the subscription needs to be disabled temporarily
   either by &lt;link linkend="sql-altersubscription-params-disable"&gt;
   &lt;command&gt;ALTER SUBSCRIPTION ... DISABLE&lt;/command&gt;&lt;/link&gt; or, the
   subscription can be used with the
   &lt;link linkend="sql-createsubscription-params-with-disable-on-error"&gt;&lt;literal&gt;disable_on_error&lt;/literal&gt;&lt;/link&gt;
   option. Then, you can use &lt;function&gt;pg_replication_origin_advance()&lt;/function&gt;
   function with the &lt;parameter&gt;node_name&lt;/parameter&gt; (i.e., &lt;literal&gt;pg_16395&lt;/literal&gt;)
   and the next LSN of the finish LSN (i.e., 0/14C0379).  The current position of
   origins can be seen in the &lt;link linkend="view-pg-replication-origin-status"&gt;
   &lt;structname&gt;pg_replication_origin_status&lt;/structname&gt;&lt;/link&gt; system view.
   Please note that skipping the whole transaction includes skipping changes that
   might not violate any constraint.  This can easily make the subscriber
   inconsistent.
   The additional details regarding conflicting rows, such as their origin and
   commit timestamp can be seen in the &lt;literal&gt;DETAIL&lt;/literal&gt; line of the
   log. But note that this information is only available when
   &lt;link linkend="guc-track-commit-timestamp"&gt;&lt;varname&gt;track_commit_timestamp&lt;/varname&gt;&lt;/link&gt;
   is enabled on the subscriber. Users can use this information to decide
   whether to retain the local change or adopt the remote alteration. For
   instance, the &lt;literal&gt;DETAIL&lt;/literal&gt; line in the above log indicates that
   the existing row was modified locally. Users can manually perform a
   remote-change-win.
</span>
《マッチ度[69.924141]》制約とレプリケーションの起点名に違反する変更を含むトランザクションのLSNは、サーバログ(LSN 0/14C0378とレプリケーション起点<code class="literal">pg_16395</code>)から見つけることができます。
競合を発生させたトランザクションは、終了LSN(LSN 0/14C0378)で<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-SKIP"><code class="command">ALTER SUBSCRIPTION ... SKIP</code></a>を使用してスキップできます。
終了LSNは、パブリッシャーでトランザクションがコミットまたは準備されたLSNにすることができます。
あるいは、<a class="link" href="functions-admin.html#PG-REPLICATION-ORIGIN-ADVANCE"><code class="function">pg_replication_origin_advance()</code></a>関数を呼び出して、トランザクションをスキップすることもできます。
この関数を使用する前に、<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-DISABLE"><code class="command">ALTER SUBSCRIPTION ... DISABLE</code></a>を使用してサブスクリプションを一時的に無効にする必要があります。
また、サブスクリプションは<a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-PARAMS-WITH-DISABLE-ON-ERROR"><code class="literal">disable_on_error</code></a>オプションを使用して使用できます。
次に、<code class="function">pg_replication_origin_advance()</code>関数を<em class="parameter"><code>node_name</code></em>(<code class="literal">pg_16395</code>)と終了LSNの次のLSN(0/14C0379)と共に使用できます。
現在の起点の位置は、<a class="link" href="view-pg-replication-origin-status.html" title="53.19. pg_replication_origin_status"><code class="structname">pg_replication_origin_status</code></a>システムビューで確認できます。
トランザクション全体をスキップすることは、いかなる制約にも違反しない可能性のある変更をスキップすることを含むことに注意してください。
これは容易にサブスクライバーを不整合にする可能性があります。
《機械翻訳》トランザクションと複製元包含に違反する変更がある制約のLSNは、名前から見つけることができます（前述のケースのLSN 0/14C0378および複製元<code class="literal">pg_16395</code>）。
コンフリクトを作成したトランザクションは、終了LSN（つまり、LSN 0/14C0378）で<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-SKIP"><code class="command">ALTER SUBSCRIPTION...SKIP</code></a>を使用してスキップされたにすることができます。
終了LSNは、トランザクションがコミットされているLSN、またはパブリッシャー上のプリペアドにすることができます。
また、この関数を使用して<a class="link" href="functions-admin.html#PG-REPLICATION-ORIGIN-ADVANCE"><code class="function">pg_replication_origin_advance()</code></a>関数.前を呼び出すことでトランザクションをスキップされたにすることもできます。
サブスクリプションニーズは<a class="link" href="sql-altersubscription.html#SQL-ALTERSUBSCRIPTION-PARAMS-DISABLE"><code class="command">ALTER SUBSCRIPTION...DISABLE</code></a>によって一時的に無効にするか、サブスクリプションを<a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-PARAMS-WITH-DISABLE-ON-ERROR"><code class="literal">disable_on_error</code></a>オプションで使用できます。
次に、<code class="function">pg_replication_origin_advance()</code>関数を<em class="parameter"><code>node_name</code></em>（つまり、<code class="literal">pg_16395</code>）および終了LSNの次のLSN（つまり、0/14C0379）と一緒に使用できます。
元の現在の位置は<a class="link" href="view-pg-replication-origin-status.html" title="53.19. pg_replication_origin_status"><code class="structname">pg_replication_origin_status</code></a>に表示されます。
この情報は、サブスクライバーで<a class="link" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP"><code class="varname">track_commit_timestamp</code></a>が有効になっている場合にのみ利用可能であることに注意してください。
ユーザはこの情報を使用して、ローカルの変更を保持するか、リモートの変更を採用するかを決定できます。
たとえば、上記のログの<code class="literal">DETAIL</code>行は、既存の行がローカルで変更されたことを示しています。
ユーザは手動でリモート変更を実行できます。
  </p><p>
<span class="original">
   When the
   &lt;link linkend="sql-createsubscription-params-with-streaming"&gt;&lt;literal&gt;streaming&lt;/literal&gt;&lt;/link&gt;
   mode is &lt;literal&gt;parallel&lt;/literal&gt;, the finish LSN of failed transactions
   may not be logged. In that case, it may be necessary to change the streaming
   mode to &lt;literal&gt;on&lt;/literal&gt; or &lt;literal&gt;off&lt;/literal&gt; and cause the same
   conflicts again so the finish LSN of the failed transaction will be written
   to the server log. For the usage of finish LSN, please refer to &lt;link
   linkend="sql-altersubscription"&gt;&lt;command&gt;ALTER SUBSCRIPTION ...
   SKIP&lt;/command&gt;&lt;/link&gt;.
</span>
<a class="link" href="sql-createsubscription.html#SQL-CREATESUBSCRIPTION-PARAMS-WITH-STREAMING"><code class="literal">streaming</code></a>モードが<code class="literal">parallel</code>の場合、失敗したトランザクションの終了LSNはログに書き込まれないことがあります。
その場合、ストリーミングモードを<code class="literal">on</code>または<code class="literal">off</code>に変更し、再度同じコンフリクトを起こすことで、失敗したトランザクションの終了LSNをサーバのログに書き込むようにする必要があるかもしれません。
終了LSNの使用方法については、<a class="link" href="sql-altersubscription.html" title="ALTER SUBSCRIPTION"><code class="command">ALTER SUBSCRIPTION ... SKIP</code></a>を参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="logical-replication-gencols.html" title="29.6. 《機械翻訳》生成された列のレプリケーション">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="logical-replication.html" title="第29章 論理レプリケーション">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="logical-replication-restrictions.html" title="29.8. 制限事項">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">29.6. 《機械翻訳》生成された列のレプリケーション </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 18.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 29.8. 制限事項</td></tr></table></div></body></html>