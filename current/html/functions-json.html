<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.16. JSON関数と演算子</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="functions-xml.html" title="9.15. XML関数" /><link rel="next" href="functions-sequence.html" title="9.17. シーケンス操作関数" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 17.0文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 17.0 : functions-json.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-xml.html" title="9.15. XML関数">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.16. JSON関数と演算子</td><td width="20%" align="right"> <a accesskey="n" href="functions-sequence.html" title="9.17. シーケンス操作関数">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.16. JSON関数と演算子 <a href="#FUNCTIONS-JSON" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;JSON Functions and Operators&lt;/title&gt;
</span><a id="id-1.5.8.24.2" class="indexterm"></a><a id="id-1.5.8.24.3" class="indexterm"></a><a id="id-1.5.8.24.4" class="indexterm"></a><a id="id-1.5.8.24.5" class="indexterm"></a><p>
<span class="original">
   This section describes:
</span>
この節では次のことを説明します。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
      functions and operators for processing and creating JSON data
</span>
JSONデータを処理、生成する関数と演算子
     </p></li><li class="listitem"><p>
<span class="original">
      the SQL/JSON path language
</span>
SQL/JSONパス言語
     </p></li><li class="listitem"><p>
<span class="original">
      the SQL/JSON query functions
</span>
SQL/JSON問い合わせ関数
     </p></li></ul></div><p>
  </p><p>
<span class="original">
   To provide native support for JSON data types within the SQL environment,
   &lt;productname&gt;PostgreSQL&lt;/productname&gt; implements the
   &lt;firstterm&gt;SQL/JSON data model&lt;/firstterm&gt;.
   This model comprises sequences of items. Each item can hold SQL scalar
   values, with an additional SQL/JSON null value, and composite data structures
   that use JSON arrays and objects. The model is a formalization of the implied
   data model in the JSON specification
   &lt;ulink url="https://datatracker.ietf.org/doc/html/rfc7159"&gt;RFC 7159&lt;/ulink&gt;.
</span>
SQL環境内のJSONデータ型にネイティブサポートを提供するために、<span class="productname">PostgreSQL</span><em class="firstterm">SQL/JSONデータモデル</em>を実装しています。
このモデルは、一連の項目で構成されます。
各項目は、SQLスカラ値、追加のSQL/JSON NULL値、およびJSON配列とオブジェクトを使用する複合データ構造を保持できます。
モデルは、JSON規格<a class="ulink" href="https://datatracker.ietf.org/doc/html/rfc7159" target="_top">RFC 7159</a>で暗黙的に指定されているデータモデルを形式化したものです。
  </p><p>
<span class="original">
   SQL/JSON allows you to handle JSON data alongside regular SQL data,
   with transaction support, including:
</span>
SQL/JSONでは、トランザクションをサポートをしながら、通常のSQLデータと一緒にJSONデータをハンドルすることができます。以下のものが含まれます：

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
     Uploading JSON data into the database and storing it in
     regular SQL columns as character or binary strings.
</span>
JSONデータをデータベースにアップロードし、それを文字またはバイナリ文字列として通常のSQL列に保存します。
    </p></li><li class="listitem"><p>
<span class="original">
     Generating JSON objects and arrays from relational data.
</span>
リレーショナルデータからJSONオブジェクトと配列を生成します。
    </p></li><li class="listitem"><p>
<span class="original">
     Querying JSON data using SQL/JSON query functions and
     SQL/JSON path language expressions.
</span>
SQL/JSON問い合わせ関数およびSQL/JSONパス言語式を使用してJSONデータを照会します。
    </p></li></ul></div><p>
  </p><p>
<span class="original">
   To learn more about the SQL/JSON standard, see
   &lt;xref linkend="sqltr-19075-6"/&gt;. For details on JSON types
   supported in &lt;productname&gt;PostgreSQL&lt;/productname&gt;,
   see &lt;xref linkend="datatype-json"/&gt;.
</span>
SQL/JSON標準を更に学ぶためには、<a class="xref" href="biblio.html#SQLTR-19075-6" title="SQL Technical Report">[sqltr-19075-6]</a>をご覧ください。
<span class="productname">PostgreSQL</span>でサポートされているJSON型の詳細に関しては、<a class="xref" href="datatype-json.html" title="8.14. JSONデータ型">8.14</a>をご覧ください。
  </p><div class="sect2" id="FUNCTIONS-JSON-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.16.1. JSONデータの処理と生成 <a href="#FUNCTIONS-JSON-PROCESSING" class="id_link">#</a></h3></div></div></div><span class="original">
   &lt;title&gt;Processing and Creating JSON Data&lt;/title&gt;
</span><p>
<span class="original">
   &lt;xref linkend="functions-json-op-table"/&gt; shows the operators that
   are available for use with JSON data types (see &lt;xref
   linkend="datatype-json"/&gt;).
   In addition, the usual comparison operators shown in &lt;xref
   linkend="functions-comparison-op-table"/&gt; are available for
   &lt;type&gt;jsonb&lt;/type&gt;, though not for &lt;type&gt;json&lt;/type&gt;.  The comparison
   operators follow the ordering rules for B-tree operations outlined in
   &lt;xref linkend="json-indexing"/&gt;.
   See also &lt;xref linkend="functions-aggregate"/&gt; for the aggregate
   function &lt;function&gt;json_agg&lt;/function&gt; which aggregates record
   values as JSON, the aggregate function
   &lt;function&gt;json_object_agg&lt;/function&gt; which aggregates pairs of values
   into a JSON object, and their &lt;type&gt;jsonb&lt;/type&gt; equivalents,
   &lt;function&gt;jsonb_agg&lt;/function&gt; and &lt;function&gt;jsonb_object_agg&lt;/function&gt;.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-OP-TABLE" title="表9.45 jsonとjsonb演算子">表 9.45</a>にJSONデータ型(<a class="xref" href="datatype-json.html" title="8.14. JSONデータ型">8.14</a>を参照)で使用可能な演算子を示します。
加えて<a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="表9.1 比較演算子">表 9.1</a>で示す通常の比較演算子が<code class="type">jsonb</code>で利用できますが、<code class="type">json</code>では利用できません。
比較演算子は<a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb インデックス">8.14.4</a>で概要が示されているように示すBツリー操作用の順序付け規則にしたがいます。
レコードの値をJSONに集約する<code class="function">json_agg</code>集約関数、値の対をJSONオブジェクトに集約する<code class="function">json_object_agg</code>集約関数、およびそれらの<code class="type">jsonb</code>版の<code class="function">jsonb_agg</code>と<code class="function">jsonb_object_agg</code>については<a class="xref" href="functions-aggregate.html" title="9.21. 集約関数">9.21</a>も参照して下さい。
  </p><div class="table" id="FUNCTIONS-JSON-OP-TABLE"><p class="title"><strong>表9.45 <code class="type">json</code>と<code class="type">jsonb</code>演算子</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;&lt;type&gt;json&lt;/type&gt; and &lt;type&gt;jsonb&lt;/type&gt; Operators&lt;/title&gt;
</span><table class="table" summary="jsonとjsonb演算子" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Operator
</span>
演算子
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Extracts &lt;parameter&gt;n&lt;/parameter&gt;'th element of JSON array
        (array elements are indexed from zero, but negative integers count
        from the end).
</span>
JSON配列の<em class="parameter"><code>n</code></em>番目の要素を取り出します。
（配列要素はゼロから始まりますが、負の整数は最後から数えられます。）
       </p>
       <p>
        <code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; 2</code>
        → <code class="returnvalue">{"c":"baz"}</code>
       </p>
       <p>
        <code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json -&gt; -3</code>
        → <code class="returnvalue">{"a":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Extracts JSON object field with the given key.
</span>
与えられたキーでJSONオブジェクトフィールドを取り出します。
       </p>
       <p>
        <code class="literal">'{"a": {"b":"foo"}}'::json -&gt; 'a'</code>
        → <code class="returnvalue">{"b":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">integer</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Extracts &lt;parameter&gt;n&lt;/parameter&gt;'th element of JSON array,
        as &lt;type&gt;text&lt;/type&gt;.
</span>
JSON配列の<em class="parameter"><code>n</code></em>番目の要素を<code class="type">text</code>として取り出します。
       </p>
       <p>
        <code class="literal">'[1,2,3]'::json -&gt;&gt; 2</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-&gt;&gt;</code> <code class="type">text</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Extracts JSON object field with the given key, as &lt;type&gt;text&lt;/type&gt;.
</span>
与えられたキーでJSONオブジェクトフィールドを<code class="type">text</code>として取り出します。
       </p>
       <p>
        <code class="literal">'{"a":1,"b":2}'::json -&gt;&gt; 'b'</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">#&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Extracts JSON sub-object at the specified path, where path elements
        can be either field keys or array indexes.
</span>
指定したパスにおけるJSONの副オブジェクトを取り出します。パス要素はフィールドキーあるいは配列のインデックスでも構いません。
       </p>
       <p>
        <code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt; '{a,b,1}'</code>
        → <code class="returnvalue">"bar"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">json</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#&gt;&gt;</code> <code class="type">text[]</code>
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Extracts JSON sub-object at the specified path as &lt;type&gt;text&lt;/type&gt;.
</span>
指定したパスにおけるJSONの副オブジェクトを<code class="type">text</code>として取り出します。
       </p>
       <p>
        <code class="literal">'{"a": {"b": ["foo","bar"]}}'::json #&gt;&gt; '{a,b,1}'</code>
        → <code class="returnvalue">bar</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such key or array element exists.
</span>
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
   </p></div><p>
<span class="original">
   Some further operators exist only for &lt;type&gt;jsonb&lt;/type&gt;, as shown
   in &lt;xref linkend="functions-jsonb-op-table"/&gt;.
   &lt;xref linkend="json-indexing"/&gt;
   describes how these operators can be used to effectively search indexed
   &lt;type&gt;jsonb&lt;/type&gt; data.
</span>
ほかに<code class="type">jsonb</code>だけで利用可能な演算子もいくつか存在します。
それらを<a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="表9.46 追加jsonb演算子">表 9.46</a>に示します。
<a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb インデックス">8.14.4</a>には、インデックス付された<code class="type">jsonb</code>データを効率的に検索するためにこれらの演算子をどのように利用できるかについて書いてあります。
  </p><div class="table" id="FUNCTIONS-JSONB-OP-TABLE"><p class="title"><strong>表9.46 追加<code class="type">jsonb</code>演算子</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;Additional &lt;type&gt;jsonb&lt;/type&gt; Operators&lt;/title&gt;
</span><table class="table" summary="追加jsonb演算子" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Operator
</span>
演算子
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@&gt;</code> <code class="type">jsonb</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Does the first JSON value contain the second?
        (See &lt;xref linkend="json-containment"/&gt; for details about containment.)
</span>
最初のJSON値は二番目を含んでいるか？
（包含の詳細は<a class="xref" href="datatype-json.html#JSON-CONTAINMENT" title="8.14.3. jsonb型用包含演算子と存在演算子">8.14.3</a>を参照してください。）
       </p>
       <p>
        <code class="literal">'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">&lt;@</code> <code class="type">jsonb</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Is the first JSON value contained in the second?
</span>
最初のJSON値は二番目に含まれているか？
       </p>
       <p>
        <code class="literal">'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?</code> <code class="type">text</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Does the text string exist as a top-level key or array element within
        the JSON value?
</span>
そのテキスト文字列はトップレベルのキーあるいは配列要素としてJSON値中に存在しているか？
       </p>
       <p>
        <code class="literal">'{"a":1, "b":2}'::jsonb ? 'b'</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">'["a", "b", "c"]'::jsonb ? 'b'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?|</code> <code class="type">text[]</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Do any of the strings in the text array exist as top-level keys or
        array elements?
</span>
テキスト配列中のどれかの文字列がトップレベルのキーあるいは配列要素として存在しているか？
       </p>
       <p>
        <code class="literal">'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'd']</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">?&amp;</code> <code class="type">text[]</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Do all of the strings in the text array exist as top-level keys or
        array elements?
</span>
テキスト配列のすべての文字列がトップレベルのキーあるいは配列要素として存在しているか？
       </p>
       <p>
        <code class="literal">'["a", "b", "c"]'::jsonb ?&amp; array['a', 'b']</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">||</code> <code class="type">jsonb</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Concatenates two &lt;type&gt;jsonb&lt;/type&gt; values.
        Concatenating two arrays generates an array containing all the
        elements of each input.  Concatenating two objects generates an
        object containing the union of their
        keys, taking the second object's value when there are duplicate keys.
        All other cases are treated by converting a non-array input into a
        single-element array, and then proceeding as for two arrays.
        Does not operate recursively: only the top-level array or object
        structure is merged.
</span>
2つの<code class="type">jsonb</code>値を結合します。
2つの配列を結合するとそれらのキーの和を持つ配列を生成します。
キーが重複している場合は2番目のオブジェクトの値が使用されます。
それ以外の場合には非配列入力を単一の要素を持つ配列に変換し、次に2つの配列として取り扱います。
再帰操作は行いません。トップレベルの配列あるいはオブジェクト構造だけがマージされます。
       </p>
       <p>
        <code class="literal">'["a", "b"]'::jsonb || '["a", "d"]'::jsonb</code>
        → <code class="returnvalue">["a", "b", "a", "d"]</code>
       </p>
       <p>
        <code class="literal">'{"a": "b"}'::jsonb || '{"c": "d"}'::jsonb</code>
        → <code class="returnvalue">{"a": "b", "c": "d"}</code>
       </p>
       <p>
        <code class="literal">'[1, 2]'::jsonb || '3'::jsonb</code>
        → <code class="returnvalue">[1, 2, 3]</code>
       </p>
       <p>
        <code class="literal">'{"a": "b"}'::jsonb || '42'::jsonb</code>
        → <code class="returnvalue">[{"a": "b"}, 42]</code>
       </p>
       <p>
<span class="original">
        To append an array to another array as a single entry, wrap it
        in an additional layer of array, for example:
</span>
一つの要素を持つとして配列を他の配列に追加するには、例のように配列の追加のレイヤ中に含めてください。
       </p>
       <p>
        <code class="literal">'[1, 2]'::jsonb || jsonb_build_array('[3, 4]'::jsonb)</code>
        → <code class="returnvalue">[1, 2, [3, 4]]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Deletes a key (and its value) from a JSON object, or matching string
        value(s) from a JSON array.
</span>
キー（及びその値）をJSONオブジェクトから削除します。あるいはマッチする文字列値をJSON配列から削除します。
       </p>
       <p>
        <code class="literal">'{"a": "b", "c": "d"}'::jsonb - 'a'</code>
        → <code class="returnvalue">{"c": "d"}</code>
       </p>
       <p>
        <code class="literal">'["a", "b", "c", "b"]'::jsonb - 'b'</code>
        → <code class="returnvalue">["a", "c"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Deletes all matching keys or array elements from the left operand.
</span>
左のオペランドからマッチするすべてのキーあるいは配列要素を削除します。
       </p>
       <p>
        <code class="literal">'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[]</code>
        → <code class="returnvalue">{}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">-</code> <code class="type">integer</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Deletes the array element with specified index (negative
        integers count from the end).  Throws an error if JSON value
        is not an array.
</span>
指定したインデックス（負の整数は最後から数えます）の配列要素を削除します。
JSON値が配列でなければエラーが生じます。
       </p>
       <p>
        <code class="literal">'["a", "b"]'::jsonb - 1 </code>
        → <code class="returnvalue">["a"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">#-</code> <code class="type">text[]</code>
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Deletes the field or array element at the specified path, where path
        elements can be either field keys or array indexes.
</span>
指定パスのフィールドあるいは配列要素を削除します。パス要素はフィールドキーあるいは配列インデックスが指定できます。
       </p>
       <p>
        <code class="literal">'["a", {"b":1}]'::jsonb #- '{1,b}'</code>
        → <code class="returnvalue">["a", {}]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@?</code> <code class="type">jsonpath</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Does JSON path return any item for the specified JSON value?
        (This is useful only with SQL-standard JSON path expressions, not
        &lt;link linkend="functions-sqljson-check-expressions"&gt;predicate check
        expressions&lt;/link&gt;, since those always return a value.)
</span>
JSONパスは指定されたJSON値に対して何らかの項目を返すか?（これはSQL標準のJSONパス式でのみ有用であり、<a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. ブール述語チェック式">述語チェック式</a>では有効ではありません。述語チェック式は常に値を返すからです。）
       </p>
       <p>
        <code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ &gt; 2)'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="type">jsonb</code> <code class="literal">@@</code> <code class="type">jsonpath</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Returns the result of a JSON path predicate check for the
        specified JSON value.
        (This is useful only
        with &lt;link linkend="functions-sqljson-check-expressions"&gt;predicate
        check expressions&lt;/link&gt;, not SQL-standard JSON path expressions,
        since it will return &lt;literal&gt;NULL&lt;/literal&gt; if the path result is
        not a single boolean value.)
</span>
指定されたJSON値に対するJSONパス述語チェックの結果を返します（これは、SQL標準のJSONパス式ではなく、<a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. ブール述語チェック式">述部チェック式</a>でのみ有用です。パス結果が単一のブール値でない場合は<code class="literal">NULL</code>を返すためです）。
       </p>
       <p>
        <code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] &gt; 2'</code>
        → <code class="returnvalue">t</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    The &lt;type&gt;jsonpath&lt;/type&gt; operators &lt;literal&gt;@?&lt;/literal&gt;
    and &lt;literal&gt;@@&lt;/literal&gt; suppress the following errors: missing object
    field or array element, unexpected JSON item type, datetime and numeric
    errors.  The &lt;type&gt;jsonpath&lt;/type&gt;-related functions described below can
    also be told to suppress these types of errors.  This behavior might be
    helpful when searching JSON document collections of varying structure.
</span>
<code class="type">jsonpath</code>演算子の<code class="literal">@?</code>および<code class="literal">@@</code>演算子は以下のエラーを抑止します。
オブジェクトフィールドあるいは配列要素の欠如、期待しないJSON要素型、日付時刻及び数値エラー。
以下に示す<code class="type">jsonpath</code>関連の関数もこれらのエラーを抑止するようにすることもできます。
この振る舞いは、異なる構造のJSON文書集合を検索する際に役に立つかも知れません。
   </p></div><p>
<span class="original">
   &lt;xref linkend="functions-json-creation-table"/&gt; shows the functions that are
   available for constructing &lt;type&gt;json&lt;/type&gt; and &lt;type&gt;jsonb&lt;/type&gt; values.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE" title="表9.47 JSON作成関数">表 9.47</a>に、<code class="type">json</code>値および<code class="type">jsonb</code>値を作成するために利用可能な関数を示します。
<span class="original">
   Some functions in this table have a &lt;literal&gt;RETURNING&lt;/literal&gt; clause,
   which specifies the data type returned.  It must be one of &lt;type&gt;json&lt;/type&gt;,
   &lt;type&gt;jsonb&lt;/type&gt;, &lt;type&gt;bytea&lt;/type&gt;, a character string type (&lt;type&gt;text&lt;/type&gt;,
   &lt;type&gt;char&lt;/type&gt;, or &lt;type&gt;varchar&lt;/type&gt;), or a type
   that can be cast to &lt;type&gt;json&lt;/type&gt;.
   By default, the &lt;type&gt;json&lt;/type&gt; type is returned.
</span>
このテーブルの一部の関数は、返されるデータ型を指定する<code class="literal">RETURNING</code>句を持っています。
これは<code class="type">json</code>、<code class="type">jsonb</code>、<code class="type">bytea</code>、文字列型（<code class="type">text</code>、<code class="type">char</code>、<code class="type">varchar</code>）、あるいは<code class="type">json</code>からその型へのキャストがある型のいずれかでなければなりません。
デフォルトでは<code class="type">json</code>型が返されます。
  </p><div class="table" id="FUNCTIONS-JSON-CREATION-TABLE"><p class="title"><strong>表9.47 JSON作成関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;JSON Creation Functions&lt;/title&gt;
</span><table class="table" summary="JSON作成関数" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Function
</span>
関数
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.1.1.1.1" class="indexterm"></a>
        <code class="function">to_json</code> ( <code class="type">anyelement</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.1.1.2.1" class="indexterm"></a>
        <code class="function">to_jsonb</code> ( <code class="type">anyelement</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Converts any SQL value to &lt;type&gt;json&lt;/type&gt; or &lt;type&gt;jsonb&lt;/type&gt;.
        Arrays and composites are converted recursively to arrays and
        objects (multidimensional arrays become arrays of arrays in JSON).
        Otherwise, if there is a cast from the SQL data type
        to &lt;type&gt;json&lt;/type&gt;, the cast function will be used to perform the
        conversion;&lt;footnote&gt;
</span>
SQL値を<code class="type">json</code>あるいは<code class="type">jsonb</code>に変換します。
配列と複合型は再帰的に配列とオブジェクトに変換されます。（多次元配列はJSONにおける配列の配列になります。）
それ以外は、そのSQLデータ型から<code class="type">json</code>にキャストがあれば、キャスト関数が変換のために用いられます。<a href="#ftn.id-1.5.8.24.10.9.2.2.1.1.3.4" class="footnote"><sup class="footnote" id="id-1.5.8.24.10.9.2.2.1.1.3.4">[a]</sup></a>
<span class="original">
        otherwise, a scalar JSON value is produced.  For any scalar other than
        a number, a Boolean, or a null value, the text representation will be
        used, with escaping as necessary to make it a valid JSON string value.
</span>
そうでなければスカラーJSON値が生成されます。
数値、論理値、NULL以外のスカラーには、有効なJSON文字列値にするための必要なエスケープ処理が施されたテキスト表現が使われます。
       </p>
       <p>
        <code class="literal">to_json('Fred said "Hi."'::text)</code>
        → <code class="returnvalue">"Fred said \"Hi.\""</code>
       </p>
       <p>
        <code class="literal">to_jsonb(row(42, 'Fred said "Hi."'::text))</code>
        → <code class="returnvalue">{"f1": 42, "f2": "Fred said \"Hi.\""}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.2.1.1.1" class="indexterm"></a>
        <code class="function">array_to_json</code> ( <code class="type">anyarray</code> [<span class="optional">, <code class="type">boolean</code> </span>] )
        → <code class="returnvalue">json</code>
       </p>
       <p>
<span class="original">
        Converts an SQL array to a JSON array.  The behavior is the same
        as &lt;function&gt;to_json&lt;/function&gt; except that line feeds will be added
        between top-level array elements if the optional boolean parameter is
        true.
</span>
SQL配列をJSON配列に変換します。
追加の論理引数が真であるときに改行がトップレベルの配列要素の間に加えられる以外は、その振る舞いは<code class="function">to_json</code>と同じです。
       </p>
       <p>
        <code class="literal">array_to_json('{{1,5},{99,100}}'::int[])</code>
        → <code class="returnvalue">[[1,5],[99,100]]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.3.1.1.1" class="indexterm"></a>
         <code class="function">json_array</code> (
         [<span class="optional"> { <em class="replaceable"><code>value_expression</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> </span>] } [<span class="optional">, ...</span>] </span>]
         [<span class="optional"> { <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code> </span>]
         [<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] </span>])
        </p>
        <p class="func_signature">
         <code class="function">json_array</code> (
         [<span class="optional"> <em class="replaceable"><code>query_expression</code></em> </span>]
         [<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] </span>])
        </p>
        <p>
<span class="original">
         Constructs a JSON array from either a series of
         &lt;replaceable&gt;value_expression&lt;/replaceable&gt; parameters or from the results
         of &lt;replaceable&gt;query_expression&lt;/replaceable&gt;,
         which must be a SELECT query returning a single column. If
         &lt;literal&gt;ABSENT ON NULL&lt;/literal&gt; is specified, NULL values are ignored.
         This is always the case if a
         &lt;replaceable&gt;query_expression&lt;/replaceable&gt; is used.
</span>
JSON配列を、一連の<em class="replaceable"><code>value_expression</code></em>引数、または<em class="replaceable"><code>query_expression</code></em>の結果のいずれかから構成します。
<em class="replaceable"><code>query_expression</code></em>は、単一の列を返すSELECT問い合わせである必要があります。
<code class="literal">ABSENT ON NULL</code>が指定されている場合、NULL値は無視されます。
<em class="replaceable"><code>query_expression</code></em>が使用されている場合、常にそうなります。
        </p>
        <p>
         <code class="literal">json_array(1,true,json '{"a":null}')</code>
         → <code class="returnvalue">[1, true, {"a":null}]</code>
        </p>
        <p>
         <code class="literal">json_array(SELECT * FROM (VALUES(1),(2)) t)</code>
         → <code class="returnvalue">[1, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.4.1.1.1" class="indexterm"></a>
        <code class="function">row_to_json</code> ( <code class="type">record</code> [<span class="optional">, <code class="type">boolean</code> </span>] )
        → <code class="returnvalue">json</code>
       </p>
       <p>
<span class="original">
        Converts an SQL composite value to a JSON object.  The behavior is the
        same as &lt;function&gt;to_json&lt;/function&gt; except that line feeds will be
        added between top-level elements if the optional boolean parameter is
        true.
</span>
SQL複合値をJSONオブジェクトに変換します。
追加の論理引数が真であるときに改行がトップレベルの配列要素の間に加えられる以外は、その振る舞いは<code class="function">to_json</code>と同じです。
       </p>
       <p>
        <code class="literal">row_to_json(row(1,'foo'))</code>
        → <code class="returnvalue">{"f1":1,"f2":"foo"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.5.1.1.1" class="indexterm"></a>
        <code class="function">json_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.5.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_build_array</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Builds a possibly-heterogeneously-typed JSON array out of a variadic
        argument list.  Each argument is converted as
        per &lt;function&gt;to_json&lt;/function&gt; or &lt;function&gt;to_jsonb&lt;/function&gt;.
</span>
異なる型から構成される可能性のあるJSON配列をvariadic引数リストから作成します。
各々の引数は<code class="function">to_json</code>あるいは<code class="function">to_jsonb</code>に従って変換されます。
       </p>
       <p>
        <code class="literal">json_build_array(1, 2, 'foo', 4, 5)</code>
        → <code class="returnvalue">[1, 2, "foo", 4, 5]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.6.1.1.1" class="indexterm"></a>
        <code class="function">json_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.6.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_build_object</code> ( <code class="literal">VARIADIC</code> <code class="type">"any"</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Builds a JSON object out of a variadic argument list.  By convention,
        the argument list consists of alternating keys and values.  Key
        arguments are coerced to text; value arguments are converted as
        per &lt;function&gt;to_json&lt;/function&gt; or &lt;function&gt;to_jsonb&lt;/function&gt;.
</span>
variadic引数リストからJSONオブジェクトを作成します。
慣例により引数リストは代替キーと値が交互に並んだものです。
キー引数はテキストに強制的に変換されます。
値引数は<code class="function">to_json</code>あるいは<code class="function">to_jsonb</code>に従って変換されます。
       </p>
       <p>
        <code class="literal">json_build_object('foo', 1, 2, row(3,'bar'))</code>
        → <code class="returnvalue">{"foo" : 1, "2" : {"f1":3,"f2":"bar"}}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
         <a id="id-1.5.8.24.10.9.2.2.7.1.1.1" class="indexterm"></a>
         <code class="function">json_object</code> (
         [<span class="optional"> { <em class="replaceable"><code>key_expression</code></em> { <code class="literal">VALUE</code> | ':' }
          <em class="replaceable"><code>value_expression</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] }[<span class="optional">, ...</span>] </span>]
         [<span class="optional"> { <code class="literal">NULL</code> | <code class="literal">ABSENT</code> } <code class="literal">ON NULL</code> </span>]
         [<span class="optional"> { <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [<span class="optional"> <code class="literal">KEYS</code> </span>] </span>]
         [<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] </span>])
        </p>
        <p>
<span class="original">
         Constructs a JSON object of all the key/value pairs given,
         or an empty object if none are given.
         &lt;replaceable&gt;key_expression&lt;/replaceable&gt; is a scalar expression
         defining the &lt;acronym&gt;JSON&lt;/acronym&gt; key, which is
         converted to the &lt;type&gt;text&lt;/type&gt; type.
         It cannot be &lt;literal&gt;NULL&lt;/literal&gt; nor can it
         belong to a type that has a cast to the &lt;type&gt;json&lt;/type&gt; type.
         If &lt;literal&gt;WITH UNIQUE KEYS&lt;/literal&gt; is specified, there must not
         be any duplicate &lt;replaceable&gt;key_expression&lt;/replaceable&gt;.
         Any pair for which the &lt;replaceable&gt;value_expression&lt;/replaceable&gt;
         evaluates to &lt;literal&gt;NULL&lt;/literal&gt; is omitted from the output
         if &lt;literal&gt;ABSENT ON NULL&lt;/literal&gt; is specified;
         if &lt;literal&gt;NULL ON NULL&lt;/literal&gt; is specified or the clause
         omitted, the key is included with value &lt;literal&gt;NULL&lt;/literal&gt;.
</span>
指定されたすべてのキー/値ペアのJSONオブジェクトを構築します。
キー/値ペアが指定されていない場合は、空のオブジェクトを構築します。
<em class="replaceable"><code>key_expression</code></em>は、<code class="type">text</code>タイプに変換される<acronym class="acronym">JSON</acronym>キーを定義するスカラ式です。
<code class="literal">NULL</code>にすることも、<code class="type">JSON</code>タイプにキャストを持つタイプに属することもできません。
<code class="literal">WITH UNIQUE KEYS</code>が指定されている場合は、重複<em class="replaceable"><code>key_expression</code></em>があってはなりません。
<code class="literal">ABSENT ON NULL</code>が指定されている場合、<code class="literal">NULL</code>と評価される<em class="replaceable"><code>value_expression</code></em>は出力から除外されます。
<code class="literal">NULL ON NULL</code>が指定されているか、その句が省略されている場合、キーは<code class="literal">NULL</code>の値で含まれます。
        </p>
        <p>
         <code class="literal">json_object('code' VALUE 'P123', 'title': 'Jaws')</code>
         → <code class="returnvalue">{"code" : "P123", "title" : "Jaws"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.8.1.1.1" class="indexterm"></a>
        <code class="function">json_object</code> ( <code class="type">text[]</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.8.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_object</code> ( <code class="type">text[]</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Builds a JSON object out of a text array.  The array must have either
        exactly one dimension with an even number of members, in which case
        they are taken as alternating key/value pairs, or two dimensions
        such that each inner array has exactly two elements, which
        are taken as a key/value pair.  All values are converted to JSON
        strings.
</span>
テキスト配列からJSONオブジェクトを作成します。
配列は、偶数個の要素からなる1次元（キー／値の対が交互に並んでいるものと扱われます）あるいは内側の配列が2つの要素を持つ2次元（2つの要素がキー／値のペアとして扱われます）のいずれかでなければなりません。
すべての値はJSON文字列に変換されます。
       </p>
       <p>
        <code class="literal">json_object('{a, 1, b, "def", c, 3.5}')</code>
        → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code>
       </p>
        <p><code class="literal">json_object('{{a, 1}, {b, "def"}, {c, 3.5}}')</code>
        → <code class="returnvalue">{"a" : "1", "b" : "def", "c" : "3.5"}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="function">json_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <code class="function">jsonb_object</code> ( <em class="parameter"><code>keys</code></em> <code class="type">text[]</code>, <em class="parameter"><code>values</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        This form of &lt;function&gt;json_object&lt;/function&gt; takes keys and values
        pairwise from separate text arrays.  Otherwise it is identical to
        the one-argument form.
</span>
この形の<code class="function">json_object</code>は2つの別々の配列からキーと値の対を取ります。
他の点ではすべて、引数1つの形と同じです。
       </p>
       <p>
        <code class="literal">json_object('{a,b}', '{1,2}')</code>
        → <code class="returnvalue">{"a": "1", "b": "2"}</code>
       </p></td></tr><tr><td class="func_table_entry">
        <p class="func_signature">
         <a id="id-1.5.8.24.10.9.2.2.10.1.1.1" class="indexterm"></a>
         <code class="function">json</code> (
         <em class="replaceable"><code>expression</code></em>
         [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>]</span>]
         [<span class="optional"> { <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [<span class="optional"> <code class="literal">KEYS</code> </span>]</span>] )
         → <code class="returnvalue">json</code>
        </p>
        <p>
<span class="original">
         Converts a given expression specified as &lt;type&gt;text&lt;/type&gt; or
         &lt;type&gt;bytea&lt;/type&gt; string (in UTF8 encoding) into a JSON
         value.  If &lt;replaceable&gt;expression&lt;/replaceable&gt; is NULL, an
         &lt;acronym&gt;SQL&lt;/acronym&gt; null value is returned.
         If &lt;literal&gt;WITH UNIQUE&lt;/literal&gt; is specified, the
         &lt;replaceable&gt;expression&lt;/replaceable&gt; must not contain any duplicate
         object keys.
</span>
指定された<code class="type">text</code>または<code class="type">bytea</code>文字列（UTF8エンコーディング）をJSON値に変換します。
<em class="replaceable"><code>expression</code></em>がNULLの場合、<acronym class="acronym">SQL</acronym>のNULL値が返されます。
<code class="literal">WITH UNIQUE</code>が指定された場合、<em class="replaceable"><code>expression</code></em>は重複するオブジェクトキーを含んではなりません。
        </p>
        <p>
         <code class="literal">json('{"a":123, "b":[true,"foo"], "a":"bar"}')</code>
         → <code class="returnvalue">{"a":123, "b":[true,"foo"], "a":"bar"}</code>
        </p>
       </td></tr><tr><td class="func_table_entry">
        <p class="func_signature">
        <a id="id-1.5.8.24.10.9.2.2.11.1.1.1" class="indexterm"></a>
        <code class="function">json_scalar</code> ( <em class="replaceable"><code>expression</code></em> )
       </p>
       <p>
<span class="original">
        Converts a given SQL scalar value into a JSON scalar value.
        If the input is NULL, an &lt;acronym&gt;SQL&lt;/acronym&gt; null is returned. If
        the input is number or a boolean value, a corresponding JSON number
        or boolean value is returned. For any other value, a JSON string is
        returned.
</span>
指定されたSQLスカラー値をJSONスカラー値に変換します。
入力がNULLの場合、<acronym class="acronym">SQL</acronym>のNULLが返されます。
入力が数値またはブール値の場合、対応するJSONの数値またはブール値が返されます。
それ以外の場合は、JSONの文字列が返されます。
       </p>
       <p>
        <code class="literal">json_scalar(123.45)</code>
        → <code class="returnvalue">123.45</code>
       </p>
       <p>
        <code class="literal">json_scalar(CURRENT_TIMESTAMP)</code>
        → <code class="returnvalue">"2022-05-10T10:51:04.62128-04:00"</code>
      </p></td></tr><tr><td class="func_table_entry">
       <p class="func_signature">
        <code class="function">json_serialize</code> (
        <em class="replaceable"><code>expression</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>]
        [<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] </span>] )
       </p>
       <p>
<span class="original">
        Converts an SQL/JSON expression into a character or binary string. The
        &lt;replaceable&gt;expression&lt;/replaceable&gt; can be of any JSON type, any
        character string type, or &lt;type&gt;bytea&lt;/type&gt; in UTF8 encoding.
        The returned type used in &lt;literal&gt; RETURNING&lt;/literal&gt; can be any
        character string type or &lt;type&gt;bytea&lt;/type&gt;. The default is
        &lt;type&gt;text&lt;/type&gt;.
</span>
SQL/JSON式を文字列またはバイナリ文字列に変換します。
<em class="replaceable"><code>expression</code></em>は、任意のJSON型、任意の文字列型、またはUTF8エンコーディングの<code class="type">bytea</code>です。
<code class="literal">RETURNING</code>で使用される戻り型は、任意の文字列型または<code class="type">bytea</code>です。
デフォルトは<code class="type">text</code>です。
       </p>
       <p>
        <code class="literal">json_serialize('{ "a" : 1 } ' RETURNING bytea)</code>
        → <code class="returnvalue">\x7b20226122203a2031207d20</code>
      </p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="1"><div id="ftn.id-1.5.8.24.10.9.2.2.1.1.3.4" class="footnote"><p><a href="#id-1.5.8.24.10.9.2.2.1.1.3.4" class="para"><sup class="para">[a] </sup></a>
<span class="original">
          For example, the &lt;xref linkend="hstore"/&gt; extension has a cast
          from &lt;type&gt;hstore&lt;/type&gt; to &lt;type&gt;json&lt;/type&gt;, so that
          &lt;type&gt;hstore&lt;/type&gt; values converted via the JSON creation functions
          will be represented as JSON objects, not as primitive string values.
</span>
たとえば<a class="xref" href="hstore.html" title="F.17. hstore — hstoreキー/値データ型">hstore</a>拡張には<code class="type">hstore</code>から<code class="type">json</code>へのキャストがあり、JSON生成関数で変換された<code class="type">hstore</code>値は、原始的な文字列値としてではなく、JSONオブジェクトとして表示されます。
         </p></div></td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   &lt;xref linkend="functions-sqljson-misc" /&gt; details SQL/JSON
   facilities for testing JSON.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-MISC" title="表9.48 SQL/JSONテスト用関数">表 9.48</a>には、JSONをテストするためのSQL/JSON機能の詳細が記載されています。
  </p><div class="table" id="FUNCTIONS-SQLJSON-MISC"><p class="title"><strong>表9.48 SQL/JSONテスト用関数</strong></p><div class="table-contents"><span class="original">
   &lt;title&gt;SQL/JSON Testing Functions&lt;/title&gt;
</span><table class="table" summary="SQL/JSONテスト用関数" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Function signature
</span>
関数の呼び出し形式
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
      </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.11.2.2.1.1.1.1" class="indexterm"></a>
        <em class="replaceable"><code>expression</code></em> <code class="literal">IS</code> [<span class="optional"> <code class="literal">NOT</code> </span>] <code class="literal">JSON</code>
        [<span class="optional"> { <code class="literal">VALUE</code> | <code class="literal">SCALAR</code> | <code class="literal">ARRAY</code> | <code class="literal">OBJECT</code> } </span>]
        [<span class="optional"> { <code class="literal">WITH</code> | <code class="literal">WITHOUT</code> } <code class="literal">UNIQUE</code> [<span class="optional"> <code class="literal">KEYS</code> </span>] </span>]
       </p>
       <p>
<span class="original">
        This predicate tests whether &lt;replaceable&gt;expression&lt;/replaceable&gt; can be
        parsed as JSON, possibly of a specified type.
        If &lt;literal&gt;SCALAR&lt;/literal&gt; or &lt;literal&gt;ARRAY&lt;/literal&gt; or
        &lt;literal&gt;OBJECT&lt;/literal&gt; is specified, the
        test is whether or not the JSON is of that particular type. If
        &lt;literal&gt;WITH UNIQUE KEYS&lt;/literal&gt; is specified, then any object in the
        &lt;replaceable&gt;expression&lt;/replaceable&gt; is also tested to see if it
        has duplicate keys.
</span>
この述語は、<em class="replaceable"><code>expression</code></em>が指定された型のJSONとして解析できるかどうかをテストします。
<code class="literal">SCALAR</code>、<code class="literal">ARRAY</code>、または<code class="literal">OBJECT</code>が指定されている場合、テストはJSONがその特定の型のものであるかどうかを示します。
<code class="literal">WITH UNIQUE KEYS</code>が指定されている場合、<em class="replaceable"><code>expression</code></em>のオブジェクトもテストされ、重複キーがあるかどうかが確認されます。
       </p>
       <p>
</p><pre class="programlisting">
SELECT js,
  js IS JSON "json?",
  js IS JSON SCALAR "scalar?",
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?"
FROM (VALUES
      ('123'), ('"abc"'), ('{"a": "b"}'), ('[1,2]'),('abc')) foo(js);
     js     | json? | scalar? | object? | array?
------------+-------+---------+---------+--------
 123        | t     | t       | f       | f
 "abc"      | t     | t       | f       | f
 {"a": "b"} | t     | f       | t       | f
 [1,2]      | t     | f       | f       | t
 abc        | f     | f       | f       | f
</pre><p>
       </p>
       <p>
</p><pre class="programlisting">
SELECT js,
  js IS JSON OBJECT "object?",
  js IS JSON ARRAY "array?",
  js IS JSON ARRAY WITH UNIQUE KEYS "array w. UK?",
  js IS JSON ARRAY WITHOUT UNIQUE KEYS "array w/o UK?"
FROM (VALUES ('[{"a":"1"},
 {"b":"2","b":"3"}]')) foo(js);
-[ RECORD 1 ]-+--------------------
js            | [{"a":"1"},        +
              |  {"b":"2","b":"3"}]
object?       | f
array?        | t
array w. UK?  | f
array w/o UK? | t
</pre><p>
      </p></td></tr></tbody></table></div></div><br class="table-break" /><p>
<span class="original">
   &lt;xref linkend="functions-json-processing-table"/&gt; shows the functions that
   are available for processing &lt;type&gt;json&lt;/type&gt; and &lt;type&gt;jsonb&lt;/type&gt; values.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="表9.49 JSON処理関数">表 9.49</a>に<code class="type">json</code>と<code class="type">jsonb</code>値を処理するのに使える関数を示します。
  </p><div class="table" id="FUNCTIONS-JSON-PROCESSING-TABLE"><p class="title"><strong>表9.49 JSON処理関数</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;JSON Processing Functions&lt;/title&gt;
</span><table class="table" summary="JSON処理関数" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Function
</span>
関数
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.1.1.1.1" class="indexterm"></a>
        <code class="function">json_array_elements</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.1.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_array_elements</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof jsonb</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON array into a set of JSON values.
</span>
トップレベルのJSON配列をJSON値の集合に展開します。
       </p>
       <p>
        <code class="literal">select * from json_array_elements('[1,true, [2,false]]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
   value
-----------
 1
 true
 [2,false]
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.2.1.1.1" class="indexterm"></a>
        <code class="function">json_array_elements_text</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof text</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.2.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_array_elements_text</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof text</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON array into a set of &lt;type&gt;text&lt;/type&gt; values.
</span>
トップレベルのJSON配列を<code class="type">text</code>値の集合に展開します。
       </p>
       <p>
        <code class="literal">select * from json_array_elements_text('["foo", "bar"]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
   value
-----------
 foo
 bar
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.3.1.1.1" class="indexterm"></a>
        <code class="function">json_array_length</code> ( <code class="type">json</code> )
        → <code class="returnvalue">integer</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.3.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_array_length</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">integer</code>
       </p>
       <p>
<span class="original">
        Returns the number of elements in the top-level JSON array.
</span>
トップレベルのJSON配列の要素数を返します。
       </p>
       <p>
        <code class="literal">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</code>
        → <code class="returnvalue">5</code>
       </p>
       <p>
        <code class="literal">jsonb_array_length('[]')</code>
        → <code class="returnvalue">0</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.4.1.1.1" class="indexterm"></a>
        <code class="function">json_each</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof record</code>
        ( <em class="parameter"><code>key</code></em> <code class="type">text</code>,
        <em class="parameter"><code>value</code></em> <code class="type">json</code> )
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.4.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_each</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof record</code>
        ( <em class="parameter"><code>key</code></em> <code class="type">text</code>,
        <em class="parameter"><code>value</code></em> <code class="type">jsonb</code> )
       </p>
       <p>
<span class="original">
        Expands the top-level JSON object into a set of key/value pairs.
</span>
トップレベルのJSONオブジェクトをキー／値のペアの集合に展開します。
       </p>
       <p>
        <code class="literal">select * from json_each('{"a":"foo", "b":"bar"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.5.1.1.1" class="indexterm"></a>
        <code class="function">json_each_text</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof record</code>
        ( <em class="parameter"><code>key</code></em> <code class="type">text</code>,
        <em class="parameter"><code>value</code></em> <code class="type">text</code> )
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.5.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_each_text</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof record</code>
        ( <em class="parameter"><code>key</code></em> <code class="type">text</code>,
        <em class="parameter"><code>value</code></em> <code class="type">text</code> )
       </p>
       <p>
<span class="original">
        Expands the top-level JSON object into a set of key/value pairs.
        The returned &lt;parameter&gt;value&lt;/parameter&gt;s will be of
        type &lt;type&gt;text&lt;/type&gt;.
</span>
トップレベルのJSONオブジェクトをキー／値のペアの集合に展開します。
返り値の<em class="parameter"><code>value</code></em>は<code class="type">text</code>型です。
       </p>
       <p>
        <code class="literal">select * from json_each_text('{"a":"foo", "b":"bar"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 key | value
-----+-------
 a   | foo
 b   | bar
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.6.1.1.1" class="indexterm"></a>
        <code class="function">json_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.6.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_extract_path</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Extracts JSON sub-object at the specified path.
        (This is functionally equivalent to the &lt;literal&gt;#&amp;gt;&lt;/literal&gt;
        operator, but writing the path out as a variadic list can be more
        convenient in some cases.)
</span>
指定したパスにおけるJSONの副オブジェクトを取り出します。
（これは<code class="literal">#&gt;</code>演算子と機能的に同じですが、パスをvariadicリストで書き出す方がより便利な場合があります。）
       </p>
       <p>
        <code class="literal">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code>
        → <code class="returnvalue">"foo"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.7.1.1.1" class="indexterm"></a>
        <code class="function">json_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">json</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.7.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_extract_path_text</code> ( <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code>, <code class="literal">VARIADIC</code> <em class="parameter"><code>path_elems</code></em> <code class="type">text[]</code> )
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Extracts JSON sub-object at the specified path as &lt;type&gt;text&lt;/type&gt;.
        (This is functionally equivalent to the &lt;literal&gt;#&amp;gt;&amp;gt;&lt;/literal&gt;
        operator.)
</span>
指定したパスにおけるJSONの副オブジェクトを<code class="type">text</code>として取り出します。
（これは機能的には<code class="literal">#&gt;&gt;</code>演算子と同じです。）
       </p>
       <p>
        <code class="literal">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}', 'f4', 'f6')</code>
        → <code class="returnvalue">foo</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.8.1.1.1" class="indexterm"></a>
        <code class="function">json_object_keys</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof text</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.8.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_object_keys</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof text</code>
       </p>
       <p>
<span class="original">
        Returns the set of keys in the top-level JSON object.
</span>
トップレベルのJSONオブジェクト中のキーの集合を返します。
       </p>
       <p>
        <code class="literal">select * from json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 json_object_keys
------------------
 f1
 f2
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.9.1.1.1" class="indexterm"></a>
        <code class="function">json_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> )
        → <code class="returnvalue">anyelement</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.9.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_populate_record</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> )
        → <code class="returnvalue">anyelement</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON object to a row having the composite type
        of the &lt;parameter&gt;base&lt;/parameter&gt; argument.  The JSON object
        is scanned for fields whose names match column names of the output row
        type, and their values are inserted into those columns of the output.
        (Fields that do not correspond to any output column name are ignored.)
        In typical use, the value of &lt;parameter&gt;base&lt;/parameter&gt; is just
        &lt;literal&gt;NULL&lt;/literal&gt;, which means that any output columns that do
        not match any object field will be filled with nulls.  However,
        if &lt;parameter&gt;base&lt;/parameter&gt; isn't &lt;literal&gt;NULL&lt;/literal&gt; then
        the values it contains will be used for unmatched columns.
</span>
トップレベルのJSONオブジェクトを<em class="parameter"><code>base</code></em>引数である複合型を持つ行に展開します。
JSONオブジェクトは出力行型の列名と一致するフィールドが検査されます。
（出力列名と関連のないフィールドは無視されます。）
典型的な使い方としては、<em class="parameter"><code>base</code></em>の値が単に<code class="literal">NULL</code>で、これはオブジェクトフィールドと一致しない出力列にはNULLがセットされることを意味します。
しかし、<em class="parameter"><code>base</code></em>が<code class="literal">NULL</code>でないなら、それが持つ値が一致しない列に使われます。
       </p>
       <p>
<span class="original">
        To convert a JSON value to the SQL type of an output column, the
        following rules are applied in sequence:
</span>
JSON値を出力列のSQL型に変換する際に以下のルールが順に適用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
           A JSON null value is converted to an SQL null in all cases.
</span>
すべての場合にJSONのNULL値はSQLのNULLに変換されます。
          </p></li><li class="listitem"><p>
<span class="original">
           If the output column is of type &lt;type&gt;json&lt;/type&gt;
           or &lt;type&gt;jsonb&lt;/type&gt;, the JSON value is just reproduced exactly.
</span>
出力列が<code class="type">json</code>型あるいは<code class="type">jsonb</code>型なら、JSON値は単にそのまま複製されます。
          </p></li><li class="listitem"><p>
<span class="original">
           If the output column is a composite (row) type, and the JSON value
           is a JSON object, the fields of the object are converted to columns
           of the output row type by recursive application of these rules.
</span>
出力行が複合(行)型でJSON値がJSONオブジェクトなら、これらのルールを再帰的に適用することによって、オブジェクトのフィールドが出力行型の列に変換されます。
          </p></li><li class="listitem"><p>
<span class="original">
           Likewise, if the output column is an array type and the JSON value
           is a JSON array, the elements of the JSON array are converted to
           elements of the output array by recursive application of these
           rules.
</span>
同様に、出力行が配列型でJSON値がJSON配列なら、これらのルールを再帰的に適用することによって、JSON配列の要素が出力配列の要素に変換されます。
          </p></li><li class="listitem"><p>
<span class="original">
           Otherwise, if the JSON value is a string, the contents of the
           string are fed to the input conversion function for the column's
           data type.
</span>
それ以外の場合で、JSON値が文字列なら、その文字列の内容が列のデータ型に対応する入力変換関数に送られます。
          </p></li><li class="listitem"><p>
<span class="original">
           Otherwise, the ordinary text representation of the JSON value is
           fed to the input conversion function for the column's data type.
</span>
さもなければ、通常のJSON値のテキスト表現が列のデータ型に対応する入力変換関数に送られます。
          </p></li></ul></div><p>
       </p>
       <p>
<span class="original">
        While the example below uses a constant JSON value, typical use would
        be to reference a &lt;type&gt;json&lt;/type&gt; or &lt;type&gt;jsonb&lt;/type&gt; column
        laterally from another table in the query's &lt;literal&gt;FROM&lt;/literal&gt;
        clause.  Writing &lt;function&gt;json_populate_record&lt;/function&gt; in
        the &lt;literal&gt;FROM&lt;/literal&gt; clause is good practice, since all of the
        extracted columns are available for use without duplicate function
        calls.
</span>
これらの関数の例ではJSON定数を使用していますが、典型的な使用法はその<code class="type">json</code>または<code class="type">jsonb</code>列を<code class="literal">FROM</code>句の別のテーブルから外側に参照することです。
<code class="literal">FROM</code>句で<code class="function">json_populate_record</code>を書くのは良い練習になります。
すべての取り出された列を重複した関数呼び出しなしに利用できるからです。
       </p>
       <p>
        <code class="literal">create type subrowtype as (d int, e text);</code>
        <code class="literal">create type myrowtype as (a int, b text[], c subrowtype);</code>
       </p>
       <p>
        <code class="literal">select * from json_populate_record(null::myrowtype,
         '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}, "x": "foo"}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.10.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_populate_record_valid</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> )
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Function for testing &lt;function&gt;jsonb_populate_record&lt;/function&gt;.  Returns
        &lt;literal&gt;true&lt;/literal&gt; if the input &lt;function&gt;jsonb_populate_record&lt;/function&gt;
        would finish without an error for the given input JSON object; that is, it's
        valid input, &lt;literal&gt;false&lt;/literal&gt; otherwise.
</span>
<code class="function">jsonb_populate_record</code>をテストする関数。
与えられた入力JSONオブジェクトに対して<code class="function">jsonb_populate_record</code>がエラーなしで終了する場合、すなわち有効な入力なら<code class="literal">true</code>を、そうでない場合は<code class="literal">false</code>を返します。
       </p>
       <p>
        <code class="literal">create type jsb_char2 as (a char(2));</code>
       </p>
       <p>
        <code class="literal">select jsonb_populate_record_valid(NULL::jsb_char2, '{"a": "aaa"}');</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 jsonb_populate_record_valid
-----------------------------
 f
(1 row)
</pre><p>

        <code class="literal">select * from jsonb_populate_record(NULL::jsb_char2, '{"a": "aaa"}') q;</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
ERROR:  value too long for type character(2)
</pre><p>
        <code class="literal">select jsonb_populate_record_valid(NULL::jsb_char2, '{"a": "aa"}');</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 jsonb_populate_record_valid
-----------------------------
 t
(1 row)
</pre><p>

        <code class="literal">select * from jsonb_populate_record(NULL::jsb_char2, '{"a": "aa"}') q;</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 a
----
 aa
(1 row)
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.11.1.1.1" class="indexterm"></a>
        <code class="function">json_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">json</code> )
        → <code class="returnvalue">setof anyelement</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.11.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_populate_recordset</code> ( <em class="parameter"><code>base</code></em> <code class="type">anyelement</code>, <em class="parameter"><code>from_json</code></em> <code class="type">jsonb</code> )
        → <code class="returnvalue">setof anyelement</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON array of objects to a set of rows having
        the composite type of the &lt;parameter&gt;base&lt;/parameter&gt; argument.
        Each element of the JSON array is processed as described above
        for &lt;function&gt;json[b]_populate_record&lt;/function&gt;.
</span>
トップレベルのJSONオブジェクトを<em class="parameter"><code>base</code></em>引数である複合型を持つ行の集合に展開します。
JSON配列の個々の要素は上の<code class="function">json[b]_populate_record</code>で説明したように処理されます。
       </p>
       <p>
        <code class="literal">create type twoints as (a int, b int);</code>
       </p>
       <p>
        <code class="literal">select * from json_populate_recordset(null::twoints, '[{"a":1,"b":2}, {"a":3,"b":4}]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 a | b
---+---
 1 | 2
 3 | 4
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.12.1.1.1" class="indexterm"></a>
        <code class="function">json_to_record</code> ( <code class="type">json</code> )
        → <code class="returnvalue">record</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.12.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_to_record</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">record</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON object to a row having the composite type
        defined by an &lt;literal&gt;AS&lt;/literal&gt; clause.  (As with all functions
        returning &lt;type&gt;record&lt;/type&gt;, the calling query must explicitly
        define the structure of the record with an &lt;literal&gt;AS&lt;/literal&gt;
        clause.)  The output record is filled from fields of the JSON object,
        in the same way as described above
        for &lt;function&gt;json[b]_populate_record&lt;/function&gt;.  Since there is no
        input record value, unmatched columns are always filled with nulls.
</span>
トップレベルのJSONオブジェクトを<code class="literal">AS</code>句で定義した複合型を持つ行に展開します。
（<code class="type">record</code>を返すすべての関数では、呼び出す問い合わせは明示的に<code class="literal">AS</code>句でレコードの構造を定義しなければなりません。）
上の<code class="function">json[b]_populate_record</code>で説明した方法で、出力レコードはJSONオブジェクトのフィールドで満たされます。
入力レコード値がないので、一致しない列は常にNULLで満たされます。
       </p>
       <p>
        <code class="literal">create type myrowtype as (a int, b text);</code>
       </p>
       <p>
        <code class="literal">select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.13.1.1.1" class="indexterm"></a>
        <code class="function">json_to_recordset</code> ( <code class="type">json</code> )
        → <code class="returnvalue">setof record</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.13.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_to_recordset</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">setof record</code>
       </p>
       <p>
<span class="original">
        Expands the top-level JSON array of objects to a set of rows having
        the composite type defined by an &lt;literal&gt;AS&lt;/literal&gt; clause.  (As
        with all functions returning &lt;type&gt;record&lt;/type&gt;, the calling query
        must explicitly define the structure of the record with
        an &lt;literal&gt;AS&lt;/literal&gt; clause.)  Each element of the JSON array is
        processed as described above
        for &lt;function&gt;json[b]_populate_record&lt;/function&gt;.
</span>
トップレベルのJSON配列を<code class="literal">AS</code>句で定義した複合型を持つ行に展開します。
（<code class="type">record</code>を返すすべての関数では、呼び出す問い合わせは明示的に<code class="literal">AS</code>句でレコードの構造を定義しなければなりません。）
上の<code class="function">json[b]_populate_record</code>で説明した方法で、JSON配列の要素は処理されます。
       </p>
       <p>
        <code class="literal">select * from json_to_recordset('[{"a":1,"b":"foo"}, {"a":"2","c":"bar"}]') as x(a int, b text)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 a |  b
---+-----
 1 | foo
 2 |
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.14.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_set</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code> </span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Returns &lt;parameter&gt;target&lt;/parameter&gt;
        with the item designated by &lt;parameter&gt;path&lt;/parameter&gt;
        replaced by &lt;parameter&gt;new_value&lt;/parameter&gt;, or with
        &lt;parameter&gt;new_value&lt;/parameter&gt; added if
        &lt;parameter&gt;create_if_missing&lt;/parameter&gt; is true (which is the
        default) and the item designated by &lt;parameter&gt;path&lt;/parameter&gt;
        does not exist.
        All earlier steps in the path must exist, or
        the &lt;parameter&gt;target&lt;/parameter&gt; is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the &lt;parameter&gt;path&lt;/parameter&gt; count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range,
        and &lt;parameter&gt;create_if_missing&lt;/parameter&gt; is true, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
</span>
<em class="parameter"><code>path</code></em>で指定された要素を<em class="parameter"><code>new_value</code></em>で置き換えて<em class="parameter"><code>target</code></em>を返します。
<em class="parameter"><code>create_if_missing</code></em>が真なら（デフォルトです）、<em class="parameter"><code>path</code></em>で指定された項目が無い時に<em class="parameter"><code>new_value</code></em>が追加されます。
パス中のすべての初期のステップは存在しなければならず、さもなければ<em class="parameter"><code>target</code></em>は変わらないままに返却されます。
パスの位置についての演算子については、<em class="parameter"><code>path</code></em>の中にある負の整数はJSON配列の終わりから数えます。
パスの最後のステップが範囲外の配列のインデックスで、<em class="parameter"><code>create_if_missing</code></em>が真のときは、インデックスが負なら配列の最初に、正なら配列の最後に新しい値が追加されます。
       </p>
       <p>
        <code class="literal">jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', '[2,3,4]', false)</code>
        → <code class="returnvalue">[{"f1": [2, 3, 4], "f2": null}, 2, null, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}', '[2,3,4]')</code>
        → <code class="returnvalue">[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.15.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_set_lax</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>create_if_missing</code></em> <code class="type">boolean</code> [<span class="optional">, <em class="parameter"><code>null_value_treatment</code></em> <code class="type">text</code> </span>]</span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        If &lt;parameter&gt;new_value&lt;/parameter&gt; is not &lt;literal&gt;NULL&lt;/literal&gt;,
        behaves identically to &lt;literal&gt;jsonb_set&lt;/literal&gt;. Otherwise behaves
        according to the value
        of &lt;parameter&gt;null_value_treatment&lt;/parameter&gt; which must be one
        of &lt;literal&gt;'raise_exception'&lt;/literal&gt;,
        &lt;literal&gt;'use_json_null'&lt;/literal&gt;, &lt;literal&gt;'delete_key'&lt;/literal&gt;, or
        &lt;literal&gt;'return_target'&lt;/literal&gt;. The default is
        &lt;literal&gt;'use_json_null'&lt;/literal&gt;.
</span>
<em class="parameter"><code>new_value</code></em>が<code class="literal">NULL</code>でないなら、<code class="literal">jsonb_set</code>と同じ振る舞いをします。
そうでなければ<em class="parameter"><code>null_value_treatment</code></em>にしたがいます。
<em class="parameter"><code>null_value_treatment</code></em>は、<code class="literal">'raise_exception'</code>、<code class="literal">'use_json_null'</code>、<code class="literal">'delete_key'</code>、<code class="literal">'return_target'</code>のいずれかでなければなりません。
デフォルトは<code class="literal">'use_json_null'</code>です。
       </p>
       <p>
        <code class="literal">jsonb_set_lax('[{"f1":1,"f2":null},2,null,3]', '{0,f1}', null)</code>
        → <code class="returnvalue">[{"f1": null, "f2": null}, 2, null, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_set_lax('[{"f1":99,"f2":null},2]', '{0,f3}', null, true, 'return_target')</code>
        → <code class="returnvalue">[{"f1": 99, "f2": null}, 2]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.16.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_insert</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">text[]</code>, <em class="parameter"><code>new_value</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>insert_after</code></em> <code class="type">boolean</code> </span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Returns &lt;parameter&gt;target&lt;/parameter&gt;
        with &lt;parameter&gt;new_value&lt;/parameter&gt; inserted.  If the item
        designated by the &lt;parameter&gt;path&lt;/parameter&gt; is an array
        element, &lt;parameter&gt;new_value&lt;/parameter&gt; will be inserted before
        that item if &lt;parameter&gt;insert_after&lt;/parameter&gt; is false (which
        is the default), or after it
        if &lt;parameter&gt;insert_after&lt;/parameter&gt; is true.  If the item
        designated by the &lt;parameter&gt;path&lt;/parameter&gt; is an object
        field, &lt;parameter&gt;new_value&lt;/parameter&gt; will be inserted only if
        the object does not already contain that key.
        All earlier steps in the path must exist, or
        the &lt;parameter&gt;target&lt;/parameter&gt; is returned unchanged.
        As with the path oriented operators, negative integers that
        appear in the &lt;parameter&gt;path&lt;/parameter&gt; count from the end
        of JSON arrays.
        If the last path step is an array index that is out of range, the new
        value is added at the beginning of the array if the index is negative,
        or at the end of the array if it is positive.
</span>
<em class="parameter"><code>new_value</code></em>を挿入して<em class="parameter"><code>target</code></em>を返します。
<em class="parameter"><code>path</code></em>で指定した項目が配列要素で、<em class="parameter"><code>insert_after</code></em>が偽（デフォルトです）ならば<em class="parameter"><code>new_value</code></em>はその項目の前に挿入され、<em class="parameter"><code>insert_after</code></em>が真であれば後に挿入されます。
<em class="parameter"><code>path</code></em>で指定した項目がオブジェクトフィールドならば、オブジェクトがすでにそのキーを含んでいない場合にのみ<em class="parameter"><code>new_value</code></em>が挿入されます。
パス中のすべての初期のステップは存在しなければならず、さもなければ<em class="parameter"><code>target</code></em>は変わらないままに返却されます。
pathについての演算子について言うと、<em class="parameter"><code>path</code></em>内の負の整数はJSON配列の終わりから数えます。
パスの最後のステップが範囲外の配列のインデックスで、インデックスが負なら配列の最初に、正なら配列の最後に新しい値が追加されます。
       </p>
       <p>
        <code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')</code>
        → <code class="returnvalue">{"a": [0, "new_value", 1, 2]}</code>
       </p>
       <p>
        <code class="literal">jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)</code>
        → <code class="returnvalue">{"a": [0, 1, "new_value", 2]}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.17.1.1.1" class="indexterm"></a>
        <code class="function">json_strip_nulls</code> ( <code class="type">json</code> )
        → <code class="returnvalue">json</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.17.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_strip_nulls</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Deletes all object fields that have null values from the given JSON
        value, recursively.  Null values that are not object fields are
        untouched.
</span>
与えられたJSON値からNULLを持つオブジェクトフィールドをすべて削除します。
オブジェクトフィールドではないNULL値は変わりません。
       </p>
       <p>
        <code class="literal">json_strip_nulls('[{"f1":1, "f2":null}, 2, null, 3]')</code>
        → <code class="returnvalue">[{"f1":1},2,null,3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.18.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_exists</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Checks whether the JSON path returns any item for the specified JSON
        value.
        (This is useful only with SQL-standard JSON path expressions, not
        &lt;link linkend="functions-sqljson-check-expressions"&gt;predicate check
        expressions&lt;/link&gt;, since those always return a value.)
        If the &lt;parameter&gt;vars&lt;/parameter&gt; argument is specified, it must
        be a JSON object, and its fields provide named values to be
        substituted into the &lt;type&gt;jsonpath&lt;/type&gt; expression.
        If the &lt;parameter&gt;silent&lt;/parameter&gt; argument is specified and
        is &lt;literal&gt;true&lt;/literal&gt;, the function suppresses the same errors
        as the &lt;literal&gt;@?&lt;/literal&gt; and &lt;literal&gt;@@&lt;/literal&gt; operators do.
</span>
JSONパスが指定したJSON値に対して項目を返すかどうかをチェックします。
（これは、<a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. ブール述語チェック式">述語チェック式</a>ではなく、SQL標準のJSONパス式でのみ有用です。
なぜなら、それらは常に値を返すからです。）
<em class="parameter"><code>vars</code></em>が指定されるなら、それはJSONオブジェクトでなければならず、そのフィールドは<code class="type">jsonpath</code>式に置き換えられる名前を持つ値を提供します。
<em class="parameter"><code>silent</code></em>引数が指定されていて<code class="literal">true</code>なら、この関数は<code class="literal">@?</code>と<code class="literal">@@</code>演算子が生成するのと同じエラーを抑止します。
       </p>
       <p>
        <code class="literal">jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.19.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_match</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Returns the result of a JSON path predicate check for the specified
        JSON value.
        (This is useful only
        with &lt;link linkend="functions-sqljson-check-expressions"&gt;predicate
        check expressions&lt;/link&gt;, not SQL-standard JSON path expressions,
        since it will either fail or return &lt;literal&gt;NULL&lt;/literal&gt; if the
        path result is not a single boolean value.)
        The optional &lt;parameter&gt;vars&lt;/parameter&gt;
        and &lt;parameter&gt;silent&lt;/parameter&gt; arguments act the same as
        for &lt;function&gt;jsonb_path_exists&lt;/function&gt;.
</span>
指定したJSON値のJSONパス述語チェックの結果を返します。
（これは、パス結果が単一のブール値でない場合、失敗するか<code class="literal">NULL</code>を返すため、SQL標準のJSONパス述語ではなく、<a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. ブール述語チェック式">述語チェック式</a>でのみ有用です）。
オプションの<em class="parameter"><code>vars</code></em>と<em class="parameter"><code>silent</code></em>引数は、<code class="function">jsonb_path_exists</code>と同じように動作します。
       </p>
       <p>
        <code class="literal">jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max))', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.20.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_query</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">setof jsonb</code>
       </p>
       <p>
<span class="original">
        Returns all JSON items returned by the JSON path for the specified
        JSON value.
        For SQL-standard JSON path expressions it returns the JSON
        values selected from &lt;parameter&gt;target&lt;/parameter&gt;.
        For &lt;link linkend="functions-sqljson-check-expressions"&gt;predicate
        check expressions&lt;/link&gt; it returns the result of the predicate
        check: &lt;literal&gt;true&lt;/literal&gt;, &lt;literal&gt;false&lt;/literal&gt;,
        or &lt;literal&gt;null&lt;/literal&gt;.
        The optional &lt;parameter&gt;vars&lt;/parameter&gt;
        and &lt;parameter&gt;silent&lt;/parameter&gt; arguments act the same as
        for &lt;function&gt;jsonb_path_exists&lt;/function&gt;.
</span>
指定されたJSON値のJSONパスによって戻されるすべてのJSON項目を戻します。
SQL標準のJSONパス式の場合、<em class="parameter"><code>target</code></em>から選択されたJSON値を返します。
<a class="link" href="functions-json.html#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" title="9.16.2.1.1. ブール述語チェック式">述語チェック式</a>の場合、述語チェックの結果を返します。
結果は<code class="literal">true</code>、<code class="literal">false</code>、<code class="literal">null</code>のいずれかです。
オプションの<em class="parameter"><code>vars</code></em>と<em class="parameter"><code>silent</code></em>引数は<code class="function">jsonb_path_exists</code>と同じように動作します。
       </p>
       <p>
        <code class="literal">select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
 jsonb_path_query
------------------
 2
 3
 4
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.21.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_query_array</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Returns all JSON items returned by the JSON path for the specified
        JSON value, as a JSON array.
        The parameters are the same as
        for &lt;function&gt;jsonb_path_query&lt;/function&gt;.
</span>
指定されたJSON値のJSONパスによって返されるすべてのJSON項目を、JSON配列として返します。
パラメータは<code class="function">jsonb_path_query</code>と同じです。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">[2, 3, 4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.22.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_query_first</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        Returns the first JSON item returned by the JSON path for the
        specified JSON value, or &lt;literal&gt;NULL&lt;/literal&gt; if there are no
        results.
        The parameters are the same as
        for &lt;function&gt;jsonb_path_query&lt;/function&gt;.
</span>
指定されたJSON値のJSONパスによって返される最初のJSON項目を返します。
結果がない場合は<code class="literal">NULL</code>です。
パラメータは<code class="function">jsonb_path_query</code>と同じです。
       </p>
       <p>
        <code class="literal">jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2, "max":4}')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.23.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_path_exists_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.23.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_path_match_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.23.1.3.1" class="indexterm"></a>
        <code class="function">jsonb_path_query_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">setof jsonb</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.23.1.4.1" class="indexterm"></a>
        <code class="function">jsonb_path_query_array_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.23.1.5.1" class="indexterm"></a>
        <code class="function">jsonb_path_query_first_tz</code> ( <em class="parameter"><code>target</code></em> <code class="type">jsonb</code>, <em class="parameter"><code>path</code></em> <code class="type">jsonpath</code> [<span class="optional">, <em class="parameter"><code>vars</code></em> <code class="type">jsonb</code> [<span class="optional">, <em class="parameter"><code>silent</code></em> <code class="type">boolean</code> </span>]</span>] )
        → <code class="returnvalue">jsonb</code>
       </p>
       <p>
<span class="original">
        These functions act like their counterparts described above without
        the &lt;literal&gt;_tz&lt;/literal&gt; suffix, except that these functions support
        comparisons of date/time values that require timezone-aware
        conversions.  The example below requires interpretation of the
        date-only value &lt;literal&gt;2015-08-02&lt;/literal&gt; as a timestamp with time
        zone, so the result depends on the current
        &lt;xref linkend="guc-timezone"/&gt; setting.  Due to this dependency, these
        functions are marked as stable, which means these functions cannot be
        used in indexes.  Their counterparts are immutable, and so can be used
        in indexes; but they will throw errors if asked to make such
        comparisons.
</span>
これらの関数は、時間帯を考慮する日時値の比較をサポートすることを除いて、上で述べた、<code class="literal">_tz</code>接尾を除いた片割れの関数のように動作します。
以下の例では日付のみの値<code class="literal">2015-08-02</code>を時間帯付きタイムスタンプとして解釈することが必要で、結果は<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>設定に依存します。
この依存性のために、これらの関数は安定(stable)、として印付けされており、インデックスにはこれらの関数は使えないことを意味します。
これらの関数の片割れは不変(immutable)なので、インデックスで使えます。しかし、そうした比較を要求されるとエラーを吐きます。
       </p>
       <p>
        <code class="literal">jsonb_path_exists_tz('["2015-08-01 12:00:00-05"]', '$[*] ? (@.datetime() &lt; "2015-08-02".datetime())')</code>
        → <code class="returnvalue">t</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.24.1.1.1" class="indexterm"></a>
        <code class="function">jsonb_pretty</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Converts the given JSON value to pretty-printed, indented text.
</span>
与えられたJSON値を整形されたインデント付きテキストに変換します。
       </p>
       <p>
        <code class="literal">jsonb_pretty('[{"f1":1,"f2":null}, 2]')</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
[
    {
        "f1": 1,
        "f2": null
    },
    2
]
</pre><p>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.25.1.1.1" class="indexterm"></a>
        <code class="function">json_typeof</code> ( <code class="type">json</code> )
        → <code class="returnvalue">text</code>
       </p>
       <p class="func_signature">
        <a id="id-1.5.8.24.10.13.2.2.25.1.2.1" class="indexterm"></a>
        <code class="function">jsonb_typeof</code> ( <code class="type">jsonb</code> )
        → <code class="returnvalue">text</code>
       </p>
       <p>
<span class="original">
        Returns the type of the top-level JSON value as a text string.
        Possible types are
        &lt;literal&gt;object&lt;/literal&gt;, &lt;literal&gt;array&lt;/literal&gt;,
        &lt;literal&gt;string&lt;/literal&gt;, &lt;literal&gt;number&lt;/literal&gt;,
        &lt;literal&gt;boolean&lt;/literal&gt;, and &lt;literal&gt;null&lt;/literal&gt;.
        (The &lt;literal&gt;null&lt;/literal&gt; result should not be confused
        with an SQL NULL; see the examples.)
</span>
トップレベルのJSON値の型をテキスト文字列として返します。
可能な型は次のとおりです。
<code class="literal">object</code>、<code class="literal">array</code>、<code class="literal">string</code>、<code class="literal">number</code>、<code class="literal">boolean</code>、<code class="literal">null</code>。
（<code class="literal">null</code>の結果をSQLのNULLと混同してはいけません。以下の例をご覧ください。）
       </p>
       <p>
        <code class="literal">json_typeof('-123.4')</code>
        → <code class="returnvalue">number</code>
       </p>
       <p>
        <code class="literal">json_typeof('null'::json)</code>
        → <code class="returnvalue">null</code>
       </p>
       <p>
        <code class="literal">json_typeof(NULL::json) IS NULL</code>
        → <code class="returnvalue">t</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="FUNCTIONS-SQLJSON-PATH"><div class="titlepage"><div><div><h3 class="title">9.16.2. SQL/JSONパス言語 <a href="#FUNCTIONS-SQLJSON-PATH" class="id_link">#</a></h3></div></div></div><span class="original">
  &lt;title&gt;The SQL/JSON Path Language&lt;/title&gt;
</span><a id="id-1.5.8.24.11.2" class="indexterm"></a><a id="id-1.5.8.24.11.3" class="indexterm"></a><p>
<span class="original">
   SQL/JSON path expressions specify item(s) to be retrieved
   from a JSON value, similarly to XPath expressions used
   for access to XML content. In &lt;productname&gt;PostgreSQL&lt;/productname&gt;,
   path expressions are implemented as the &lt;type&gt;jsonpath&lt;/type&gt;
   data type and can use any elements described in
   &lt;xref linkend="datatype-jsonpath"/&gt;.
</span>
SQL/JSONパス式は、XMLコンテンツへのアクセスで使用されるXPath式同様、JSON値から取り出す項目を指定します。
<span class="productname">PostgreSQL</span>ではパス式は<code class="type">jsonpath</code>データ型として実装されており、<a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath型">8.14.7</a>で説明されているすべての要素を使うことができます。
  </p><p>
<span class="original">
   JSON query functions and operators
   pass the provided path expression to the &lt;firstterm&gt;path engine&lt;/firstterm&gt;
   for evaluation. If the expression matches the queried JSON data,
   the corresponding JSON item, or set of items, is returned.
   If there is no match, the result will be &lt;literal&gt;NULL&lt;/literal&gt;,
   &lt;literal&gt;false&lt;/literal&gt;, or an error, depending on the function.
   Path expressions are written in the SQL/JSON path language
   and can include arithmetic expressions and functions.
</span>
JSON問い合わせ関数と演算子は与えられたパス式を<em class="firstterm">path engine</em>に渡して評価します。
式が問い合わせ対象のJSONデータにマッチすれば、関連するSQL/JSON項目が返却されます。
一致しない場合、結果は<code class="literal">NULL</code>、<code class="literal">false</code>、または関数によって異なるエラーになります。
パス式はSQL/JSONパス言語で書かれ、算術式と関数を含むことができます。
  </p><p>
<span class="original">
   A path expression consists of a sequence of elements allowed
   by the &lt;type&gt;jsonpath&lt;/type&gt; data type.
   The path expression is normally evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of JSON items is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
</span>
パス式は<code class="type">jsonpath</code>データ型で認められた一連の要素からなります。
パス式は通常左から右へと評価されますが、括弧を使って演算の順序を変更することができます。
評価が成功すれば、一連のJSON項目が生成され、評価結果が指定した計算を完了したJSON問い合わせ関数に戻されます。
  </p><p>
<span class="original">
   To refer to the JSON value being queried (the
   &lt;firstterm&gt;context item&lt;/firstterm&gt;), use the &lt;literal&gt;$&lt;/literal&gt; variable
   in the path expression. The first element of a path must always
   be &lt;literal&gt;$&lt;/literal&gt;. It can be followed by one or more
   &lt;link linkend="type-jsonpath-accessors"&gt;accessor operators&lt;/link&gt;,
   which go down the JSON structure level by level to retrieve sub-items
   of the context item. Each accessor operator acts on the
   result(s) of the previous evaluation step, producing zero, one, or more
   output items from each input item.
</span>
問い合わせ対象（<em class="firstterm">context item</em>）のJSONデータを参照するには、パス式内で<code class="literal">$</code>値を使います。
パスの最初の要素は常に<code class="literal">$</code>でなければなりません。
複数の<a class="link" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="表8.25 jsonpath Accessors">アクセサ演算子</a>をその後に記述することもできます。
この後に、JSON構造のレベルを1つずつ下ってコンテキスト項目のサブ項目を取得する<a class="link" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="表8.25 jsonpath Accessors">アクセサ演算子</a>を1つ以上指定することができます。
各アクセサ演算子は、前の評価ステップの結果に作用し、各入力項目から0個、1個、または複数の出力項目を生成します。
  </p><p>
<span class="original">
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
</span>
たとえば、次のようなパースしたいGPSトラッカーからのJSONデータがあるとします。
</p><pre class="programlisting">
SELECT '{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}' AS json \gset
</pre><p>
<span class="original">
   (The above example can be copied-and-pasted
   into &lt;application&gt;psql&lt;/application&gt; to set things up for the following
   examples.  Then &lt;application&gt;psql&lt;/application&gt; will
   expand &lt;literal&gt;:'json'&lt;/literal&gt; into a suitably-quoted string
   constant containing the JSON value.)
</span>
（上記の例は、<span class="application">psql</span>にコピー&amp;ペーストして、以下の例の設定を行うことができます。
そうすると、<span class="application">psql</span>は<code class="literal">:'json'</code>を適切に引用符付けされた文字列定数に展開し、JSON値を含めます。）
  </p><p>
<span class="original">
   To retrieve the available track segments, you need to use the
   &lt;literal&gt;.&lt;replaceable&gt;key&lt;/replaceable&gt;&lt;/literal&gt; accessor
   operator to descend through surrounding JSON objects, for example:
</span>
使用可能なトラックセグメントを取り出すには、<code class="literal">.<em class="replaceable"><code>key</code></em></code>アクセサ演算子を使用して、周辺のJSONオブジェクトを下っていく必要があります。
例:
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments');</code></strong>
                                                                         jsonb_path_query
-----------------------------------------------------------​-----------------------------------------------------------​---------------------------------------------
 [{"HR": 73, "location": [47.763, 13.4034], "start time": "2018-10-14 10:05:14"}, {"HR": 135, "location": [47.706, 13.2635], "start time": "2018-10-14 10:39:21"}]
</pre><p>
  </p><p>
<span class="original">
   To retrieve the contents of an array, you typically use the
   &lt;literal&gt;[*]&lt;/literal&gt; operator.
   The following example will return the location coordinates for all
   the available track segments:
</span>
配列の内容を取り出すには、典型的には<code class="literal">[*]</code>演算子を使います。
次の例は、使用可能なすべてのトラックセグメントの位置座標を返します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*].location');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre><p>
<span class="original">
   Here we started with the whole JSON input value (&lt;literal&gt;$&lt;/literal&gt;),
   then the &lt;literal&gt;.track&lt;/literal&gt; accessor selected the JSON object
   associated with the &lt;literal&gt;"track"&lt;/literal&gt; object key, then
   the &lt;literal&gt;.segments&lt;/literal&gt; accessor selected the JSON array
   associated with the &lt;literal&gt;"segments"&lt;/literal&gt; key within that
   object, then the &lt;literal&gt;[*]&lt;/literal&gt; accessor selected each element
   of that array (producing a series of items), then
   the &lt;literal&gt;.location&lt;/literal&gt; accessor selected the JSON array
   associated with the &lt;literal&gt;"location"&lt;/literal&gt; key within each of
   those objects.  In this example, each of those objects had
   a &lt;literal&gt;"location"&lt;/literal&gt; key; but if any of them did not,
   the &lt;literal&gt;.location&lt;/literal&gt; accessor would have simply produced no
   output for that input item.
</span>
ここでは、JSON入力値(<code class="literal">$</code>)全体から始め、<code class="literal">.track</code>アクセサが<code class="literal">"track"</code>オブジェクトキーに関連付けられたJSONオブジェクトを選択し、<code class="literal">.segments</code>アクセサがそのオブジェクト内の<code class="literal">"segments"</code>キーに関連付けられたJSON配列を選択し、<code class="literal">[*]</code>アクセサがその配列の各要素を（一連の項目を生成しながら）選択し、<code class="literal">.location</code>アクセサがそれらのオブジェクトのそれぞれの中の<code class="literal">"location"</code>キーに関連付けられたJSON配列を選択しました。
この例では、それらのオブジェクトのそれぞれに<code class="literal">"location"</code>キーがありましたが、もしそうでなければ、<code class="literal">.location</code>アクセッサは単にその入力項目に対して何の出力も生成しなかったでしょう。
  </p><p>
<span class="original">
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the &lt;literal&gt;[]&lt;/literal&gt;
   accessor operator. Recall that JSON array indexes are 0-relative:
</span>
最初のセグメントの座標だけを返すには、<code class="literal">[]</code>アクセサ演算子の中で対応する添え字を指定することができます。
JSON配列インデックスは0スタートであることに注意してください。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[0].location');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
</pre><p>
  </p><p>
<span class="original">
   The result of each path evaluation step can be processed
   by one or more of the &lt;type&gt;jsonpath&lt;/type&gt; operators and methods
   listed in &lt;xref linkend="functions-sqljson-path-operators"/&gt;.
   Each method name must be preceded by a dot. For example,
   you can get the size of an array:
</span>
各段階でのパス評価結果は<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.3. SQL/JSONパス演算子とメソッド">9.16.2.3</a>に列挙されている一つ以上の<code class="type">jsonpath</code>演算子とメソッドで処理することができます。
各々のメソッド名の前にピリオドを付けなければなりません。
たとえば配列の大きさを得ることができます。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments.size()');</code></strong>
 jsonb_path_query
------------------
 2
</pre><p>
<span class="original">
   More examples of using &lt;type&gt;jsonpath&lt;/type&gt; operators
   and methods within path expressions appear below in
   &lt;xref linkend="functions-sqljson-path-operators"/&gt;.
</span>
パス式内の<code class="type">jsonpath</code>演算子とメソッドを使用する他の例については以下の<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.16.2.3. SQL/JSONパス演算子とメソッド">9.16.2.3</a>を参照してください。
  </p><p>
<span class="original">
   A path can also contain
   &lt;firstterm&gt;filter expressions&lt;/firstterm&gt; that work similarly to the
   &lt;literal&gt;WHERE&lt;/literal&gt; clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:
</span>
パスには、SQLの<code class="literal">WHERE</code>句のように働く<em class="firstterm">フィルター式</em>を含めることもできます。
フィルター式はクェスチョンマークで始まり、カッコ内に条件を記述します。

</p><pre class="synopsis">
? (<em class="replaceable"><code>condition</code></em>)
</pre><p>
  </p><p>
<span class="original">
   Filter expressions must be written just after the path evaluation step
   to which they should apply. The result of that step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can
   produce &lt;literal&gt;true&lt;/literal&gt;, &lt;literal&gt;false&lt;/literal&gt;,
   or &lt;literal&gt;unknown&lt;/literal&gt;. The &lt;literal&gt;unknown&lt;/literal&gt; value
   plays the same role as SQL &lt;literal&gt;NULL&lt;/literal&gt; and can be tested
   for with the &lt;literal&gt;is unknown&lt;/literal&gt; predicate. Further path
   evaluation steps use only those items for which the filter expression
   returned &lt;literal&gt;true&lt;/literal&gt;.
</span>
フィルター式はそれを適用するパス評価段階の直後に指定しなければなりません。
この段階の結果は、指定した条件を満たす項目だけが含まれるようにフィルターされます。
SQL/JSONは3値論理を定義しており、条件は<code class="literal">true</code>、<code class="literal">false</code>、<code class="literal">unknown</code>のどれかを生成します。
<code class="literal">unknown</code>は値はSQLの<code class="literal">NULL</code>と同じ役割を果たし、<code class="literal">is unknown</code>述語で評価できます。
その後の評価段階では<code class="literal">true</code>を返すフィルター式に対応する項目だけが使われます。
  </p><p>
<span class="original">
   The functions and operators that can be used in filter expressions are
   listed in &lt;xref linkend="functions-sqljson-filter-ex-table"/&gt;.  Within a
   filter expression, the &lt;literal&gt;@&lt;/literal&gt; variable denotes the value
   being considered (i.e., one result of the preceding path step).  You can
   write accessor operators after &lt;literal&gt;@&lt;/literal&gt; to retrieve component
   items.
</span>
フィルター式内で利用できる関数と演算子は<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="表9.51 jsonpathフィルター式要素">表 9.51</a>にリストされています。
フィルター式内では、考慮する必要のある値は<code class="literal">@</code>変数で示します。（つまり以前のパスステップの結果の一つです。）
コンポーネント項目を取得するためにアクセサ演算子を<code class="literal">@</code>の後に記述することができます。
  </p><p>
<span class="original">
   For example, suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this as follows:
</span>
たとえば130より高いすべての心拍数を取り出したいとします。
これを実現するには、次のようにします。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*].HR ? (@ &gt; 130)');</code></strong>
 jsonb_path_query
------------------
 135
</pre><p>
  </p><p>
<span class="original">
   To get the start times of segments with such values, you have to
   filter out irrelevant segments before selecting the start times, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
</span>
そうした値を持つセグメントの開始時刻を得たい場合は、開始時刻を選択する前に無関係のセグメントを取り除く必要があります。
そうすることにより前の段階にフィルター式が適用されるので、その条件で適用されるパスは異なります。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*] ? (@.HR &gt; 130)."start time"');</code></strong>
   jsonb_path_query
-----------------------
 "2018-10-14 10:39:21"
</pre><p>
  </p><p>
<span class="original">
   You can use several filter expressions in sequence, if required.
   The following example selects start times of all segments that
   contain locations with relevant coordinates and high heart rate values:
</span>
必要なら複数のフィルター式を順に使用することができます。
次の例では、関連する座標と高い心拍数値を持つ位置を含むすべてのセグメントの開始時間を選択します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"');</code></strong>
   jsonb_path_query
-----------------------
 "2018-10-14 10:39:21"
</pre><p>
  </p><p>
<span class="original">
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
</span>
異なる入れ子レベルに対してフィルタ式を適用することもできます。
次の例では、まず位置ですべてのセグメントをフィルタし、もしあれば高い心拍数値を返します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)');</code></strong>
 jsonb_path_query
------------------
 135
</pre><p>
  </p><p>
<span class="original">
   You can also nest filter expressions within each other.
   This example returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise:
</span>
フィルタ式をネストして、フィルタ式を相互にネストすることもできます。
次の例では、トラックに高心拍数値のセグメントが含まれている場合はそのサイズを返し、それ以外の場合は空のシーケンスを返します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()');</code></strong>
 jsonb_path_query
------------------
 2
</pre><p>
  </p><div class="sect3" id="FUNCTIONS-SQLJSON-DEVIATIONS"><div class="titlepage"><div><div><h4 class="title">9.16.2.1. SQL標準との違い <a href="#FUNCTIONS-SQLJSON-DEVIATIONS" class="id_link">#</a></h4></div></div></div><span class="original">
  &lt;title&gt;Deviations from the SQL Standard&lt;/title&gt;
</span><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt;'s implementation of the SQL/JSON path
    language has the following deviations from the SQL/JSON standard.
</span>
<span class="productname">PostgreSQL</span>のSQL/JSONパス言語の実装はSQL/JSON標準と次の点が異なります。
   </p><div class="sect4" id="FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS"><div class="titlepage"><div><div><h5 class="title">9.16.2.1.1. ブール述語チェック式 <a href="#FUNCTIONS-SQLJSON-CHECK-EXPRESSIONS" class="id_link">#</a></h5></div></div></div><span class="original">
   &lt;title&gt;Boolean Predicate Check Expressions&lt;/title&gt;
</span><p>
<span class="original">
     As an extension to the SQL standard,
     a &lt;productname&gt;PostgreSQL&lt;/productname&gt; path expression can be a
     Boolean predicate, whereas the SQL standard allows predicates only within
     filters. While SQL-standard path expressions return the relevant
     element(s) of the queried JSON value, predicate check expressions
     return the single three-valued result of the
     predicate: &lt;literal&gt;true&lt;/literal&gt;,
     &lt;literal&gt;false&lt;/literal&gt;, or &lt;literal&gt;unknown&lt;/literal&gt;.
     For example, we could write this SQL-standard filter expression:
</span>
SQL標準の拡張として、<span class="productname">PostgreSQL</span>パス式はブール述語になりますが、SQL標準では述語はフィルタ内でのみ許されます。
SQL標準のパス式は、問い合わせられたJSON値の関連する要素を返しますが、述語チェック式は述語の単一の3値結果<code class="literal">true</code>、<code class="literal">false</code>、<code class="literal">unknown</code>を返します。
たとえば、次のSQL標準フィルタ式を記述できます。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments ?(@[*].HR &gt; 130)');</code></strong>
                                jsonb_path_query
-----------------------------------------------------------​----------------------
 {"HR": 135, "location": [47.706, 13.2635], "start time": "2018-10-14 10:39:21"}
</pre><p>
<span class="original">
     The similar predicate check expression simply
     returns &lt;literal&gt;true&lt;/literal&gt;, indicating that a match exists:
</span>
類似述語チェック式は単に<code class="literal">true</code>を返し、一致が存在することを示します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', '$.track.segments[*].HR &gt; 130');</code></strong>
 jsonb_path_query
------------------
 true
</pre><p>
     </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
       Predicate check expressions are required in the
       &lt;literal&gt;@@&lt;/literal&gt; operator (and the
       &lt;function&gt;jsonb_path_match&lt;/function&gt; function), and should not be used
       with the &lt;literal&gt;@?&lt;/literal&gt; operator (or the
       &lt;function&gt;jsonb_path_exists&lt;/function&gt; function).
</span>
述語チェック式は<code class="literal">@@</code>演算子（および<code class="function">jsonb_path_match</code>関数）で必要であり、<code class="literal">@?</code>演算子（または<code class="function">jsonb_path_exists</code>関数）では使用すべきではありません。
      </p></div></div><div class="sect4" id="FUNCTIONS-SQLJSON-REGULAR-EXPRESSION-DEVIATION"><div class="titlepage"><div><div><h5 class="title">9.16.2.1.2. Regular Expression Interpretation <a href="#FUNCTIONS-SQLJSON-REGULAR-EXPRESSION-DEVIATION" class="id_link">#</a></h5></div></div></div><p>
<span class="original">
      There are minor differences in the interpretation of regular
      expression patterns used in &lt;literal&gt;like_regex&lt;/literal&gt; filters, as
      described in &lt;xref linkend="jsonpath-regular-expressions"/&gt;.
</span>
<a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.4. SQL/JSON正規表現">9.16.2.4</a>で述べるように、<code class="literal">like_regex</code>フィルターで使用される正規表現パターンの解釈には些細な違いがあります。
     </p></div></div><div class="sect3" id="FUNCTIONS-SQLJSON-STRICT-AND-LAX-MODES"><div class="titlepage"><div><div><h4 class="title">9.16.2.2. 厳密モードと非厳密モード <a href="#FUNCTIONS-SQLJSON-STRICT-AND-LAX-MODES" class="id_link">#</a></h4></div></div></div><span class="original">
   &lt;title&gt;Strict and Lax Modes&lt;/title&gt;
</span><p>
<span class="original">
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array is defined as a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
</span>
JSONデータを問い合わせる際、パス式は実際のJSONデータ構造に一致しないかも知れません。
存在しないオブジェクトのメンバあるいは配列要素へのアクセスは構造上のエラーとして定義されています。
SQL/JSONパス式には構造上のエラーを扱うための2つのモードがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
      lax (default) &amp;mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any structural errors that cannot be fixed as described below
      are suppressed, producing no match.
</span>
非厳密(lax)モード（デフォルト）— パスエンジンは指定したパスを問い合わせデータに暗黙的に適合させます。
以下に説明するように修正できない構造エラーは抑制され、一致は生成されません。
     </p></li><li class="listitem"><p>
<span class="original">
      strict &amp;mdash; if a structural error occurs, an error is raised.
</span>
厳密(strict)モード — 構造上のエラーがあるとエラーが発生します。
     </p></li></ul></div><p>
<span class="original">
    Lax mode facilitates matching of a JSON document and path
    expression when the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array, or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    the operation. Also, comparison operators automatically unwrap their
    operands in lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed when:
</span>
非厳密モードは、JSONデータが期待されるスキーマに沿わないときにJSON文書とパス式のマッチングを助けます。
あるオペランドが操作の要件に合わないときにはそれをSQL/JSON配列にまとめたり、あるいは操作を行う前にそれをSQL/JSONシーケンスに展開することもできます。
また非厳密モードにおいては、比較演算子は自動的にオペランドを展開し、SQL/JSON配列をそのまま比較することができます。
大きさ1の配列はその単独要素と同じものとして扱われます。
自動展開は以下の場合に行われません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       The path expression contains &lt;literal&gt;type()&lt;/literal&gt; or
       &lt;literal&gt;size()&lt;/literal&gt; methods that return the type
       and the number of elements in the array, respectively.
</span>
それぞれ配列の型、要素数を返す<code class="literal">type()</code>、<code class="literal">size()</code>をパス式が含む。
      </p></li><li class="listitem"><p>
<span class="original">
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
</span>
問い合わせ対象のJSONデータが入れ子の配列を含む。
この場合はもっとも外側の配列のみが展開され、内側の配列は変わりません。
ですから、それぞれの評価段階において1レベルのみに暗黙的な展開が行われます。
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using lax mode:
</span>
たとえば、上述のGPSデータに問い合わせする場合、非厳密モードでは配列のセグメントを含んでいるという事実から抽出できます。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'lax $.track.segments.location');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre><p>
   </p><p>
<span class="original">
    In strict mode, the specified path must exactly match the structure of
    the queried JSON document, so using this path
    expression will cause an error:
</span>
厳密モードでは、指定されたパスは問い合わせ対象のJSONドキュメントの構造と正確に一致する必要があるため、このパス式を使用するとエラーが発生します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'strict $.track.segments.location');</code></strong>
ERROR:  jsonpath member accessor can only be applied to an object
</pre><p>
<span class="original">
    To get the same result as in lax mode, you have to explicitly unwrap the
    &lt;literal&gt;segments&lt;/literal&gt; array:
</span>
非厳密モードと同じ結果を得るには、<code class="literal">segments</code>配列を明示的に展開する必要があります。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'strict $.track.segments[*].location');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
</pre><p>
   </p><p>
<span class="original">
    The unwrapping behavior of lax mode can lead to surprising results. For
    instance, the following query using the &lt;literal&gt;.**&lt;/literal&gt; accessor
    selects every &lt;literal&gt;HR&lt;/literal&gt; value twice:
</span>
非厳密モードの展開動作は、驚くべき結果をもたらす可能性があります。
たとえば、<code class="literal">.**</code>アクセサを使用する次の問い合わせは、すべての<code class="literal">HR</code>値を2回選択します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'lax $.**.HR');</code></strong>
 jsonb_path_query
------------------
 73
 135
 73
 135
</pre><p>
<span class="original">
    This happens because the &lt;literal&gt;.**&lt;/literal&gt; accessor selects both
    the &lt;literal&gt;segments&lt;/literal&gt; array and each of its elements, while
    the &lt;literal&gt;.HR&lt;/literal&gt; accessor automatically unwraps arrays when
    using lax mode. To avoid surprising results, we recommend using
    the &lt;literal&gt;.**&lt;/literal&gt; accessor only in strict mode. The
    following query selects each &lt;literal&gt;HR&lt;/literal&gt; value just once:
</span>
これは<code class="literal">.**</code>アクセサが<code class="literal">segments</code>とその各々の要素の両方を検索するからです。
一方、<code class="literal">.HR</code>アクセサは非厳密モードでは自動的に配列を展開します。
予期しない結果を避けるには、<code class="literal">.**</code>アクセサを厳密モードでのみ使うことをお勧めします。
次の問い合わせは<code class="literal">HR</code>の各値を一度だけ検索します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'strict $.**.HR');</code></strong>
 jsonb_path_query
------------------
 73
 135
</pre><p>
   </p><p>
<span class="original">
    The unwrapping of arrays can also lead to unexpected results. Consider this
    example, which selects all the &lt;literal&gt;location&lt;/literal&gt; arrays:
</span>
配列の展開は予期しない結果をもたらす可能性もあります。
<code class="literal">location</code>配列をすべて選択する次の例を考えてみましょう。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'lax $.track.segments[*].location');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
(2 rows)
</pre><p>
<span class="original">
    As expected it returns the full arrays. But applying a filter expression
    causes the arrays to be unwrapped to evaluate each item, returning only the
    items that match the expression:
</span>
予想どおり、配列全体が返されます。
しかし、フィルタ式を適用すると、配列が展開され、各項目が評価されて、式に一致する項目のみが返されます。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'lax $.track.segments[*].location ?(@[*] &gt; 15)');</code></strong>
 jsonb_path_query
------------------
 47.763
 47.706
(2 rows)
</pre><p>
<span class="original">
    This despite the fact that the full arrays are selected by the path
    expression. Use strict mode to restore selecting the arrays:
</span>
これは、完全な配列がpath式によって選択されるという事実にもかかわらずです。
厳密モードを使用して、配列の選択を復元します。
</p><pre class="screen">
<code class="prompt">=&gt;</code> <strong class="userinput"><code>select jsonb_path_query(:'json', 'strict $.track.segments[*].location ?(@[*] &gt; 15)');</code></strong>
 jsonb_path_query
-------------------
 [47.763, 13.4034]
 [47.706, 13.2635]
(2 rows)
</pre><p>
   </p></div><div class="sect3" id="FUNCTIONS-SQLJSON-PATH-OPERATORS"><div class="titlepage"><div><div><h4 class="title">9.16.2.3. SQL/JSONパス演算子とメソッド <a href="#FUNCTIONS-SQLJSON-PATH-OPERATORS" class="id_link">#</a></h4></div></div></div><span class="original">
   &lt;title&gt;SQL/JSON Path Operators and Methods&lt;/title&gt;
</span><p>
<span class="original">
    &lt;xref linkend="functions-sqljson-op-table"/&gt; shows the operators and
    methods available in &lt;type&gt;jsonpath&lt;/type&gt;.  Note that while the unary
    operators and methods can be applied to multiple values resulting from a
    preceding path step, the binary operators (addition etc.) can only be
    applied to single values.  In lax mode, methods applied to an array will be
    executed for each value in the array.  The exceptions are
    &lt;literal&gt;.type()&lt;/literal&gt; and &lt;literal&gt;.size()&lt;/literal&gt;, which apply to
    the array itself.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-OP-TABLE" title="表9.50 jsonpath演算子とメソッド">表 9.50</a>に<code class="type">jsonpath</code>で利用可能な演算子とメソッドを示します。
単項演算子とメソッドは以前のパスステップから生じた複数の値に適用できますが、二項演算子（加算など）は単一の値にしか適用できないことに注意してください。
非厳密モードでは、配列に適用されるメソッドは配列内の各値に対して実行されます。
例外は<code class="literal">.type()</code>と<code class="literal">.size()</code>で、配列自分自身に適用されます。
   </p><div class="table" id="FUNCTIONS-SQLJSON-OP-TABLE"><p class="title"><strong>表9.50 <code class="type">jsonpath</code>演算子とメソッド</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;&lt;type&gt;jsonpath&lt;/type&gt; Operators and Methods&lt;/title&gt;
</span><table class="table" summary="jsonpath演算子とメソッド" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Operator/Method
</span>
演算子/メソッド
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">+</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Addition
</span>
加算
       </p>
       <p>
        <code class="literal">jsonb_path_query('[2]', '$[0] + 3')</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">+</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Unary plus (no operation); unlike addition, this can iterate over
        multiple values
</span>
単項のプラス（演算なし）。加算と違って、複数の値に渡って適用できます。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '+ $.x')</code>
        → <code class="returnvalue">[2, 3, 4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">-</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Subtraction
</span>
減算
       </p>
       <p>
        <code class="literal">jsonb_path_query('[2]', '7 - $[0]')</code>
        → <code class="returnvalue">5</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">-</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Negation; unlike subtraction, this can iterate over
        multiple values
</span>
負符号。減算と違って、複数の値に渡って適用できます。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": [2,3,4]}', '- $.x')</code>
        → <code class="returnvalue">[-2, -3, -4]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">*</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Multiplication
</span>
乗算
       </p>
       <p>
        <code class="literal">jsonb_path_query('[4]', '2 * $[0]')</code>
        → <code class="returnvalue">8</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">/</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Division
</span>
除算
       </p>
       <p>
        <code class="literal">jsonb_path_query('[8.5]', '$[0] / 2')</code>
        → <code class="returnvalue">4.2500000000000000</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">%</code> <em class="replaceable"><code>number</code></em>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Modulo (remainder)
</span>
剰余（残り）
       </p>
       <p>
        <code class="literal">jsonb_path_query('[32]', '$[0] % 10')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">type()</code>
        → <code class="returnvalue"><em class="replaceable"><code>string</code></em></code>
       </p>
       <p>
<span class="original">
        Type of the JSON item (see &lt;function&gt;json_typeof&lt;/function&gt;)
</span>
JSON項目の型（<code class="function">json_typeof</code>を参照）
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "2", {}]', '$[*].type()')</code>
        → <code class="returnvalue">["number", "string", "object"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">size()</code>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Size of the JSON item (number of array elements, or 1 if not an
        array)
</span>
JSON項目の大きさ（配列の要素数。配列でなければ1）
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"m": [11, 15]}', '$.m.size()')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">boolean()</code>
        → <code class="returnvalue"><em class="replaceable"><code>boolean</code></em></code>
       </p>
       <p>
<span class="original">
        Boolean value converted from a JSON boolean, number, or string
</span>
JSONのブール値、数値、または文字列から変換されたブール値。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "yes", false]', '$[*].boolean()')</code>
        → <code class="returnvalue">[true, true, false]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">string()</code>
        → <code class="returnvalue"><em class="replaceable"><code>string</code></em></code>
       </p>
       <p>
<span class="original">
        String value converted from a JSON boolean, number, string, or
        datetime
</span>
JSONのブール値、数値、文字列、または日時から変換された文字列値。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1.23, "xyz", false]', '$[*].string()')</code>
        → <code class="returnvalue">["1.23", "xyz", "false"]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15 12:34:56"', '$.timestamp().string()')</code>
        → <code class="returnvalue">"2023-08-15T12:34:56"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">double()</code>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Approximate floating-point number converted from a JSON number or
        string
</span>
JSON数値あるいは文字列から変換した概算の浮動小数点数
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"len": "1.9"}', '$.len.double() * 2')</code>
        → <code class="returnvalue">3.8</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">.</code> <code class="literal">ceiling()</code>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Nearest integer greater than or equal to the given number
</span>
引数より大きいか等しく、与えられた数に最も近い整数
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"h": 1.3}', '$.h.ceiling()')</code>
        → <code class="returnvalue">2</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">.</code> <code class="literal">floor()</code>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Nearest integer less than or equal to the given number
</span>
引数より小さいか等しく、与えられた数に最も近い整数
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"h": 1.7}', '$.h.floor()')</code>
        → <code class="returnvalue">1</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>number</code></em> <code class="literal">.</code> <code class="literal">abs()</code>
        → <code class="returnvalue"><em class="replaceable"><code>number</code></em></code>
       </p>
       <p>
<span class="original">
        Absolute value of the given number
</span>
与えられた数の絶対値
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"z": -0.3}', '$.z.abs()')</code>
        → <code class="returnvalue">0.3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">bigint()</code>
        → <code class="returnvalue"><em class="replaceable"><code>bigint</code></em></code>
       </p>
       <p>
<span class="original">
        Big integer value converted from a JSON number or string
</span>
JSONの数値または文字列から変換された大きな整数値。
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"len": "9876543219"}', '$.len.bigint()')</code>
        → <code class="returnvalue">9876543219</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">decimal( [ <em class="replaceable"><code>precision</code></em> [ , <em class="replaceable"><code>scale</code></em> ] ] )</code>
        → <code class="returnvalue"><em class="replaceable"><code>decimal</code></em></code>
       </p>
       <p>
<span class="original">
        Rounded decimal value converted from a JSON number or string
        (&lt;literal&gt;precision&lt;/literal&gt; and &lt;literal&gt;scale&lt;/literal&gt; must be
        integer values)
</span>
JSONの数値または文字列から変換された丸められた10進数値（<code class="literal">精度</code>および<code class="literal">位取り</code>は整数値である必要があります）。
       </p>
       <p>
        <code class="literal">jsonb_path_query('1234.5678', '$.decimal(6, 2)')</code>
        → <code class="returnvalue">1234.57</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">integer()</code>
        → <code class="returnvalue"><em class="replaceable"><code>integer</code></em></code>
       </p>
       <p>
<span class="original">
        Integer value converted from a JSON number or string
</span>
JSONの数値または文字列から変換された整数値。
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"len": "12345"}', '$.len.integer()')</code>
        → <code class="returnvalue">12345</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">.</code> <code class="literal">number()</code>
        → <code class="returnvalue"><em class="replaceable"><code>numeric</code></em></code>
       </p>
       <p>
<span class="original">
        Numeric value converted from a JSON number or string
</span>
JSONの数値または文字列から変換されたNumeric値。
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"len": "123.45"}', '$.len.number()')</code>
        → <code class="returnvalue">123.45</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">datetime()</code>
        → <code class="returnvalue"><em class="replaceable"><code>datetime_type</code></em></code>
        (see note)
       </p>
       <p>
<span class="original">
        Date/time value converted from a string
</span>
文字列から変換した日時値
       </p>
       <p>
        <code class="literal">jsonb_path_query('["2015-8-1", "2015-08-12"]', '$[*] ? (@.datetime() &lt; "2015-08-2".datetime())')</code>
        → <code class="returnvalue">"2015-8-1"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">datetime(<em class="replaceable"><code>template</code></em>)</code>
        → <code class="returnvalue"><em class="replaceable"><code>datetime_type</code></em></code>
        (see note)
       </p>
       <p>
<span class="original">
        Date/time value converted from a string using the
        specified &lt;function&gt;to_timestamp&lt;/function&gt; template
</span>
指定の<code class="function">to_timestamp</code>テンプレートを使って文字列から変換した日時値
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["12:30", "18:40"]', '$[*].datetime("HH24:MI")')</code>
        → <code class="returnvalue">["12:30:00", "18:40:00"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">date()</code>
        → <code class="returnvalue"><em class="replaceable"><code>date</code></em></code>
       </p>
       <p>
<span class="original">
        Date value converted from a string
</span>
文字列から変換された日付値。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15"', '$.date()')</code>
        → <code class="returnvalue">"2023-08-15"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">time()</code>
        → <code class="returnvalue"><em class="replaceable"><code>time without time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Time without time zone value converted from a string
</span>
文字列から変換した時間帯のない時刻値
       </p>
       <p>
        <code class="literal">jsonb_path_query('"12:34:56"', '$.time()')</code>
        → <code class="returnvalue">"12:34:56"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">time(<em class="replaceable"><code>precision</code></em>)</code>
        → <code class="returnvalue"><em class="replaceable"><code>time without time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Time without time zone value converted from a string, with fractional
        seconds adjusted to the given precision
</span>
文字列から変換された時間帯のない時間の値。分数の秒は指定された精度に調整されます。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"12:34:56.789"', '$.time(2)')</code>
        → <code class="returnvalue">"12:34:56.79"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">time_tz()</code>
        → <code class="returnvalue"><em class="replaceable"><code>time with time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Time with time zone value converted from a string
</span>
文字列から変換されたタイムゾーン値を持つ時間。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"12:34:56 +05:30"', '$.time_tz()')</code>
        → <code class="returnvalue">"12:34:56+05:30"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">time_tz(<em class="replaceable"><code>precision</code></em>)</code>
        → <code class="returnvalue"><em class="replaceable"><code>time with time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Time with time zone value converted from a string, with fractional
        seconds adjusted to the given precision
</span>
文字列から変換された時間帯を持つ時間。分数の秒は指定された精度に調整されます。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"12:34:56.789 +05:30"', '$.time_tz(2)')</code>
        → <code class="returnvalue">"12:34:56.79+05:30"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">timestamp()</code>
        → <code class="returnvalue"><em class="replaceable"><code>timestamp without time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Timestamp without time zone value converted from a string
</span>
文字列から変換された時間帯なしのタイムスタンプ
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15 12:34:56"', '$.timestamp()')</code>
        → <code class="returnvalue">"2023-08-15T12:34:56"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">timestamp(<em class="replaceable"><code>precision</code></em>)</code>
        → <code class="returnvalue"><em class="replaceable"><code>timestamp without time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Timestamp without time zone value converted from a string, with
        fractional seconds adjusted to the given precision
</span>
文字列から変換された時間帯なしのタイムスタンプ値。分数の秒数は指定された精度に調整されます。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15 12:34:56.789"', '$.timestamp(2)')</code>
        → <code class="returnvalue">"2023-08-15T12:34:56.79"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">timestamp_tz()</code>
        → <code class="returnvalue"><em class="replaceable"><code>timestamp with time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Timestamp with time zone value converted from a string
</span>
文字列から変換された時間帯を持つタイムスタンプ。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15 12:34:56 +05:30"', '$.timestamp_tz()')</code>
        → <code class="returnvalue">"2023-08-15T12:34:56+05:30"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">.</code> <code class="literal">timestamp_tz(<em class="replaceable"><code>precision</code></em>)</code>
        → <code class="returnvalue"><em class="replaceable"><code>timestamp with time zone</code></em></code>
       </p>
       <p>
<span class="original">
        Timestamp with time zone value converted from a string, with fractional
        seconds adjusted to the given precision
</span>
文字列から変換された時間帯を持つタイムスタンプ値。分数の秒数は指定された精度に調整されます。
       </p>
       <p>
        <code class="literal">jsonb_path_query('"2023-08-15 12:34:56.789 +05:30"', '$.timestamp_tz(2)')</code>
        → <code class="returnvalue">"2023-08-15T12:34:56.79+05:30"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>object</code></em> <code class="literal">.</code> <code class="literal">keyvalue()</code>
        → <code class="returnvalue"><em class="replaceable"><code>array</code></em></code>
       </p>
       <p>
<span class="original">
        The object's key-value pairs, represented as an array of objects
        containing three fields: &lt;literal&gt;"key"&lt;/literal&gt;,
        &lt;literal&gt;"value"&lt;/literal&gt;, and &lt;literal&gt;"id"&lt;/literal&gt;;
        &lt;literal&gt;"id"&lt;/literal&gt; is a unique identifier of the object the
        key-value pair belongs to
</span>
以下の3つのフィールドを含むオブジェクトの配列で表現したオブジェクトのキー/値ペア。
<code class="literal">"key"</code>、<code class="literal">"value"</code>、<code class="literal">"id"</code>。
<code class="literal">"id"</code>はキー/値ペアが属するオブジェクトのユニーク識別子です。
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"x": "20", "y": 32}', '$.keyvalue()')</code>
        → <code class="returnvalue">[{"id": 0, "key": "x", "value": "20"}, {"id": 0, "key": "y", "value": 32}]</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
      The result type of the &lt;literal&gt;datetime()&lt;/literal&gt; and
      &lt;literal&gt;datetime(&lt;replaceable&gt;template&lt;/replaceable&gt;)&lt;/literal&gt;
      methods can be &lt;type&gt;date&lt;/type&gt;, &lt;type&gt;timetz&lt;/type&gt;, &lt;type&gt;time&lt;/type&gt;,
      &lt;type&gt;timestamptz&lt;/type&gt;, or &lt;type&gt;timestamp&lt;/type&gt;.
      Both methods determine their result type dynamically.
</span>
<code class="literal">datetime()</code>と<code class="literal">datetime(<em class="replaceable"><code>template</code></em>)</code>の結果型は<code class="type">date</code>、<code class="type">timetz</code>、<code class="type">time</code>、<code class="type">timestamptz</code>、あるいは<code class="type">timestamp</code>です。
両方のメソッドは結果型を動的に決定します。
     </p><p>
<span class="original">
      The &lt;literal&gt;datetime()&lt;/literal&gt; method sequentially tries to
      match its input string to the ISO formats
      for &lt;type&gt;date&lt;/type&gt;, &lt;type&gt;timetz&lt;/type&gt;, &lt;type&gt;time&lt;/type&gt;,
      &lt;type&gt;timestamptz&lt;/type&gt;, and &lt;type&gt;timestamp&lt;/type&gt;. It stops on
      the first matching format and emits the corresponding data type.
</span>
<code class="literal">datetime()</code>メソッドは入力文字列を<code class="type">date</code>、<code class="type">timetz</code>、<code class="type">time</code>、<code class="type">timestamptz</code>、<code class="type">timestamp</code>のISO形式に対して順にマッチを試みます。
最初にマッチした形式で停止し、関連するデータ型を出力します。
     </p><p>
<span class="original">
      The &lt;literal&gt;datetime(&lt;replaceable&gt;template&lt;/replaceable&gt;)&lt;/literal&gt;
      method determines the result type according to the fields used in the
      provided template string.
</span>
<code class="literal">datetime(<em class="replaceable"><code>template</code></em>)</code>メソッドは与えられたテンプレート文字列にあるフィールドに従って結果型を決定します。
     </p><p>
<span class="original">
      The &lt;literal&gt;datetime()&lt;/literal&gt; and
      &lt;literal&gt;datetime(&lt;replaceable&gt;template&lt;/replaceable&gt;)&lt;/literal&gt; methods
      use the same parsing rules as the &lt;literal&gt;to_timestamp&lt;/literal&gt; SQL
      function does (see &lt;xref linkend="functions-formatting"/&gt;), with three
      exceptions.  First, these methods don't allow unmatched template
      patterns.  Second, only the following separators are allowed in the
      template string: minus sign, period, solidus (slash), comma, apostrophe,
      semicolon, colon and space.  Third, separators in the template string
      must exactly match the input string.
</span>
<code class="literal">datetime()</code>と<code class="literal">datetime(<em class="replaceable"><code>template</code></em>)</code>は<code class="literal">to_timestamp</code>SQL関数と同じ解析ルール(参照<a class="xref" href="functions-formatting.html" title="9.8. データ型書式設定関数">9.8</a>)を用いますが、3つの例外があります。
一番目に、これらのメソッドは一致しないテンプレートパターンを許容しません。二番目に次の区切り文字のみを許容します。負符号、ピリオド、斜線（スラッシュ）、カンマ、アポストロフィー、セミコロン、コロン、空白、です。
三番目にテンプレート文字列中の区切り文字は正確に入力文字列と一致しなければなりません。
     </p><p>
<span class="original">
      If different date/time types need to be compared, an implicit cast is
      applied. A &lt;type&gt;date&lt;/type&gt; value can be cast to &lt;type&gt;timestamp&lt;/type&gt;
      or &lt;type&gt;timestamptz&lt;/type&gt;, &lt;type&gt;timestamp&lt;/type&gt; can be cast to
      &lt;type&gt;timestamptz&lt;/type&gt;, and &lt;type&gt;time&lt;/type&gt; to &lt;type&gt;timetz&lt;/type&gt;.
      However, all but the first of these conversions depend on the current
      &lt;xref linkend="guc-timezone"/&gt; setting, and thus can only be performed
      within timezone-aware &lt;type&gt;jsonpath&lt;/type&gt; functions.  Similarly, other
      date/time-related methods that convert strings to date/time types
      also do this casting, which may involve the current
      &lt;xref linkend="guc-timezone"/&gt; setting. Therefore, these conversions can
      also only be performed within timezone-aware &lt;type&gt;jsonpath&lt;/type&gt;
      functions.
</span>
異なる日時型の比較が必要なら、暗黙的なキャストが適用されます。
<code class="type">date</code>値は<code class="type">timestamp</code>あるいは<code class="type">timestamptz</code>にキャストできます。
<code class="type">timestamp</code>は<code class="type">timestamptz</code>に、<code class="type">time</code>は<code class="type">timetz</code>にキャストできます。
しかし、これらの変換は最初のものを除くすべてが現在の<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>設定に依存します。ですから時間帯を認識する<code class="type">jsonpath</code>関数中でのみ実行可能です。
同様に、文字列を日付/時刻型に変換する他の日付/時刻関連のメソッドも、現在の<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>設定を含む可能性があるこのキャストを行います。
したがって、これらの変換は、timezoneを意識した<code class="type">jsonpath</code>関数内でのみ実行できます。
     </p></div><p>
<span class="original">
    &lt;xref linkend="functions-sqljson-filter-ex-table"/&gt; shows the available
    filter expression elements.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="表9.51 jsonpathフィルター式要素">表 9.51</a>に利用可能なフィルタ式要素を示します。
   </p><div class="table" id="FUNCTIONS-SQLJSON-FILTER-EX-TABLE"><p class="title"><strong>表9.51 <code class="type">jsonpath</code>フィルター式要素</strong></p><div class="table-contents"><span class="original">
    &lt;title&gt;&lt;type&gt;jsonpath&lt;/type&gt; Filter Expression Elements&lt;/title&gt;
</span><table class="table" summary="jsonpathフィルター式要素" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Predicate/Value
</span>
述語/値
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
       </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">==</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Equality comparison (this, and the other comparison operators, work on
        all JSON scalar values)
</span>
等値比較（これと他の比較演算子はすべてのJSONスカラー値で使えます）
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == 1)')</code>
        → <code class="returnvalue">[1, 1]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, "a", 1, 3]', '$[*] ? (@ == "a")')</code>
        → <code class="returnvalue">["a"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">!=</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">&lt;&gt;</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Non-equality comparison
</span>
非等値比較
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 1, 3]', '$[*] ? (@ != 1)')</code>
        → <code class="returnvalue">[2, 3]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;&gt; "b")')</code>
        → <code class="returnvalue">["a", "c"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Less-than comparison
</span>
未満比較
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &lt; 2)')</code>
        → <code class="returnvalue">[1]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Less-than-or-equal-to comparison
</span>
以下比較
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["a", "b", "c"]', '$[*] ? (@ &lt;= "b")')</code>
        → <code class="returnvalue">["a", "b"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Greater-than comparison
</span>
より大きい比較
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt; 2)')</code>
        → <code class="returnvalue">[3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>value</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>value</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Greater-than-or-equal-to comparison
</span>
以上比較
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('[1, 2, 3]', '$[*] ? (@ &gt;= 2)')</code>
        → <code class="returnvalue">[2, 3]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">true</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        JSON constant &lt;literal&gt;true&lt;/literal&gt;
</span>
JSON定数<code class="literal">真</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == true)')</code>
        → <code class="returnvalue">{"name": "Chris", "parent": true}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">false</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        JSON constant &lt;literal&gt;false&lt;/literal&gt;
</span>
JSON定数<code class="literal">偽</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "John", "parent": false}, {"name": "Chris", "parent": true}]', '$[*] ? (@.parent == false)')</code>
        → <code class="returnvalue">{"name": "John", "parent": false}</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">null</code>
        → <code class="returnvalue"><em class="replaceable"><code>value</code></em></code>
       </p>
       <p>
<span class="original">
        JSON constant &lt;literal&gt;null&lt;/literal&gt; (note that, unlike in SQL,
        comparison to &lt;literal&gt;null&lt;/literal&gt; works normally)
</span>
JSON定数<code class="literal">null</code>（SQLとは違って<code class="literal">null</code>との比較は通常通り動作することに注意してください。）
       </p>
       <p>
        <code class="literal">jsonb_path_query('[{"name": "Mary", "job": null}, {"name": "Michael", "job": "driver"}]', '$[*] ? (@.job == null) .name')</code>
        → <code class="returnvalue">"Mary"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>boolean</code></em> <code class="literal">&amp;&amp;</code> <em class="replaceable"><code>boolean</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Boolean AND
</span>
論理AND
       </p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)')</code>
        → <code class="returnvalue">3</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>boolean</code></em> <code class="literal">||</code> <em class="replaceable"><code>boolean</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Boolean OR
</span>
論理OR
       </p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (@ &lt; 1 || @ &gt; 5)')</code>
        → <code class="returnvalue">7</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">!</code> <em class="replaceable"><code>boolean</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Boolean NOT
</span>
論理NOT
       </p>
       <p>
        <code class="literal">jsonb_path_query('[1, 3, 7]', '$[*] ? (!(@ &lt; 5))')</code>
        → <code class="returnvalue">7</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>boolean</code></em> <code class="literal">is unknown</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Tests whether a Boolean condition is &lt;literal&gt;unknown&lt;/literal&gt;.
</span>
論理条件が<code class="literal">unknown</code>であるかどうかを検査します。
       </p>
       <p>
        <code class="literal">jsonb_path_query('[-1, 2, 7, "foo"]', '$[*] ? ((@ &gt; 0) is unknown)')</code>
        → <code class="returnvalue">"foo"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">like_regex</code> <em class="replaceable"><code>string</code></em> [<span class="optional"> <code class="literal">flag</code> <em class="replaceable"><code>string</code></em> </span>]
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Tests whether the first operand matches the regular expression
        given by the second operand, optionally with modifications
        described by a string of &lt;literal&gt;flag&lt;/literal&gt; characters (see
        &lt;xref linkend="jsonpath-regular-expressions"/&gt;).
</span>
最初のオペランドが2番目のオペランドで与えられる正規表現にマッチするかどうか検査します。
オプションで<code class="literal">flag</code>文字列で記述される変更を伴います。（<a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.16.2.4. SQL/JSON正規表現">9.16.2.4</a>を参照してください。）
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c")')</code>
        → <code class="returnvalue">["abc", "abdacb"]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('["abc", "abd", "aBdC", "abdacb", "babc"]', '$[*] ? (@ like_regex "^ab.*c" flag "i")')</code>
        → <code class="returnvalue">["abc", "aBdC", "abdacb"]</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <em class="replaceable"><code>string</code></em> <code class="literal">starts with</code> <em class="replaceable"><code>string</code></em>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Tests whether the second operand is an initial substring of the first
        operand.
</span>
2番目の文字列が1番目のオペランドの最初の部分文字列かどうかを検査します。
       </p>
       <p>
        <code class="literal">jsonb_path_query('["John Smith", "Mary Stone", "Bob Johnson"]', '$[*] ? (@ starts with "John")')</code>
        → <code class="returnvalue">"John Smith"</code>
       </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <code class="literal">exists</code> <code class="literal">(</code> <em class="replaceable"><code>path_expression</code></em> <code class="literal">)</code>
        → <code class="returnvalue">boolean</code>
       </p>
       <p>
<span class="original">
        Tests whether a path expression matches at least one SQL/JSON item.
        Returns &lt;literal&gt;unknown&lt;/literal&gt; if the path expression would result
        in an error; the second example uses this to avoid a no-such-key error
        in strict mode.
</span>
パス式が少なくとも一つのSQL/JSON項目とマッチするかどうかを検査します。
パス式がエラーとなる場合は<code class="literal">unknown</code>を返します。2番目の例は厳密モードでキーが存在しないエラーを回避するためにこれを使っています。
       </p>
       <p>
        <code class="literal">jsonb_path_query('{"x": [1, 2], "y": [2, 4]}', 'strict $.* ? (exists (@ ? (@[*] &gt; 2)))')</code>
        → <code class="returnvalue">[2, 4]</code>
       </p>
       <p>
        <code class="literal">jsonb_path_query_array('{"value": 41}', 'strict $ ? (exists (@.name)) .name')</code>
        → <code class="returnvalue">[]</code>
       </p></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3" id="JSONPATH-REGULAR-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.16.2.4. SQL/JSON正規表現 <a href="#JSONPATH-REGULAR-EXPRESSIONS" class="id_link">#</a></h4></div></div></div><span class="original">
    &lt;title&gt;SQL/JSON Regular Expressions&lt;/title&gt;
</span><a id="id-1.5.8.24.11.24.2" class="indexterm"></a><a id="id-1.5.8.24.11.24.3" class="indexterm"></a><p>
<span class="original">
     SQL/JSON path expressions allow matching text to a regular expression
     with the &lt;literal&gt;like_regex&lt;/literal&gt; filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
</span>
SQL/JSONパス式では<code class="literal">like_regex</code>フィルタを使ってテキストを正規表現にマッチさせることができます。
たとえば、次のSQL/JSONパス式問い合わせは、英語の母音で始まる配列内のすべての文字列に大文字小文字を無視してマッチするでしょう。
</p><pre class="programlisting">
$[*] ? (@ like_regex "^[aeiou]" flag "i")
</pre><p>
    </p><p>
<span class="original">
     The optional &lt;literal&gt;flag&lt;/literal&gt; string may include one or more of
     the characters
     &lt;literal&gt;i&lt;/literal&gt; for case-insensitive match,
     &lt;literal&gt;m&lt;/literal&gt; to allow &lt;literal&gt;^&lt;/literal&gt;
     and &lt;literal&gt;$&lt;/literal&gt; to match at newlines,
     &lt;literal&gt;s&lt;/literal&gt; to allow &lt;literal&gt;.&lt;/literal&gt; to match a newline,
     and &lt;literal&gt;q&lt;/literal&gt; to quote the whole pattern (reducing the
     behavior to a simple substring match).
</span>
オプションの<code class="literal">flag</code>文字列は一つ以上の文字を含むことができます。
<code class="literal">i</code>は大文字小文字を無視したマッチ、<code class="literal">m</code>は<code class="literal">^</code>と<code class="literal">$</code>で改行にマッチ、<code class="literal">s</code>は<code class="literal">.</code>が改行にマッチ、<code class="literal">q</code>はパターン全体を参照します。（振る舞いを単純な部分文字列マッチとします）
    </p><p>
<span class="original">
     The SQL/JSON standard borrows its definition for regular expressions
     from the &lt;literal&gt;LIKE_REGEX&lt;/literal&gt; operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     &lt;literal&gt;LIKE_REGEX&lt;/literal&gt; operator.  Therefore,
     the &lt;literal&gt;like_regex&lt;/literal&gt; filter is implemented using the
     POSIX regular expression engine described in
     &lt;xref linkend="functions-posix-regexp"/&gt;.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     &lt;xref linkend="posix-vs-xquery"/&gt;.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
</span>
SQL/JSON標準は正規表現の定義を、XQuery標準を使用する<code class="literal">LIKE_REGEX</code>演算子から借りています。
PostgreSQLは今の所<code class="literal">LIKE_REGEX</code>演算子をサポートしていません。
ですから、<code class="literal">like_regex</code>フィルタは<a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. POSIX正規表現">9.7.3</a>で説明されているPOSIX正規表現で実装されています。
このことにより、<a class="xref" href="functions-matching.html#POSIX-VS-XQUERY" title="9.7.3.8. 標準SQLおよびXQueryとの違い">9.7.3.8</a>で列挙されているSQL/JSON標準の振る舞いとの小さな違いが生じます。
しかし、ここで述べているフラグ文字の非互換性はSQL/JSONには適用されないことに注意してください。SQL/JSONは、XQueryのフラグ文字をPOSIXエンジンが期待するのと一致するように解釈するからです。
    </p><p>
<span class="original">
     Keep in mind that the pattern argument of &lt;literal&gt;like_regex&lt;/literal&gt;
     is a JSON path string literal, written according to the rules given in
     &lt;xref linkend="datatype-jsonpath"/&gt;.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match string values of the root document that contain
     only digits:
</span>
<code class="literal">like_regex</code>のパターン引数は<a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.7. jsonpath型">8.14.7</a>で説明されているルールにしたがって書かれたJSONパス文字列リテラルであることに注意してください。
これは、正規表現で使用するすべてのバックスラッシュを二重に書かなければならないことを意味します。
たとえば、数字のみを含むroot文書の文字列値にマッチさせるには以下のようにします。
</p><pre class="programlisting">
$.* ? (@ like_regex "^\\d+$")
</pre><p>
    </p></div></div><div class="sect2" id="SQLJSON-QUERY-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">9.16.3. SQL/JSON問い合わせ関数 <a href="#SQLJSON-QUERY-FUNCTIONS" class="id_link">#</a></h3></div></div></div><span class="original">
    &lt;title&gt;SQL/JSON Query Functions&lt;/title&gt;
</span><p>
<span class="original">
   SQL/JSON functions &lt;literal&gt;JSON_EXISTS()&lt;/literal&gt;,
   &lt;literal&gt;JSON_QUERY()&lt;/literal&gt;, and &lt;literal&gt;JSON_VALUE()&lt;/literal&gt;
   described in &lt;xref linkend="functions-sqljson-querying"/&gt; can be used
   to query JSON documents.  Each of these functions apply a
   &lt;replaceable&gt;path_expression&lt;/replaceable&gt; (an SQL/JSON path query) to a
   &lt;replaceable&gt;context_item&lt;/replaceable&gt; (the document).  See
   &lt;xref linkend="functions-sqljson-path"/&gt; for more details on what
   the &lt;replaceable&gt;path_expression&lt;/replaceable&gt; can contain. The
   &lt;replaceable&gt;path_expression&lt;/replaceable&gt; can also reference variables,
   whose values are specified with their respective names in the
   &lt;literal&gt;PASSING&lt;/literal&gt; clause that is supported by each function.
   &lt;replaceable&gt;context_item&lt;/replaceable&gt; can be a &lt;type&gt;jsonb&lt;/type&gt; value
   or a character string that can be successfully cast to &lt;type&gt;jsonb&lt;/type&gt;.
</span>
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-QUERYING" title="表9.52 SQL/JSON問い合わせ関数">表 9.52</a>で記述されたSQL/JSON関数<code class="literal">JSON_EXISTS()</code>、<code class="literal">JSON_QUERY()</code>、<code class="literal">JSON_VALUE()</code>は、JSON文書への問い合わせに使用できます。
これらの各関数は、<em class="replaceable"><code>path_expression</code></em>（SQL/JSONパス問い合わせ）を<em class="replaceable"><code>context_item</code></em>（文書）に適用します。
<em class="replaceable"><code>path_expression</code></em>の内容の詳細については、<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH" title="9.16.2. SQL/JSONパス言語">9.16.2</a>を参照してください。
<em class="replaceable"><code>path_expression</code></em>はリファレンス変数にすることもできます。その値は、各関数でサポートされている<code class="literal">PASSING</code>句でそれぞれの名前で指定されます。
<em class="replaceable"><code>context_item</code></em>には、<code class="type">jsonb</code>の値、または文字の並びにキャストできる<code class="type">jsonb</code>を指定できます。
  </p><div class="table" id="FUNCTIONS-SQLJSON-QUERYING"><p class="title"><strong>表9.52 SQL/JSON問い合わせ関数</strong></p><div class="table-contents"><span class="original">
   &lt;title&gt;SQL/JSON Query Functions&lt;/title&gt;
</span><table class="table" summary="SQL/JSON問い合わせ関数" border="1"><colgroup><col /></colgroup><thead><tr><th class="func_table_entry"><p class="func_signature">
<span class="original">
        Function signature
</span>
関数の呼び出し形式
       </p>
       <p>
<span class="original">
        Description
</span>
説明
       </p>
       <p>
<span class="original">
        Example(s)
</span>
例
      </p></th></tr></thead><tbody><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.12.3.2.2.1.1.1.1" class="indexterm"></a>
</p><pre class="synopsis">
<code class="function">JSON_EXISTS</code> (
<em class="replaceable"><code>context_item</code></em>, <em class="replaceable"><code>path_expression</code></em>
[<span class="optional"> <code class="literal">PASSING</code> { <em class="replaceable"><code>value</code></em> <code class="literal">AS</code> <em class="replaceable"><code>varname</code></em> } [<span class="optional">, ...</span>]</span>]
[<span class="optional">{ <code class="literal">TRUE</code> | <code class="literal">FALSE</code> |<code class="literal"> UNKNOWN</code> | <code class="literal">ERROR</code> } <code class="literal">ON ERROR</code> </span>]) → <code class="returnvalue">boolean</code>
</pre><p class="func_signature">
       </p>
     <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
        Returns true if the SQL/JSON &lt;replaceable&gt;path_expression&lt;/replaceable&gt;
        applied to the &lt;replaceable&gt;context_item&lt;/replaceable&gt; yields any
        items, false otherwise.
</span>
<em class="replaceable"><code>context_item</code></em>に適用されたSQL/JSON <em class="replaceable"><code>path_expression</code></em>が項目を生成する場合は真を返し、それ以外の場合は偽を返します。
       </p></li><li class="listitem"><p>
<span class="original">
        The &lt;literal&gt;ON ERROR&lt;/literal&gt; clause specifies the behavior if
        an error occurs during &lt;replaceable&gt;path_expression&lt;/replaceable&gt;
        evaluation.  Specifying &lt;literal&gt;ERROR&lt;/literal&gt; will cause an error to
        be thrown with the appropriate message.  Other options include
        returning &lt;type&gt;boolean&lt;/type&gt; values &lt;literal&gt;FALSE&lt;/literal&gt; or
        &lt;literal&gt;TRUE&lt;/literal&gt; or the value &lt;literal&gt;UNKNOWN&lt;/literal&gt; which
        is actually an SQL NULL. The default when no &lt;literal&gt;ON ERROR&lt;/literal&gt;
        clause is specified is to return the &lt;type&gt;boolean&lt;/type&gt; value
        &lt;literal&gt;FALSE&lt;/literal&gt;.
</span>
<code class="literal">ON ERROR</code>句は、<em class="replaceable"><code>path_expression</code></em>の評価中にエラーが発生した場合の動作を指定します。
<code class="literal">ERROR</code>を指定すると、適切なメッセージとともにエラーを引き起こします。
他のオプションには<code class="type">boolean</code>値である<code class="literal">FALSE</code>または<code class="literal">TRUE</code>、あるいは実際にはSQL NULLである<code class="literal">UNKNOWN</code>の値を返すものがあります。
<code class="literal">ON ERROR</code>句が指定されていない場合のデフォルトでは、<code class="type">boolean</code>値の<code class="literal">FALSE</code>を返します。
       </p></li></ul></div>
       <p>
<span class="original">
        Examples:
</span>
例：
       </p>
       <p>
        <code class="literal">JSON_EXISTS(jsonb '{"key1": [1,2,3]}', 'strict $.key1[*] ? (@ &gt; $x)' PASSING 2 AS x)</code>
        → <code class="returnvalue">t</code>
       </p>
       <p>
        <code class="literal">JSON_EXISTS(jsonb '{"a": [1,2,3]}', 'lax $.a[5]' ERROR ON ERROR)</code>
        → <code class="returnvalue">f</code>
       </p>
       <p>
        <code class="literal">JSON_EXISTS(jsonb '{"a": [1,2,3]}', 'strict $.a[5]' ERROR ON ERROR)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
ERROR:  jsonpath array subscript is out of bounds
</pre><p>
      </p></td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.12.3.2.2.2.1.1.1" class="indexterm"></a>
</p><pre class="synopsis">
<code class="function">JSON_QUERY</code> (
<em class="replaceable"><code>context_item</code></em>, <em class="replaceable"><code>path_expression</code></em>
[<span class="optional"> <code class="literal">PASSING</code> { <em class="replaceable"><code>value</code></em> <code class="literal">AS</code> <em class="replaceable"><code>varname</code></em> } [<span class="optional">, ...</span>]</span>]
[<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> [<span class="optional"> <code class="literal">FORMAT JSON</code> [<span class="optional"> <code class="literal">ENCODING UTF8</code> </span>] </span>] </span>]
[<span class="optional"> { <code class="literal">WITHOUT</code> | <code class="literal">WITH</code> { <code class="literal">CONDITIONAL</code> | [<span class="optional"><code class="literal">UNCONDITIONAL</code></span>] } } [<span class="optional"> <code class="literal">ARRAY</code> </span>] <code class="literal">WRAPPER</code> </span>]
[<span class="optional"> { <code class="literal">KEEP</code> | <code class="literal">OMIT</code> } <code class="literal">QUOTES</code> [<span class="optional"> <code class="literal">ON SCALAR STRING</code> </span>] </span>]
[<span class="optional"> { <code class="literal">ERROR</code> | <code class="literal">NULL</code> | <code class="literal">EMPTY</code> { [<span class="optional"> <code class="literal">ARRAY</code> </span>] | <code class="literal">OBJECT</code> } | <code class="literal">DEFAULT</code> <em class="replaceable"><code>expression</code></em> } <code class="literal">ON EMPTY</code> </span>]
[<span class="optional"> { <code class="literal">ERROR</code> | <code class="literal">NULL</code> | <code class="literal">EMPTY</code> { [<span class="optional"> <code class="literal">ARRAY</code> </span>] | <code class="literal">OBJECT</code> } | <code class="literal">DEFAULT</code> <em class="replaceable"><code>expression</code></em> } <code class="literal">ON ERROR</code> </span>]) → <code class="returnvalue">jsonb</code>
</pre><p class="func_signature">
      </p>
     <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
        Returns the result of applying the SQL/JSON
        &lt;replaceable&gt;path_expression&lt;/replaceable&gt; to the
        &lt;replaceable&gt;context_item&lt;/replaceable&gt;.
</span>
SQL/JSON<em class="replaceable"><code>path_expression</code></em>を<em class="replaceable"><code>context_item</code></em>に適用した結果を返します。
       </p></li><li class="listitem"><p>
<span class="original">
         By default, the result is returned as a value of type &lt;type&gt;jsonb&lt;/type&gt;,
         though the &lt;literal&gt;RETURNING&lt;/literal&gt; clause can be used to return
         as some other type to which it can be successfully coerced.
</span>
デフォルトでは、結果は<code class="type">jsonb</code>型の値として返されますが、<code class="literal">RETURNING</code>句を使って、結果が正常に強制される他の型を返すことができます。
       </p></li><li class="listitem"><p>
<span class="original">
        If the path expression may return multiple values, it might be necessary
        to wrap those values using the &lt;literal&gt;WITH WRAPPER&lt;/literal&gt; clause to
        make it a valid JSON string, because the default behavior is to not wrap
        them, as if &lt;literal&gt;WITHOUT WRAPPER&lt;/literal&gt; were specified. The
        &lt;literal&gt;WITH WRAPPER&lt;/literal&gt; clause is by default taken to mean
        &lt;literal&gt;WITH UNCONDITIONAL WRAPPER&lt;/literal&gt;, which means that even a
        single result value will be wrapped. To apply the wrapper only when
        multiple values are present, specify &lt;literal&gt;WITH CONDITIONAL WRAPPER&lt;/literal&gt;.
        Getting multiple values in result will be treated as an error if
        &lt;literal&gt;WITHOUT WRAPPER&lt;/literal&gt; is specified.
</span>
パス式が複数の結果を返す場合、それらの値を適切なJSON文字列にするために、<code class="literal">WITH WRAPPER</code>句を使用してこれらの値をラップする必要があります。
なぜなら、デフォルトの動作は、<code class="literal">WITHOUT WRAPPER</code>が指定されているかのようにラップしないからです。
<code class="literal">WITH WRAPPER</code>句は、デフォルトでは<code class="literal">WITH UNCONDITIONAL WRAPPER</code>を意味すると解釈されます。これは、単一の結果値であってもラップされることを意味します。
複数の値が存在する場合にのみラッパーを適用するには、<code class="literal">WITH CONDITIONAL WRAPPER</code>を指定します。
<code class="literal">WITHOUT WRAPPER</code>が指定されていて、結果に複数の値が含まれると、エラーとして扱われます。
       </p></li><li class="listitem"><p>
<span class="original">
        If the result is a scalar string, by default, the returned value will
        be surrounded by quotes, making it a valid JSON value.  It can be made
        explicit by specifying &lt;literal&gt;KEEP QUOTES&lt;/literal&gt;.  Conversely,
        quotes can be omitted by specifying &lt;literal&gt;OMIT QUOTES&lt;/literal&gt;.
        To ensure that the result is a valid JSON value, &lt;literal&gt;OMIT QUOTES&lt;/literal&gt;
        cannot be specified when &lt;literal&gt;WITH WRAPPER&lt;/literal&gt; is also
        specified.
</span>
結果がスカラ文字列の場合、デフォルトでは戻り値は引用符で囲まれ、有効なJSON値になります。
これは、<code class="literal">KEEP QUOTES</code>を指定することで明示的にできます。
逆に、<code class="literal">OMIT QUOTES</code>を指定することで引用符を省略できます。
結果が有効なJSON値である保証には、<code class="literal">WITH WRAPPER</code>も指定されている場合、<code class="literal">OMIT QUOTES</code>は指定できません。
       </p></li><li class="listitem"><p>
<span class="original">
        The &lt;literal&gt;ON EMPTY&lt;/literal&gt; clause specifies the behavior if
        evaluating &lt;replaceable&gt;path_expression&lt;/replaceable&gt; yields an empty
        set. The &lt;literal&gt;ON ERROR&lt;/literal&gt; clause specifies the behavior
        if an error occurs when evaluating &lt;replaceable&gt;path_expression&lt;/replaceable&gt;,
        when coercing the result value to the &lt;literal&gt;RETURNING&lt;/literal&gt; type,
        or when evaluating the &lt;literal&gt;ON EMPTY&lt;/literal&gt; expression if the
        &lt;replaceable&gt;path_expression&lt;/replaceable&gt; evaluation returns an empty
        set.
</span>
<code class="literal">ON EMPTY</code>句は、<em class="replaceable"><code>path_expression</code></em>を評価した結果空の集合が生成される場合の動作を指定します。
<code class="literal">ON ERROR</code>句は、<em class="replaceable"><code>path_expression</code></em>を評価した際、結果値を<code class="literal">RETURNING</code>型に強制した際、または<em class="replaceable"><code>path_expression</code></em>評価で空の集合が返され<code class="literal">ON EMPTY</code>式を評価した際にエラーが発生する場合の動作を指定します。
       </p></li><li class="listitem"><p>
<span class="original">
        For both &lt;literal&gt;ON EMPTY&lt;/literal&gt; and &lt;literal&gt;ON ERROR&lt;/literal&gt;,
        specifying &lt;literal&gt;ERROR&lt;/literal&gt; will cause an error to be thrown with
        the appropriate message. Other options include returning an SQL NULL, an
        empty array (&lt;literal&gt;EMPTY &lt;optional&gt;ARRAY&lt;/optional&gt;&lt;/literal&gt;),
        an empty object (&lt;literal&gt;EMPTY OBJECT&lt;/literal&gt;), or a user-specified
        expression (&lt;literal&gt;DEFAULT&lt;/literal&gt; &lt;replaceable&gt;expression&lt;/replaceable&gt;)
        that can be coerced to jsonb or the type specified in &lt;literal&gt;RETURNING&lt;/literal&gt;.
        The default when &lt;literal&gt;ON EMPTY&lt;/literal&gt; or &lt;literal&gt;ON ERROR&lt;/literal&gt;
        is not specified is to return an SQL NULL value.
</span>
<code class="literal">ON EMPTY</code>と<code class="literal">ON ERROR</code>の両方で、<code class="literal">ERROR</code>を指定すると、適切なエラーとともにメッセージがスローされます。
他のオプションにはSQL NULL、空の配列（<code class="literal">EMPTY [<span class="optional">ARRAY</span>]</code>）、空のオブジェクト（<code class="literal">EMPTY OBJECT</code>）、jsonbまたは<code class="literal">RETURNING</code>で指定されたタイプに強制できるユーザ指定の式（<code class="literal">DEFAULT</code> <em class="replaceable"><code>expression</code></em>）があります。
<code class="literal">ON EMPTY</code>あるいは<code class="literal">ON ERROR</code>句が指定されていない場合のデフォルトでは、SQL NULL値を返します。
       </p></li></ul></div>
       <p>
<span class="original">
        Examples:
</span>
例：
       </p>
       <p>
        <code class="literal">JSON_QUERY(jsonb '[1,[2,3],null]', 'lax $[*][$off]' PASSING 1 AS off WITH CONDITIONAL WRAPPER)</code>
        → <code class="returnvalue">3</code>
       </p>
       <p>
        <code class="literal">JSON_QUERY(jsonb '{"a": "[1, 2]"}', 'lax $.a' OMIT QUOTES)</code>
        → <code class="returnvalue">[1, 2]</code>
       </p>
       <p>
        <code class="literal">JSON_QUERY(jsonb '{"a": "[1, 2]"}', 'lax $.a' RETURNING int[] OMIT QUOTES ERROR ON ERROR)</code>
        → <code class="returnvalue"></code>
</p><pre class="programlisting">
ERROR:  malformed array literal: "[1, 2]"
DETAIL:  Missing "]" after array dimensions.
</pre><p>
       </p>
      </td></tr><tr><td class="func_table_entry"><p class="func_signature">
        <a id="id-1.5.8.24.12.3.2.2.3.1.1.1" class="indexterm"></a>
</p><pre class="synopsis">
<code class="function">JSON_VALUE</code> (
<em class="replaceable"><code>context_item</code></em>, <em class="replaceable"><code>path_expression</code></em>
[<span class="optional"> <code class="literal">PASSING</code> { <em class="replaceable"><code>value</code></em> <code class="literal">AS</code> <em class="replaceable"><code>varname</code></em> } [<span class="optional">, ...</span>]</span>]
[<span class="optional"> <code class="literal">RETURNING</code> <em class="replaceable"><code>data_type</code></em> </span>]
[<span class="optional"> { <code class="literal">ERROR</code> | <code class="literal">NULL</code> | <code class="literal">DEFAULT</code> <em class="replaceable"><code>expression</code></em> } <code class="literal">ON EMPTY</code> </span>]
[<span class="optional"> { <code class="literal">ERROR</code> | <code class="literal">NULL</code> | <code class="literal">DEFAULT</code> <em class="replaceable"><code>expression</code></em> } <code class="literal">ON ERROR</code> </span>]) → <code class="returnvalue">text</code>
</pre><p class="func_signature">
       </p>
     <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
        Returns the result of applying the SQL/JSON
        &lt;replaceable&gt;path_expression&lt;/replaceable&gt; to the
        &lt;replaceable&gt;context_item&lt;/replaceable&gt;.
</span>
SQL/JSON <em class="replaceable"><code>path_expression</code></em>を<em class="replaceable"><code>context_item</code></em>に適用した結果を返します。
       </p></li><li class="listitem"><p>
<span class="original">
        Only use &lt;function&gt;JSON_VALUE()&lt;/function&gt; if the extracted value is
        expected to be a single &lt;acronym&gt;SQL/JSON&lt;/acronym&gt; scalar item;
        getting multiple values will be treated as an error. If you expect that
        extracted value might be an object or an array, use the
        &lt;function&gt;JSON_QUERY&lt;/function&gt; function instead.
</span>
<code class="function">JSON_VALUE()</code>を使用するのは、抽出された値が単一の<acronym class="acronym">SQL/JSON</acronym>スカラ項目であると予想される場合のみです。複数の値の取得はエラーとして扱われます。
抽出された値がオブジェクトまたは配列であると予想される場合は、代わりに<code class="function">JSON_QUERY</code>関数を使用します。
       </p></li><li class="listitem"><p>
<span class="original">
        By default, the result, which must be a single scalar value, is
        returned as a value of type &lt;type&gt;text&lt;/type&gt;, though the
        &lt;literal&gt;RETURNING&lt;/literal&gt; clause can be used to return as some
        other type to which it can be successfully coerced.
</span>
デフォルトでは、結果は単一のスカラー値である必要があり、<code class="type">text</code>型の値として返されます。
ただし、<code class="literal">RETURNING</code>句は、結果が正常に強制できる他の型として使用できます。
       </p></li><li class="listitem"><p>
<span class="original">
        The &lt;literal&gt;ON ERROR&lt;/literal&gt; and &lt;literal&gt;ON EMPTY&lt;/literal&gt;
        clauses have similar semantics as mentioned in the description of
        &lt;function&gt;JSON_QUERY&lt;/function&gt;, except the set of values returned in
        lieu of throwing an error is different.
</span>
<code class="literal">ON ERROR</code>句と<code class="literal">ON EMPTY</code>句のセマンティクスは、<code class="function">JSON_QUERY</code>の説明で説明したものと似ていますが、エラーを発生する代わりに返される値の集合が異なります。
       </p></li><li class="listitem"><p>
<span class="original">
        Note that scalar strings returned by &lt;function&gt;JSON_VALUE&lt;/function&gt;
        always have their quotes removed, equivalent to specifying
        &lt;literal&gt;OMIT QUOTES&lt;/literal&gt; in &lt;function&gt;JSON_QUERY&lt;/function&gt;.
</span>
<code class="function">JSON_VALUE</code>によって返されるスカラー文字列は、<code class="function">JSON_QUERY</code>で<code class="literal">OMIT QUOTES</code>を指定するのと同じように、常に引用符が削除されることに注意してください。
       </p></li></ul></div>
       <p>
<span class="original">
        Examples:
</span>
例：
       </p>
       <p>
        <code class="literal">JSON_VALUE(jsonb '"123.45"', '$' RETURNING float)</code>
        → <code class="returnvalue">123.45</code>
       </p>
       <p>
        <code class="literal">JSON_VALUE(jsonb '"03:04 2015-02-01"', '$.datetime("HH24:MI YYYY-MM-DD")' RETURNING date)</code>
        → <code class="returnvalue">2015-02-01</code>
       </p>
       <p>
        <code class="literal">JSON_VALUE(jsonb '[1,2]', 'strict $[$off]' PASSING 1 as off)</code>
        → <code class="returnvalue">2</code>
       </p>
       <p>
        <code class="literal">JSON_VALUE(jsonb '[1,2]', 'strict $[*]' DEFAULT 9 ON ERROR)</code>
        → <code class="returnvalue">9</code>
       </p>
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    The &lt;replaceable&gt;context_item&lt;/replaceable&gt; expression is converted to
    &lt;type&gt;jsonb&lt;/type&gt; by an implicit cast if the expression is not already of
    type &lt;type&gt;jsonb&lt;/type&gt;. Note, however, that any parsing errors that occur
    during that conversion are thrown unconditionally, that is, are not
    handled according to the (specified or implicit) &lt;literal&gt;ON ERROR&lt;/literal&gt;
    clause.
</span>
<em class="replaceable"><code>context_item</code></em>式は、まだ<code class="type">jsonb</code>型でない場合、暗黙キャストによって<code class="type">jsonb</code>に変換されます。
ただし、その変換中に発生する解析エラーは、無条件に発生します。つまり、（指定または暗黙的な）<code class="literal">ON ERROR</code>句に従って処理されません。
   </p></div><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
    &lt;function&gt;JSON_VALUE()&lt;/function&gt; returns an SQL NULL if
    &lt;replaceable&gt;path_expression&lt;/replaceable&gt; returns a JSON
    &lt;literal&gt;null&lt;/literal&gt;, whereas &lt;function&gt;JSON_QUERY()&lt;/function&gt; returns
    the JSON &lt;literal&gt;null&lt;/literal&gt; as is.
</span>
<em class="replaceable"><code>path_expression</code></em>がSQL<code class="literal">null</code>を返す場合、<code class="function">JSON_VALUE()</code>はSQL NULLを返します。一方、<code class="function">JSON_QUERY()</code>はJSON <code class="literal">null</code>をそのまま返します。
   </p></div></div><div class="sect2" id="FUNCTIONS-SQLJSON-TABLE"><div class="titlepage"><div><div><h3 class="title">9.16.4. JSON_TABLE <a href="#FUNCTIONS-SQLJSON-TABLE" class="id_link">#</a></h3></div></div></div><a id="id-1.5.8.24.13.2" class="indexterm"></a><p>
<span class="original">
   &lt;function&gt;JSON_TABLE&lt;/function&gt; is an SQL/JSON function which
   queries &lt;acronym&gt;JSON&lt;/acronym&gt; data
   and presents the results as a relational view, which can be accessed as a
   regular SQL table. You can use &lt;function&gt;JSON_TABLE&lt;/function&gt; inside
   the &lt;literal&gt;FROM&lt;/literal&gt; clause of a &lt;literal&gt;SELECT&lt;/literal&gt;,
   &lt;literal&gt;UPDATE&lt;/literal&gt;, or &lt;literal&gt;DELETE&lt;/literal&gt; and as data source
   in a &lt;literal&gt;MERGE&lt;/literal&gt; statement.
</span>
<code class="function">JSON_TABLE</code>は<acronym class="acronym">JSON</acronym>データを問い合わせ、結果を通常のSQLテーブルとしてアクセスできるリレーショナルビューとして表示するSQL/JSON関数です。
<code class="function">JSON_TABLE</code>は、<code class="literal">SELECT</code>、<code class="literal">UPDATE</code>、または<code class="literal">DELETE</code>の<code class="literal">FROM</code>句内で使用できます。また、<code class="literal">MERGE</code>文のデータソースとしても使用できます。
  </p><p>
<span class="original">
   Taking JSON data as input, &lt;function&gt;JSON_TABLE&lt;/function&gt; uses a JSON path
   expression to extract a part of the provided data to use as a
   &lt;firstterm&gt;row pattern&lt;/firstterm&gt; for the constructed view.  Each SQL/JSON
   value given by the row pattern serves as source for a separate row in the
   constructed view.
</span>
JSONデータを入力として、<code class="function">JSON_TABLE</code>はJSONパス式を使用して、提供されたデータの一部を抽出し、構築されたビューの<em class="firstterm">行パターン</em>として使用します。
行パターンで指定された各SQL/JSON値は、構築されたビューの別々の行のソースとして機能します。
  </p><p>
<span class="original">
   To split the row pattern into columns, &lt;function&gt;JSON_TABLE&lt;/function&gt;
   provides the &lt;literal&gt;COLUMNS&lt;/literal&gt; clause that defines the
   schema of the created view. For each column, a separate JSON path expression
   can be specified to be evaluated against the row pattern to get an SQL/JSON
   value that will become the value for the specified column in a given output
   row.
</span>
行パターンを列に分割するために、<code class="function">JSON_TABLE</code>は作成されたビューのスキーマを定義する<code class="literal">COLUMNS</code>句を提供します。
各列に対して、個別のJSONパス式を指定して、行パターンに対して評価されるようにできます。これは、指定された出力行の特定の列の値になります。
  </p><p>
<span class="original">
   JSON data stored at a nested level of the row pattern can be extracted using
   the &lt;literal&gt;NESTED PATH&lt;/literal&gt; clause.  Each
   &lt;literal&gt;NESTED PATH&lt;/literal&gt; clause can be used to generate one or more
   columns using the data from a nested level of the row pattern.  Those
   columns can be specified using a &lt;literal&gt;COLUMNS&lt;/literal&gt; clause that
   looks similar to the top-level COLUMNS clause.  Rows constructed from
   NESTED COLUMNS are called &lt;firstterm&gt;child rows&lt;/firstterm&gt; and are joined
   against the row constructed from the columns specified in the parent
   &lt;literal&gt;COLUMNS&lt;/literal&gt; clause to get the row in the final view.  Child
   columns themselves may contain a &lt;literal&gt;NESTED PATH&lt;/literal&gt;
   specification thus allowing to extract data located at arbitrary nesting
   levels.  Columns produced by multiple &lt;literal&gt;NESTED PATH&lt;/literal&gt;s at the
   same level are considered to be &lt;firstterm&gt;siblings&lt;/firstterm&gt; of each
   other and their rows after joining with the parent row are combined using
   UNION.
</span>
行パターンのネストされたレベルに格納されたJSONデータは、<code class="literal">NESTED PATH</code>句を使用して抽出できます。
各<code class="literal">NESTED PATH</code>句は、行パターンのネストされたレベルからのデータを使用して1つ以上の列を生成するために使用できます。
これらの列は、最上位のCOLUMNS句と同様の<code class="literal">COLUMNS</code>句を使用して指定できます。
NESTED COLUMNSから構成される行は<em class="firstterm">子行</em>（<em class="firstterm">child rows</em>）と呼ばれ、親の<code class="literal">COLUMNS</code>句で指定された列から構成される行に対して結合され、最終的なビューの行が得られます。
子列自体は<code class="literal">NESTED PATH</code>指定を含むことができ、任意のネストレベルにあるデータを抽出することができます。
同じレベルにある複数の<code class="literal">NESTED PATH</code>によって生成された列は、互いに<em class="firstterm">兄弟</em>（<em class="firstterm">siblings</em>）と見なされ、親行と結合された後の行はUNIONを使用して結合されます。
  </p><p>
<span class="original">
   The rows produced by &lt;function&gt;JSON_TABLE&lt;/function&gt; are laterally
   joined to the row that generated them, so you do not have to explicitly join
   the constructed view with the original table holding &lt;acronym&gt;JSON&lt;/acronym&gt;
   data.
</span>
<code class="function">JSON_TABLE</code>が生成する行は、それを生成した行に横方向に結合されるため、<acronym class="acronym">JSON</acronym>データを保持する元のテーブルに構築されたビューを明示的に結合する必要はありません。
  </p><p>
<span class="original">
   The syntax is:
</span>
構文は次のとおりです。
  </p><pre class="synopsis">
JSON_TABLE (
    <em class="replaceable"><code>context_item</code></em>, <em class="replaceable"><code>path_expression</code></em> [<span class="optional"> AS <em class="replaceable"><code>json_path_name</code></em> </span>] [<span class="optional"> PASSING { <em class="replaceable"><code>value</code></em> AS <em class="replaceable"><code>varname</code></em> } [<span class="optional">, ...</span>] </span>]
    COLUMNS ( <em class="replaceable"><code>json_table_column</code></em> [<span class="optional">, ...</span>] )
    [<span class="optional"> { <code class="literal">ERROR</code> | <code class="literal">EMPTY</code> [<span class="optional">ARRAY</span>]} <code class="literal">ON ERROR</code> </span>]
)

<span class="phrase">
<span class="original">
where &lt;replaceable class="parameter"&gt;json_table_column&lt;/replaceable&gt; is:
</span>
ここで<em class="replaceable"><code>json_table_column</code></em>は次のとおりです。
</span>
  <em class="replaceable"><code>name</code></em> FOR ORDINALITY
  | <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>type</code></em>
        [<span class="optional"> FORMAT JSON [<span class="optional">ENCODING <code class="literal">UTF8</code></span>]</span>]
        [<span class="optional"> PATH <em class="replaceable"><code>path_expression</code></em> </span>]
        [<span class="optional"> { WITHOUT | WITH { CONDITIONAL | [<span class="optional">UNCONDITIONAL</span>] } } [<span class="optional"> ARRAY </span>] WRAPPER </span>]
        [<span class="optional"> { KEEP | OMIT } QUOTES [<span class="optional"> ON SCALAR STRING </span>] </span>]
        [<span class="optional"> { ERROR | NULL | EMPTY { [<span class="optional">ARRAY</span>] | OBJECT } | DEFAULT <em class="replaceable"><code>expression</code></em> } ON EMPTY </span>]
        [<span class="optional"> { ERROR | NULL | EMPTY { [<span class="optional">ARRAY</span>] | OBJECT } | DEFAULT <em class="replaceable"><code>expression</code></em> } ON ERROR </span>]
  | <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>type</code></em> EXISTS [<span class="optional"> PATH <em class="replaceable"><code>path_expression</code></em> </span>]
        [<span class="optional"> { ERROR | TRUE | FALSE | UNKNOWN } ON ERROR </span>]
  | NESTED [<span class="optional"> PATH </span>] <em class="replaceable"><code>path_expression</code></em> [<span class="optional"> AS <em class="replaceable"><code>json_path_name</code></em> </span>] COLUMNS ( <em class="replaceable"><code>json_table_column</code></em> [<span class="optional">, ...</span>] )
</pre><p>
<span class="original">
   Each syntax element is described below in more detail.
</span>
各構文要素について、以下でさらに詳しく説明します。
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <code class="literal"><em class="replaceable"><code>context_item</code></em>, <em class="replaceable"><code>path_expression</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>json_path_name</code></em> </span>] [<span class="optional"> <code class="literal">PASSING</code> { <em class="replaceable"><code>value</code></em> <code class="literal">AS</code> <em class="replaceable"><code>varname</code></em> } [<span class="optional">, ...</span>]</span>]</code>
    </span></dt><dd><p>
<span class="original">
     The &lt;replaceable&gt;context_item&lt;/replaceable&gt; specifies the input document
     to query, the &lt;replaceable&gt;path_expression&lt;/replaceable&gt; is an SQL/JSON
     path expression defining the query, and &lt;replaceable&gt;json_path_name&lt;/replaceable&gt;
     is an optional name for the &lt;replaceable&gt;path_expression&lt;/replaceable&gt;.
     The optional &lt;literal&gt;PASSING&lt;/literal&gt; clause provides data values for
     the variables mentioned in the &lt;replaceable&gt;path_expression&lt;/replaceable&gt;.
     The result of the input data evaluation using the aforementioned elements
     is called the &lt;firstterm&gt;row pattern&lt;/firstterm&gt;, which is used as the
     source for row values in the constructed view.
</span>
<em class="replaceable"><code>context_item</code></em>は問い合わせの入力ドキュメントを指定し、<em class="replaceable"><code>path_expression</code></em>は問い合わせを定義するSQL/JSONパス式であり、<em class="replaceable"><code>json_path_name</code></em>は<em class="replaceable"><code>path_expression</code></em>のオプションの名前です。
オプションの<code class="literal">PASSING</code>句は、<em class="replaceable"><code>path_expression</code></em>で言及されている変数にデータ値を提供します。
前述の要素を使用して入力データを評価した結果は<em class="firstterm">row pattern</em>と呼ばれ、構築されたビューの行値のソースとして使用されます。
    </p></dd><dt><span class="term">
     <code class="literal">COLUMNS</code> ( <em class="replaceable"><code>json_table_column</code></em> [<span class="optional">, ...</span>] )
    </span></dt><dd><p>
<span class="original">
     The &lt;literal&gt;COLUMNS&lt;/literal&gt; clause defining the schema of the
     constructed view. In this clause, you can specify each column to be
     filled with an SQL/JSON value obtained by applying a JSON path expression
     against the row pattern.  &lt;replaceable&gt;json_table_column&lt;/replaceable&gt; has
     the following variants:
</span>
構築されたビューのスキーマを定義する<code class="literal">COLUMNS</code>句。
この句では、各列に対して、行パターンに対してJSONパス式を適用することによって得られるSQL/JSON値を指定できます。
<em class="replaceable"><code>json_table_column</code></em>には、次の種類があります。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
     <em class="replaceable"><code>name</code></em> <code class="literal">FOR ORDINALITY</code>
    </span></dt><dd><p>
<span class="original">
     Adds an ordinality column that provides sequential row numbering starting
     from 1.  Each &lt;literal&gt;NESTED PATH&lt;/literal&gt; (see below) gets its own
     counter for any nested ordinality columns.
</span>
1から始まる連続した行番号を提供する序数列を追加します。
各<code class="literal">NESTED PATH</code>（下記参照）は、ネストされた序数列に対してそれぞれ独自のカウンタを持ちます。
    </p></dd><dt><span class="term">
     <code class="literal"><em class="replaceable"><code>name</code></em> <em class="replaceable"><code>type</code></em>
          [<span class="optional"><code class="literal">FORMAT JSON</code> [<span class="optional">ENCODING <code class="literal">UTF8</code></span>]</span>]
          [<span class="optional"> <code class="literal">PATH</code> <em class="replaceable"><code>path_expression</code></em> </span>]</code>
    </span></dt><dd><p>
<span class="original">
     Inserts an SQL/JSON value obtained by applying
     &lt;replaceable&gt;path_expression&lt;/replaceable&gt; against the row pattern into
     the view's output row after coercing it to specified
     &lt;replaceable&gt;type&lt;/replaceable&gt;.
</span>
指定された<em class="replaceable"><code>type</code></em>に強制変換した後、ビューの出力行に<em class="replaceable"><code>path_expression</code></em>を適用して得られたSQL/JSON値を挿入します。
    </p><p>
<span class="original">
     Specifying &lt;literal&gt;FORMAT JSON&lt;/literal&gt; makes it explicit that you
     expect the value to be a valid &lt;type&gt;json&lt;/type&gt; object.  It only
     makes sense to specify &lt;literal&gt;FORMAT JSON&lt;/literal&gt; if
     &lt;replaceable&gt;type&lt;/replaceable&gt; is one of &lt;type&gt;bpchar&lt;/type&gt;,
     &lt;type&gt;bytea&lt;/type&gt;, &lt;type&gt;character varying&lt;/type&gt;, &lt;type&gt;name&lt;/type&gt;,
     &lt;type&gt;json&lt;/type&gt;, &lt;type&gt;jsonb&lt;/type&gt;, &lt;type&gt;text&lt;/type&gt;, or a domain over
     these types.
</span>
<code class="literal">FORMAT JSON</code>を指定すると、値が有効な<code class="type">json</code>オブジェクトであることが明示的に指定されます。
<code class="literal">FORMAT JSON</code>を指定するのは、<em class="replaceable"><code>type</code></em>が<code class="type">bpchar</code>、<code class="type">bytea</code>、<code class="type">character varying</code>、<code class="type">name</code>、<code class="type">json</code>、<code class="type">jsonb</code>、<code class="type">text</code>、またはこれらの型のドメインのいずれかである場合に限られます。
    </p><p>
<span class="original">
     Optionally, you can specify &lt;literal&gt;WRAPPER&lt;/literal&gt; and
     &lt;literal&gt;QUOTES&lt;/literal&gt; clauses to format the output. Note that
     specifying &lt;literal&gt;OMIT QUOTES&lt;/literal&gt; overrides
     &lt;literal&gt;FORMAT JSON&lt;/literal&gt; if also specified, because unquoted
     literals do not constitute valid &lt;type&gt;json&lt;/type&gt; values.
</span>
オプションで、<code class="literal">WRAPPER</code>と<code class="literal">QUOTES</code>句を指定して出力をフォーマットすることもできます。
引用符なしのリテラルは有効な<code class="type">json</code>値を構成しないため、<code class="literal">QUOTES</code>を指定すると、<code class="literal">FORMAT JSON</code>が上書きされることに注意してください。
    </p><p>
<span class="original">
     Optionally, you can use &lt;literal&gt;ON EMPTY&lt;/literal&gt; and
     &lt;literal&gt;ON ERROR&lt;/literal&gt; clauses to specify whether to throw the error
     or return the specified value when the result of JSON path evaluation is
     empty and when an error occurs during JSON path evaluation or when
     coercing the SQL/JSON value to the specified type, respectively.  The
     default for both is to return a &lt;literal&gt;NULL&lt;/literal&gt; value.
</span>
オプションで、<code class="literal">ON EMPTY</code>と<code class="literal">ON ERROR</code>句を使用して、JSONパス評価の結果が空の場合と、JSONパスの評価中あるいはSQL/JSON値を指定された型に強制変換したときにエラーが発生した場合に対して、エラーを発生するか、指定された値を返すかをそれぞれ指定できます。
どちらもデフォルトは<code class="literal">NULL</code>です。
    </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
      This clause is internally turned into and has the same semantics as
      &lt;function&gt;JSON_VALUE&lt;/function&gt; or &lt;function&gt;JSON_QUERY&lt;/function&gt;.
      The latter if the specified type is not a scalar type or if either of
      &lt;literal&gt;FORMAT JSON&lt;/literal&gt;, &lt;literal&gt;WRAPPER&lt;/literal&gt;, or
      &lt;literal&gt;QUOTES&lt;/literal&gt; clause is present.
</span>
この句は内部的に<code class="function">JSON_VALUE</code>または<code class="function">JSON_QUERY</code>と同じ意味になります。
後者は、指定された型がスカラー型でない場合、または<code class="literal">FORMAT JSON</code>、<code class="literal">WRAPPER</code>、または<code class="literal">QUOTES</code>句のいずれかが存在する場合です。
     </p></div></dd><dt><span class="term">
       <em class="replaceable"><code>name</code></em> <em class="replaceable"><code>type</code></em>
       <code class="literal">EXISTS</code> [<span class="optional"> <code class="literal">PATH</code> <em class="replaceable"><code>path_expression</code></em> </span>]
    </span></dt><dd><p>
<span class="original">
     Inserts a boolean value obtained by applying
     &lt;replaceable&gt;path_expression&lt;/replaceable&gt; against the row pattern
     into the view's output row after coercing it to specified
     &lt;replaceable&gt;type&lt;/replaceable&gt;.
</span>
指定された<em class="replaceable"><code>type</code></em>に強制変換した後、ビューの出力行に<em class="replaceable"><code>path_expression</code></em>を適用して得られたブール値を挿入します。
    </p><p>
<span class="original">
     The value corresponds to whether applying the &lt;literal&gt;PATH&lt;/literal&gt;
     expression to the row pattern yields any values.
</span>
この値は、<code class="literal">PATH</code>式を行パターンに適用した結果、値が生成されるかどうかに対応します。
    </p><p>
<span class="original">
     The specified &lt;replaceable&gt;type&lt;/replaceable&gt; should have a cast from the
     &lt;type&gt;boolean&lt;/type&gt; type.
</span>
指定された<em class="replaceable"><code>type</code></em>は<code class="type">boolean</code>型からのキャストを持つべきです。
    </p><p>
<span class="original">
     Optionally, you can use &lt;literal&gt;ON ERROR&lt;/literal&gt; to specify whether to
     throw the error or return the specified value when an error occurs during
     JSON path evaluation or when coercing SQL/JSON value to the specified
     type.  The default is to return a boolean value
     &lt;literal&gt;FALSE&lt;/literal&gt;.
</span>
オプションで<code class="literal">ON ERROR</code>を使用して、JSONパス評価中にエラーが発生した場合、またはSQL/JSON値を指定された型に強制変換した場合に、エラーを発生するか、指定された値を返すかを指定できます。
デフォルトは、ブール値<code class="literal">FALSE</code>を返します。
    </p><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
      This clause is internally turned into and has the same semantics as
      &lt;function&gt;JSON_EXISTS&lt;/function&gt;.
</span>
この句は内部的には<code class="function">JSON_EXISTS</code>と同じ意味に変換されます。
     </p></div></dd><dt><span class="term">
      <code class="literal">NESTED [<span class="optional"> PATH </span>]</code> <em class="replaceable"><code>path_expression</code></em> [<span class="optional"> <code class="literal">AS</code> <em class="replaceable"><code>json_path_name</code></em> </span>]
          <code class="literal">COLUMNS</code> ( <em class="replaceable"><code>json_table_column</code></em> [<span class="optional">, ...</span>] )
    </span></dt><dd><p>
<span class="original">
     Extracts SQL/JSON values from nested levels of the row pattern,
     generates one or more columns as defined by the &lt;literal&gt;COLUMNS&lt;/literal&gt;
     subclause, and inserts the extracted SQL/JSON values into those
     columns.  The &lt;replaceable&gt;json_table_column&lt;/replaceable&gt;
     expression in the &lt;literal&gt;COLUMNS&lt;/literal&gt; subclause uses the same
     syntax as in the parent &lt;literal&gt;COLUMNS&lt;/literal&gt; clause.
</span>
行パターンのネストされたレベルからSQL/JSON値を抽出し、<code class="literal">COLUMNS</code>副句で定義された1つ以上の列を生成し、それらの列に抽出されたSQL/JSON値を挿入します。
<code class="literal">COLUMNS</code>副句の<em class="replaceable"><code>json_table_column</code></em>式は、親の<code class="literal">COLUMNS</code>句と同じ構文を使用します。
    </p><p>
<span class="original">
     The &lt;literal&gt;NESTED PATH&lt;/literal&gt; syntax is recursive,
     so you can go down multiple nested levels by specifying several
     &lt;literal&gt;NESTED PATH&lt;/literal&gt; subclauses within each other.
     It allows to unnest the hierarchy of JSON objects and arrays
     in a single function invocation rather than chaining several
     &lt;function&gt;JSON_TABLE&lt;/function&gt; expressions in an SQL statement.
</span>
<code class="literal">NESTED PATH</code>構文は再帰的です。
したがって、複数の<code class="literal">NESTED PATH</code>副構文を互いに指定することで、複数のネストされたレベルを下に移動できます。
これにより、SQL文内で複数の<code class="function">JSON_TABLE</code>式を連鎖させるのではなく、単一の関数呼び出しでJSONオブジェクトと配列の階層をネスト解除できます。
    </p></dd></dl></div><div class="note"><h3 class="title">注記</h3><p>
<span class="original">
      In each variant of &lt;replaceable&gt;json_table_column&lt;/replaceable&gt; described
      above, if the &lt;literal&gt;PATH&lt;/literal&gt; clause is omitted, path expression
      &lt;literal&gt;$.&lt;replaceable&gt;name&lt;/replaceable&gt;&lt;/literal&gt; is used, where
      &lt;replaceable&gt;name&lt;/replaceable&gt; is the provided column name.
</span>
上記の<em class="replaceable"><code>json_table_column</code></em>の各種類において、<code class="literal">PATH</code>句が省略された場合、パス式<code class="literal">$.<em class="replaceable"><code>name</code></em></code>が使用されます。
ここで、<em class="replaceable"><code>name</code></em>は指定された列名です。
     </p></div></dd><dt><span class="term">
     <code class="literal">AS</code> <em class="replaceable"><code>json_path_name</code></em>
    </span></dt><dd><p>
<span class="original">
     The optional &lt;replaceable&gt;json_path_name&lt;/replaceable&gt; serves as an
     identifier of the provided &lt;replaceable&gt;path_expression&lt;/replaceable&gt;.
     The name must be unique and distinct from the column names.
</span>
オプションの<em class="replaceable"><code>json_path_name</code></em>は、指定された<em class="replaceable"><code>path_expression</code></em>の識別子として機能します。
名前は一意でなければならず、列名と区別する必要があります。
    </p></dd><dt><span class="term">
     { <code class="literal">ERROR</code> | <code class="literal">EMPTY</code> } <code class="literal">ON ERROR</code>
    </span></dt><dd><p>
<span class="original">
     The optional &lt;literal&gt;ON ERROR&lt;/literal&gt; can be used to specify how to
     handle errors when evaluating the top-level
     &lt;replaceable&gt;path_expression&lt;/replaceable&gt;.  Use &lt;literal&gt;ERROR&lt;/literal&gt;
     if you want the errors to be thrown and &lt;literal&gt;EMPTY&lt;/literal&gt; to
     return an empty table, that is, a table containing 0 rows.  Note that
     this clause does not affect the errors that occur when evaluating
     columns, for which the behavior depends on whether the
     &lt;literal&gt;ON ERROR&lt;/literal&gt; clause is specified against a given column.
</span>
オプションの<code class="literal">ON ERROR</code>は、最上位の<em class="replaceable"><code>path_expression</code></em>を評価する際のエラー処理方法を指定するために使用できます。
エラーを発生する場合は<code class="literal">ERROR</code>を使用し、空のテーブル、つまり0行を含むテーブルを返す場合は<code class="literal">EMPTY</code>を使用します。
この句は、列の評価時に発生するエラーには影響しないことに注意してください。
この場合の動作は、<code class="literal">ON ERROR</code>句が指定された列に対して指定されているかどうかによって異なります。
    </p></dd></dl></div><p>Examples</p><p>
<span class="original">
      In the examples that follow, the following table containing JSON data
      will be used:
</span>
以下の例では、次の表にJSONデータを含めます。

</p><pre class="programlisting">
CREATE TABLE my_films ( js jsonb );

INSERT INTO my_films VALUES (
'{ "favorites" : [
   { "kind" : "comedy", "films" : [
     { "title" : "Bananas",
       "director" : "Woody Allen"},
     { "title" : "The Dinner Game",
       "director" : "Francis Veber" } ] },
   { "kind" : "horror", "films" : [
     { "title" : "Psycho",
       "director" : "Alfred Hitchcock" } ] },
   { "kind" : "thriller", "films" : [
     { "title" : "Vertigo",
       "director" : "Alfred Hitchcock" } ] },
   { "kind" : "drama", "films" : [
     { "title" : "Yojimbo",
       "director" : "Akira Kurosawa" } ] }
  ] }');
</pre><p>

     </p><p>
<span class="original">
      The following query shows how to use &lt;function&gt;JSON_TABLE&lt;/function&gt; to
      turn the JSON objects in the &lt;structname&gt;my_films&lt;/structname&gt; table
      to a view containing columns for the keys &lt;literal&gt;kind&lt;/literal&gt;,
      &lt;literal&gt;title&lt;/literal&gt;, and &lt;literal&gt;director&lt;/literal&gt; contained in
      the original JSON along with an ordinality column:
</span>
次の問い合わせは、<code class="function">JSON_TABLE</code>を使用して、<code class="structname">my_films</code>テーブル内のJSONオブジェクトを、通常の列を伴って元のJSONに含まれるキー<code class="literal">kind</code>、<code class="literal">title</code>、および<code class="literal">director</code>の列を含むビューに変換する方法を示しています。

</p><pre class="programlisting">
SELECT jt.* FROM
 my_films,
 JSON_TABLE (js, '$.favorites[*]' COLUMNS (
   id FOR ORDINALITY,
   kind text PATH '$.kind',
   title text PATH '$.films[*].title' WITH WRAPPER,
   director text PATH '$.films[*].director' WITH WRAPPER)) AS jt;
</pre><p>

</p><pre class="screen">
 id |   kind   |             title              |             director
----+----------+--------------------------------+----------------------------------
  1 | comedy   | ["Bananas", "The Dinner Game"] | ["Woody Allen", "Francis Veber"]
  2 | horror   | ["Psycho"]                     | ["Alfred Hitchcock"]
  3 | thriller | ["Vertigo"]                    | ["Alfred Hitchcock"]
  4 | drama    | ["Yojimbo"]                    | ["Akira Kurosawa"]
(4 rows)
</pre><p>

     </p><p>
<span class="original">
      The following is a modified version of the above query to show the
      usage of &lt;literal&gt;PASSING&lt;/literal&gt; arguments in the filter specified in
      the top-level JSON path expression and the various options for the
      individual columns:
</span>
上記の問い合わせを次のように変更すると、トップレベルのJSONパス式で指定されたフィルタで<code class="literal">PASSING</code>引数の使用方法と、個々の列に対するさまざまなオプションが表示されます。

</p><pre class="programlisting">
SELECT jt.* FROM
 my_films,
 JSON_TABLE (js, '$.favorites[*] ? (@.films[*].director == $filter)'
   PASSING 'Alfred Hitchcock' AS filter, 'Vertigo' AS filter2
     COLUMNS (
     id FOR ORDINALITY,
     kind text PATH '$.kind',
     title text FORMAT JSON PATH '$.films[*].title' OMIT QUOTES,
     director text PATH '$.films[*].director' KEEP QUOTES)) AS jt;
</pre><p>

</p><pre class="screen">
 id |   kind   |  title  |      director
----+----------+---------+--------------------
  1 | horror   | Psycho  | "Alfred Hitchcock"
  2 | thriller | Vertigo | "Alfred Hitchcock"
(2 rows)
</pre><p>

     </p><p>
<span class="original">
      The following is a modified version of the above query to show the usage
      of &lt;literal&gt;NESTED PATH&lt;/literal&gt; for populating title and director
      columns, illustrating how they are joined to the parent columns id and
      kind:
</span>
以下は、タイトルとディレクターの列を生成するために<code class="literal">NESTED PATH</code>を使用する上記の問い合わせの修正版で、親の列idとkindにどのように結合されるかを示しています。

</p><pre class="programlisting">
SELECT jt.* FROM
 my_films,
 JSON_TABLE ( js, '$.favorites[*] ? (@.films[*].director == $filter)'
   PASSING 'Alfred Hitchcock' AS filter
   COLUMNS (
    id FOR ORDINALITY,
    kind text PATH '$.kind',
    NESTED PATH '$.films[*]' COLUMNS (
      title text FORMAT JSON PATH '$.title' OMIT QUOTES,
      director text PATH '$.director' KEEP QUOTES))) AS jt;
</pre><p>

</p><pre class="screen">
 id |   kind   |  title  |      director
----+----------+---------+--------------------
  1 | horror   | Psycho  | "Alfred Hitchcock"
  2 | thriller | Vertigo | "Alfred Hitchcock"
(2 rows)
</pre><p>

     </p><p>
<span class="original">
      The following is the same query but without the filter in the root
      path:
</span>
次の問い合わせは、ルートパスにフィルタを指定しない場合と同じです。

</p><pre class="programlisting">
SELECT jt.* FROM
 my_films,
 JSON_TABLE ( js, '$.favorites[*]'
   COLUMNS (
    id FOR ORDINALITY,
    kind text PATH '$.kind',
    NESTED PATH '$.films[*]' COLUMNS (
      title text FORMAT JSON PATH '$.title' OMIT QUOTES,
      director text PATH '$.director' KEEP QUOTES))) AS jt;
</pre><p>

</p><pre class="screen">
 id |   kind   |      title      |      director
----+----------+-----------------+--------------------
  1 | comedy   | Bananas         | "Woody Allen"
  1 | comedy   | The Dinner Game | "Francis Veber"
  2 | horror   | Psycho          | "Alfred Hitchcock"
  3 | thriller | Vertigo         | "Alfred Hitchcock"
  4 | drama    | Yojimbo         | "Akira Kurosawa"
(5 rows)
</pre><p>

     </p><p>
<span class="original">
      The following shows another query using a different &lt;type&gt;JSON&lt;/type&gt;
      object as input.  It shows the UNION "sibling join" between
      &lt;literal&gt;NESTED&lt;/literal&gt; paths &lt;literal&gt;$.movies[*]&lt;/literal&gt; and
      &lt;literal&gt;$.books[*]&lt;/literal&gt; and also the usage of
      &lt;literal&gt;FOR ORDINALITY&lt;/literal&gt; column at &lt;literal&gt;NESTED&lt;/literal&gt;
      levels (columns &lt;literal&gt;movie_id&lt;/literal&gt;, &lt;literal&gt;book_id&lt;/literal&gt;,
      and &lt;literal&gt;author_id&lt;/literal&gt;):
</span>
次に異なる<code class="type">JSON</code>オブジェクトを入力として使用する別の問い合わせを示します。
これは、<code class="literal">NESTED</code>パスである<code class="literal">$.movies[*]</code>と<code class="literal">$.books[*]</code>との間のUNION”兄弟結合”（sibling join）を示しています。
また、<code class="literal">NESTED</code>レベルでの<code class="literal">FOR ORDINALITY</code>列（列<code class="literal">movie_id</code>、<code class="literal">book_id</code>、および<code class="literal">author_id</code>）の使用を示しています。

</p><pre class="programlisting">
SELECT * FROM JSON_TABLE (
'{"favorites":
    {"movies":
      [{"name": "One", "director": "John Doe"},
       {"name": "Two", "director": "Don Joe"}],
     "books":
      [{"name": "Mystery", "authors": [{"name": "Brown Dan"}]},
       {"name": "Wonder", "authors": [{"name": "Jun Murakami"}, {"name":"Craig Doe"}]}]
}}'::json, '$.favorites[*]'
COLUMNS (
  user_id FOR ORDINALITY,
  NESTED '$.movies[*]'
    COLUMNS (
    movie_id FOR ORDINALITY,
    mname text PATH '$.name',
    director text),
  NESTED '$.books[*]'
    COLUMNS (
      book_id FOR ORDINALITY,
      bname text PATH '$.name',
      NESTED '$.authors[*]'
        COLUMNS (
          author_id FOR ORDINALITY,
          author_name text PATH '$.name'))));
</pre><p>

</p><pre class="screen">
 user_id | movie_id | mname | director | book_id |  bname  | author_id | author_name
---------+----------+-------+----------+---------+---------+-----------+--------------
       1 |        1 | One   | John Doe |         |         |           |
       1 |        2 | Two   | Don Joe  |         |         |           |
       1 |          |       |          |       1 | Mystery |         1 | Brown Dan
       1 |          |       |          |       2 | Wonder  |         1 | Jun Murakami
       1 |          |       |          |       2 | Wonder  |         2 | Craig Doe
(5 rows)
</pre><p>

     </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-xml.html" title="9.15. XML関数">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-sequence.html" title="9.17. シーケンス操作関数">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.15. XML関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 17.0文書">ホーム</a></td><td width="40%" align="right" valign="top"> 9.17. シーケンス操作関数</td></tr></table></div></body></html>