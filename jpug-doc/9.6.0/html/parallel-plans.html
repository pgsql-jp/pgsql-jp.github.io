<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.3. Parallel Plans</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.6.0文書" /><link rel="up" href="parallel-query.html" title="第15章 Parallel Query" /><link rel="prev" href="when-can-parallel-query-be-used.html" title="15.2. When Can Parallel Query Be Used?" /><link rel="next" href="parallel-safety.html" title="15.4. Parallel Safety" /><link rel="copyright" href="legalnotice.html" title="法的告知" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.6.0文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.6.0 parallel-plans.html">誤訳等の報告</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="when-can-parallel-query-be-used.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="parallel-query.html">上へ</a></td><td width="60%" align="center">15.3. Parallel Plans</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="parallel-safety.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="parallel-plans"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.3. Parallel Plans</h2></div></div></div><p>    Because each worker executes the parallel portion of the plan to
    completion, it is not possible to simply take an ordinary query plan
    and run it using multiple workers.  Each worker would produce a full
    copy of the output result set, so the query would not run any faster
    than normal but would produce incorrect results.  Instead, the parallel
    portion of the plan must be what is known internally to the query
    optimizer as a <em class="firstterm">partial plan</em>; that is, it must constructed
    so that each process will which executes the plan will generate only a
    subset of the output rows in such a way that each required output row
    is guaranteed to be generated by exactly one of the cooperating processes.
  </p><div class="sect2" id="parallel-scans"><div class="titlepage"><div><div><h3 class="title">15.3.1. Parallel Scans</h3></div></div></div><p>    Currently, the only type of scan which has been modified to work with
    parallel query is a sequential scan.  Therefore, the driving table in
    a parallel plan will always be scanned using a
    <code class="literal">Parallel Seq Scan</code>.  The relation's blocks will be divided
    among the cooperating processes.  Blocks are handed out one at a
    time, so that access to the relation remains sequential.  Each process
    will visit every tuple on the page assigned to it before requesting a new
    page.
  </p></div><div class="sect2" id="parallel-joins"><div class="titlepage"><div><div><h3 class="title">15.3.2. Parallel Joins</h3></div></div></div><p>    The driving table may be joined to one or more other tables using nested
    loops or hash joins.  The outer side of the join may be any kind of
    non-parallel plan that is otherwise supported by the planner provided that
    it is safe to run within a parallel worker.  For example, it may be an
    index scan which looks up a value based on a column taken from the inner
    table. Each worker will execute the outer side of the plan in full, which
    is why merge joins are not supported here. The outer side of a merge join
    will often involve sorting the entire inner table; even if it involves an
    index, it is unlikely to be productive to have multiple processes each
    conduct a full index scan of the inner table.
  </p></div><div class="sect2" id="parallel-aggregation"><div class="titlepage"><div><div><h3 class="title">15.3.3. Parallel Aggregation</h3></div></div></div><p>    It is not possible to perform the aggregation portion of a query entirely
    in parallel.  For example, if a query involves selecting
    <code class="literal">COUNT(*)</code>, each worker could compute a total, but those totals
    would need to combined in order to produce a final answer.  If the query
    involved a <code class="literal">GROUP BY</code> clause, a separate total would need to
    be computed for each group.  Even though aggregation can't be done entirely
    in parallel, queries involving aggregation are often excellent candidates
    for parallel query, because they typically read many rows but return only
    a few rows to the client.  Queries that return many rows to the client
    are often limited by the speed at which the client can read the data,
    in which case parallel query cannot help very much.
  </p><p>    <span class="productname">PostgreSQL</span> supports parallel aggregation by aggregating
    twice.  First, each process participating in the parallel portion of the
    query performs an aggregation step, producing a partial result for each
    group of which that process is aware.  This is reflected in the plan as
    a <code class="literal">PartialAggregate</code> node.  Second, the partial results are
    transferred to the leader via the <code class="literal">Gather</code> node.  Finally, the
    leader re-aggregates the results across all workers in order to produce
    the final result.  This is reflected in the plan as a
    <code class="literal">FinalizeAggregate</code> node.
  </p><p>    Parallel aggregation is not supported in all situations.  Each aggregate
    must be <a class="link" href="parallel-safety.html" title="15.4. Parallel Safety">safe</a> for parallelism and must
    have a combine function.  If the aggregate has a transition state of type
    <code class="literal">internal</code>, it must have serialization and deserialization
    functions.  See <a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a> for more details.
    Parallel aggregation is not supported for ordered set aggregates or when
    the query involves <code class="literal">GROUPING SETS</code>.  It can only be used when
    all joins involved in the query are also part of the parallel portion
    of the plan.
  </p></div><div class="sect2" id="parallel-plan-tips"><div class="titlepage"><div><div><h3 class="title">15.3.4. Parallel Plan Tips</h3></div></div></div><p>    If a query that is expected to do so does not produce a parallel plan,
    you can try reducing <a class="xref" href="runtime-config-query.html#guc-parallel-setup-cost">parallel_setup_cost</a> or
    <a class="xref" href="runtime-config-query.html#guc-parallel-tuple-cost">parallel_tuple_cost</a>.  Of course, this plan may turn
    out to be slower than the serial plan which the planner preferred, but
    this will not always be the case.  If you don't get a parallel
    plan even with very small values of these settings (e.g. after setting
    them both to zero), there may be some reason why the query planner is
    unable to generate a parallel plan for your query.  See
    <a class="xref" href="when-can-parallel-query-be-used.html" title="15.2. When Can Parallel Query Be Used?">15.2. When Can Parallel Query Be Used?</a> and
    <a class="xref" href="parallel-safety.html" title="15.4. Parallel Safety">15.4. Parallel Safety</a> for information on why this may be
    the case.
  </p><p>    When executing a parallel plan, you can use <code class="literal">EXPLAIN (ANALYZE,
    VERBOSE)</code> will display per-worker statistics for each plan node.
    This may be useful in determining whether the work is being evenly
    distributed between all plan nodes and more generally in understanding the
    performance characteristics of the plan.
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-safety.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. When Can Parallel Query Be Used? </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 15.4. Parallel Safety</td></tr></table></div></body></html>