<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.3. パラレルプラン</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.6.0文書" /><link rel="up" href="parallel-query.html" title="第15章 パラレルクエリ" /><link rel="prev" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？" /><link rel="next" href="parallel-safety.html" title="15.4. パラレル安全" /><link rel="copyright" href="legalnotice.html" title="法的告知" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.6.0文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.6.0 parallel-plans.html">誤訳等の報告</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="when-can-parallel-query-be-used.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="parallel-query.html">上へ</a></td><td width="60%" align="center">15.3. パラレルプラン</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="parallel-safety.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="parallel-plans"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.3. パラレルプラン</h2></div></div></div><span class="original">
  &lt;title&gt;Parallel Plans&lt;/title&gt;
</span><p><span class="original">
    Because each worker executes the parallel portion of the plan to
    completion, it is not possible to simply take an ordinary query plan
    and run it using multiple workers.  Each worker would produce a full
    copy of the output result set, so the query would not run any faster
    than normal but would produce incorrect results.  Instead, the parallel
    portion of the plan must be what is known internally to the query
    optimizer as a &lt;firstterm&gt;partial plan&lt;/&gt;; that is, it must constructed
    so that each process will which executes the plan will generate only a
    subset of the output rows in such a way that each required output row
    is guaranteed to be generated by exactly one of the cooperating processes.
</span>各々のワーカーは完了すべきプランのパラレル部分を実行するので、単に通常のクエリプランを適用し、複数のワーカーを使って実行することはできません。
それぞれのワーカーが結果セットの全体のコピーを生成するので、クエリは通常よりも決して速くなりませんし、不正な結果を生成してしまいます。
そうではなくて、プランのパラレル部分は、クエリオプティマイザの内部で<em class="firstterm">部分プラン</em>として知られているものでなくてはなりません。
すなわち、プランを実行する各プロセスが、要求される個々の出力行が、協調動作するプロセスの正確に１個だけによって生成されることが保証されているような方法で、出力行の一部だけを生成します。
  </p><div class="sect2" id="parallel-scans"><div class="titlepage"><div><div><h3 class="title">15.3.1. パラレルスキャン</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Scans&lt;/title&gt;
</span><p><span class="original">
    Currently, the only type of scan which has been modified to work with
    parallel query is a sequential scan.  Therefore, the driving table in
    a parallel plan will always be scanned using a
    &lt;literal&gt;Parallel Seq Scan&lt;/&gt;.  The relation's blocks will be divided
    among the cooperating processes.  Blocks are handed out one at a
    time, so that access to the relation remains sequential.  Each process
    will visit every tuple on the page assigned to it before requesting a new
    page.
</span>今のところ、パラレルクエリに適合するように修正されたスキャンタイプはシーケンシャルスキャンだけです。
したがって、パラレルプラン中で対象となるテーブルは常に<code class="literal">Parallel Seq Scan</code>を使ってスキャンされます。
リレーションのブロックは協調するプロセスの間で分割されます。
リレーションへのアクセスが順次になるように、ブロックは一時に１個だけ渡されます。
個々のプロセスは割り当てられたページのすべてのタプルをアクセスしてから、新しいページを要求します。
  </p></div><div class="sect2" id="parallel-joins"><div class="titlepage"><div><div><h3 class="title">15.3.2. パラレルジョイン</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Joins&lt;/title&gt;
</span><p><span class="original">
    The driving table may be joined to one or more other tables using nested
    loops or hash joins.  The outer side of the join may be any kind of
    non-parallel plan that is otherwise supported by the planner provided that
    it is safe to run within a parallel worker.  For example, it may be an
    index scan which looks up a value based on a column taken from the inner
    table. Each worker will execute the outer side of the plan in full, which
    is why merge joins are not supported here. The outer side of a merge join
    will often involve sorting the entire inner table; even if it involves an
    index, it is unlikely to be productive to have multiple processes each
    conduct a full index scan of the inner table.
</span>処理対象のテーブルは、1個以上の他のテーブルとネステッドループか、ハッシュ結合で結合されます。
結合の外側は、パラレルワーカー中で実行しても安全だという条件下で、プランナがサポートするどのような非パラレルプランであっても構いません。
たとえば、内側のテーブルの列の値を参照するインデックススキャンでも構いません。
各々のワーカーは外側のプラン全体を実行します。
これがマージ結合がサポートされていない理由です。
マージ結合の外側は、しばしば内側のテーブル全体のソートを引き起こします。
たとえインデックスが使用されるとしても、内側のテーブルのフルインデックススキャンを行う複数のプロセスを持つのは生産的とは言えません。
  </p></div><div class="sect2" id="parallel-aggregation"><div class="titlepage"><div><div><h3 class="title">15.3.3. パラレル集約</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Aggregation&lt;/title&gt;
</span><p><span class="original">
    It is not possible to perform the aggregation portion of a query entirely
    in parallel.  For example, if a query involves selecting
    &lt;literal&gt;COUNT(*)&lt;/&gt;, each worker could compute a total, but those totals
    would need to combined in order to produce a final answer.  If the query
    involved a &lt;literal&gt;GROUP BY&lt;/&gt; clause, a separate total would need to
    be computed for each group.  Even though aggregation can't be done entirely
    in parallel, queries involving aggregation are often excellent candidates
    for parallel query, because they typically read many rows but return only
    a few rows to the client.  Queries that return many rows to the client
    are often limited by the speed at which the client can read the data,
    in which case parallel query cannot help very much.
</span>クエリの集約部分全体を並列実行するのは不可能です。
たとえば、クエリが<code class="literal">COUNT(*)</code>を検索するとして、個々のワーカーは合計は計算できるでしょう。
しかし、これらの合計値は最終結果を生成するために併合しなければなりません。
もしクエリが<code class="literal">GROUP BY</code>句を実行すると、各々のグループで別々の合計を計算する必要があります。
たとえ集約処理全体がパラレルにならないとしても、集約処理を伴うクエリは、しばしばパラレルクエリの良い候補となります。
集約処理は、典型的には多数の行を読み、少数の行だけをクライアントに返すからです。
多くの行をクライアントに返す処理では、しばしばクライアントがデータを読む速度に制限され、パラレルクエリはあまり助けになりません。
  </p><p><span class="original">
    &lt;productname&gt;PostgreSQL&lt;/&gt; supports parallel aggregation by aggregating
    twice.  First, each process participating in the parallel portion of the
    query performs an aggregation step, producing a partial result for each
    group of which that process is aware.  This is reflected in the plan as
    a &lt;literal&gt;PartialAggregate&lt;/&gt; node.  Second, the partial results are
    transferred to the leader via the &lt;literal&gt;Gather&lt;/&gt; node.  Finally, the
    leader re-aggregates the results across all workers in order to produce
    the final result.  This is reflected in the plan as a
    &lt;literal&gt;FinalizeAggregate&lt;/&gt; node.
</span><span class="productname">PostgreSQL</span>は、集約処理を2回行うことによってパラレル集約処理をサポートします。
まず、クエリのパラレル部分に参加している個々のプロセスが集約ステップを実行し、それぞれのプロセスが認識しているグループに対する部分的な結果を生成します。
これは<code class="literal">PartialAggregate</code>ノードとしてプラン中に反映されています。
次に、<code class="literal">Gather</code>ノードを通じて部分的な結果がリーダーに転送されます。
最後に、最終的な結果を生成するために、リーダーはすべてのワーカーにまたがる結果を再集約します。
これは、<code class="literal">FinalizeAggregate</code>ノードとしてプラン中に反映されています。
  </p><p><span class="original">
    Parallel aggregation is not supported in all situations.  Each aggregate
    must be &lt;link linkend="parallel-safety"&gt;safe&lt;/&gt; for parallelism and must
    have a combine function.  If the aggregate has a transition state of type
    &lt;literal&gt;internal&lt;/&gt;, it must have serialization and deserialization
    functions.  See &lt;xref linkend="sql-createaggregate"&gt; for more details.
    Parallel aggregation is not supported for ordered set aggregates or when
    the query involves &lt;literal&gt;GROUPING SETS&lt;/&gt;.  It can only be used when
    all joins involved in the query are also part of the parallel portion
    of the plan.
</span>どんな状況でもパラレル集約がサポートされているわけではありません。
個々の集約は並列処理<a class="link" href="parallel-safety.html" title="15.4. パラレル安全">安全</a>で、合同関数(combine function)を持っていなければなりません。
その集約が<code class="literal">internal</code>型の遷移状態を持っているならば、シリアライズ関数とデシリアライズ関数を持っていなければなりません。
更なる詳細は<a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>をご覧ください。
パラレル集約は、順序集合集約、あるいはクエリが<code class="literal">GROUPING SETS</code>を実行する場合にはサポートされません。
パラレル集約は、クエリの中で実行されるすべての結合が、プラン中の並列実行部分の一部であるときにのみ利用できます。
  </p></div><div class="sect2" id="parallel-plan-tips"><div class="titlepage"><div><div><h3 class="title">15.3.4. パラレルプランに関するヒント</h3></div></div></div><span class="original">
  &lt;title&gt;Parallel Plan Tips&lt;/title&gt;
</span><p><span class="original">
    If a query that is expected to do so does not produce a parallel plan,
    you can try reducing &lt;xref linkend="guc-parallel-setup-cost"&gt; or
    &lt;xref linkend="guc-parallel-tuple-cost"&gt;.  Of course, this plan may turn
    out to be slower than the serial plan which the planner preferred, but
    this will not always be the case.  If you don't get a parallel
    plan even with very small values of these settings (e.g. after setting
    them both to zero), there may be some reason why the query planner is
    unable to generate a parallel plan for your query.  See
    &lt;xref linkend="when-can-parallel-query-be-used"&gt; and
    &lt;xref linkend="parallel-safety"&gt; for information on why this may be
    the case.
</span>パラレルプランを生成すると期待していたクエリがそうならない場合には、<a class="xref" href="runtime-config-query.html#guc-parallel-setup-cost">parallel_setup_cost</a>または<a class="xref" href="runtime-config-query.html#guc-parallel-tuple-cost">parallel_tuple_cost</a>を減らしてみてください。
もちろん、このプランは結局のところ、プランナが選択した順次実行プランよりも遅いということもあり得ますが、いつもそうだとは限りません。
これらの設定値を非常に小さく（つまり両方とも0に）したにも関わらずパラレルプランを得られない場合、あなたのクエリのためにクエリプランナがパラレルプランを生成できない何か理由があるのかもしれません。
そうしたケースに該当しているかどうかを、<a class="xref" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？">15.2. どのような時にパラレルクエリは使用できるのか？</a>と<a class="xref" href="parallel-safety.html" title="15.4. パラレル安全">15.4. パラレル安全</a>を参照して確認してください。
  </p><p><span class="original">
    When executing a parallel plan, you can use &lt;literal&gt;EXPLAIN (ANALYZE,
    VERBOSE)&lt;/literal&gt; will display per-worker statistics for each plan node.
    This may be useful in determining whether the work is being evenly
    distributed between all plan nodes and more generally in understanding the
    performance characteristics of the plan.
</span>パラレルプランを実行する際には、<code class="literal">EXPLAIN (ANALYZE, VERBOSE)</code>を使って個々のプランノードに対するワーカーごとの状態を表示することができます。
これは、すべてのプランノードに均等に仕事が分散されているかどうかを確認すること、そしてもっと一般的には、プランの性能特性を理解するのに役に立つかもしれません。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="when-can-parallel-query-be-used.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-safety.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">15.2. どのような時にパラレルクエリは使用できるのか？ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 15.4. パラレル安全</td></tr></table></div></body></html>