<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.26. pgcrypto</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="pgbuffercache.html" title="F.25. pg_buffercache" /><link rel="next" href="pgfreespacemap.html" title="F.27. pg_freespacemap" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.26. pgcrypto</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="pgbuffercache.html" title="F.25. pg_buffercache">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="付録F 追加で提供されるモジュール">上へ</a></td><th width="60%" align="center">付録F 追加で提供されるモジュール</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.0文書">ホーム</a></td><td width="10%" align="right"> <a accesskey="n" href="pgfreespacemap.html" title="F.27. pg_freespacemap">次へ</a></td></tr></table><hr></hr></div><div class="sect1" id="pgcrypto"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.26. pgcrypto</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="pgcrypto.html#idm46270476458288">F.26.1. 汎用ハッシュ関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476437568">F.26.2. パスワードハッシュ化関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476338560">F.26.3. PGP暗号化関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476215536">F.26.4. 暗号化そのものを行う関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476186064">F.26.5. ランダムデータ関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476180784">F.26.6. 注釈</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#idm46270476129424">F.26.7. 作者</a></span></dt></dl></div><a id="idm46270476462832" class="indexterm"></a><a id="idm46270476461808" class="indexterm"></a><p><!--
  The <filename>pgcrypto</> module provides cryptographic functions for
  <productname>PostgreSQL</>.
--><code class="filename">pgcrypto</code>モジュールは<span class="productname">PostgreSQL</span>用の暗号関数を提供します。
 </p><div class="sect2" id="idm46270476458288"><div class="titlepage"><div><div><h3 class="title">F.26.1. 汎用ハッシュ関数</h3></div></div></div><!--
  <title>General Hashing Functions</title>
--><div class="sect3" id="idm46270476457600"><div class="titlepage"><div><div><h4 class="title">F.26.1.1. <code class="function">digest()</code></h4></div></div></div><a id="idm46270476456784" class="indexterm"></a><pre class="synopsis">digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea</pre><p><!--
    Computes a binary hash of the given <parameter>data</>.
    <parameter>type</> is the algorithm to use.
    Standard algorithms are <literal>md5</literal>, <literal>sha1</literal>,
    <literal>sha224</literal>, <literal>sha256</literal>,
    <literal>sha384</literal> and <literal>sha512</literal>.
    If <filename>pgcrypto</> was built with
    OpenSSL, more algorithms are available, as detailed in
    <xref linkend="pgcrypto-with-without-openssl">.
-->与えられた<em class="parameter"><code>data</code></em>のバイナリハッシュを計算します。
<em class="parameter"><code>type</code></em>は使用するアルゴリズムです。
標準アルゴリズムは<code class="literal">md5</code>、<code class="literal">sha1</code>、<code class="literal">sha224</code>、<code class="literal">sha256</code>、<code class="literal">sha384</code>、および<code class="literal">sha512</code>です。
<code class="filename">pgcrypto</code>がOpenSSL付きで構築された場合、<a class="xref" href="pgcrypto.html#pgcrypto-with-without-openssl" title="表F.20 OpenSSLの有無による機能のまとめ">表 F.20</a>で詳解する、より多くのアルゴリズムを利用することができます。
   </p><p><!--
    If you want the digest as a hexadecimal string, use
    <function>encode()</> on the result.  For example:
-->ダイジェストを16進数表記の文字列としたい場合は、結果に対して<code class="function">encode()</code>を使用してください。
以下に例を示します。
</p><pre class="programlisting">CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;</pre><p>
   </p></div><div class="sect3" id="idm46270476445072"><div class="titlepage"><div><div><h4 class="title">F.26.1.2. <code class="function">hmac()</code></h4></div></div></div><a id="idm46270476444256" class="indexterm"></a><pre class="synopsis">hmac(data text, key text, type text) returns bytea
hmac(data bytea, key text, type text) returns bytea</pre><p><!--
    Calculates hashed MAC for <parameter>data</> with key <parameter>key</>.
    <parameter>type</> is the same as in <function>digest()</>.
--><em class="parameter"><code>key</code></em>をキーとした<em class="parameter"><code>data</code></em>のハッシュ化MACを計算します。
<em class="parameter"><code>type</code></em>は<code class="function">digest()</code>の場合と同じです。
   </p><p><!--
    This is similar to <function>digest()</> but the hash can only be
    recalculated knowing the key.  This prevents the scenario of someone
    altering data and also changing the hash to match.
--><code class="function">digest()</code>と似ていますが、ハッシュはキーを知っている場合にのみ再計算できます。
これは、誰かがデータを変更し、同時に一致するようにハッシュを変更するという状況を防ぎます。
   </p><p><!--
    If the key is larger than the hash block size it will first be hashed and
    the result will be used as key.
-->キーがハッシュブロックサイズより大きい場合、まずハッシュ化され、その結果をキーとして使用します。
   </p></div></div><div class="sect2" id="idm46270476437568"><div class="titlepage"><div><div><h3 class="title">F.26.2. パスワードハッシュ化関数</h3></div></div></div><!--
  <title>Password Hashing Functions</title>
--><p><!--
   The functions <function>crypt()</> and <function>gen_salt()</>
   are specifically designed for hashing passwords.
   <function>crypt()</> does the hashing and <function>gen_salt()</>
   prepares algorithm parameters for it.
--><code class="function">crypt()</code>および<code class="function">gen_salt()</code>関数は特にパスワードのハッシュ化のために設計されたものです。
<code class="function">crypt()</code>がハッシュ処理を行い、<code class="function">gen_salt()</code>はハッシュ処理用のアルゴリズム上のパラメータを準備します。
  </p><p><!--
   The algorithms in <function>crypt()</> differ from the usual
   MD5 or SHA1 hashing algorithms in the following respects:
--><code class="function">crypt()</code>アルゴリズムは、以下の点で通常のMD5やSHA1のようなハッシュ処理アルゴリズムと異なります。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
     They are slow.  As the amount of data is so small, this is the only
     way to make brute-forcing passwords hard.
-->低速です。
データ量が少ないためパスワード総当たり攻撃に対して頑健にする唯一の方法です。
    </p></li><li class="listitem"><p><!--
     They use a random value, called the <firstterm>salt</>, so that users
     having the same password will have different encrypted passwords.
     This is also an additional defense against reversing the algorithm.
-->結果には<em class="firstterm">ソルト</em>というランダムな値が含まれます。
このため同じパスワードのユーザでも異なった暗号化パスワードを持ちます。
これはアルゴリズムの逆処理に対する追加の防御です。
    </p></li><li class="listitem"><p><!--
     They include the algorithm type in the result, so passwords hashed with
     different algorithms can co-exist.
-->結果内にアルゴリズムの種類が含まれます。
このため異なるアルゴリズムでハッシュ化したパスワードが混在可能です。
    </p></li><li class="listitem"><p><!--
     Some of them are adaptive &mdash; that means when computers get
     faster, you can tune the algorithm to be slower, without
     introducing incompatibility with existing passwords.
-->一部は適応型です。
つまり、コンピュータが高速になったとしても、既存のパスワードとの互換性を損なうことなくアルゴリズムを低速に調整することができます。
    </p></li></ol></div><p><!--
   <xref linkend="pgcrypto-crypt-algorithms"> lists the algorithms
   supported by the <function>crypt()</function> function.
--><code class="function">crypt()</code>関数がサポートするアルゴリズムを<a class="xref" href="pgcrypto.html#pgcrypto-crypt-algorithms" title="表F.17 crypt()がサポートするアルゴリズム">表 F.17</a>に列挙します。
  </p><div class="table" id="pgcrypto-crypt-algorithms"><p class="title"><strong>表F.17 <code class="function">crypt()</code>がサポートするアルゴリズム</strong></p><div class="table-contents"><!--
   <title>Supported Algorithms for <function>crypt()</></title>
--><table class="table" summary="crypt()がサポートするアルゴリズム" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>パスワード最大長</th><th>適応型かどうか</th><th>ソルトビット長</th><th>出力長</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">bf</code></td><td>72</td><td>はい</td><td>128</td><td>60</td><td>Blowfishベース、2a版</td></tr><tr><td><code class="literal">md5</code></td><td>無制限</td><td>いいえ</td><td>48</td><td>34</td><td>MD5ベースの暗号</td></tr><tr><td><code class="literal">xdes</code></td><td>8</td><td>はい</td><td>24</td><td>20</td><td>拡張DES</td></tr><tr><td><code class="literal">des</code></td><td>8</td><td>いいえ</td><td>12</td><td>13</td><td>元来のUNIX crypt</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" id="idm46270476410384"><div class="titlepage"><div><div><h4 class="title">F.26.2.1. <code class="function">crypt()</code></h4></div></div></div><a id="idm46270476409568" class="indexterm"></a><pre class="synopsis">crypt(password text, salt text) returns text</pre><p><!--
    Calculates a crypt(3)-style hash of <parameter>password</>.
    When storing a new password, you need to use
    <function>gen_salt()</> to generate a new <parameter>salt</> value.
    To check a password, pass the stored hash value as <parameter>salt</>,
    and test whether the result matches the stored value.
--><em class="parameter"><code>password</code></em>のcrypt(3)形式のハッシュを計算します。
新しいパスワードを保管する時には、<code class="function">gen_salt()</code>を使用して新しい<em class="parameter"><code>salt</code></em>を生成する必要があります。
パスワードを検査する時、既存のハッシュ値を<em class="parameter"><code>salt</code></em>として渡し、結果が格納された値と一致するかどうかを確認します。
   </p><p><!--
    Example of setting a new password:
-->新しいパスワードの設定例を以下に示します。
</p><pre class="programlisting">UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));</pre><p>
   </p><p><!--
    Example of authentication:
-->認証の例です。
</p><pre class="programlisting">SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;</pre><p><!--
    This returns <literal>true</> if the entered password is correct.
-->
入力パスワードが正しければ<code class="literal">true</code>を返します。
   </p></div><div class="sect3" id="idm46270476401040"><div class="titlepage"><div><div><h4 class="title">F.26.2.2. <code class="function">gen_salt()</code></h4></div></div></div><a id="idm46270476400224" class="indexterm"></a><pre class="synopsis">gen_salt(type text [, iter_count integer ]) returns text</pre><p><!--
    Generates a new random salt string for use in <function>crypt()</>.
    The salt string also tells <function>crypt()</> which algorithm to use.
--><code class="function">crypt()</code>で使用するランダムなソルト文字列を新規に生成します。
また、このソルト文字列は<code class="function">crypt()</code>にどのアルゴリズムを使用するかを通知します。
   </p><p><!--
    The <parameter>type</> parameter specifies the hashing algorithm.
    The accepted types are: <literal>des</literal>, <literal>xdes</literal>,
    <literal>md5</literal> and <literal>bf</literal>.
--><em class="parameter"><code>type</code></em>パラメータはハッシュ化アルゴリズムを指定します。
受付可能な種類は、<code class="literal">des</code>、<code class="literal">xdes</code>、<code class="literal">md5</code>、<code class="literal">bf</code>です。
   </p><p><!--
    The <parameter>iter_count</> parameter lets the user specify the iteration
    count, for algorithms that have one.
    The higher the count, the more time it takes to hash
    the password and therefore the more time to break it.  Although with
    too high a count the time to calculate a hash may be several years
    &mdash; which is somewhat impractical.  If the <parameter>iter_count</>
    parameter is omitted, the default iteration count is used.
    Allowed values for <parameter>iter_count</> depend on the algorithm and
    are shown in <xref linkend="pgcrypto-icfc-table">.
-->繰り返し回数を持つアルゴリズムでは、ユーザは<em class="parameter"><code>iter_count</code></em>パラメータを使用して繰り返し回数を指定できます。
指定する回数を高くすれば、パスワードのハッシュ化にかかる時間が長くなり、それを破るための時間も長くなります。
しかし、あまりに多くの回数を指定すると、ハッシュ計算にかかる時間は数年に渡ってしまう可能性があります。
これは実用的ではありません。
<em class="parameter"><code>iter_count</code></em>パラメータを省略した場合、デフォルトの繰り返し回数が使用されます。
<em class="parameter"><code>iter_count</code></em>で受け付けられる値はアルゴリズムに依存し、<a class="xref" href="pgcrypto.html#pgcrypto-icfc-table" title="表F.18 crypt()用の繰り返し回数">表 F.18</a>に示す通りです。
   </p><div class="table" id="pgcrypto-icfc-table"><p class="title"><strong>表F.18 <code class="function">crypt()</code>用の繰り返し回数</strong></p><div class="table-contents"><!--
    <title>Iteration Counts for <function>crypt()</></title>
--><table class="table" summary="crypt()用の繰り返し回数" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>デフォルト</th><th>最小</th><th>最大</th></tr></thead><tbody><tr><td><code class="literal">xdes</code></td><td>725</td><td>1</td><td>16777215</td></tr><tr><td><code class="literal">bf</code></td><td>6</td><td>4</td><td>31</td></tr></tbody></table></div></div><br class="table-break" /><p><!--
    For <literal>xdes</literal> there is an additional limitation that the
    iteration count must be an odd number.
--><code class="literal">xdes</code>の場合は他にも、回数が奇数でなければならないという制限があります。
   </p><p><!--
    To pick an appropriate iteration count, consider that
    the original DES crypt was designed to have the speed of 4 hashes per
    second on the hardware of that time.
    Slower than 4 hashes per second would probably dampen usability.
    Faster than 100 hashes per second is probably too fast.
-->適切な繰り返し回数を選択するために、元々のDES暗号は当時のハードウェアで1秒あたり4個のハッシュを持つことができるように設計されたことを考えてください。
毎秒4ハッシュより遅いと、おそらく使い勝手が悪いでしょう。
毎秒100ハッシュより速いというのは、十中八九、あまりにも速すぎるでしょう。
   </p><p><!--
    <xref linkend="pgcrypto-hash-speed-table"> gives an overview of the relative slowness
    of different hashing algorithms.
    The table shows how much time it would take to try all
    combinations of characters in an 8-character password, assuming
    that the password contains either only lower case letters, or
    upper- and lower-case letters and numbers.
    In the <literal>crypt-bf</literal> entries, the number after a slash is
    the <parameter>iter_count</parameter> parameter of
    <function>gen_salt</function>.
-->ハッシュ化アルゴリズム別に相対的な速度に関する概要を<a class="xref" href="pgcrypto.html#pgcrypto-hash-speed-table" title="表F.19 ハッシュアルゴリズムの速度">表 F.19</a>にまとめました。
この表は、8文字のパスワード内のすべての文字の組合せを取るためにかかる時間を示します。
また、すべて小文字の英字のみのパスワードである場合と大文字小文字が混在した英字と数字のパスワードの場合を仮定します。
<code class="literal">crypt-bf</code>の項では、スラッシュの後の数値は<code class="function">gen_salt</code>の<em class="parameter"><code>iter_count</code></em>です。
   </p><div class="table" id="pgcrypto-hash-speed-table"><p class="title"><strong>表F.19 ハッシュアルゴリズムの速度</strong></p><div class="table-contents"><!--
    <title>Hash Algorithm Speeds</title>
--><table class="table" summary="ハッシュアルゴリズムの速度" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>1秒当たりのハッシュ数</th><th><code class="literal">[a-z]</code>の場合</th><th><code class="literal">[A-Za-z0-9]</code>の場合</th><th><code class="literal">md5ハッシュ</code>を単位とした持続期間</th></tr></thead><tbody><tr><td><code class="literal">crypt-bf/8</code></td><td>1792</td><td>4年</td><td>3927年</td><td>100k</td></tr><tr><td><code class="literal">crypt-bf/7</code></td><td>3648</td><td>2年</td><td>1929年</td><td>50k</td></tr><tr><td><code class="literal">crypt-bf/6</code></td><td>7168</td><td>1年</td><td>982年</td><td>25k</td></tr><tr><td><code class="literal">crypt-bf/5</code></td><td>13504</td><td>188日</td><td>521年</td><td>12.5k</td></tr><tr><td><code class="literal">crypt-md5</code></td><td>171584</td><td>15日</td><td>41年</td><td>1k</td></tr><tr><td><code class="literal">crypt-des</code></td><td>23221568</td><td>157.5分</td><td>108日</td><td>7</td></tr><tr><td><code class="literal">sha1</code></td><td>37774272</td><td>90分</td><td>68日</td><td>4</td></tr><tr><td><code class="literal">md5</code>(ハッシュ)</td><td>150085504</td><td>22.5分</td><td>17日</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p><!--
    Notes:
-->注意：
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><!--
     The machine used is an Intel Mobile Core i3.
-->Intel Mobile Core i3のマシンを使用しました。
     </p></li><li class="listitem"><p><!--
      <literal>crypt-des</> and <literal>crypt-md5</> algorithm numbers are
      taken from John the Ripper v1.6.38 <literal>-test</> output.
--><code class="literal">crypt-des</code>および<code class="literal">crypt-md5</code>アルゴリズムの数値はJohn the Ripper v1.6.38の<code class="literal">-test</code>出力から得たものです。
     </p></li><li class="listitem"><p><!--
      <literal>md5 hash</> numbers are from mdcrack 1.2.
--><code class="literal">md5ハッシュ</code>の数値はmdcrack 1.2のものです。
     </p></li><li class="listitem"><p><!--
      <literal>sha1</> numbers are from lcrack-20031130-beta.
--><code class="literal">sha1</code>の数値はlcrack-20031130-betaのものです。
     </p></li><li class="listitem"><p><!--
      <literal>crypt-bf</literal> numbers are taken using a simple program that
      loops over 1000 8-character passwords.  That way I can show the speed
      with different numbers of iterations.  For reference: <literal>john
      -test</literal> shows 13506 loops/sec for <literal>crypt-bf/5</>.
      (The very small
      difference in results is in accordance with the fact that the
      <literal>crypt-bf</literal> implementation in <filename>pgcrypto</>
      is the same one used in John the Ripper.)
--><code class="literal">crypt-bf</code>の数は、1000個の8文字パスワードをループする単純なプログラムを使用して得たものです。
こうして、異なる回数の速度を示すことができました。
参考までに、<code class="literal">john -test</code>は<code class="literal">crypt-bf/5</code>で13506 loops/secでした。
（結果の差異が非常に小さいことは、<code class="filename">pgcrypto</code>における<code class="literal">crypt-bf</code>実装がJohn the Ripperで使用されるものと同じであるという事実と一致します。）
     </p></li></ul></div><p><!--
    Note that <quote>try all combinations</quote> is not a realistic exercise.
    Usually password cracking is done with the help of dictionaries, which
    contain both regular words and various mutations of them.  So, even
    somewhat word-like passwords could be cracked much faster than the above
    numbers suggest, while a 6-character non-word-like password may escape
    cracking.  Or not.
--><span class="quote">「<span class="quote">すべての組み合わせを試行する</span>」</span>ことは現実的な行使ではありません。
通常パスワード推定は、普通の単語とその変形の両方を含む辞書を使用して行われます。
ですので、いささかなりとも言葉に似たパスワードは上で示した数値よりも速く推定されます。
また6文字の単語に似ていないパスワードは推定を免れるかもしれませんし、免れないかもしれません。
   </p></div></div><div class="sect2" id="idm46270476338560"><div class="titlepage"><div><div><h3 class="title">F.26.3. PGP暗号化関数</h3></div></div></div><!--
  <title>PGP Encryption Functions</title>
--><p><!--
   The functions here implement the encryption part of the OpenPGP (RFC 4880)
   standard.  Supported are both symmetric-key and public-key encryption.
-->ここで示す関数はOpenPGP（RFC 4880）標準の暗号処理部分を実装します。
対称鍵および公開鍵暗号化がサポートされます。
  </p><p><!--
   An encrypted PGP message consists of 2 parts, or <firstterm>packets</>:
-->暗号化されたPGPメッセージは次の2つの部品（または<em class="firstterm">パケット</em>）から構成されます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><!--
     Packet containing a session key &mdash; either symmetric-key or public-key
     encrypted.
-->セッションキーを含むパケット。
対称鍵または公開鍵で暗号化されています。
    </p></li><li class="listitem"><p><!--
     Packet containing data encrypted with the session key.
-->セッションキーにより暗号化されたデータを含むパケット。
    </p></li></ul></div><p><!--
   When encrypting with a symmetric key (i.e., a password):
-->対称鍵（つまりパスワード）で暗号化する場合
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
     The given password is hashed using a String2Key (S2K) algorithm.  This is
     rather similar to <function>crypt()</> algorithms &mdash; purposefully
     slow and with random salt &mdash; but it produces a full-length binary
     key.
-->与えられたパスワードはString2Key(S2K)アルゴリズムでハッシュ化されます。
これはどちらかというと<code class="function">crypt()</code>アルゴリズムと似て、意図的に低速で、かつランダムなソルトを使用します。
しかし、全長のバイナリキーを生成します。
    </p></li><li class="listitem"><p><!--
     If a separate session key is requested, a new random key will be
     generated.  Otherwise the S2K key will be used directly as the session
     key.
-->分離したセッションキーが要求された場合、新しいランダムなキーが生成されます。
さもなくば、S2Kキーがそのままセッションキーとして使用されます。
    </p></li><li class="listitem"><p><!--
     If the S2K key is to be used directly, then only S2K settings will be put
     into the session key packet.  Otherwise the session key will be encrypted
     with the S2K key and put into the session key packet.
-->S2Kキーがそのまま使用される場合、S2K設定のみがセッションキーパケットに格納されます。
さもなくば、セッションキーはS2Kキーで暗号化され、セッションキーパケットに格納されます。
    </p></li></ol></div><p><!--
   When encrypting with a public key:
-->公開鍵で暗号化する場合
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
     A new random session key is generated.
-->新しいランダムなセッションキーが生成されます。
    </p></li><li class="listitem"><p><!--
     It is encrypted using the public key and put into the session key packet.
-->これは公開鍵を使用して暗号化され、セッションキーパケットに格納されます。
    </p></li></ol></div><p><!--
   In either case the data to be encrypted is processed as follows:
-->どちらの場合でもデータ暗号化は以下のように処理されます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
     Optional data-manipulation: compression, conversion to UTF-8,
     and/or conversion of line-endings.
-->省略可能なデータ操作として、圧縮、UTF-8への変換、改行の変換があります。
    </p></li><li class="listitem"><p><!--
     The data is prefixed with a block of random bytes.  This is equivalent
     to using a random IV.
-->データの前にはランダムなバイト数のブロックが付きます。
これはrandom IVを使用する場合と同じです。
    </p></li><li class="listitem"><p><!--
     An SHA1 hash of the random prefix and data is appended.
-->ランダムな前置ブロックとデータのSHA1ハッシュが後に付けられます。
    </p></li><li class="listitem"><p><!--
     All this is encrypted with the session key and placed in the data packet.
-->これをすべてセッションキーで暗号化し、データパケットに格納します。
    </p></li></ol></div><div class="sect3" id="idm46270476320896"><div class="titlepage"><div><div><h4 class="title">F.26.3.1. <code class="function">pgp_sym_encrypt()</code></h4></div></div></div><a id="idm46270476320080" class="indexterm"></a><a id="idm46270476319392" class="indexterm"></a><pre class="synopsis">pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea</pre><p><!--
    Encrypt <parameter>data</> with a symmetric PGP key <parameter>psw</>.
    The <parameter>options</> parameter can contain option settings,
    as described below.
-->対称PGPキー<em class="parameter"><code>psw</code></em>で<em class="parameter"><code>data</code></em>を暗号化します。
<em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="idm46270476315136"><div class="titlepage"><div><div><h4 class="title">F.26.3.2. <code class="function">pgp_sym_decrypt()</code></h4></div></div></div><a id="idm46270476314320" class="indexterm"></a><a id="idm46270476313632" class="indexterm"></a><pre class="synopsis">pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea</pre><p><!--
    Decrypt a symmetric-key-encrypted PGP message.
-->対称鍵で暗号化されたPGPメッセージを復号します。
   </p><p><!--
    Decrypting <type>bytea</> data with <function>pgp_sym_decrypt</> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_sym_decrypt_bytea</> is fine.
--><code class="function">pgp_sym_decrypt</code>で<code class="type">bytea</code>型のデータを復号することはできません。
これは無効な文字データの出力を防止するためです。
元のテキストのデータを<code class="function">pgp_sym_decrypt_bytea</code>で復号することが正しい方法です。
   </p><p><!--
    The <parameter>options</> parameter can contain option settings,
    as described below.
--><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="idm46270476308128"><div class="titlepage"><div><div><h4 class="title">F.26.3.3. <code class="function">pgp_pub_encrypt()</code></h4></div></div></div><a id="idm46270476307312" class="indexterm"></a><a id="idm46270476306624" class="indexterm"></a><pre class="synopsis">pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea</pre><p><!--
    Encrypt <parameter>data</> with a public PGP key <parameter>key</>.
    Giving this function a secret key will produce an error.
-->公開PGPキー<em class="parameter"><code>key</code></em>で<em class="parameter"><code>data</code></em>を暗号化します。
この関数に秘密キーを与えるとエラーになります。
   </p><p><!--
    The <parameter>options</> parameter can contain option settings,
    as described below.
--><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="idm46270476302016"><div class="titlepage"><div><div><h4 class="title">F.26.3.4. <code class="function">pgp_pub_decrypt()</code></h4></div></div></div><a id="idm46270476301200" class="indexterm"></a><a id="idm46270476300512" class="indexterm"></a><pre class="synopsis">pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea</pre><p><!--
    Decrypt a public-key-encrypted message.  <parameter>key</> must be the
    secret key corresponding to the public key that was used to encrypt.
    If the secret key is password-protected, you must give the password in
    <parameter>psw</>.  If there is no password, but you want to specify
    options, you need to give an empty password.
-->公開鍵で暗号化されたメッセージを復号します。
<em class="parameter"><code>key</code></em>は、暗号化に使用した公開鍵に対応する秘密鍵でなければなりません。
秘密鍵がパスワードで保護されている場合は、そのパスワードを<em class="parameter"><code>psw</code></em>で指定しなければなりません。
パスワードはないが、オプションを指定したい場合は空のパスワードを指定する必要があります。
   </p><p><!--
    Decrypting <type>bytea</> data with <function>pgp_pub_decrypt</> is disallowed.
    This is to avoid outputting invalid character data.  Decrypting
    originally textual data with <function>pgp_pub_decrypt_bytea</> is fine.
--><code class="function">pgp_pub_decrypt</code>で<code class="type">bytea</code>型のデータを復号することはできません。
これは無効な文字データの出力を防止するためです。
元のテキストのデータを<code class="function">pgp_pub_decrypt_bytea</code>で復号することが正しい方法です。
   </p><p><!--
    The <parameter>options</> parameter can contain option settings,
    as described below.
--><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="idm46270476292896"><div class="titlepage"><div><div><h4 class="title">F.26.3.5. <code class="function">pgp_key_id()</code></h4></div></div></div><a id="idm46270476292080" class="indexterm"></a><pre class="synopsis">pgp_key_id(bytea) returns text</pre><p><!--
    <function>pgp_key_id</> extracts the key ID of a PGP public or secret key.
    Or it gives the key ID that was used for encrypting the data, if given
    an encrypted message.
--><code class="function">pgp_key_id</code>はPGP公開鍵または秘密鍵のキーIDを取り出します。
暗号化されたメッセージが指定された場合は、データの暗号化に使用されたキーIDを与えます。
   </p><p><!--
    It can return 2 special key IDs:
-->2つの特殊なキーIDを返すことがあります。
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>      <code class="literal">SYMKEY</code>
     </p><p><!--
      The message is encrypted with a symmetric key.
-->メッセージは対称鍵で暗号化されました。
     </p></li><li class="listitem"><p>      <code class="literal">ANYKEY</code>
     </p><p><!--
      The message is public-key encrypted, but the key ID has been removed.
      That means you will need to try all your secret keys on it to see
      which one decrypts it.  <filename>pgcrypto</> itself does not produce
      such messages.
-->メッセージは公開鍵で暗号化されましたが、キーIDが消去されていました。
つまり、どれで復号できるかを判定するためにはすべての秘密キーを試行しなければならないことを意味します。
<code class="filename">pgcrypto</code>自身はこうしたメッセージを生成しません。
     </p></li></ul></div><p><!--
    Note that different keys may have the same ID.   This is rare but a normal
    event. The client application should then try to decrypt with each one,
    to see which fits &mdash; like handling <literal>ANYKEY</>.
-->異なるキーが同一IDを持つ場合があることに注意してください。
これは稀ですが、正常なイベントです。
この場合クライアントアプリケーションはどちらが当てはまるかを調べるために、<code class="literal">ANYKEY</code>の場合と同様に、それぞれのキーで復号を試行しなければなりません。
   </p></div><div class="sect3" id="idm46270476282592"><div class="titlepage"><div><div><h4 class="title">F.26.3.6. <code class="function">armor()</code>, <code class="function">dearmor()</code></h4></div></div></div><a id="idm46270476281088" class="indexterm"></a><a id="idm46270476280400" class="indexterm"></a><pre class="synopsis">armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea</pre><p><!--
    These functions wrap/unwrap binary data into PGP ASCII-armor format,
    which is basically Base64 with CRC and additional formatting.
-->PGPのASCIIアーマー形式にデータを隠す、または、データを取り出します。
ASCIIアーマーは基本的にCRC付きのBASE64という形式で、追加のフォーマットがあります。
   </p><p><!--
    If the <parameter>keys</> and <parameter>values</> arrays are specified,
    an <firstterm>armor header</> is added to the armored format for each
    key/value pair. Both arrays must be single-dimensional, and they must
    be of the same length.  The keys and values cannot contain any non-ASCII
    characters.
--><em class="parameter"><code>keys</code></em>と<em class="parameter"><code>values</code></em>の配列が指定された場合には、各キーと値の対に対して<em class="firstterm">アーマーヘッダ</em>がアーマー形式に追加されます。
どちらの配列も1次元で、同じ長さでなければなりません。
keysとvaluesに非ASCII文字を含めることはできません。
   </p></div><div class="sect3" id="idm46270476275296"><div class="titlepage"><div><div><h4 class="title">F.26.3.7. <code class="function">pgp_armor_headers</code></h4></div></div></div><a id="idm46270476274480" class="indexterm"></a><pre class="synopsis">pgp_armor_headers(data text, key out text, value out text) returns setof record</pre><p><!--
    <function>pgp_armor_headers()</> extracts the armor headers from
    <parameter>data</>.  The return value is a set of rows with two columns,
    key and value.  If the keys or values contain any non-ASCII characters,
    they are treated as UTF-8.
--><code class="function">pgp_armor_headers()</code>は<em class="parameter"><code>data</code></em>からアーマーヘッダを取り出します。
戻り値はキーと値の2つの列からなる行の集合です。
もしキーや値に非アスキー文字が含まれていれば、UTF-8として扱われます。
   </p></div><div class="sect3" id="idm46270476270976"><div class="titlepage"><div><div><h4 class="title">F.26.3.8. PGP関数用のオプション</h4></div></div></div><!--
   <title>Options for PGP Functions</title>
--><p><!--
    Options are named to be similar to GnuPG.  An option's value should be
    given after an equal sign; separate options from each other with commas.
    For example:
-->オプションはGnuPGに似せて命名しています。
オプションの値は等号記号の後に指定しなければなりません。
複数のオプションはカンマで区切ってください。
以下に例を示します。
</p><pre class="programlisting">pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')</pre><p>
   </p><p><!--
    All of the options except <literal>convert-crlf</literal> apply only to
    encrypt functions.  Decrypt functions get the parameters from the PGP
    data.
--><code class="literal">convert-crlf</code>を除くすべてのオプションは暗号化関数にのみ適用可能です。
復号関数はPGPデータからこうしたパラメータを入手します。
   </p><p><!--
    The most interesting options are probably
    <literal>compress-algo</literal> and <literal>unicode-mode</literal>.
    The rest should have reasonable defaults.
-->もっとも興味深いオプションはおそらく<code class="literal">compress-algo</code>と<code class="literal">unicode-mode</code>でしょう。
残りはデフォルトで問題ないはずです。
   </p><div class="sect4" id="idm46270476265344"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.1. cipher-algo</h5></div></div></div><p><!--
    Which cipher algorithm to use.
-->使用する暗号アルゴリズム。
   </p><div class="literallayout"><p><!--
Values: bf, aes128, aes192, aes256 (OpenSSL-only: <literal>3des</literal>, <literal>cast5</literal>)
Default: aes128
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->値: bf, aes128, aes192, aes256 (OpenSSL-only: <code class="literal">3des</code>, <code class="literal">cast5</code>)<br />
デフォルト: aes128<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="idm46270476261776"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.2. compress-algo</h5></div></div></div><p><!--
    Which compression algorithm to use.  Only available if
    <productname>PostgreSQL</productname> was built with zlib.
-->使用する圧縮アルゴリズム。
<span class="productname">PostgreSQL</span>がzlib付きで構築されている場合のみ利用可能です。
   </p><div class="literallayout"><p><!--
Values:
  0 - no compression
  1 - ZIP compression
  2 - ZLIB compression (= ZIP plus meta-data and block CRCs)
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->値:<br />
 0 - 非圧縮<br />
 1 - ZIP圧縮<br />
 2 - ZLIB圧縮 (ZIPにメタデータとブロックCRCを加えたもの)<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="idm46270476258576"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.3. compress-level</h5></div></div></div><p><!--
    How much to compress.  Higher levels compress smaller but are slower.
    0 disables compression.
-->どの程度圧縮するかです。
レベルが大きい程小さくなりますが、低速になります。
0は圧縮を無効にします。
   </p><div class="literallayout"><p><!--
Values: 0, 1-9
Default: 6
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->値: 0, 1-9<br />
デフォルト: 6<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="idm46270476256448"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.4. convert-crlf</h5></div></div></div><p><!--
    Whether to convert <literal>\n</literal> into <literal>\r\n</literal> when
    encrypting and <literal>\r\n</literal> to <literal>\n</literal> when
    decrypting.  RFC 4880 specifies that text data should be stored using
    <literal>\r\n</literal> line-feeds.  Use this to get fully RFC-compliant
    behavior.
-->暗号化の際に<code class="literal">\n</code>を<code class="literal">\r\n</code>に、復号の際に<code class="literal">\r\n</code> を<code class="literal">\n</code> に変換するかどうか。
RFC 4880では、テキストデータは改行コードとして<code class="literal">\r\n</code> を使用して格納すべきであると規定されています。
完全にRFC準拠の動作を行いたければ、これを使用してください。
   </p><div class="literallayout"><p><!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
-->値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</p></div></div><div class="sect4" id="idm46270476250064"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.5. disable-mdc</h5></div></div></div><p><!--
    Do not protect data with SHA-1.  The only good reason to use this
    option is to achieve compatibility with ancient PGP products, predating
    the addition of SHA-1 protected packets to RFC 4880.
    Recent gnupg.org and pgp.com software supports it fine.
-->データをSHA-1で保護しません。
このオプションを使用することが良い唯一の理由は、SHA-1で保護されたパケットがRFC 4880に追加される前の、古いPGP製品との互換性を得るためです。
最近のgnupg.orgおよびpgp.comのソフトウェアではこれを正しくサポートしています。
   </p><div class="literallayout"><p><!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="idm46270476247056"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.6. sess-key</h5></div></div></div><p><!--
    Use separate session key.  Public-key encryption always uses a separate
    session key; this option is for symmetric-key encryption, which by default
    uses the S2K key directly.
-->分離したセッションキーを使用します。
公開鍵暗号では常に分離したセッションキーを使用します。
このオプションは対称鍵暗号向けのもので、デフォルトではS2Kキーをそのまま使用します。
   </p><div class="literallayout"><p><!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt
-->値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="idm46270476244704"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.7. s2k-mode</h5></div></div></div><p><!--
    Which S2K algorithm to use.
-->使用するS2Kアルゴリズム。
   </p><div class="literallayout"><p><!--
Values:
  0 - Without salt.  Dangerous!
  1 - With salt but with fixed iteration count.
  3 - Variable iteration count.
Default: 3
Applies to: pgp_sym_encrypt
-->値:<br />
  0 - ソルト無。危険です!<br />
  1 - ソルト有。固定繰り返し回数。<br />
  3 - 可変繰り返し回数。<br />
デフォルト: 3<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="idm46270476242496"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.8. s2k-count</h5></div></div></div><p><!--
    The number of iterations of the S2K algorithm to use.  It must
    be a value between 1024 and 65011712, inclusive.
-->使用するS2Kアルゴリズムで使う繰り返しの回数。
1024以上、65011712以下の値でなければなりません。
   </p><div class="literallayout"><p><!--
Default: A random value between 65536 and 253952
Applies to: pgp_sym_encrypt, only with s2k-mode=3
-->デフォルト: 65536から253952までの乱数値<br />
適用範囲: s2k-mode=3と指定した時のpgp_sym_encrypt</p></div></div><div class="sect4" id="idm46270476240192"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.9. s2k-digest-algo</h5></div></div></div><p><!--
    Which digest algorithm to use in S2K calculation.
-->S2K計算で使用するダイジェストアルゴリズム。
   </p><div class="literallayout"><p><!--
Values: md5, sha1
Default: sha1
Applies to: pgp_sym_encrypt
-->値: md5, sha1<br />
デフォルト: sha1<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="idm46270476238064"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.10. s2k-cipher-algo</h5></div></div></div><p><!--
    Which cipher to use for encrypting separate session key.
-->分離したセッションキーの暗号化に使用する暗号。
   </p><div class="literallayout"><p><!--
Values: bf, aes, aes128, aes192, aes256
Default: use cipher-algo
Applies to: pgp_sym_encrypt
-->値: bf, aes, aes128, aes192, aes256<br />
デフォルト: cipher-algoを使用<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="idm46270476235792"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.11. unicode-mode</h5></div></div></div><p><!--
    Whether to convert textual data from database internal encoding to
    UTF-8 and back.  If your database already is UTF-8, no conversion will
    be done, but the message will be tagged as UTF-8.  Without this option
    it will not be.
-->テキストデータをデータベース内部符号化方式からUTF-8に変換して戻すかどうかです。
データベースがすでにUTF-8であれば、変換は起こらず、データにUTF-8としてタグが付くのみです。
このオプションがないと、何も行われません。
   </p><div class="literallayout"><p><!--
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
-->値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div></div><div class="sect3" id="idm46270476233024"><div class="titlepage"><div><div><h4 class="title">F.26.3.9. GnuPGを使用したキーの生成</h4></div></div></div><!--
  <title>Generating PGP Keys with GnuPG</title>
--><p><!--
   To generate a new key:
-->新しいキーを生成します。
</p><pre class="programlisting">gpg --gen-key</pre><p>
  </p><p><!--
   The preferred key type is <quote>DSA and Elgamal</>.
-->推奨するキー種類は<span class="quote">「<span class="quote">DSAとElgamal</span>」</span>です。
  </p><p><!--
   For RSA encryption you must create either DSA or RSA sign-only key
   as master and then add an RSA encryption subkey with
   <literal>gpg &#045;&#045;edit-key</literal>.
-->RSA暗号化のためには、マスタとしてDSAまたはRSAで署名のみのキーを作成し、そして<code class="literal">gpg --edit-key</code>を使用してRSAで暗号化された副キーを追加しなければなりません
  </p><p><!--
   To list keys:
-->キーを列挙します。
</p><pre class="programlisting">gpg --list-secret-keys</pre><p>
  </p><p><!--
   To export a public key in ASCII-armor format:
-->ASCIIアーマー形式で公開鍵をエクスポートします。
</p><pre class="programlisting">gpg -a --export KEYID &gt; public.key</pre><p>
  </p><p><!--
   To export a secret key in ASCII-armor format:
-->ASCIIアーマー形式の秘密鍵をエクスポートします。
</p><pre class="programlisting">gpg -a --export-secret-keys KEYID &gt; secret.key</pre><p>
  </p><p><!--
   You need to use <function>dearmor()</> on these keys before giving them to
   the PGP functions.  Or if you can handle binary data, you can drop
   <literal>-a</literal> from the command.
-->PGP関数にこれらのキーを渡す前に<code class="function">dearmor()</code>を使用する必要があります。
バイナリデータを扱うことができる場合、gpgから<code class="literal">-a</code>フラグを省略することができます。
  </p><p><!--
   For more details see <literal>man gpg</literal>,
   <ulink url="http://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink> and other documentation on
   <ulink url="http://www.gnupg.org"></ulink>.
-->詳細は<code class="literal">man gpg</code>、<a class="ulink" href="http://www.gnupg.org/gph/en/manual.html" target="_top">The GNU Privacy Handbook</a>、<a class="ulink" href="http://www.gnupg.org" target="_top">http://www.gnupg.org</a>サイトの各種文書を参照してください。
  </p></div><div class="sect3" id="idm46270476219920"><div class="titlepage"><div><div><h4 class="title">F.26.3.10. PGPコードの制限</h4></div></div></div><!--
  <title>Limitations of PGP Code</title>
--><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><!--
    No support for signing.  That also means that it is not checked
    whether the encryption subkey belongs to the master key.
-->署名に関するサポートはありません。
これはまた、暗号化副キーがマスタキーに属しているかどうか検査しないことを意味します。
    </p></li><li class="listitem"><p><!--
    No support for encryption key as master key.  As such practice
    is generally discouraged, this should not be a problem.
-->マスタキーとして暗号化キーをサポートしません。
一般的にこうした状況は現実的ではありませんので、問題にならないはずです。
    </p></li><li class="listitem"><p><!--
    No support for several subkeys.  This may seem like a problem, as this
    is common practice.  On the other hand, you should not use your regular
    GPG/PGP keys with <filename>pgcrypto</>, but create new ones,
    as the usage scenario is rather different.
-->複数の副キーに関するサポートはありません。
よくありますので、これは問題になりそうに見えます。
一方、通常のGPG/PGPキーを<code class="filename">pgcrypto</code>で使用すべきではありません。
使用する状況が多少異なりますので新しく作成してください。
    </p></li></ul></div></div></div><div class="sect2" id="idm46270476215536"><div class="titlepage"><div><div><h3 class="title">F.26.4. 暗号化そのものを行う関数</h3></div></div></div><!--
  <title>Raw Encryption Functions</title>
--><p><!--
   These functions only run a cipher over data; they don't have any advanced
   features of PGP encryption.  Therefore they have some major problems:
-->これらの関数はデータ全体を暗号化するためだけに実行します。
PGP暗号化の持つ先端的な機能はありません。
したがって、大きな問題がいくつか存在します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
    They use user key directly as cipher key.
-->暗号キーとしてユーザキーをそのまま使用します。
    </p></li><li class="listitem"><p><!--
    They don't provide any integrity checking, to see
    if the encrypted data was modified.
-->暗号化されたデータが変更されたかどうかを確認するための整合性検査をまったく提供しません。
    </p></li><li class="listitem"><p><!--
    They expect that users manage all encryption parameters
    themselves, even IV.
-->ユーザが、IVをも含め暗号化パラメータ自体をすべて管理していることを想定しています。
    </p></li><li class="listitem"><p><!--
    They don't handle text.
-->テキストは扱いません。
    </p></li></ol></div><p><!--
   So, with the introduction of PGP encryption, usage of raw
   encryption functions is discouraged.
-->このため、PGP暗号化の導入もあり、暗号化のみの関数はあまり使用されません。
  </p><a id="idm46270476209808" class="indexterm"></a><a id="idm46270476209232" class="indexterm"></a><a id="idm46270476208544" class="indexterm"></a><a id="idm46270476207856" class="indexterm"></a><pre class="synopsis">encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea</pre><p><!--
   Encrypt/decrypt data using the cipher method specified by
   <parameter>type</parameter>.  The syntax of the
   <parameter>type</parameter> string is:
--><em class="parameter"><code>type</code></em>で指定した暗号方法を使用してデータの暗号化・復号を行います。
<em class="parameter"><code>type</code></em>文字列の構文は以下の通りです。

</p><pre class="synopsis"><em class="replaceable"><code>algorithm</code></em> [<span class="optional"> <code class="literal">-</code> <em class="replaceable"><code>mode</code></em> </span>] [<span class="optional"> <code class="literal">/pad:</code> <em class="replaceable"><code>padding</code></em> </span>]</pre><p><!--
   where <replaceable>algorithm</> is one of:
-->
ここで<em class="replaceable"><code>algorithm</code></em>は以下の1つです。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">bf</code> — Blowfish</p></li><li class="listitem"><p><code class="literal">aes</code> — AES (Rijndael-128)</p></li></ul></div><p><!--
   and <replaceable>mode</> is one of:
-->
また<em class="replaceable"><code>mode</code></em>は以下の1つです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><!--
    <literal>cbc</literal> &mdash; next block depends on previous (default)
--><code class="literal">cbc</code> — 次のブロックは前ブロックに依存します（デフォルト）
    </p></li><li class="listitem"><p><!--
    <literal>ecb</literal> &mdash; each block is encrypted separately (for
    testing only)
--><code class="literal">ecb</code> — 各ブロックは独自に暗号化されます（試験用途のみ）
    </p></li></ul></div><p><!--
   and <replaceable>padding</> is one of:
-->
<em class="replaceable"><code>padding</code></em>は以下の1つです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><!--
    <literal>pkcs</literal> &mdash; data may be any length (default)
--><code class="literal">pkcs</code> — データ長に制限はありません（デフォルト）
    </p></li><li class="listitem"><p><!--
    <literal>none</literal> &mdash; data must be multiple of cipher block size
--><code class="literal">none</code> — データは暗号ブロックサイズの倍数でなければなりません
    </p></li></ul></div><p>
  </p><p><!--
   So, for example, these are equivalent:
-->このため、例えば以下は同じです。
</p><pre class="programlisting">encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')</pre><p>
  </p><p><!--
   In <function>encrypt_iv</> and <function>decrypt_iv</>, the
   <parameter>iv</> parameter is the initial value for the CBC mode;
   it is ignored for ECB.
   It is clipped or padded with zeroes if not exactly block size.
   It defaults to all zeroes in the functions without this parameter.
--><code class="function">encrypt_iv</code>および<code class="function">decrypt_iv</code>では、<em class="parameter"><code>iv</code></em>パラメータはCBCモード用の初期値となります。
ECBでは無視されます。
正確にブロック長でない場合、切り詰められるか、もしくはゼロで埋められます。
このパラメータがない場合、関数のデフォルト値はすべてゼロです。
  </p></div><div class="sect2" id="idm46270476186064"><div class="titlepage"><div><div><h3 class="title">F.26.5. ランダムデータ関数</h3></div></div></div><!--
  <title>Random-Data Functions</title>
--><a id="idm46270476185440" class="indexterm"></a><pre class="synopsis">gen_random_bytes(count integer) returns bytea</pre><p><!--
   Returns <parameter>count</> cryptographically strong random bytes.
   At most 1024 bytes can be extracted at a time.  This is to avoid
   draining the randomness generator pool.
-->暗号論的に強いランダムな<em class="parameter"><code>count</code></em>バイトを返します。
一度に最大で1024バイトを抽出することができます。
ランダム性ジェネレータプールを空にすることを防止するためのものです。
  </p><a id="idm46270476182608" class="indexterm"></a><pre class="synopsis">gen_random_uuid() returns uuid</pre><p><!--
   Returns a version 4 (random) UUID.
-->バージョン4(ランダムな)UUIDを返します。
  </p></div><div class="sect2" id="idm46270476180784"><div class="titlepage"><div><div><h3 class="title">F.26.6. 注釈</h3></div></div></div><!--
  <title>Notes</title>
--><div class="sect3" id="idm46270476180192"><div class="titlepage"><div><div><h4 class="title">F.26.6.1. 構築</h4></div></div></div><!--
   <title>Configuration</title>
--><p><!--
    <filename>pgcrypto</> configures itself according to the findings of the
    main PostgreSQL <literal>configure</literal> script.  The options that
    affect it are <literal>&#045;&#045;with-zlib</literal> and
    <literal>&#045;&#045;with-openssl</literal>.
--><code class="filename">pgcrypto</code>は自身で主PostgreSQLの<code class="literal">configure</code>スクリプトの検出結果に従って構築します。
構築に影響するオプションは<code class="literal">--with-zlib</code>と<code class="literal">--with-openssl</code>です。
   </p><p><!--
    When compiled with zlib, PGP encryption functions are able to
    compress data before encrypting.
-->ZLIB付きでコンパイルされた場合、PGP暗号化関数は暗号化前にデータを圧縮することができます。
   </p><p><!--
    When compiled with OpenSSL, there will be more algorithms available.
    Also public-key encryption functions will be faster as OpenSSL
    has more optimized BIGNUM functions.
-->OpenSSL付きでコンパイルされた場合、より多くのアルゴリズムが利用できるようになります。
また、OpenSSLがより最適化されたBIGNUM関数を持つため、公開鍵暗号化関数は高速になります。
   </p><div class="table" id="pgcrypto-with-without-openssl"><p class="title"><strong>表F.20 OpenSSLの有無による機能のまとめ</strong></p><div class="table-contents"><!--
    <title>Summary of Functionality with and without OpenSSL</title>
--><table class="table" summary="OpenSSLの有無による機能のまとめ" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>機能</th><th>組み込み</th><th>OpenSSL付き</th></tr></thead><tbody><tr><td>MD5</td><td>○</td><td>○</td></tr><tr><td>SHA1</td><td>○</td><td>○</td></tr><tr><td>SHA224/256/384/512</td><td>○</td><td>○</td></tr><tr><td>この他のダイジェストアルゴリズム</td><td>×</td><td>○（注1）</td></tr><tr><td>Blowfish</td><td>○</td><td>○</td></tr><tr><td>AES</td><td>○</td><td>○</td></tr><tr><td>DES/3DES/CAST5</td><td>×</td><td>○</td></tr><tr><td>暗号化そのもの</td><td>○</td><td>○</td></tr><tr><td>PGP対称暗号化</td><td>○</td><td>○</td></tr><tr><td>PGP公開キー暗号化</td><td>○</td><td>○</td></tr></tbody></table></div></div><br class="table-break" /><p><!--
    Notes:
-->注
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><!--
      Any digest algorithm OpenSSL supports is automatically picked up.
      This is not possible with ciphers, which need to be supported
      explicitly.
-->OpenSSLがサポートする任意のダイジェストアルゴリズムが自動的に選択されます。
これは、明示的にサポートされなければならない暗号では使用できません。
     </p></li></ol></div></div><div class="sect3" id="idm46270476156240"><div class="titlepage"><div><div><h4 class="title">F.26.6.2. NULLの扱い</h4></div></div></div><!--
   <title>NULL Handling</title>
--><p><!--
    As is standard in SQL, all functions return NULL, if any of the arguments
    are NULL.  This may create security risks on careless usage.
-->標準SQLの通り、引数のいずれかがNULLの場合、すべての関数はNULLを返します。
注意せずに使用すると、これがセキュリティ上の問題になるかもしれません。
   </p></div><div class="sect3" id="idm46270476154880"><div class="titlepage"><div><div><h4 class="title">F.26.6.3. セキュリティ上の制限</h4></div></div></div><!--
   <title>Security Limitations</title>
--><p><!--
    All <filename>pgcrypto</> functions run inside the database server.
    That means that all
    the data and passwords move between <filename>pgcrypto</> and client
    applications in clear text.  Thus you must:
--><code class="filename">pgcrypto</code>の関数はすべてデータベースサーバ内部で実行されます。
これは、<code class="filename">pgcrypto</code>とクライアントアプリケーションとの間でやり取りされるデータはすべて平文であることを意味します。
したがって、以下を行う必要があります。
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><!--
     <para>Connect locally or use SSL connections.</para>
--><p>ローカルまたはSSL接続で接続</p></li><li class="listitem"><!--
     <para>Trust both system and database administrator.</para>
--><p>システム管理者およびデータベース管理者を信頼</p></li></ol></div><p><!--
    If you cannot, then better do crypto inside client application.
-->これらが不可能であれば、クライアントアプリケーション内で暗号化する方が望まれます。
   </p><p><!--
    The implementation does not resist
    <ulink url="http://en.wikipedia.org/wiki/Side-channel_attack">side-channel
    attacks</ulink>.  For example, the time required for
    a <filename>pgcrypto</> decryption function to complete varies among
    ciphertexts of a given size.
-->実装は<a class="ulink" href="http://en.wikipedia.org/wiki/Side-channel_attack" target="_top">サイドチャネル攻撃</a>に耐えられません。
例えば、<code class="filename">pgcrypto</code>復号関数が完了するのに掛かる時間は、一定の長さの暗号文に対して一様ではありません。
   </p></div><div class="sect3" id="idm46270476147232"><div class="titlepage"><div><div><h4 class="title">F.26.6.4. 有用な文書</h4></div></div></div><!--
   <title>Useful Reading</title>
--><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.gnupg.org/gph/en/manual.html" target="_top">http://www.gnupg.org/gph/en/manual.html</a></p><!--
     <para>The GNU Privacy Handbook.</para>
--><p>GNUプライバシーハンドブック</p></li><li class="listitem"><p><a class="ulink" href="http://www.openwall.com/crypt/" target="_top">http://www.openwall.com/crypt/</a></p><!--
     <para>Describes the crypt-blowfish algorithm.</para>
--><p>blowfish暗号アルゴリズムの説明</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.stack.nl/~galactus/remailers/passphrase-faq.html" target="_top">http://www.stack.nl/~galactus/remailers/passphrase-faq.html</a>
     </p><!--
     <para>How to choose a good password.</para>
--><p>優れたパスワードの選び方</p></li><li class="listitem"><p><a class="ulink" href="http://world.std.com/~reinhold/diceware.html" target="_top">http://world.std.com/~reinhold/diceware.html</a></p><!--
     <para>Interesting idea for picking passwords.</para>
--><p>パスワード決定に関する面白い考え</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html" target="_top">http://www.interhack.net/people/cmcurtin/snake-oil-faq.html</a>
     </p><!--
     <para>Describes good and bad cryptography.</para>
--><p>良い暗号、悪い暗号に関する説明</p></li></ul></div></div><div class="sect3" id="idm46270476139888"><div class="titlepage"><div><div><h4 class="title">F.26.6.5. 技術的な参考情報</h4></div></div></div><!--
   <title>Technical References</title>
--><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc4880" target="_top">https://tools.ietf.org/html/rfc4880</a></p><!--
     <para>OpenPGP message format.</para>
--><p>OpenPGPメッセージフォーマット</p></li><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc1321" target="_top">https://tools.ietf.org/html/rfc1321</a></p><!--
     <para>The MD5 Message-Digest Algorithm.</para>
--><p>MD5 メッセージダイジェストアルゴリズム</p></li><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc2104" target="_top">https://tools.ietf.org/html/rfc2104</a></p><p>HMAC: Keyed-Hashing for Message Authentication.</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.usenix.org/events/usenix99/provos.html" target="_top">http://www.usenix.org/events/usenix99/provos.html</a>
     </p><!--
     <para>Comparison of crypt-des, crypt-md5 and bcrypt algorithms.</para>
--><p>DES暗号、MD5暗号、bcryptアルゴリズムの比較</p></li><li class="listitem"><p>      <a class="ulink" href="http://en.wikipedia.org/wiki/Fortuna_(PRNG)" target="_top">http://en.wikipedia.org/wiki/Fortuna_(PRNG)</a>
     </p><!--
     <para>Description of Fortuna CSPRNG.</para>
--><p>Fortuna CSPRNGの説明</p></li><li class="listitem"><p><a class="ulink" href="http://jlcooke.ca/random/" target="_top">http://jlcooke.ca/random/</a></p><!--
     <para>Jean-Luc Cooke Fortuna-based <filename>/dev/random</> driver for Linux.</para>
--><p>Linux用Jean-Luc Cooke Fortunaに基づく<code class="filename">/dev/random</code>ドライバ</p></li><li class="listitem"><p><a class="ulink" href="http://kodu.ut.ee/~lipmaa/crypto/" target="_top">http://kodu.ut.ee/~lipmaa/crypto/</a></p><!--
     <para>Collection of cryptology pointers.</para>
--><p>暗号学に関するリンク集</p></li></ul></div></div></div><div class="sect2" id="idm46270476129424"><div class="titlepage"><div><div><h3 class="title">F.26.7. 作者</h3></div></div></div><!--
  <title>Author</title>
--><p>   Marko Kreen <code class="email">&lt;<a class="email" href="mailto:markokr@gmail.com">markokr@gmail.com</a>&gt;</code>
  </p><p><!--
   <filename>pgcrypto</filename> uses code from the following sources:
-->   <code class="literal">pgcrypto</code>は以下のソースを使用しています。
  </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th><p>アルゴリズム</p></th><th><p>作者</p></th><th><p>元ソース</p></th></tr></thead><tbody><tr><td>DES crypt</td><td>David Burren他</td><td>FreeBSD libcrypt</td></tr><tr><td>MD5 crypt</td><td>Poul-Henning Kamp</td><td>FreeBSD libcrypt</td></tr><tr><td>Blowfish crypt</td><td>Solar Designer</td><td>www.openwall.com</td></tr><tr><td>Blowfish cipher</td><td>Simon Tatham</td><td>PuTTY</td></tr><tr><td>Rijndael cipher</td><td>Brian Gladman</td><td>OpenBSD sys/crypto</td></tr><tr><td>MD5ハッシュとSHA1</td><td>WIDE Project</td><td>KAME kame/sys/crypto</td></tr><tr><td>SHA256/384/512 </td><td>Aaron D. Gifford</td><td>OpenBSD sys/crypto</td></tr><tr><td>BIGNUM math</td><td>Michael J. Fromberger</td><td>dartmouth.edu/~sting/sw/imath</td></tr></tbody></table></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pgbuffercache.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="pgfreespacemap.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">F.25. pg_buffercache </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> F.27. pg_freespacemap</td></tr></table></div></body></html>