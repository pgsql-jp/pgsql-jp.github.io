<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.26. pgcrypto</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="pgbuffercache.html" title="F.25. pg_buffercache" /><link rel="next" href="pgfreespacemap.html" title="F.27. pg_freespacemap" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.26. pgcrypto</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="pgbuffercache.html" title="F.25. pg_buffercache">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Appendix F. 追加で提供されるモジュール">Up</a></td><th width="60%" align="center">Appendix F. 追加で提供されるモジュール</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="pgfreespacemap.html" title="F.27. pg_freespacemap">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PGCRYPTO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.26. pgcrypto</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.5">F.26.1. 汎用ハッシュ関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.6">F.26.2. パスワードハッシュ化関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.7">F.26.3. PGP暗号化関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.8">F.26.4. 暗号化そのものを行う関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.9">F.26.5. ランダムデータ関数</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.10">F.26.6. 注釈</a></span></dt><dt><span class="sect2"><a href="pgcrypto.html#id-1.11.7.35.11">F.26.7. 作者</a></span></dt></dl></div><a id="id-1.11.7.35.2" class="indexterm"></a><a id="id-1.11.7.35.3" class="indexterm"></a><p><code class="filename">pgcrypto</code>モジュールは<span class="productname">PostgreSQL</span>用の暗号関数を提供します。
 </p><div class="sect2" id="id-1.11.7.35.5"><div class="titlepage"><div><div><h3 class="title">F.26.1. 汎用ハッシュ関数</h3></div></div></div><div class="sect3" id="id-1.11.7.35.5.2"><div class="titlepage"><div><div><h4 class="title">F.26.1.1. <code class="function">digest()</code></h4></div></div></div><a id="id-1.11.7.35.5.2.2" class="indexterm"></a><pre class="synopsis">digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea</pre><p>与えられた<em class="parameter"><code>data</code></em>のバイナリハッシュを計算します。
<em class="parameter"><code>type</code></em>は使用するアルゴリズムです。
標準アルゴリズムは<code class="literal">md5</code>、<code class="literal">sha1</code>、<code class="literal">sha224</code>、<code class="literal">sha256</code>、<code class="literal">sha384</code>、および<code class="literal">sha512</code>です。
<code class="filename">pgcrypto</code>がOpenSSL付きで構築された場合、<a class="xref" href="pgcrypto.html#PGCRYPTO-WITH-WITHOUT-OPENSSL" title="Table F.20. OpenSSLの有無による機能のまとめ">Table F.20</a>で詳解する、より多くのアルゴリズムを利用することができます。
   </p><p>ダイジェストを16進数表記の文字列としたい場合は、結果に対して<code class="function">encode()</code>を使用してください。
以下に例を示します。
</p><pre class="programlisting">CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;</pre><p>
   </p></div><div class="sect3" id="id-1.11.7.35.5.3"><div class="titlepage"><div><div><h4 class="title">F.26.1.2. <code class="function">hmac()</code></h4></div></div></div><a id="id-1.11.7.35.5.3.2" class="indexterm"></a><pre class="synopsis">hmac(data text, key text, type text) returns bytea
hmac(data bytea, key bytea, type text) returns bytea</pre><p><em class="parameter"><code>key</code></em>をキーとした<em class="parameter"><code>data</code></em>のハッシュ化MACを計算します。
<em class="parameter"><code>type</code></em>は<code class="function">digest()</code>の場合と同じです。
   </p><p><code class="function">digest()</code>と似ていますが、ハッシュはキーを知っている場合にのみ再計算できます。
これは、誰かがデータを変更し、同時に一致するようにハッシュを変更するという状況を防ぎます。
   </p><p>キーがハッシュブロックサイズより大きい場合、まずハッシュ化され、その結果をキーとして使用します。
   </p></div></div><div class="sect2" id="id-1.11.7.35.6"><div class="titlepage"><div><div><h3 class="title">F.26.2. パスワードハッシュ化関数</h3></div></div></div><p><code class="function">crypt()</code>および<code class="function">gen_salt()</code>関数は特にパスワードのハッシュ化のために設計されたものです。
<code class="function">crypt()</code>がハッシュ処理を行い、<code class="function">gen_salt()</code>はハッシュ処理用のアルゴリズム上のパラメータを準備します。
  </p><p><code class="function">crypt()</code>アルゴリズムは、以下の点で通常のMD5やSHA1のようなハッシュ処理アルゴリズムと異なります。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>低速です。
データ量が少ないためパスワード総当たり攻撃に対して頑健にする唯一の方法です。
    </p></li><li class="listitem"><p>結果には<em class="firstterm">ソルト</em>というランダムな値が含まれます。
このため同じパスワードのユーザでも異なった暗号化パスワードを持ちます。
これはアルゴリズムの逆処理に対する追加の防御です。
    </p></li><li class="listitem"><p>結果内にアルゴリズムの種類が含まれます。
このため異なるアルゴリズムでハッシュ化したパスワードが混在可能です。
    </p></li><li class="listitem"><p>一部は適応型です。
つまり、コンピュータが高速になったとしても、既存のパスワードとの互換性を損なうことなくアルゴリズムを低速に調整することができます。
    </p></li></ol></div><p><code class="function">crypt()</code>関数がサポートするアルゴリズムを<a class="xref" href="pgcrypto.html#PGCRYPTO-CRYPT-ALGORITHMS" title="Table F.17. crypt()がサポートするアルゴリズム">Table F.17</a>に列挙します。
  </p><div class="table" id="PGCRYPTO-CRYPT-ALGORITHMS"><p class="title"><strong>Table F.17. <code class="function">crypt()</code>がサポートするアルゴリズム</strong></p><div class="table-contents"><table class="table" summary="crypt()がサポートするアルゴリズム" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>パスワード最大長</th><th>適応型かどうか</th><th>ソルトビット長</th><th>出力長</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">bf</code></td><td>72</td><td>はい</td><td>128</td><td>60</td><td>Blowfishベース、2a版</td></tr><tr><td><code class="literal">md5</code></td><td>無制限</td><td>いいえ</td><td>48</td><td>34</td><td>MD5ベースの暗号</td></tr><tr><td><code class="literal">xdes</code></td><td>8</td><td>はい</td><td>24</td><td>20</td><td>拡張DES</td></tr><tr><td><code class="literal">des</code></td><td>8</td><td>いいえ</td><td>12</td><td>13</td><td>元来のUNIX crypt</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" id="id-1.11.7.35.6.7"><div class="titlepage"><div><div><h4 class="title">F.26.2.1. <code class="function">crypt()</code></h4></div></div></div><a id="id-1.11.7.35.6.7.2" class="indexterm"></a><pre class="synopsis">crypt(password text, salt text) returns text</pre><p><em class="parameter"><code>password</code></em>のcrypt(3)形式のハッシュを計算します。
新しいパスワードを保管する時には、<code class="function">gen_salt()</code>を使用して新しい<em class="parameter"><code>salt</code></em>を生成する必要があります。
パスワードを検査する時、既存のハッシュ値を<em class="parameter"><code>salt</code></em>として渡し、結果が格納された値と一致するかどうかを確認します。
   </p><p>新しいパスワードの設定例を以下に示します。
</p><pre class="programlisting">UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));</pre><p>
   </p><p>認証の例です。
</p><pre class="programlisting">SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;</pre><p>
入力パスワードが正しければ<code class="literal">true</code>を返します。
   </p></div><div class="sect3" id="id-1.11.7.35.6.8"><div class="titlepage"><div><div><h4 class="title">F.26.2.2. <code class="function">gen_salt()</code></h4></div></div></div><a id="id-1.11.7.35.6.8.2" class="indexterm"></a><pre class="synopsis">gen_salt(type text [, iter_count integer ]) returns text</pre><p><code class="function">crypt()</code>で使用するランダムなソルト文字列を新規に生成します。
また、このソルト文字列は<code class="function">crypt()</code>にどのアルゴリズムを使用するかを通知します。
   </p><p><em class="parameter"><code>type</code></em>パラメータはハッシュ化アルゴリズムを指定します。
受付可能な種類は、<code class="literal">des</code>、<code class="literal">xdes</code>、<code class="literal">md5</code>、<code class="literal">bf</code>です。
   </p><p>繰り返し回数を持つアルゴリズムでは、ユーザは<em class="parameter"><code>iter_count</code></em>パラメータを使用して繰り返し回数を指定できます。
指定する回数を高くすれば、パスワードのハッシュ化にかかる時間が長くなり、それを破るための時間も長くなります。
しかし、あまりに多くの回数を指定すると、ハッシュ計算にかかる時間は数年に渡ってしまう可能性があります。
これは実用的ではありません。
<em class="parameter"><code>iter_count</code></em>パラメータを省略した場合、デフォルトの繰り返し回数が使用されます。
<em class="parameter"><code>iter_count</code></em>で受け付けられる値はアルゴリズムに依存し、<a class="xref" href="pgcrypto.html#PGCRYPTO-ICFC-TABLE" title="Table F.18. crypt()用の繰り返し回数">Table F.18</a>に示す通りです。
   </p><div class="table" id="PGCRYPTO-ICFC-TABLE"><p class="title"><strong>Table F.18. <code class="function">crypt()</code>用の繰り返し回数</strong></p><div class="table-contents"><table class="table" summary="crypt()用の繰り返し回数" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>デフォルト</th><th>最小</th><th>最大</th></tr></thead><tbody><tr><td><code class="literal">xdes</code></td><td>725</td><td>1</td><td>16777215</td></tr><tr><td><code class="literal">bf</code></td><td>6</td><td>4</td><td>31</td></tr></tbody></table></div></div><br class="table-break" /><p><code class="literal">xdes</code>の場合は他にも、回数が奇数でなければならないという制限があります。
   </p><p>適切な繰り返し回数を選択するために、元々のDES暗号は当時のハードウェアで1秒あたり4個のハッシュを持つことができるように設計されたことを考えてください。
毎秒4ハッシュより遅いと、おそらく使い勝手が悪いでしょう。
毎秒100ハッシュより速いというのは、十中八九、あまりにも速すぎるでしょう。
   </p><p>ハッシュ化アルゴリズム別に相対的な速度に関する概要を<a class="xref" href="pgcrypto.html#PGCRYPTO-HASH-SPEED-TABLE" title="Table F.19. ハッシュアルゴリズムの速度">Table F.19</a>にまとめました。
この表は、8文字のパスワード内のすべての文字の組合せを取るためにかかる時間を示します。
また、すべて小文字の英字のみのパスワードである場合と大文字小文字が混在した英字と数字のパスワードの場合を仮定します。
<code class="literal">crypt-bf</code>の項では、スラッシュの後の数値は<code class="function">gen_salt</code>の<em class="parameter"><code>iter_count</code></em>です。
   </p><div class="table" id="PGCRYPTO-HASH-SPEED-TABLE"><p class="title"><strong>Table F.19. ハッシュアルゴリズムの速度</strong></p><div class="table-contents"><table class="table" summary="ハッシュアルゴリズムの速度" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>アルゴリズム</th><th>1秒当たりのハッシュ数</th><th><code class="literal">[a-z]</code>の場合</th><th><code class="literal">[A-Za-z0-9]</code>の場合</th><th><code class="literal">md5ハッシュ</code>を単位とした持続期間</th></tr></thead><tbody><tr><td><code class="literal">crypt-bf/8</code></td><td>1792</td><td>4年</td><td>3927年</td><td>100k</td></tr><tr><td><code class="literal">crypt-bf/7</code></td><td>3648</td><td>2年</td><td>1929年</td><td>50k</td></tr><tr><td><code class="literal">crypt-bf/6</code></td><td>7168</td><td>1年</td><td>982年</td><td>25k</td></tr><tr><td><code class="literal">crypt-bf/5</code></td><td>13504</td><td>188日</td><td>521年</td><td>12.5k</td></tr><tr><td><code class="literal">crypt-md5</code></td><td>171584</td><td>15日</td><td>41年</td><td>1k</td></tr><tr><td><code class="literal">crypt-des</code></td><td>23221568</td><td>157.5分</td><td>108日</td><td>7</td></tr><tr><td><code class="literal">sha1</code></td><td>37774272</td><td>90分</td><td>68日</td><td>4</td></tr><tr><td><code class="literal">md5</code>(ハッシュ)</td><td>150085504</td><td>22.5分</td><td>17日</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p>注意：
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Intel Mobile Core i3のマシンを使用しました。
     </p></li><li class="listitem"><p><code class="literal">crypt-des</code>および<code class="literal">crypt-md5</code>アルゴリズムの数値はJohn the Ripper v1.6.38の<code class="literal">-test</code>出力から得たものです。
     </p></li><li class="listitem"><p><code class="literal">md5ハッシュ</code>の数値はmdcrack 1.2のものです。
     </p></li><li class="listitem"><p><code class="literal">sha1</code>の数値はlcrack-20031130-betaのものです。
     </p></li><li class="listitem"><p><code class="literal">crypt-bf</code>の数は、1000個の8文字パスワードをループする単純なプログラムを使用して得たものです。
こうして、異なる回数の速度を示すことができました。
参考までに、<code class="literal">john -test</code>は<code class="literal">crypt-bf/5</code>で13506 loops/secでした。
（結果の差異が非常に小さいことは、<code class="filename">pgcrypto</code>における<code class="literal">crypt-bf</code>実装がJohn the Ripperで使用されるものと同じであるという事実と一致します。）
     </p></li></ul></div><p><span class="quote">“<span class="quote">すべての組み合わせを試行する</span>”</span>ことは現実的な行使ではありません。
通常パスワード推定は、普通の単語とその変形の両方を含む辞書を使用して行われます。
ですので、いささかなりとも言葉に似たパスワードは上で示した数値よりも速く推定されます。
また6文字の単語に似ていないパスワードは推定を免れるかもしれませんし、免れないかもしれません。
   </p></div></div><div class="sect2" id="id-1.11.7.35.7"><div class="titlepage"><div><div><h3 class="title">F.26.3. PGP暗号化関数</h3></div></div></div><p>ここで示す関数はOpenPGP（RFC 4880）標準の暗号処理部分を実装します。
対称鍵および公開鍵暗号化がサポートされます。
  </p><p>暗号化されたPGPメッセージは次の2つの部品（または<em class="firstterm">パケット</em>）から構成されます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>セッションキーを含むパケット。
対称鍵または公開鍵で暗号化されています。
    </p></li><li class="listitem"><p>セッションキーにより暗号化されたデータを含むパケット。
    </p></li></ul></div><p>対称鍵（つまりパスワード）で暗号化する場合
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>与えられたパスワードはString2Key(S2K)アルゴリズムでハッシュ化されます。
これはどちらかというと<code class="function">crypt()</code>アルゴリズムと似て、意図的に低速で、かつランダムなソルトを使用します。
しかし、全長のバイナリキーを生成します。
    </p></li><li class="listitem"><p>分離したセッションキーが要求された場合、新しいランダムなキーが生成されます。
さもなくば、S2Kキーがそのままセッションキーとして使用されます。
    </p></li><li class="listitem"><p>S2Kキーがそのまま使用される場合、S2K設定のみがセッションキーパケットに格納されます。
さもなくば、セッションキーはS2Kキーで暗号化され、セッションキーパケットに格納されます。
    </p></li></ol></div><p>公開鍵で暗号化する場合
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>新しいランダムなセッションキーが生成されます。
    </p></li><li class="listitem"><p>これは公開鍵を使用して暗号化され、セッションキーパケットに格納されます。
    </p></li></ol></div><p>どちらの場合でもデータ暗号化は以下のように処理されます。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>省略可能なデータ操作として、圧縮、UTF-8への変換、改行の変換があります。
    </p></li><li class="listitem"><p>データの前にはランダムなバイト数のブロックが付きます。
これはrandom IVを使用する場合と同じです。
    </p></li><li class="listitem"><p>ランダムな前置ブロックとデータのSHA1ハッシュが後に付けられます。
    </p></li><li class="listitem"><p>これをすべてセッションキーで暗号化し、データパケットに格納します。
    </p></li></ol></div><div class="sect3" id="id-1.11.7.35.7.11"><div class="titlepage"><div><div><h4 class="title">F.26.3.1. <code class="function">pgp_sym_encrypt()</code></h4></div></div></div><a id="id-1.11.7.35.7.11.2" class="indexterm"></a><a id="id-1.11.7.35.7.11.3" class="indexterm"></a><pre class="synopsis">pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea</pre><p>対称PGPキー<em class="parameter"><code>psw</code></em>で<em class="parameter"><code>data</code></em>を暗号化します。
<em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="id-1.11.7.35.7.12"><div class="titlepage"><div><div><h4 class="title">F.26.3.2. <code class="function">pgp_sym_decrypt()</code></h4></div></div></div><a id="id-1.11.7.35.7.12.2" class="indexterm"></a><a id="id-1.11.7.35.7.12.3" class="indexterm"></a><pre class="synopsis">pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea</pre><p>対称鍵で暗号化されたPGPメッセージを復号します。
   </p><p><code class="function">pgp_sym_decrypt</code>で<code class="type">bytea</code>型のデータを復号することはできません。
これは無効な文字データの出力を防止するためです。
元のテキストのデータを<code class="function">pgp_sym_decrypt_bytea</code>で復号することが正しい方法です。
   </p><p><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="id-1.11.7.35.7.13"><div class="titlepage"><div><div><h4 class="title">F.26.3.3. <code class="function">pgp_pub_encrypt()</code></h4></div></div></div><a id="id-1.11.7.35.7.13.2" class="indexterm"></a><a id="id-1.11.7.35.7.13.3" class="indexterm"></a><pre class="synopsis">pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea</pre><p>公開PGPキー<em class="parameter"><code>key</code></em>で<em class="parameter"><code>data</code></em>を暗号化します。
この関数に秘密キーを与えるとエラーになります。
   </p><p><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="id-1.11.7.35.7.14"><div class="titlepage"><div><div><h4 class="title">F.26.3.4. <code class="function">pgp_pub_decrypt()</code></h4></div></div></div><a id="id-1.11.7.35.7.14.2" class="indexterm"></a><a id="id-1.11.7.35.7.14.3" class="indexterm"></a><pre class="synopsis">pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea</pre><p>公開鍵で暗号化されたメッセージを復号します。
<em class="parameter"><code>key</code></em>は、暗号化に使用した公開鍵に対応する秘密鍵でなければなりません。
秘密鍵がパスワードで保護されている場合は、そのパスワードを<em class="parameter"><code>psw</code></em>で指定しなければなりません。
パスワードはないが、オプションを指定したい場合は空のパスワードを指定する必要があります。
   </p><p><code class="function">pgp_pub_decrypt</code>で<code class="type">bytea</code>型のデータを復号することはできません。
これは無効な文字データの出力を防止するためです。
元のテキストのデータを<code class="function">pgp_pub_decrypt_bytea</code>で復号することが正しい方法です。
   </p><p><em class="parameter"><code>options</code></em>パラメータには後述のオプション設定を含めることができます。
   </p></div><div class="sect3" id="id-1.11.7.35.7.15"><div class="titlepage"><div><div><h4 class="title">F.26.3.5. <code class="function">pgp_key_id()</code></h4></div></div></div><a id="id-1.11.7.35.7.15.2" class="indexterm"></a><pre class="synopsis">pgp_key_id(bytea) returns text</pre><p><code class="function">pgp_key_id</code>はPGP公開鍵または秘密鍵のキーIDを取り出します。
暗号化されたメッセージが指定された場合は、データの暗号化に使用されたキーIDを与えます。
   </p><p>2つの特殊なキーIDを返すことがあります。
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>      <code class="literal">SYMKEY</code>
     </p><p>メッセージは対称鍵で暗号化されました。
     </p></li><li class="listitem"><p>      <code class="literal">ANYKEY</code>
     </p><p>メッセージは公開鍵で暗号化されましたが、キーIDが消去されていました。
つまり、どれで復号できるかを判定するためにはすべての秘密キーを試行しなければならないことを意味します。
<code class="filename">pgcrypto</code>自身はこうしたメッセージを生成しません。
     </p></li></ul></div><p>異なるキーが同一IDを持つ場合があることに注意してください。
これは稀ですが、正常なイベントです。
この場合クライアントアプリケーションはどちらが当てはまるかを調べるために、<code class="literal">ANYKEY</code>の場合と同様に、それぞれのキーで復号を試行しなければなりません。
   </p></div><div class="sect3" id="id-1.11.7.35.7.16"><div class="titlepage"><div><div><h4 class="title">F.26.3.6. <code class="function">armor()</code>, <code class="function">dearmor()</code></h4></div></div></div><a id="id-1.11.7.35.7.16.2" class="indexterm"></a><a id="id-1.11.7.35.7.16.3" class="indexterm"></a><pre class="synopsis">armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea</pre><p>PGPのASCIIアーマー形式にデータを隠す、または、データを取り出します。
ASCIIアーマーは基本的にCRC付きのBASE64という形式で、追加のフォーマットがあります。
   </p><p><em class="parameter"><code>keys</code></em>と<em class="parameter"><code>values</code></em>の配列が指定された場合には、各キーと値の対に対して<em class="firstterm">アーマーヘッダ</em>がアーマー形式に追加されます。
どちらの配列も1次元で、同じ長さでなければなりません。
keysとvaluesに非ASCII文字を含めることはできません。
   </p></div><div class="sect3" id="id-1.11.7.35.7.17"><div class="titlepage"><div><div><h4 class="title">F.26.3.7. <code class="function">pgp_armor_headers</code></h4></div></div></div><a id="id-1.11.7.35.7.17.2" class="indexterm"></a><pre class="synopsis">pgp_armor_headers(data text, key out text, value out text) returns setof record</pre><p><code class="function">pgp_armor_headers()</code>は<em class="parameter"><code>data</code></em>からアーマーヘッダを取り出します。
戻り値はキーと値の2つの列からなる行の集合です。
もしキーや値に非アスキー文字が含まれていれば、UTF-8として扱われます。
   </p></div><div class="sect3" id="id-1.11.7.35.7.18"><div class="titlepage"><div><div><h4 class="title">F.26.3.8. PGP関数用のオプション</h4></div></div></div><p>オプションはGnuPGに似せて命名しています。
オプションの値は等号記号の後に指定しなければなりません。
複数のオプションはカンマで区切ってください。
以下に例を示します。
</p><pre class="programlisting">pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')</pre><p>
   </p><p><code class="literal">convert-crlf</code>を除くすべてのオプションは暗号化関数にのみ適用可能です。
復号関数はPGPデータからこうしたパラメータを入手します。
   </p><p>もっとも興味深いオプションはおそらく<code class="literal">compress-algo</code>と<code class="literal">unicode-mode</code>でしょう。
残りはデフォルトで問題ないはずです。
   </p><div class="sect4" id="id-1.11.7.35.7.18.5"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.1. cipher-algo</h5></div></div></div><p>使用する暗号アルゴリズム。
   </p><div class="literallayout"><p>値: bf, aes128, aes192, aes256 (OpenSSL-only: <code class="literal">3des</code>, <code class="literal">cast5</code>)<br />
デフォルト: aes128<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.6"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.2. compress-algo</h5></div></div></div><p>使用する圧縮アルゴリズム。
<span class="productname">PostgreSQL</span>がzlib付きで構築されている場合のみ利用可能です。
   </p><div class="literallayout"><p>値:<br />
 0 - 非圧縮<br />
 1 - ZIP圧縮<br />
 2 - ZLIB圧縮 (ZIPにメタデータとブロックCRCを加えたもの)<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.7"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.3. compress-level</h5></div></div></div><p>どの程度圧縮するかです。
レベルが大きい程小さくなりますが、低速になります。
0は圧縮を無効にします。
   </p><div class="literallayout"><p>値: 0, 1-9<br />
デフォルト: 6<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.8"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.4. convert-crlf</h5></div></div></div><p>暗号化の際に<code class="literal">\n</code>を<code class="literal">\r\n</code>に、復号の際に<code class="literal">\r\n</code> を<code class="literal">\n</code> に変換するかどうか。
RFC 4880では、テキストデータは改行コードとして<code class="literal">\r\n</code> を使用して格納すべきであると規定されています。
完全にRFC準拠の動作を行いたければ、これを使用してください。
   </p><div class="literallayout"><p>値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.9"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.5. disable-mdc</h5></div></div></div><p>データをSHA-1で保護しません。
このオプションを使用することが良い唯一の理由は、SHA-1で保護されたパケットがRFC 4880に追加される前の、古いPGP製品との互換性を得るためです。
最近のgnupg.orgおよびpgp.comのソフトウェアではこれを正しくサポートしています。
   </p><div class="literallayout"><p>値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.10"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.6. sess-key</h5></div></div></div><p>分離したセッションキーを使用します。
公開鍵暗号では常に分離したセッションキーを使用します。
このオプションは対称鍵暗号向けのもので、デフォルトではS2Kキーをそのまま使用します。
   </p><div class="literallayout"><p>値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.11"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.7. s2k-mode</h5></div></div></div><p>使用するS2Kアルゴリズム。
   </p><div class="literallayout"><p>値:<br />
  0 - ソルト無。危険です!<br />
  1 - ソルト有。固定繰り返し回数。<br />
  3 - 可変繰り返し回数。<br />
デフォルト: 3<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.12"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.8. s2k-count</h5></div></div></div><p>使用するS2Kアルゴリズムで使う繰り返しの回数。
1024以上、65011712以下の値でなければなりません。
   </p><div class="literallayout"><p>デフォルト: 65536から253952までの乱数値<br />
適用範囲: s2k-mode=3と指定した時のpgp_sym_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.13"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.9. s2k-digest-algo</h5></div></div></div><p>S2K計算で使用するダイジェストアルゴリズム。
   </p><div class="literallayout"><p>値: md5, sha1<br />
デフォルト: sha1<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.14"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.10. s2k-cipher-algo</h5></div></div></div><p>分離したセッションキーの暗号化に使用する暗号。
   </p><div class="literallayout"><p>値: bf, aes, aes128, aes192, aes256<br />
デフォルト: cipher-algoを使用<br />
適用範囲: pgp_sym_encrypt</p></div></div><div class="sect4" id="id-1.11.7.35.7.18.15"><div class="titlepage"><div><div><h5 class="title">F.26.3.8.11. unicode-mode</h5></div></div></div><p>テキストデータをデータベース内部符号化方式からUTF-8に変換して戻すかどうかです。
データベースがすでにUTF-8であれば、変換は起こらず、データにUTF-8としてタグが付くのみです。
このオプションがないと、何も行われません。
   </p><div class="literallayout"><p>値: 0, 1<br />
デフォルト: 0<br />
適用範囲: pgp_sym_encrypt, pgp_pub_encrypt</p></div></div></div><div class="sect3" id="id-1.11.7.35.7.19"><div class="titlepage"><div><div><h4 class="title">F.26.3.9. GnuPGを使用したキーの生成</h4></div></div></div><p>新しいキーを生成します。
</p><pre class="programlisting">gpg --gen-key</pre><p>
  </p><p>推奨するキー種類は<span class="quote">“<span class="quote">DSAとElgamal</span>”</span>です。
  </p><p>RSA暗号化のためには、マスタとしてDSAまたはRSAで署名のみのキーを作成し、そして<code class="literal">gpg --edit-key</code>を使用してRSAで暗号化された副キーを追加しなければなりません
  </p><p>キーを列挙します。
</p><pre class="programlisting">gpg --list-secret-keys</pre><p>
  </p><p>ASCIIアーマー形式で公開鍵をエクスポートします。
</p><pre class="programlisting">gpg -a --export KEYID &gt; public.key</pre><p>
  </p><p>ASCIIアーマー形式の秘密鍵をエクスポートします。
</p><pre class="programlisting">gpg -a --export-secret-keys KEYID &gt; secret.key</pre><p>
  </p><p>PGP関数にこれらのキーを渡す前に<code class="function">dearmor()</code>を使用する必要があります。
バイナリデータを扱うことができる場合、gpgから<code class="literal">-a</code>フラグを省略することができます。
  </p><p>詳細は<code class="literal">man gpg</code>、<a class="ulink" href="http://www.gnupg.org/gph/en/manual.html" target="_top">The GNU Privacy Handbook</a>、<a class="ulink" href="http://www.gnupg.org" target="_top">http://www.gnupg.org</a>サイトの各種文書を参照してください。
  </p></div><div class="sect3" id="id-1.11.7.35.7.20"><div class="titlepage"><div><div><h4 class="title">F.26.3.10. PGPコードの制限</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>署名に関するサポートはありません。
これはまた、暗号化副キーがマスタキーに属しているかどうか検査しないことを意味します。
    </p></li><li class="listitem"><p>マスタキーとして暗号化キーをサポートしません。
一般的にこうした状況は現実的ではありませんので、問題にならないはずです。
    </p></li><li class="listitem"><p>複数の副キーに関するサポートはありません。
よくありますので、これは問題になりそうに見えます。
一方、通常のGPG/PGPキーを<code class="filename">pgcrypto</code>で使用すべきではありません。
使用する状況が多少異なりますので新しく作成してください。
    </p></li></ul></div></div></div><div class="sect2" id="id-1.11.7.35.8"><div class="titlepage"><div><div><h3 class="title">F.26.4. 暗号化そのものを行う関数</h3></div></div></div><p>これらの関数はデータ全体を暗号化するためだけに実行します。
PGP暗号化の持つ先端的な機能はありません。
したがって、大きな問題がいくつか存在します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>暗号キーとしてユーザキーをそのまま使用します。
    </p></li><li class="listitem"><p>暗号化されたデータが変更されたかどうかを確認するための整合性検査をまったく提供しません。
    </p></li><li class="listitem"><p>ユーザが、IVをも含め暗号化パラメータ自体をすべて管理していることを想定しています。
    </p></li><li class="listitem"><p>テキストは扱いません。
    </p></li></ol></div><p>このため、PGP暗号化の導入もあり、暗号化のみの関数はあまり使用されません。
  </p><a id="id-1.11.7.35.8.5" class="indexterm"></a><a id="id-1.11.7.35.8.6" class="indexterm"></a><a id="id-1.11.7.35.8.7" class="indexterm"></a><a id="id-1.11.7.35.8.8" class="indexterm"></a><pre class="synopsis">encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea</pre><p><em class="parameter"><code>type</code></em>で指定した暗号方法を使用してデータの暗号化・復号を行います。
<em class="parameter"><code>type</code></em>文字列の構文は以下の通りです。

</p><pre class="synopsis"><em class="replaceable"><code>algorithm</code></em> [<span class="optional"> <code class="literal">-</code> <em class="replaceable"><code>mode</code></em> </span>] [<span class="optional"> <code class="literal">/pad:</code> <em class="replaceable"><code>padding</code></em> </span>]</pre><p>
ここで<em class="replaceable"><code>algorithm</code></em>は以下の1つです。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">bf</code> — Blowfish</p></li><li class="listitem"><p><code class="literal">aes</code> — AES (Rijndael-128, -192 or -256)</p></li></ul></div><p>
また<em class="replaceable"><code>mode</code></em>は以下の1つです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">cbc</code> — 次のブロックは前ブロックに依存します（デフォルト）
    </p></li><li class="listitem"><p><code class="literal">ecb</code> — 各ブロックは独自に暗号化されます（試験用途のみ）
    </p></li></ul></div><p>
<em class="replaceable"><code>padding</code></em>は以下の1つです。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">pkcs</code> — データ長に制限はありません（デフォルト）
    </p></li><li class="listitem"><p><code class="literal">none</code> — データは暗号ブロックサイズの倍数でなければなりません
    </p></li></ul></div><p>
  </p><p>このため、例えば以下は同じです。
</p><pre class="programlisting">encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')</pre><p>
  </p><p><code class="function">encrypt_iv</code>および<code class="function">decrypt_iv</code>では、<em class="parameter"><code>iv</code></em>パラメータはCBCモード用の初期値となります。
ECBでは無視されます。
正確にブロック長でない場合、切り詰められるか、もしくはゼロで埋められます。
このパラメータがない場合、関数のデフォルト値はすべてゼロです。
  </p></div><div class="sect2" id="id-1.11.7.35.9"><div class="titlepage"><div><div><h3 class="title">F.26.5. ランダムデータ関数</h3></div></div></div><a id="id-1.11.7.35.9.2" class="indexterm"></a><pre class="synopsis">gen_random_bytes(count integer) returns bytea</pre><p>暗号論的に強いランダムな<em class="parameter"><code>count</code></em>バイトを返します。
一度に最大で1024バイトを抽出することができます。
ランダム性ジェネレータプールを空にすることを防止するためのものです。
  </p><a id="id-1.11.7.35.9.5" class="indexterm"></a><pre class="synopsis">gen_random_uuid() returns uuid</pre><p>バージョン4(ランダムな)UUIDを返します。
  </p></div><div class="sect2" id="id-1.11.7.35.10"><div class="titlepage"><div><div><h3 class="title">F.26.6. 注釈</h3></div></div></div><div class="sect3" id="id-1.11.7.35.10.2"><div class="titlepage"><div><div><h4 class="title">F.26.6.1. 構築</h4></div></div></div><p><code class="filename">pgcrypto</code>は自身で主PostgreSQLの<code class="literal">configure</code>スクリプトの検出結果に従って構築します。
構築に影響するオプションは<code class="literal">--with-zlib</code>と<code class="literal">--with-openssl</code>です。
   </p><p>ZLIB付きでコンパイルされた場合、PGP暗号化関数は暗号化前にデータを圧縮することができます。
   </p><p>OpenSSL付きでコンパイルされた場合、より多くのアルゴリズムが利用できるようになります。
また、OpenSSLがより最適化されたBIGNUM関数を持つため、公開鍵暗号化関数は高速になります。
   </p><div class="table" id="PGCRYPTO-WITH-WITHOUT-OPENSSL"><p class="title"><strong>Table F.20. OpenSSLの有無による機能のまとめ</strong></p><div class="table-contents"><table class="table" summary="OpenSSLの有無による機能のまとめ" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>機能</th><th>組み込み</th><th>OpenSSL付き</th></tr></thead><tbody><tr><td>MD5</td><td>○</td><td>○</td></tr><tr><td>SHA1</td><td>○</td><td>○</td></tr><tr><td>SHA224/256/384/512</td><td>○</td><td>○</td></tr><tr><td>この他のダイジェストアルゴリズム</td><td>×</td><td>○（注1）</td></tr><tr><td>Blowfish</td><td>○</td><td>○</td></tr><tr><td>AES</td><td>○</td><td>○</td></tr><tr><td>DES/3DES/CAST5</td><td>×</td><td>○</td></tr><tr><td>暗号化そのもの</td><td>○</td><td>○</td></tr><tr><td>PGP対称暗号化</td><td>○</td><td>○</td></tr><tr><td>PGP公開キー暗号化</td><td>○</td><td>○</td></tr></tbody></table></div></div><br class="table-break" /><p>注
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>OpenSSLがサポートする任意のダイジェストアルゴリズムが自動的に選択されます。
これは、明示的にサポートされなければならない暗号では使用できません。
     </p></li></ol></div></div><div class="sect3" id="id-1.11.7.35.10.3"><div class="titlepage"><div><div><h4 class="title">F.26.6.2. NULLの扱い</h4></div></div></div><p>標準SQLの通り、引数のいずれかがNULLの場合、すべての関数はNULLを返します。
注意せずに使用すると、これがセキュリティ上の問題になるかもしれません。
   </p></div><div class="sect3" id="id-1.11.7.35.10.4"><div class="titlepage"><div><div><h4 class="title">F.26.6.3. セキュリティ上の制限</h4></div></div></div><p><code class="filename">pgcrypto</code>の関数はすべてデータベースサーバ内部で実行されます。
これは、<code class="filename">pgcrypto</code>とクライアントアプリケーションとの間でやり取りされるデータはすべて平文であることを意味します。
したがって、以下を行う必要があります。
   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ローカルまたはSSL接続で接続</p></li><li class="listitem"><p>システム管理者およびデータベース管理者を信頼</p></li></ol></div><p>これらが不可能であれば、クライアントアプリケーション内で暗号化する方が望まれます。
   </p><p>実装は<a class="ulink" href="http://en.wikipedia.org/wiki/Side-channel_attack" target="_top">サイドチャネル攻撃</a>に耐えられません。
例えば、<code class="filename">pgcrypto</code>復号関数が完了するのに掛かる時間は、一定の長さの暗号文に対して一様ではありません。
   </p></div><div class="sect3" id="id-1.11.7.35.10.5"><div class="titlepage"><div><div><h4 class="title">F.26.6.4. 有用な文書</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="http://www.gnupg.org/gph/en/manual.html" target="_top">http://www.gnupg.org/gph/en/manual.html</a></p><p>GNUプライバシーハンドブック</p></li><li class="listitem"><p><a class="ulink" href="http://www.openwall.com/crypt/" target="_top">http://www.openwall.com/crypt/</a></p><p>blowfish暗号アルゴリズムの説明</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.stack.nl/~galactus/remailers/passphrase-faq.html" target="_top">http://www.stack.nl/~galactus/remailers/passphrase-faq.html</a>
     </p><p>優れたパスワードの選び方</p></li><li class="listitem"><p><a class="ulink" href="http://world.std.com/~reinhold/diceware.html" target="_top">http://world.std.com/~reinhold/diceware.html</a></p><p>パスワード決定に関する面白い考え</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html" target="_top">http://www.interhack.net/people/cmcurtin/snake-oil-faq.html</a>
     </p><p>良い暗号、悪い暗号に関する説明</p></li></ul></div></div><div class="sect3" id="id-1.11.7.35.10.6"><div class="titlepage"><div><div><h4 class="title">F.26.6.5. 技術的な参考情報</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc4880" target="_top">https://tools.ietf.org/html/rfc4880</a></p><p>OpenPGPメッセージフォーマット</p></li><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc1321" target="_top">https://tools.ietf.org/html/rfc1321</a></p><p>MD5 メッセージダイジェストアルゴリズム</p></li><li class="listitem"><p><a class="ulink" href="https://tools.ietf.org/html/rfc2104" target="_top">https://tools.ietf.org/html/rfc2104</a></p><p>HMAC: Keyed-Hashing for Message Authentication.</p></li><li class="listitem"><p>      <a class="ulink" href="http://www.usenix.org/events/usenix99/provos.html" target="_top">http://www.usenix.org/events/usenix99/provos.html</a>
     </p><p>DES暗号、MD5暗号、bcryptアルゴリズムの比較</p></li><li class="listitem"><p>      <a class="ulink" href="http://en.wikipedia.org/wiki/Fortuna_(PRNG)" target="_top">http://en.wikipedia.org/wiki/Fortuna_(PRNG)</a>
     </p><p>Fortuna CSPRNGの説明</p></li><li class="listitem"><p><a class="ulink" href="http://jlcooke.ca/random/" target="_top">http://jlcooke.ca/random/</a></p><p>Linux用Jean-Luc Cooke Fortunaに基づく<code class="filename">/dev/random</code>ドライバ</p></li><li class="listitem"><p><a class="ulink" href="http://kodu.ut.ee/~lipmaa/crypto/" target="_top">http://kodu.ut.ee/~lipmaa/crypto/</a></p><p>暗号学に関するリンク集</p></li></ul></div></div></div><div class="sect2" id="id-1.11.7.35.11"><div class="titlepage"><div><div><h3 class="title">F.26.7. 作者</h3></div></div></div><p>   Marko Kreen <code class="email">&lt;<a class="email" href="mailto:markokr@gmail.com">markokr@gmail.com</a>&gt;</code>
  </p><p>   <code class="literal">pgcrypto</code>は以下のソースを使用しています。
  </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th><p>アルゴリズム</p></th><th><p>作者</p></th><th><p>元ソース</p></th></tr></thead><tbody><tr><td>DES crypt</td><td>David Burren他</td><td>FreeBSD libcrypt</td></tr><tr><td>MD5 crypt</td><td>Poul-Henning Kamp</td><td>FreeBSD libcrypt</td></tr><tr><td>Blowfish crypt</td><td>Solar Designer</td><td>www.openwall.com</td></tr><tr><td>Blowfish cipher</td><td>Simon Tatham</td><td>PuTTY</td></tr><tr><td>Rijndael cipher</td><td>Brian Gladman</td><td>OpenBSD sys/crypto</td></tr><tr><td>MD5ハッシュとSHA1</td><td>WIDE Project</td><td>KAME kame/sys/crypto</td></tr><tr><td>SHA256/384/512 </td><td>Aaron D. Gifford</td><td>OpenBSD sys/crypto</td></tr><tr><td>BIGNUM math</td><td>Michael J. Fromberger</td><td>dartmouth.edu/~sting/sw/imath</td></tr></tbody></table></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pgbuffercache.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="pgfreespacemap.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">F.25. pg_buffercache </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> F.27. pg_freespacemap</td></tr></table></div></body></html>