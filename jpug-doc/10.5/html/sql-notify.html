<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>NOTIFY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-move.html" title="MOVE" /><link rel="next" href="sql-prepare.html" title="PREPARE" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">NOTIFY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-move.html" title="MOVE">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-prepare.html" title="PREPARE">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-NOTIFY"><div class="titlepage"></div><a id="id-1.9.3.151.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">NOTIFY</span></h2><p>NOTIFY — 通知を生成する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">NOTIFY <em class="replaceable"><code>channel</code></em> [ , <em class="replaceable"><code>payload</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.151.5"><h2>説明</h2><p><code class="command">NOTIFY</code>コマンドは、現在のデータベース内で事前に指定チャネル名について<code class="command">LISTEN <em class="replaceable"><code>channel</code></em></code>コマンドを実行したクライアントアプリケーションに<span class="quote">“<span class="quote">ペイロード</span>”</span>文字列(省略可能)を持つ通知イベントを送ります。
通知はすべてのユーザから可視です。
  </p><p><code class="command">NOTIFY</code>は同一の<span class="productname">PostgreSQL</span>データベースにアクセスするプロセスの集合に対する単純なプロセス間通信の仕組みを提供します。
通知の際にペイロード文字列を送信することができます。
また、データベース内のテーブルを使用して通知者から（1つまたは複数の）リスナに追加的なデータを渡すことにより、構造化されたデータを渡す高度な仕組みを構築することができます。
  </p><p>通知イベントとしてクライアントに渡される情報には、通知チャネル名と通知を行うセッションのサーバプロセスの<acronym class="acronym">PID</acronym>、ペイロード文字列(指定されていなければ空文字列)が含まれます。
  </p><p>各データベースにおいて使用される通知チャネル名とその意味についての定義は、データベース設計者に任されています。
通知チャネル名には、データベース内のテーブル名と同じものを使用するのが一般的です。
通知イベントは本質的に<span class="quote">“<span class="quote">このテーブルを変更しました。変更された箇所を確認してください</span>”</span>ということを意味するものです。
しかし、<code class="command">NOTIFY</code>コマンドと<code class="command">LISTEN</code>コマンドでは、そのような関連付けは強制されていません。
例えば、データベース設計者は、1つのテーブルに対する異なる種類の変更を通知するために、複数の異なる通知チャネル名を使用することができます。
他の方法としてペイロード文字列を使用して各種様々な状況に対応させることもできます。
  </p><p>特定のテーブルが変更されたことを通知するために<code class="command">NOTIFY</code>を使用する場合、<code class="command">NOTIFY</code>をテーブル更新時に発行される文トリガー内に配置すると便利です。
こうすると、通知はテーブルが変更された時に自動的に行われるので、アプリケーションプログラマが通知の実行を忘れるといった事故を防ぐことができます。
  </p><p><code class="command">NOTIFY</code>とSQLトランザクションの間には、いくつかの重要な相互作用があります。
まず、<code class="command">NOTIFY</code>がトランザクション内部で実行された場合、通知イベントはトランザクションがコミットされない限り配送されません。
トランザクションがアボートされた場合、<code class="command">NOTIFY</code>だけでなく、そのトランザクション内で行われたコマンドが全て無効化されるので、これは妥当といえます。
しかし、通知イベントが即座に配送されることを期待していた場合、当惑するかもしれません。
次に、監視中のセッションがトランザクション処理中に通知シグナルを受け取った場合、そのトランザクションが（コミットもしくはアボートされて）完了するまで、通知イベントは接続しているクライアントに配送されません。
この理由も同じです。トランザクションに通知が配送された後にそのトランザクションがアボートされた場合、何とかして通知を取り消したくなりますが、サーバはいったんクライアントに送信した通知を<span class="quote">“<span class="quote">取り戻す</span>”</span>ことはできません。
したがって、通知イベントはトランザクションとトランザクションの合間にのみ配送されます。
結論として、<code class="command">NOTIFY</code>を使用してシグナルの実時間処理をするアプリケーションではトランザクションを短くしておかなければなりません。
  </p><p>同じチャネル名が、同一トランザクションから同じペイロード文字列で複数回通知される場合、
データベースサーバは1つの通知のみを伝えるように決定することがあります。
一方、異なるペイロード文字列を持つ通知は常に別の通知として伝えられます。
同様に別のトランザクションからの通知が1つの通知にまとめられることは決してありません。
重複する通知インスタンスを後で削除する場合は例外ですが、<code class="command">NOTIFY</code>は同一トランザクションからの通知は送信された順番に配送されることを保証します。
また異なるトランザクションからのメッセージがトランザクションのコミット順で配送されることも保証します。
  </p><p><code class="command">NOTIFY</code>を実行するクライアント自身が、その通知の通知チャネルを監視していることはよくあります。
この場合、同じ通知名を監視する他のセッションに対するのと同じように通知イベントが戻ってきます。
アプリケーションのロジックにもよりますが、これは無駄な作業になることがあります。
例えば、そのセッションが書き出したばかりのデータベースに対する更新を調べるためにテーブルの再読み込みを行う場合などが考えられます。
通知元セッションのサーバプロセスの<acronym class="acronym">PID</acronym>(通知イベントメッセージ内にあります)と、自分自身の<acronym class="acronym">PID</acronym>(<span class="application">libpq</span>で得られます)が同じかどうか調べることで、こういった余計な作業を回避できます。
<acronym class="acronym">PID</acronym>が同じであれば、その通知イベントは自分自身から跳ね返ってきたものであり、無視することができます。
  </p></div><div class="refsect1" id="id-1.9.3.151.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>channel</code></em></span></dt><dd><p>シグナルとして送られる通知チャネル名です（任意の識別子）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>payload</code></em></span></dt><dd><p>通知と一緒に通信される<span class="quote">“<span class="quote">ペイロード</span>”</span>文字列です。
これは単純な文字列リテラルとして指定されなければなりません。
デフォルトの設定では、8000バイト未満でなければなりません。
(バイナリデータまたは大規模な情報を渡さなければならないのであれば、データベーステーブル内に格納しレコードのキーを送信することが最善です。)
     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.151.7"><h2>注釈</h2><p>送信済みだがすべての監視セッションでは処理されていない通知を保持するためのキューが存在します。
このキューがいっぱいになると、<code class="command">NOTIFY</code>を呼び出すトランザクションのコミットに失敗します。
キューはかなり大きなもの(標準のインストレーションで8ギガバイト)であり、ほとんどすべての環境で十分な大きさであるはずです。
しかしセッションが<code class="command">NOTIFY</code>を実行した後に長期間のトランザクションに入った場合、キューからクリーンアップできなくなります。
キューの半分までたまると、ログファイル内にクリーンアップを妨げているセッションを指し示す警告が現れるようになります。
この場合、クリーンアップ処理が進むように、確実にそのセッションでその現在のトランザクションを完了させるようにしなければなりません
  </p><p>関数<code class="function">pg_notification_queue_usage</code>は現在、保留中の通知によって占められているキューの割合を返します。
詳細な情報については<a class="xref" href="functions-info.html" title="9.25. システム情報関数">Section 9.25</a>を参照してください。
  </p><p><code class="command">NOTIFY</code>を実行したトランザクションでは二相コミットを準備することはできません。
  </p><div class="refsect2" id="id-1.9.3.151.7.5"><h3>pg_notify</h3><a id="id-1.9.3.151.7.5.2" class="indexterm"></a><p>通知を送信するために関数<code class="literal"><code class="function">pg_notify</code>(<code class="type">text</code>,<code class="type">text</code>)</code>を使用することもできます。
この関数は第1引数としてチャネル名、第2引数としてペイロードを取ります。
不定のチャネル名、ペイロードで作業しなければならない場合は、<code class="command">NOTIFY</code>コマンドよりこの関数を使用する方がかなり簡単です。
   </p></div></div><div class="refsect1" id="id-1.9.3.151.8"><h2>例</h2><p><span class="application">psql</span>から監視/通知処理の設定と実行を行います。

</p><pre class="programlisting">LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.</pre></div><div class="refsect1" id="id-1.9.3.151.9"><h2>互換性</h2><p>標準SQLには<code class="command">NOTIFY</code>はありません。
  </p></div><div class="refsect1" id="id-1.9.3.151.10"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-listen.html" title="LISTEN"><span class="refentrytitle">LISTEN</span></a>, <a class="xref" href="sql-unlisten.html" title="UNLISTEN"><span class="refentrytitle">UNLISTEN</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-move.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-prepare.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">MOVE </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> PREPARE</td></tr></table></div></body></html>