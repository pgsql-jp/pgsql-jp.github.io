<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>24.1. 定常的なバキューム作業</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="maintenance.html" title="Chapter 24. 定常的なデータベース保守作業" /><link rel="next" href="routine-reindex.html" title="24.2. 定常的なインデックスの再作成" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">24.1. 定常的なバキューム作業</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="maintenance.html" title="Chapter 24. 定常的なデータベース保守作業">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="maintenance.html" title="Chapter 24. 定常的なデータベース保守作業">Up</a></td><th width="60%" align="center">Chapter 24. 定常的なデータベース保守作業</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="routine-reindex.html" title="24.2. 定常的なインデックスの再作成">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ROUTINE-VACUUMING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">24.1. 定常的なバキューム作業</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-BASICS">24.1.1. バキューム作業の基本</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-SPACE-RECOVERY">24.1.2. ディスク容量の復旧</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-STATISTICS">24.1.3. プランナ用の統計情報の更新</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-VISIBILITY-MAP">24.1.4. 可視性マップの更新</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND">24.1.5. トランザクションIDの周回エラーの防止</a></span></dt><dt><span class="sect2"><a href="routine-vacuuming.html#AUTOVACUUM">24.1.6. 自動バキュームデーモン</a></span></dt></dl></div><a id="id-1.6.11.10.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>データベースは<em class="firstterm">バキューム処理</em>として知られている定期的な保守を必要とします。
多くのインストレーションでは、<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">Section 24.1.6</a>で説明されている<em class="firstterm">自動バキュームデーモン</em>でのバキューム処理を行わせることで充分です。
それぞれの状況に合った最善の結果を得るため、そこで説明する自動バキューム用パラメータの調整が必要かもしれません。
データベース管理者によっては、<span class="application">cron</span>もしくは<span class="application">タスクスケジューラ</span>スクリプトに従って典型的に実行される、手作業管理の<code class="command">VACUUM</code>コマンドによりデーモンの活動を補足したり、置き換えたりすることを意図するかもしれません。
手作業管理のバキューム処理を適切に設定するためには、以下のいくつかの小節で説明する問題点を理解することが必須です。
自動バキューム処理に信頼をおいている管理者にとっても、この資料に目を通すことはそれらの理解と自動バキューム処理の調整に役に立つことでしょう。
  </p><div class="sect2" id="VACUUM-BASICS"><div class="titlepage"><div><div><h3 class="title">24.1.1. バキューム作業の基本</h3></div></div></div><p><span class="productname">PostgreSQL</span>の<a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a>コマンドは以下の理由により定期的にそれぞれのテーブルを処理しなければなりません。

    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">更新、あるいは削除された行によって占められたディスク領域の復旧または再利用。</li><li class="listitem"><span class="productname">PostgreSQL</span>問い合わせプランナによって使用されるデータ統計情報の更新。</li><li class="listitem">可視性マップの更新。
これにより<a class="link" href="indexes-index-only-scans.html" title="11.11. インデックスオンリースキャン">インデックスオンリースキャン</a>が高速化される。
      </li><li class="listitem"><em class="firstterm">トランザクションIDの周回</em>または<em class="firstterm">マルチトランザクションIDの周回</em>による非常に古いデータの損失を防止。</li></ol></div><p>

以降の小節で説明するように、これらの理由の1つ1つは<code class="command">VACUUM</code>操作の実行について、その頻度の変動や対象領域の変動に影響します。
   </p><p><code class="command">VACUUM</code>には、標準<code class="command">VACUUM</code>と<code class="command">VACUUM FULL</code>という２つの種類があります。
<code class="command">VACUUM FULL</code>はより多くのディスク容量を回収することができますが、実行にとても時間がかかります。
また、<code class="command">VACUUM</code>の標準形式は実運用のデータベースに対する操作と同時に実行させることができます。
（<code class="command">SELECT</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>などのコマンドは通常通りに動作し続けます。
しかし、バキューム処理中は<code class="command">ALTER TABLE</code>などのコマンドを使用してテーブル定義を変更することはできません。）
<code class="command">VACUUM FULL</code>はそれが作用する全てのテーブルに対し排他ロックを必要とするので、それらテーブルのその他の用途と並行して行うことはできません。
一般的に、管理者は標準<code class="command">VACUUM</code>の使用に努め、<code class="command">VACUUM FULL</code>の使用を避けるべきです。
   </p><p><code class="command">VACUUM</code>は、かなりの量のI/Oトラフィックを発生させます。
このため、他の実行中のセッションの性能を劣化させる可能性があります。
バックグラウンドで実行されるバキューム処理による性能への影響を軽減させることを調整できるような設定パラメータがあります。
<a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="19.4.4. コストに基づくVacuum遅延">Section 19.4.4</a>を参照してください。
   </p></div><div class="sect2" id="VACUUM-FOR-SPACE-RECOVERY"><div class="titlepage"><div><div><h3 class="title">24.1.2. ディスク容量の復旧</h3></div></div></div><a id="id-1.6.11.10.5.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>では、行の<code class="command">UPDATE</code>もしくは<code class="command">DELETE</code>は古い行を即座に削除しません。
この方法は、多版同時性制御（<acronym class="acronym">MVCC</acronym>。<a class="xref" href="mvcc.html" title="Chapter 13. 同時実行制御">Chapter 13</a>を参照してください）の恩恵を受けるために必要なものです。
あるバージョンの行は他のトランザクションから参照される可能性がある場合は削除されてはなりません。
しかし最終的には、更新された前の行や削除された行を参照するトランザクションはなくなります。
必要なディスク容量が無制限に増加しないように、これらが占める領域は、新しい行で再利用できるように回収されなければなりません。
これは<code class="command">VACUUM</code>を実行することで行われます。
   </p><p>標準形式の<code class="command">VACUUM</code>は、テーブルとインデックス内の不要な行を削除し、その領域を将来の再利用が可能であるものとして記録します。
しかし、その領域をオペレーティングシステムに返却することはありません。
例外として、テーブルの末尾に完全に空のページが存在し、かつそのテーブルの排他ロックが容易に獲得できるような特殊な場合には、その領域を返却します。
対照的に<code class="command">VACUUM FULL</code>は、不要な領域のない全く新しいバージョンのテーブルファイルを書き出すことで、積極的にテーブルを圧縮します。
テーブルの容量を最小化しますが、長い時間がかかる可能性があります。
また操作が終わるまで、テーブルの新しいコピー用に余計なディスク領域を必要とします。
   </p><p>定常的なバキューム作業の通例の目安は<code class="command">VACUUM FULL</code>の必要性を避けるに充分な頻度で標準<code class="command">VACUUM</code>を行うことです。
自動バキュームデーモンはこのようにして作動を試みます。
そして実際<code class="command">VACUUM FULL</code>を行いません。
この手法において、その発想はテーブルを最小サイズに保つのではなく、ディスク領域使用の安定状態を保持することです。
それぞれのテーブルは、その最小サイズにバキューム作業とバキューム作業の間で使用されることになる容量を加えたのに等しい空間を占有します。
<code class="command">VACUUM FULL</code>は、テーブルをその最小サイズまで縮小し、ディスク空間をオペレーティングシステムに返却するために使用することができますが、もし将来そのテーブルが再び肥大化するのであれば、大した意味がありません。
従って、程よい頻度の標準<code class="command">VACUUM</code>を実行するほうが、不定期の<code class="command">VACUUM FULL</code>を実行するより大量の更新テーブルを保守するにはより良い取り組みとなります。
   </p><p>例えば負荷が少ない夜間に全ての作業を行うように、一部の管理者は自身で計画したバキューム作業の方を選びます。
固定したスケジュールに従ってバキューム作業を行うことについての問題は、もし更新作業によりテーブルが予期せぬ急増に遭遇した場合、空き領域を回収するために<code class="command">VACUUM FULL</code>が本当に必要となるところまで肥大化することです。
自動バキュームデーモンを使用することにより、この問題は緩和されます。
なぜなら、このデーモンは更新作業に反応して動的にバキューム作業を計画するからです。
完全に作業量を予測することができない限り、デーモンを完全に無効化するのは勧められません。
取り得る妥協案の1つは、いつになく激しい更新作業にのみ反応するよう、デーモンのパラメータを設定することです。
これにより、抑制可能な範囲を維持しつつ、負荷が標準的な場合に計画化された<code class="command">VACUUM</code>がまとめて作業を行うことを想定することができます。
   </p><p>自動バキュームを使用しない場合の典型的な方式は、データベース全体の<code class="command">VACUUM</code>を1日1回使用頻度が低い時間帯にスケジュールすることです。
必要に応じて、更新頻度の激しいテーブルのバキューム処理をより頻繁に行うよう追加してください。
（非常に高い頻度でデータの更新を行うインストレーションの中では、分間隔位という頻度で高負荷なテーブルの<code class="command">VACUUM</code>を行うこともあります。）
1つのクラスタで複数のデータベースがある場合、それぞれをバキュームすることを忘れないでください。
<a class="xref" href="app-vacuumdb.html" title="vacuumdb"><span class="refentrytitle"><span class="application">vacuumdb</span></span></a>プログラムが役に立つかもしれません。
   </p><div class="tip"><h3 class="title">Tip</h3><p>大規模な更新や削除作業の結果としてテーブルが不要な行バージョンを大量に含む場合、通常の<code class="command">VACUUM</code>では満足のゆくものではないかもしれません。
もしそのようなテーブルを所有し、それが占有する余分なディスク空間の回収が必要であれば、<code class="command">VACUUM FULL</code>、またはその代わりに<a class="xref" href="sql-cluster.html" title="CLUSTER"><span class="refentrytitle">CLUSTER</span></a>やテーブルを書き換える<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>構文の1つを使用しなければなりません。
これらのコマンドはテーブル全体を新しいコピーに書き換え、それに対する新規インデックスを作成します。
これらの選択肢はすべて排他ロックを必要とします。
新しいものが完成するまで、テーブルの旧コピーとインデックスは解放されませんので、元のテーブルと同程度の容量の余計なディスク領域も一時的に使用することに注意してください。
   </p></div><div class="tip"><h3 class="title">Tip</h3><p>テーブルの内容が定期的に完全に削除される場合、<code class="command">DELETE</code>の後に<code class="command">VACUUM</code>を使用するよりも、<a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>を使用する方が良いでしょう。
<code class="command">TRUNCATE</code>はテーブルの全ての内容を即座に削除します。
また、その後に不要となったディスク容量を回収するために<code class="command">VACUUM</code>や<code class="command">VACUUM FULL</code>を行う必要がありません。
不利な点は厳格なMVCC動作が違反となることです。
   </p></div></div><div class="sect2" id="VACUUM-FOR-STATISTICS"><div class="titlepage"><div><div><h3 class="title">24.1.3. プランナ用の統計情報の更新</h3></div></div></div><a id="id-1.6.11.10.6.2" class="indexterm"></a><a id="id-1.6.11.10.6.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>問い合わせプランナは、優れた問い合わせ計画を作成するのに、テーブルの内容に関する統計情報に依存しています。
この統計情報は<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>によって収集されます。
このコマンドはそのものを呼び出す以外にも、<code class="command">VACUUM</code>のオプション処理としても呼び出すことができます。
合理的な精度の統計情報を持つことは重要です。
さもないと非効率的な計画を選択してしまい、データベースの性能を悪化させてしまいます。
   </p><p>自動バキュームデーモンが有効になっている場合は、テーブルの内容が大きく変更されたときはいつでも自動的に<code class="command">ANALYZE</code>コマンドを発行します。
しかし、特にテーブルの更新作業が<span class="quote">“<span class="quote">興味のある</span>”</span>列の統計情報に影響を与えないことが判っている時、手作業により計画された<code class="command">ANALYZE</code>操作を当てにする方が好ましいと管理者は思うかもしれません。
デーモンは、挿入または更新された行数の関数として<code class="command">ANALYZE</code>を厳密に計画します。
しかし、意味のある統計情報の変更につながるかどうかは判りません。
   </p><p>領域復旧のためのバキューム処理と同様、頻繁な統計情報の更新は、滅多に更新されないテーブルよりも更新の激しいテーブルにとってより有益です。
しかし、頻繁に更新されるテーブルであっても、データの統計的な分布が大きく変更されなければ、統計情報を更新する必要はありません。
単純な鉄則は、テーブル内の列の最小値、最大値にどのくらいの変化があったかを考えることです。
例えば、行の更新時刻を保持する<code class="type">timestamp</code>列の場合、最大値は行が追加、更新されるにつれて、単純に増加します。
こういった列は、おそらく、例えば、あるWebサイト上のアクセスされたページのURLを保持する列よりも頻繁に統計情報を更新する必要があるでしょう。
このURL列の更新頻度も高いものかもしれませんが、その値の統計的な分布の変更は相対的に見ておそらく低いものです。
   </p><p>特定のテーブルに対して<code class="command">ANALYZE</code>を実行することができます。
また、テーブルの特定の列のみに対してさえも実行することができます。
ですので、アプリケーションの要求に応じて、他よりも頻繁に一部の統計情報を更新できるような柔軟性があります。
しかし、実際には、操作が高速であるため、単にデータベース全体を解析することが最善です。
<code class="command">ANALYZE</code>は、すべての行を読むのではなく、テーブルから統計的にランダムな行を抽出して使用します。
   </p><div class="tip"><h3 class="title">Tip</h3><p>列単位での<code class="command">ANALYZE</code>実行頻度の調整はあまり実用的とは言えるものではありませんが、<code class="command">ANALYZE</code>で集計される統計情報の詳細レベルの調整を列単位で行うことは価値がある場合があります。
<code class="literal">WHERE</code>句でよく使用され、データ分布の規則性がほとんどない列は、他の列よりもより細かいデータの度数分布が必要になるでしょう。
<code class="command">ALTER TABLE SET STATISTICS</code>を参照するか、<a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>設定パラメータでデータベース全体のデフォルトを変更してください。
    </p><p>またデフォルトで、関数の選択性に関して利用可能な制限付きの情報があります。
しかし、関数呼び出しを使用する式インデックスを作成する場合、有用な統計情報が関数に関して収集されます。
これにより式インデックスを使用する問い合わせ計画を大きく改良することができます。
    </p></div><div class="tip"><h3 class="title">Tip</h3><p>自動バキュームデーモンは、有益になる頻度を決定する手段がありませんので、外部テーブルに対して<code class="command">ANALYZE</code>コマンドを発行しません。
問い合わせが適切な計画作成のために外部テーブルの統計情報が必要であれば、適当なスケジュールでこれらのテーブルに対して手作業で管理する<code class="command">ANALYZE</code>コマンドを実行することを勧めます。
    </p></div></div><div class="sect2" id="VACUUM-FOR-VISIBILITY-MAP"><div class="titlepage"><div><div><h3 class="title">24.1.4. 可視性マップの更新</h3></div></div></div><p>バキュームは、どのページにすべての有効トランザクション（およびページが再度更新されるまでの将来のトランザクション）で可視であることが分かっているタプルのみが含まれるかを追跡するために、各テーブルの<a class="link" href="storage-vm.html" title="66.4. 可視性マップ">可視性マップ</a>の保守を行います。
２つの目的があります。
１つ目はバキューム自身が、整理するものがありませんので、こうしたページを次回飛ばすことができます。
   </p><p>２つ目は、<span class="productname">PostgreSQL</span>が、背後にあるテーブルを参照することなく、インデックスのみを使用して一部の問い合わせに応えることができるようになります。
<span class="productname">PostgreSQL</span>のインデックスにはタプルの可視性に関する情報を持ちませんので、通常のインデックススキャンは合致したインデックス項目のヒープタプルを取り込み、現在のトランザクションから可視であるべきかどうか検査します。
一方で<a class="link" href="indexes-index-only-scans.html" title="11.11. インデックスオンリースキャン"><em class="firstterm">インデックスオンリースキャン</em></a>はまず可視性マップを検査します。
そのページのタプルがすべて可視であることが分かれば、ヒープの取り出しを省くことができます。
可視性マップによりディスクアクセスを防ぐことができる大規模なデータ群に対して、特に有効です。
可視性マップはヒープより非常に小さいため、ヒープが非常に大きい場合であっても簡単にキャッシュすることができます。
   </p></div><div class="sect2" id="VACUUM-FOR-WRAPAROUND"><div class="titlepage"><div><div><h3 class="title">24.1.5. トランザクションIDの周回エラーの防止</h3></div></div></div><a id="id-1.6.11.10.8.2" class="indexterm"></a><a id="id-1.6.11.10.8.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>の<a class="link" href="mvcc-intro.html" title="13.1. 序文">MVCC</a>トランザクションのセマンティックは、トランザクションID（<acronym class="acronym">XID</acronym>）番号の比較が可能であることに依存しています。
現在のトランザクションのXIDよりも新しい挿入時のXIDを持ったバージョンの行は、<span class="quote">“<span class="quote">未来のもの</span>”</span>であり、現在のトランザクションから可視であってはなりません。
しかし、トランザクションIDのサイズには制限（32ビット）があり、長時間（40億トランザクション）稼働しているクラスタは<em class="firstterm">トランザクションの周回</em>を経験します。
XIDのカウンタが一周して0に戻り、そして、突然に、過去になされたトランザクションが将来のものと見えるように、つまり、その出力が不可視になります。
端的に言うと、破滅的なデータの損失です。
（実際はデータは保持されていますが、それを入手することができなければ、慰めにならないでしょう。）
これを防ぐためには、すべてのデータベースにあるすべてのテーブルを少なくとも20億トランザクションごとにバキュームする必要があります。
   </p><p>定期的なバキューム処理によりこの問題が解決する理由は、<code class="command">VACUUM</code>が行に<span class="emphasis"><em>凍結状態</em></span>という印をつけて、挿入トランザクションの効果が確実に可視になるような十分遠い過去にコミットされたトランザクションによりそれらが挿入されたことを表すからです。
<span class="productname">PostgreSQL</span>は特別なXID、<code class="literal">FrozenTransactionId</code>を確保します。
このXIDは通常のXIDの比較規則には従わず、常に全ての通常のXIDよりも古いものとみなされます。
通常のXID（2以上の値）はmodulo-2<sup>32</sup>という数式を使用して比較されます。
これは、全ての通常のXIDでは、20億の<span class="quote">“<span class="quote">より古い</span>”</span>XIDと20億の<span class="quote">“<span class="quote">より新しい</span>”</span>XIDが存在することを意味します。
言い換えると、通常のXID空間は終わることなく循環されているということです。
そのため、ある特定のXIDであるバージョンの行を作成すると、そのバージョンの行は、以降の20億トランザクションからはどの通常のXIDについて比較しているのかには関係なく、 <span class="quote">“<span class="quote">過去のもの</span>”</span>と認識されます。
そのバージョンの行が20億トランザクション以上後にも存在していた場合、それは突然に未来のものとして認識されます。
これを防ぐために、凍結された行バージョンは挿入XIDが<code class="literal">FrozenTransactionId</code>であるかのように扱われ、それで、周回問題に関係なく、すべての通常のトランザクションから<span class="quote">“<span class="quote">過去のもの</span>”</span>として認識され、また、そのバージョンの行はどれだけ古いものであろうと、削除されるまで有効状態となります。
   </p><div class="note"><h3 class="title">Note</h3><p>9.4より前のバージョンの<span class="productname">PostgreSQL</span>では、行の挿入XIDを実際に<code class="literal">FrozenTransactionId</code>で置換することで凍結が実装されており、これは行の<code class="structname">xmin</code>システム列として見えていました。
それより新しいバージョンでは単にフラグのビットをセットするだけで、行の元の<code class="structname">xmin</code>は後の検証での利用に備えて保存します。
しかし、9.4以前のバージョンから<span class="application">pg_upgrade</span>でアップグレードしたデータベースでは、<code class="structname">xmin</code>が <code class="literal">FrozenTransactionId</code> (2)に等しい行がまだあるかもしれません。
    </p><p>また、システムカタログには<code class="structname">xmin</code>が<code class="literal">BootstrapTransactionId</code> (1)に等しい行が含まれる場合があり、これはその行が<span class="application">initdb</span>の最初の段階で挿入されたことを意味します。
<code class="literal">FrozenTransactionId</code>と同様、この特別なXIDはすべての通常のXIDよりも古いものとして扱われます。
    </p></div><p><a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>は、その行バージョンが凍結される前に、XID値がどのくらい経過しているのかを制御します。
この設定値を大きくすることで、そうでなければ凍結状態になる行がすぐに再び修正されるのであれば、不必要な作業を避けられるかもしれませんが、この設定値を小さくすることでテーブルを次にバキュームする必要が起こるまで継続できるトランザクション数が増加します。
   </p><p><code class="command">VACUUM</code>は<a class="link" href="storage-vm.html" title="66.4. 可視性マップ">可視性マップ</a>を使用して、テーブルのどのページを走査する必要があるかを決定します。
通常は、不要な行バージョンを持っていないページを読み飛ばします。
このとき、そのページに古いXID値の行バージョンがまだある可能性があったとしても読み飛ばします。
したがって、通常の<code class="command">VACUUM</code>では必ずしもテーブル内のすべての古い行バージョンを凍結するわけではありません。
定期的に<code class="command">VACUUM</code>は<em class="firstterm">積極的なバキューム</em>を実行し、そのときは不要な行も凍結されていないXID値やMXID値もないページのみを読み飛ばします。
<a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>は<code class="command">VACUUM</code>がいつこれを行うかを制御します。
つまり、最後にそのような走査が行われた後に実行されたトランザクションの数が<code class="varname">vacuum_freeze_table_age</code>から<code class="varname">vacuum_freeze_min_age</code>を引いた数より大きいとき、全可視ではあるが全凍結ではないページも走査されます。
<code class="varname">vacuum_freeze_table_age</code>を0に設定すると<code class="command">VACUUM</code>はすべての走査についてこのより積極的な戦略を使うようになります。
   </p><p>テーブルをバキュームすることなく処理できる最大の時間は、20億トランザクションから最後に積極的なバキュームを実行した時点の<code class="varname">vacuum_freeze_min_age</code>の値を差し引いたものです。
この時間よりも長期間バキュームを行わないと、データ損失が発生するかもしれません。
これを確実に防止するために、自動バキュームが<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>設定パラメータで指定された時代より古いXIDを持つ、凍結状態でない行を含む可能性がある任意のテーブルに対して呼び出されます。
（これは自動バキュームが無効であっても起こります。）
   </p><p>これは、あるテーブルがバキュームされていなかったとしても、自動バキュームがおよそ<code class="varname">autovacuum_freeze_max_age</code> - <code class="varname">vacuum_freeze_min_age</code>トランザクション毎に呼び出されることを意味します。
領域確保のために定常的にバキューム処理を行うテーブルでは、これは重要ではありません。
しかし、（挿入のみで更新や削除が行われないテーブルを含む）静的なテーブルでは、領域確保のためのバキューム処理を行う必要がなくなりますので、非常に長期間静的なテーブルでは、強制的な自動バキューム間の間隔を最大まで延ばすことができます。
記載するまでもありませんが、<code class="varname">autovacuum_freeze_max_age</code>を増やすことでも<code class="varname">vacuum_freeze_min_age</code>を減らすことでも、これを行うことができます。
   </p><p><code class="varname">vacuum_freeze_table_age</code>に対する有効な最大値は0.95 * <code class="varname">autovacuum_freeze_max_age</code>です。
これより値が高いと値は最大値までに制限されます。
<code class="varname">autovacuum_freeze_max_age</code>より高い値は、周回防止用の自動バキュームがその時点でいずれにせよ誘発され、0.95という乗算係数がそれが起こる前に手動による<code class="command">VACUUM</code>実行の余地を残すため、意味を持ちません。
経験則に従うと、定期的に計画された<code class="command">VACUUM</code>もしくは通常の削除・更新作業により誘発された自動バキュームがその期間で実行されるように十分な間隔を残しておくように、<code class="command">vacuum_freeze_table_age</code>は<code class="varname">autovacuum_freeze_max_age</code>より多少低い値に設定されるべきです。
これを余りにも近い値に設定すると、たとえ領域を回収するために最近テーブルがバキュームされたとしても、周回防止用の自動バキュームに帰着します。
一方より低い値はより頻繁な積極的バキュームを引き起こします。
   </p><p><code class="varname">autovacuum_freeze_max_age</code>（およびそれに付随する<code class="varname">vacuum_freeze_table_age</code>）を増やす唯一の欠点は、データベースクラスタのサブディレクトリ<code class="filename">pg_xact</code>と<code class="filename">pg_commit_ts</code>がより大きな容量となることです。
<code class="varname">autovacuum_freeze_max_age</code>の範囲まですべてのトランザクションのコミット状況と(<code class="varname">track_commit_timestamp</code>が指定されていれば)タイムスタンプを格納しなければならないためです。
コミット状況は1トランザクション当たり2ビット使用しますので、もし<code class="varname">autovacuum_freeze_max_age</code>をその最大許容値である20億に設定している場合、<code class="filename">pg_xact</code>はおよそ0.5ギガバイトまで、<code class="filename">pg_commit_ts</code>は約20GBまで膨らむものと考えられます。
これがデータベースサイズ全体に対してとるに足らないものであれば、<code class="varname">autovacuum_freeze_max_age</code>を最大許容値に設定することを勧めます。
さもなければ、<code class="filename">pg_xact</code>と<code class="filename">pg_commit_ts</code>の容量として許容できる値に応じてそれらを設定してください。
（デフォルトは2億トランザクションです。換算すると<code class="filename">pg_xact</code>はおよそ50MB、<code class="filename">pg_commit_ts</code>はおよそ2GBの容量となります。）
   </p><p><code class="varname">vacuum_freeze_min_age</code> を減らすことにも1つ欠点があります。
これにより<code class="command">VACUUM</code>が大して役に立たなくなるかもしれません。
テーブル行がすぐに変更される場合（新しいXIDを獲得することになります）、行バージョンを凍結することは時間の無駄です。
そのため、この設定は、行の変更が起こらなくなるまで凍結されない程度に大きくすべきです。
   </p><p>データベース内のもっとも古い凍結されていないXIDの年代を追跡するために、<code class="command">VACUUM</code>はシステムテーブル<code class="structname">pg_class</code>と<code class="structname">pg_database</code>にXID統計情報を保持します。
特に、テーブルに対応する<code class="structname">pg_class</code>行の<code class="structfield">relfrozenxid</code>列には、テーブルに対する最後の積極的な<code class="command">VACUUM</code>で使用された凍結切捨てXIDが含まれます。
この切り捨てXIDよりも古いXIDを持つトランザクションにより挿入されたすべての行は凍結状態であることが保証されています。
同様に、データベースに対応する<code class="structname">pg_database</code>行の<code class="structfield">datfrozenxid</code>列は、データベース内で現れる凍結されていないXIDの下限値です。
これは、そのデータベース内のテーブル当たりの<code class="structfield">relfrozenxid</code>値の最小値です。
この情報を検査する簡便な方法は、以下の問い合わせを実行することです。

</p><pre class="programlisting">SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;</pre><p>

<code class="literal">age</code>列は切り捨てXIDから現在のトランザクションXIDまでのトランザクション数を測ります。
   </p><p><code class="command">VACUUM</code>は通常は最後のバキュームの後で変更されたページのみ走査しますが、<code class="structfield">relfrozenxid</code>はテーブルの凍結されていないXIDを含むかもしれないすべてのページを走査したときのみ繰り上がります。
これは、<code class="structfield">relfrozenxid</code>が<code class="varname">vacuum_freeze_table_age</code>トランザクション年齢より大きい時、<code class="command">VACUUM</code>の<code class="literal">FREEZE</code>オプションが使用された時、もしくは使用されない行バージョンを削除するため全てのページをバキュームしなければならなくなった時に発生します。
<code class="command">VACUUM</code>がテーブルの全凍結になっていないすべてのページを走査したとき、<code class="literal">age(relfrozenxid)</code>は、使用された<code class="varname">vacuum_freeze_min_age</code>設定より若干大きくなるはずです
（<code class="command">VACUUM</code>を起動してから始まったトランザクションの数分大きくなります）。
<code class="structfield">relfrozenxid</code>を繰り上げる<code class="command">VACUUM</code>が<code class="varname">autovacuum_freeze_max_age</code>に達するまでにテーブルに対して発行されない場合、そのテーブルに対して自動バキュームが早急に強制されます。
   </p><p>何らかの理由により自動バキュームがテーブルの古いXIDの整理に失敗した場合、システムはデータベースの最古のXIDが周回ポイントから1000万トランザクションに達した場合と似たような警告メッセージを発行し始めます。

</p><pre class="programlisting">WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".</pre><p>

（ヒントで示唆されたように手動<code class="command">VACUUM</code>はこの問題を解決します。
しかし、<code class="command">VACUUM</code>はスーパーユーザで実行されなければなりません。
さもないとシステムカタログの処理に失敗し、このためデータベースの<code class="structfield">datfrozenxid</code>を桁上げすることができません。）
こうした警告も無視し続け、周回するまでのトランザクションが100万より少なくなると、システムは停止し、新しいトランザクションの起動を拒絶します。

</p><pre class="programlisting">ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and vacuum that database in single-user mode.</pre><p>

この100万トランザクションという安全マージンは、管理者が必要な<code class="command">VACUUM</code>コマンドを手作業で実行することで、データを失うことなくリカバリすることができるようにするために存在します。
しかし、システムがこの安全のための停止モードになると、コマンドを実行しませんので、実行するためには、サーバを停止し、シングルユーザモードでサーバを起動して<code class="command">VACUUM</code>を行う他ありません。
この停止モードはシングルユーザモードでは強制されません。
シングルユーザモードの使用に関する詳細は<a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a>マニュアルページを参照してください。
   </p><div class="sect3" id="VACUUM-FOR-MULTIXACT-WRAPAROUND"><div class="titlepage"><div><div><h4 class="title">24.1.5.1. マルチトランザクションと周回</h4></div></div></div><a id="id-1.6.11.10.8.17.2" class="indexterm"></a><a id="id-1.6.11.10.8.17.3" class="indexterm"></a><p><em class="firstterm">マルチトランザクションID</em>は複数のトランザクションによる行ロックをサポートするのに使われます。
タプルヘッダにはロック情報を格納するために限られた容量しかありませんので、二つ以上のトランザクションが同時に行をロックする時には必ず、その情報は<span class="quote">“<span class="quote">マルチプル（訳注:複数の）トランザクションID</span>”</span>、略してマルチトランザクションID、にエンコードされます。
あるマルチトランザクションIDにどのトランザクションIDが含まれているかという情報は<code class="filename">pg_multixact</code>サブディレクトリに別に格納されており、マルチトランザクションIDのみがタプルヘッダの<code class="structfield">xmax</code>フィールドに現れます。
トランザクションIDと同様に、マルチトランザクションIDは32ビットカウンタと対応する記憶領域として実装されており、どちらも注意深い年代管理や記憶領域の整理、周回の取り扱いが必要です。
各マルチトランザクションにはメンバの一覧を保持する独立した記憶領域があり、そこでも32ビットカウンタを使っているので同じように管理しなければなりません。
    </p><p>テーブルの何らかの部分に対し<code class="command">VACUUM</code>走査されるときはいつでも、そのときに見つかった<a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE">vacuum_multixact_freeze_min_age</a>よりも古いマルチトランザクションIDはすべて異なる値で置き換えられます。
異なる値とは、0かもしれませんし、単一のトランザクションIDかもしれませんし、より新しいマルチトランザクションIDかもしれません。
各テーブルでは、<code class="structname">pg_class</code>.<code class="structfield">relminmxid</code>がそのテーブルのタプルにまだ現れるマルチトランザクションIDのうちできるだけ古いものを保持しています。
この値が<a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE">vacuum_multixact_freeze_table_age</a>よりも古ければ、積極的バキュームが強制されます。
前節で説明したように、積極的なバキュームでは全凍結であるとわかっているページのみがスキップされます。
<code class="structname">pg_class</code>.<code class="structfield">relminmxid</code>に対してその年代を調べるのに<code class="function">mxid_age()</code>を使えます。
    </p><p>積極的な<code class="command">VACUUM</code>走査は、その原因が何かに関わらず、そのテーブルのその値を進めることができます。
結局、データベースすべてのテーブルすべてが走査され、最も古いマルチトランザクション値が進められますので、ディスク上でより古いマルチトランザクションを保持している領域は削除できます。
    </p><p>安全装置として、<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>よりもそのマルチトランザクション年代が大きいどのテーブルに対しても、積極的なバキューム走査が起こります。
メンバ記憶領域の使用量がアドレス指定可能な記憶領域の50%を越えた場合にも、積極的なバキューム走査は、マルチトランザクション年代の一番古いものから始めて、すべてのテーブルに対して段階的に起こります。
この種の積極的走査はどちらも、自動バキュームが名目上は無効にされていても発生します。
    </p></div></div><div class="sect2" id="AUTOVACUUM"><div class="titlepage"><div><div><h3 class="title">24.1.6. 自動バキュームデーモン</h3></div></div></div><a id="id-1.6.11.10.9.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>には、省略可能ですが強く推奨される<em class="firstterm">自動バキューム</em>という機能があります。
これは<code class="command">VACUUM</code>と<code class="command">ANALYZE</code>コマンドの実行を自動化することを目的としたものです。
有効にすると、自動バキュームは大量のタプルの挿入、更新、削除があったテーブルを検査します。
この検査は統計情報収集機能を使用します。
したがって、<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-COUNTS">track_counts</a>が<code class="literal">true</code>に設定されていないと、自動バキュームを使用することができません。
デフォルトの設定では、自動バキュームは有効で、関連するパラメータも適切に設定されています。
   </p><p>実際のところ<span class="quote">“<span class="quote">自動バキュームデーモン</span>”</span>は複数のプロセスから構成されます。
<em class="firstterm">自動バキュームランチャ</em>という永続的デーモンプロセスが存在し、<em class="firstterm">自動バキュームワーカ</em>プロセスがすべてのデータベースを処理します。
ランチャは、1つのワーカを各データベースに対し<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-NAPTIME">autovacuum_naptime</a>秒ごとに開始するよう試みることにより、時間に対して作業を分散化します。
（したがってインストレーションに<em class="replaceable"><code>N</code></em>個のデータベースがある場合、新規ワーカが<code class="varname">autovacuum_naptime</code>/<em class="replaceable"><code>N</code></em>秒毎に起動されます。）
同時に最大<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a>個のプロセスが実行可能です。
処理対象のデータベースが<code class="varname">autovacuum_max_workers</code>より多くある場合、次のデータベースは最初のワーカが終了するとすぐに処理されます。
それぞれのワーカプロセスはデータベース内の各テーブルを検査し、必要に応じて<code class="command">VACUUM</code>または<code class="command">ANALYZE</code>コマンドを発行します。
<a class="xref" href="runtime-config-autovacuum.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a>も自動バキュームワーカの活動を監視するために設定できます。
   </p><p>短期間にいくつかの大規模なテーブルがすべてバキューム対象として適切な状態になったとすると、すべての自動バキュームワーカはこうしたテーブルに対するバキューム処理に長い期間占領される可能性があります。
これにより、ワーカが利用できるようになるまで、他のテーブルやデータベースに対するバキュームが行われなくなります。
また、単一データベースに対するワーカ数には制限はありませんが、ワーカはすでに他のワーカによって実行された作業を繰り返さないように試みます。
ワーカの実行数は<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>制限にも<a class="xref" href="runtime-config-connection.html#GUC-SUPERUSER-RESERVED-CONNECTIONS">superuser_reserved_connections</a>制限にも計上されないことに注意してください。
   </p><p>テーブルの<code class="structfield">relfrozenxid</code>値が<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>トランザクション年齢よりも古い場合、そのテーブルは常にバキュームされます
（これはfreeze max ageがストレージパラメータにより変更されたテーブルに対しても適用されます。以下を参照）。
さもなければ、直前の<code class="command">VACUUM</code>の後に不要となったタプル数が<span class="quote">“<span class="quote">バキューム閾値</span>”</span>を超えると、テーブルはバキュームされます。
このバキューム閾値は以下のように定義されます。
</p><pre class="programlisting">バキューム閾値 = バキューム基礎閾値 + バキューム規模係数 * タプル数</pre><p>
ここで、バキューム基礎閾値は<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD">autovacuum_vacuum_threshold</a>、バキューム規模係数は<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR">autovacuum_vacuum_scale_factor</a>、タプル数は<code class="structname">pg_class</code>.<code class="structfield">reltuples</code>です。
不要となったタプル数は、統計情報コレクタから取り出されます。
これは、各<code class="command">UPDATE</code>、<code class="command">DELETE</code>操作で更新される、ほぼ正確な数です。
（負荷が高いと一部の情報が失われる可能性があることから、これはほぼ正確な数でしかありません。）
テーブルの<code class="structfield">relfrozenxid</code>値が<code class="varname">vacuum_freeze_table_age</code>トランザクション年齢より大きい場合、古いタプルを凍結して、<code class="structfield">relfrozenxid</code>を繰り上げるため、積極的なバキュームが実行されます。
そうでなければ最後のバキュームの後に変更されたページのみ走査されます。
   </p><p>解析でも似たような条件が使用されます。
以下で定義される閾値が、前回の<code class="command">ANALYZE</code>の後に挿入、更新、削除されたタプル数と比較されます。
</p><pre class="programlisting">解析閾値 = 解析基礎閾値 + 解析規模係数 * タプル数</pre><p>
   </p><p>一時テーブルには自動バキュームでアクセスすることはできません。
したがってセッションのSQLコマンドを用いて適切なバキュームおよび解析操作を行わなければなりません。
   </p><p>デフォルトの閾値と規模係数は、<code class="filename">postgresql.conf</code>から取られますが、(他の多くの自動バキューム制御パラメータと合わせて)テーブル毎に上書きすることができます。
より詳細な情報は<a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="格納パラメータ">格納パラメータ</a>を参照してください。
テーブルのストレージパラメータで設定が変更されると、そのテーブルを処理する時にその値が使用されます。
そうでなければ、全体設定が使われます。
全体設定についての詳細な情報は<a class="xref" href="runtime-config-autovacuum.html" title="19.10. 自動Vacuum作業">Section 19.10</a>を参照してください。
   </p><p>複数のワーカプロセスが実行している場合、自動バキュームコスト遅延パラメータ(<a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="19.4.4. コストに基づくVacuum遅延">Section 19.4.4</a>を参照してください)は実行中のワーカ全体に<span class="quote">“<span class="quote">振り分け</span>”</span>られます。
このため、ワーカの実稼働数に関らず、システムに与えるI/Oの総影響は変わりありません。
しかし、テーブル毎の<code class="literal">autovacuum_vacuum_cost_delay</code>または<code class="literal">autovacuum_vacuum_cost_limit</code>ストレージパラメータが設定されたテーブルを処理するワーカは振り分けアルゴリズムでは考慮されません。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="maintenance.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="maintenance.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="routine-reindex.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 24. 定常的なデータベース保守作業 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 24.2. 定常的なインデックスの再作成</td></tr></table></div></body></html>