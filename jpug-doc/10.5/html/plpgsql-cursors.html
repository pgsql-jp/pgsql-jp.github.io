<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.7. カーソル</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-control-structures.html" title="42.6. 制御構造" /><link rel="next" href="plpgsql-errors-and-messages.html" title="42.8. エラーとメッセージ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.7. カーソル</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-control-structures.html" title="42.6. 制御構造">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-errors-and-messages.html" title="42.8. エラーとメッセージ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-CURSORS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.7. カーソル</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-DECLARATIONS">42.7.1. カーソル変数の宣言</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-OPENING">42.7.2. カーソルを開く</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-USING">42.7.3. カーソルの使用</a></span></dt><dt><span class="sect2"><a href="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP">42.7.4. カーソル結果に対するループ</a></span></dt></dl></div><a id="id-1.8.8.9.2" class="indexterm"></a><p>問い合わせ全体を一度に実行するのではなく、<em class="firstterm">カーソル</em>を設定して、問い合わせをカプセル化し、問い合わせの結果を一度に数行ずつ読み取ることができます。
これを行う理由の1つは、結果内に多数の行がある場合のメモリの枯渇を防ぐことです。
（しかし、<span class="application">PL/pgSQL</span>ユーザは通常これを心配する必要はありません。
<code class="literal">FOR</code>ループは自動的にカーソルを内部的に使用してメモリの問題を防ぐからです。）
より興味深い使用方法として、呼び出し元が行を読み取ることをできるように、作成されたカーソルへの参照を返す方法があります。
これにより、関数から大量の行集合を返す際の効率が向上します。
   </p><div class="sect2" id="PLPGSQL-CURSOR-DECLARATIONS"><div class="titlepage"><div><div><h3 class="title">42.7.1. カーソル変数の宣言</h3></div></div></div><p><span class="application">PL/pgSQL</span>におけるカーソルへのアクセスは全て、カーソル変数を経由します。
カーソル変数は、常に特殊な<code class="type">refcursor</code>データ型です。
カーソル変数を作成する1つの方法は、単に<code class="type">refcursor</code>型の変数として宣言することです。
他の方法は、カーソル宣言構文を使用することです。
以下にその一般形を示します。
</p><pre class="synopsis"><em class="replaceable"><code>name</code></em> [<span class="optional"> [<span class="optional"> NO </span>] SCROLL </span>] CURSOR [<span class="optional"> ( <em class="replaceable"><code>arguments</code></em> ) </span>] FOR <em class="replaceable"><code>query</code></em>;</pre><p>
（<span class="productname">Oracle</span>との互換性のため、<code class="literal">FOR</code>は<code class="literal">IS</code>に置き換えることができます。）
もし<code class="literal">SCROLL</code>を指定すれば、カーソルは逆方向に移動できます。
もし<code class="literal">NO SCROLL</code>を指定すれば、逆方向の行の取り出しはできません。
どちらも指定しない時、逆方向に取り出しできるかは問い合わせに依存します。
もし<em class="replaceable"><code>arguments</code></em>があれば、<code class="literal"><em class="replaceable"><code>name</code></em> <em class="replaceable"><code>datatype</code></em></code>をカンマで区切ったリストで、与えられた問い合わせ内のパラメータ値として置換される名前を定義します。
その名前に実際に置換される値は、カーソルを開いた時点より後に指定されます。
    </p><p>以下に例を示します。
</p><pre class="programlisting">DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;</pre><p>
これら3つの変数は全て<code class="type">refcursor</code>データ型を持ちますが、最初のものは全ての問い合わせに使用でき、2番目には完全な問い合わせが既に<em class="firstterm">バウンド</em>されています（結び付けられています）。
また、最後のものには、パラメータ付きの問い合わせがバウンドされています
（<code class="literal">key</code>はカーソルが開いた時に整数パラメータ値に置き換えられます）。
<code class="literal">curs1</code>変数は、特定の問い合わせに結び付けられていませんので、<em class="firstterm">アンバウンド</em>であると呼ばれます。
    </p></div><div class="sect2" id="PLPGSQL-CURSOR-OPENING"><div class="titlepage"><div><div><h3 class="title">42.7.2. カーソルを開く</h3></div></div></div><p>カーソルを使用して行を取り出す前に、<em class="firstterm">開かれる</em>必要があります。
（これは<code class="command">DECLARE CURSOR</code> SQLコマンドの動作と同じです。）
<span class="application">PL/pgSQL</span>には3種類の<code class="command">OPEN</code>文があり、そのうちの2つはアンバウンドカーソル変数を使用し、残りの1つはバウンドカーソル変数を使用します。
    </p><div class="note"><h3 class="title">Note</h3><p>バウンドカーソル変数は<a class="xref" href="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP" title="42.7.4. カーソル結果に対するループ">Section 42.7.4</a>で説明されている<code class="command">FOR</code>文で、明示的にカーソルを開かなくても使用することができます。
     </p></div><div class="sect3" id="id-1.8.8.9.5.4"><div class="titlepage"><div><div><h4 class="title">42.7.2.1. <code class="command">OPEN FOR</code> <em class="replaceable"><code>query</code></em></h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>unbound_cursorvar</code></em> [<span class="optional"> [<span class="optional"> NO </span>] SCROLL </span>] FOR <em class="replaceable"><code>query</code></em>;</pre><p>カーソル変数は開かれ、実行するよう指定した問い合わせが付与されます。
既に開いたカーソルを開くことはできず、また、アンバウンドカーソル変数として（つまり、単なる<code class="type">refcursor</code>変数として）宣言されていなければなりません。
この問い合わせは<code class="command">SELECT</code>文であるか、または（<code class="command">EXPLAIN</code>のように）何らかの行を返すものでなければなりません。
この問い合わせは、他の<span class="application">PL/pgSQL</span>のSQL文と同様の方法で扱われます。
<span class="application">PL/pgSQL</span>の変数名は置き換えられ、問い合わせ計画は再利用できるようにキャッシュされます。
<span class="application">PL/pgSQL</span>変数がカーソルを使用する問い合わせに代入された時、変数は<code class="command">OPEN</code>時の値となり、その後の変更はカーソルの動きに影響しません。
<code class="literal">SCROLL</code>および<code class="literal">NO SCROLL</code>オプションの意味はバウンドカーソルと同様です。
       </p><p>以下に例を示します。
</p><pre class="programlisting">OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.9.5.5"><div class="titlepage"><div><div><h4 class="title">42.7.2.2. <code class="command">OPEN FOR EXECUTE</code></h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>unbound_cursorvar</code></em> [<span class="optional"> [<span class="optional"> NO </span>] SCROLL </span>] FOR EXECUTE <em class="replaceable"><code>query_string</code></em>
                                     [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>];</pre><p>カーソル変数は開かれ、実行するよう指定した問い合わせが付与されます。
既に開いたカーソルを開くことはできず、また、アンバウンドカーソル変数として（つまり、単なる<code class="type">refcursor</code>変数として）宣言されていなければなりません。
問い合わせは、<code class="command">EXECUTE</code>コマンドと同じ方法による文字列式として指定されます。
通常と同様に、これにより、次回に実行する際に違った問い合わせを計画できる柔軟性が得られます(<a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="42.10.2. 計画のキャッシュ">Section 42.10.2</a>参照)。
また、変数置換がコマンド文字列上で行われないことも意味します。
<code class="command">EXECUTE</code>と同様に<code class="literal">format()</code>と<code class="literal">USING</code>を介して動的コマンドにパラメータ値を挿入することができます。
<code class="literal">SCROLL</code>および<code class="literal">NO SCROLL</code>オプションの意味はバウンドカーソルと同様です。
         </p><p>以下に例を示します。
</p><pre class="programlisting">OPEN curs1 FOR EXECUTE format('SELECT * FROM %I WHERE col1 = $1',tabname) USING keyvalue;</pre><p>
この例では、テーブル名は問い合わせに<code class="function">format()</code>で挿入されています。
<code class="literal">col1</code>との比較値は<code class="literal">USING</code>経由で埋め込まれますので、引用符を付ける必要がありません。
       </p></div><div class="sect3" id="PLPGSQL-OPEN-BOUND-CURSOR"><div class="titlepage"><div><div><h4 class="title">42.7.2.3. バウンドカーソルを開く</h4></div></div></div><pre class="synopsis">OPEN <em class="replaceable"><code>bound_cursorvar</code></em> [<span class="optional"> ( [<span class="optional"> <em class="replaceable"><code>argument_name</code></em> := </span>] <em class="replaceable"><code>argument_value</code></em> [<span class="optional">, ...</span>] ) </span>];</pre><p>宣言時に問い合わせが結び付いたカーソル変数を開くために使用される<code class="command">OPEN</code>の形式です。
既に開いたカーソルを開くことはできません。
実引数の式のリストはカーソルが引数を取るものと宣言された場合にのみ現れます。
これらの値は問い合わせの中で置き換えられます。
         </p><p>バウンドカーソルの問い合わせ計画は常にキャッシュ可能とみなされます。
この場合、<code class="command">EXECUTE</code>と等価なものはありません。
<code class="literal">SCROLL</code>および<code class="literal">NO SCROLL</code>を<code class="command">OPEN</code>において指定できないことに注意してください。
カーソル移動の仕様はすでに決まっているからです。
         </p><p><em class="firstterm">位置的</em>表記または<em class="firstterm">記名的</em>表記を使用して、引数の値を渡すことができます。
位置的表記では、全ての引数が順番に指定されます。
記名的表記では、引数の式と区別するために<code class="literal">:=</code>を使用して、各々の引数の名前が指定されます。
<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">Section 4.3</a>に記述した関数呼び出しと同様に、位置的表記と記名的表記を混用できます。
         </p><p>例を示します（ここでは上例のカーソル宣言を使用します）。
</p><pre class="programlisting">OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);</pre><p>
         </p><p>変数の代入はバウンドカーソルの問い合わせで行われるため、カーソルへ値を渡す方法が2つあります。
<code class="command">OPEN</code>コマンドの明確な引数とするものと、問い合わせにおける<span class="application">PL/pgSQL</span>変数として暗黙的に参照するものです。
しかし、バウンドカーソルの宣言より前に宣言した変数だけが代入されます。
どちらの場合も、<code class="command">OPEN</code>の実行時に変数値が決まります。
例えば、上例の<code class="literal">curs3</code>と同じ結果を取得する方法を、以下に示します。
</p><pre class="programlisting">DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;</pre><p>
         </p></div></div><div class="sect2" id="PLPGSQL-CURSOR-USING"><div class="titlepage"><div><div><h3 class="title">42.7.3. カーソルの使用</h3></div></div></div><p>カーソルを開いてから、ここで説明する文を使用してカーソルを扱うことができます。
    </p><p>これらの操作は、カーソルを開始するために開いた関数内で行う必要はありません。
関数から<code class="type">refcursor</code>値を返し、呼び出し元でそのカーソルの操作をさせることもできます。
（内部的には<code class="type">refcursor</code>値は、カーソルへの有効な問い合わせを持つポータルの名前を示す単なる文字列です。
この名前は、ポータルを壊すことなく、他の<code class="type">refcursor</code>型の変数に代入することで、他に渡すことができます。）
    </p><p>全てのポータルは、暗黙的にトランザクションの終わりで閉ざされます。
したがって、<code class="type">refcursor</code>値はそのトランザクションの終わりまでの間のみ開いたカーソルへの参照として有効です。
    </p><div class="sect3" id="id-1.8.8.9.6.5"><div class="titlepage"><div><div><h4 class="title">42.7.3.1. <code class="literal">FETCH</code></h4></div></div></div><pre class="synopsis">FETCH [<span class="optional"> <em class="replaceable"><code>direction</code></em> { FROM | IN } </span>] <em class="replaceable"><code>cursor</code></em> INTO <em class="replaceable"><code>target</code></em>;</pre><p><code class="command">FETCH</code>は<code class="command">SELECT INTO</code>と同様に、カーソルから次の行を抽出し、対象に格納します。
対象とは、行変数、レコード変数、または単純な変数をカンマで区切ったリストです。
<code class="command">SELECT INTO</code>の場合と同様、特殊な<code class="literal">FOUND</code>変数を検査することで、行が取得できたかどうかを確認することができます。
    </p><p><em class="replaceable"><code>direction</code></em>句は複数行を取り出すことができるコマンドを除き、SQL <a class="xref" href="sql-fetch.html" title="FETCH"><span class="refentrytitle">FETCH</span></a>で許可されたどのようなコマンドも可能です。
すなわち、以下のものです。
     <code class="literal">NEXT</code>,
     <code class="literal">PRIOR</code>,
     <code class="literal">FIRST</code>,
     <code class="literal">LAST</code>,
     <code class="literal">ABSOLUTE</code> <em class="replaceable"><code>count</code></em>,
     <code class="literal">RELATIVE</code> <em class="replaceable"><code>count</code></em>,
     <code class="literal">FORWARD</code>または
     <code class="literal">BACKWARD</code>.
<em class="replaceable"><code>direction</code></em>句の省略は、<code class="literal">NEXT</code>の指定と同じです。
<code class="literal">SCROLL</code>オプションを用いてカーソルを宣言または開かないと、<em class="replaceable"><code>direction</code></em>の値による逆方向への移動の要求は失敗します。
    </p><p><em class="replaceable"><code>cursor</code></em>名は、開いているカーソルのポータルを参照する<code class="type">refcursor</code>変数名でなければなりません。
    </p><p>例：
</p><pre class="programlisting">FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.9.6.6"><div class="titlepage"><div><div><h4 class="title">42.7.3.2. <code class="literal">MOVE</code></h4></div></div></div><pre class="synopsis">MOVE [<span class="optional"> <em class="replaceable"><code>direction</code></em> { FROM | IN } </span>] <em class="replaceable"><code>cursor</code></em>;</pre><p><code class="command">MOVE</code>コマンドは、データを取り出さないでカーソルの位置を変更します。
移動先の行を返さないでカーソルの位置だけを変更することを除けば、<code class="command">FETCH</code>コマンドと同一の働きをします。
<code class="command">SELECT INTO</code>と同様に、特殊な変数<code class="literal">FOUND</code>を用いて、移動先に行が存在するかどうかを検査できます。
    </p><p>例:
</p><pre class="programlisting">MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.9.6.7"><div class="titlepage"><div><div><h4 class="title">42.7.3.3. <code class="literal">UPDATE/DELETE WHERE CURRENT OF</code></h4></div></div></div><pre class="synopsis">UPDATE <em class="replaceable"><code>table</code></em> SET ... WHERE CURRENT OF <em class="replaceable"><code>cursor</code></em>;
DELETE FROM <em class="replaceable"><code>table</code></em> WHERE CURRENT OF <em class="replaceable"><code>cursor</code></em>;</pre><p>カーソルの位置をテーブルの行に変更すれば、カーソルによって特定した行を更新または消去できます。
カーソル問い合わせは何が許されているのか（特にグループ化しないとき）についての制限があり、それはカーソル内で<code class="literal">FOR UPDATE</code>を使用することが最善です。
より詳細については<a class="xref" href="sql-declare.html" title="DECLARE"><span class="refentrytitle">DECLARE</span></a>マニュアルページを参照下さい。
       </p><p>以下に例を示します。
</p><pre class="programlisting">UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.9.6.8"><div class="titlepage"><div><div><h4 class="title">42.7.3.4. <code class="literal">CLOSE</code></h4></div></div></div><pre class="synopsis">CLOSE <em class="replaceable"><code>cursor</code></em>;</pre><p><code class="command">CLOSE</code>はポータルの背後にあるカーソルを閉じます。
これを使用してトランザクションの終わりよりも前にリソースを解放することができ、また、カーソル変数を解放し、再度開くことができます。
       </p><p>例：
</p><pre class="programlisting">CLOSE curs1;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.9.6.9"><div class="titlepage"><div><div><h4 class="title">42.7.3.5. カーソルを返す</h4></div></div></div><p><span class="application">PL/pgSQL</span>関数では、呼び出し元にカーソルを返すことができます。
この方法は、関数から複数行または複数列を返す場合、特にその結果集合が非常に大きい場合に有用です。
これを行うには、関数はカーソルを開き、呼び出し元にカーソル名を返します（もしくは、もし呼び出し元でポータル名がわかっていれば、単純に指定されたポータル名を使用してカーソルを開きます）。
これにより、呼び出し元はカーソルから行を取り出すことができるようになります。
カーソルは呼び出し元で閉じることができます。
または、トランザクションが終了した際に自動的に閉じられます。
       </p><p>カーソル用のポータル名は、プログラマが指定するか、または自動的に生成されます。
ポータル名を指定するには、開く前に、単に<code class="type">refcursor</code>変数に文字列を代入します。
<code class="type">refcursor</code>変数の文字列値は<code class="command">OPEN</code>によって、背後のポータル名として使用されます。
しかし、<code class="type">refcursor</code>変数がNULLの場合、<code class="command">OPEN</code>は自動的に既存のポータルと競合しない名前を生成し、それを<code class="type">refcursor</code>変数に代入します。
       </p><div class="note"><h3 class="title">Note</h3><p>バウンドカーソル変数は、その名前を表現する文字列値で初期化されます。
そのため、プログラマがカーソルを開く前に代入により上書きしない限り、ポータル名はカーソル変数と同じになります。
しかし、アンバウンドカーソル変数の初期値はデフォルトでNULLです。
そのため、上書きされていない場合に自動的に生成される一意な名前を受け取ります。
        </p></div><p>以下の例は、呼び出し元でカーソル名を指定する方法を示しています。

</p><pre class="programlisting">CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;</pre><p>
       </p><p>以下の例では、自動的に生成されたカーソル名を使用しています。

</p><pre class="programlisting">CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- カーソルを使用するには、トランザクション内部である必要があります。
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;</pre><p>
       </p><p>以下の例は単一関数から複数のカーソルを返す方法を示しています。

</p><pre class="programlisting">CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- カーソルを使用するには、トランザクション内部である必要があります。
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;</pre><p>
       </p></div></div><div class="sect2" id="PLPGSQL-CURSOR-FOR-LOOP"><div class="titlepage"><div><div><h3 class="title">42.7.4. カーソル結果に対するループ</h3></div></div></div><p>カーソルで返される行に対して反復することができる<code class="command">FOR</code>文の亜種があります。
構文は以下のようになります。

</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>recordvar</code></em> IN <em class="replaceable"><code>bound_cursorvar</code></em> [<span class="optional"> ( [<span class="optional"> <em class="replaceable"><code>argument_name</code></em> := </span>] <em class="replaceable"><code>argument_value</code></em> [<span class="optional">, ...</span>] ) </span>] LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>

カーソル変数は宣言されたとき、何らかの問い合わせとバウンドされていなければならず、また既に開かれていては<span class="emphasis"><em>なりません</em></span>。
<code class="command">FOR</code>文は自動的にカーソルを開き、ループから抜けたときに再度閉じます。
実際の引数値式のリストは、カーソルが引数を取ることを宣言された場合に限ってのみ出現できます。
これらの値は、<code class="command">OPEN</code>過程と同じ方法で、問い合わせの中で置換されます（<a class="xref" href="plpgsql-cursors.html#PLPGSQL-OPEN-BOUND-CURSOR" title="42.7.2.3. バウンドカーソルを開く">Section 42.7.2.3</a>を参照してください）。
   </p><p><em class="replaceable"><code>recordvar</code></em>変数は、<code class="type">record</code>型として自動的に定義され、ループ内でのみ存在します
（存在するいかなる変数名の定義もループ内では無視されます）。
カーソルによって返されたそれぞれの行はこのレコード変数に引き続いて割り当てられ、ループ本体が実行されます。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-control-structures.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-errors-and-messages.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.6. 制御構造 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.8. エラーとメッセージ</td></tr></table></div></body></html>