<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>24.3. ログファイルの保守</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="routine-reindex.html" title="24.2. 定常的なインデックスの再作成" /><link rel="next" href="backup.html" title="Chapter 25. バックアップとリストア" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">24.3. ログファイルの保守</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="routine-reindex.html" title="24.2. 定常的なインデックスの再作成">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="maintenance.html" title="Chapter 24. 定常的なデータベース保守作業">Up</a></td><th width="60%" align="center">Chapter 24. 定常的なデータベース保守作業</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="backup.html" title="Chapter 25. バックアップとリストア">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LOGFILE-MAINTENANCE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">24.3. ログファイルの保守</h2></div></div></div><a id="id-1.6.11.12.2" class="indexterm"></a><p>データベースサーバのログ出力を<code class="filename">/dev/null</code>に渡して単に破棄するのではなく、どこかに保存しておくことを推奨します。
問題の原因を究明する時にログ出力は貴重です。
しかし、ログ出力は（特により高いデバッグレベルの時に）巨大になりがちですので、際限なく保存したくはないでしょう。
新しいログファイルを開始させ、適切な期間を経過した古いログファイルを捨てるために、ログファイルを<span class="quote">“<span class="quote">回転</span>”</span>させる必要があります。
  </p><p>単に<code class="command">postgres</code>の<span class="systemitem">stderr</span>をファイルに渡している場合、ログ出力を保持できますが、そのログファイルを切り詰めるためにはサーバを停止させ、再度起動させるしか方法がありません。
開発環境で<span class="productname">PostgreSQL</span>を使用しているのであればこれで構いませんが、実運用サーバでこの振舞いが適切となることはほぼありません。
  </p><p>サーバの<span class="systemitem">stderr</span>を何らかのログ回転プログラムに送信する方が良いでしょう。
組み込みのログ回転機能があり、<code class="filename">postgresql.conf</code>の<code class="varname">logging_collector</code>設定パラメータを<code class="literal">true</code>に設定することでこれを使用することができます。
このプログラムを制御するパラメータについては<a class="xref" href="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE" title="19.8.1. ログの出力先">Section 19.8.1</a>で説明します。
また、この方法を使用して、機械読み取りしやすい<acronym class="acronym">CSV</acronym>(カンマ区分値)書式でログデータを取り込むことができます。
  </p><p>また、既に他のサーバソフトウェアで使用している外部のログ回転プログラムがあるのであれば、それを使用したいと考えるでしょう。
例えば、<span class="productname">Apache</span>配布物に含まれる<span class="application">rotatelogs</span>を<span class="productname">PostgreSQL</span>で使用することができます。
これを行うには、単にサーバの<span class="systemitem">stderr</span>を目的のプログラムにパイプで渡してください。
<code class="command">pg_ctl</code>を使用してサーバを起動している場合は<span class="systemitem">stderr</span>は既に<span class="systemitem">stdout</span>にリダイレクトされていますので、以下の例のようにコマンドをパイプする必要があるだけです。

</p><pre class="programlisting">pg_ctl start | rotatelogs /var/log/pgsql_log 86400</pre><p>
  </p><p>この他の実運用レベルのログ出力の管理方法は、<span class="application">syslog</span>に送信し、<span class="application">syslog</span>にファイルの回転を行わせることです。
このためには、<code class="filename">postgresql.conf</code>の<code class="varname">log_destination</code>設定パラメータを<code class="literal">syslog</code>（<span class="application">syslog</span>のみにログを出力）に設定してください。
そして、新しいログファイルへの書き込みを始めたい時に、<span class="application">syslog</span>デーモンに<code class="literal">SIGHUP</code>シグナルを送信してください。
ログ回転を自動化させたい場合は、<span class="application">logrotate</span>プログラムを設定することで、<span class="application">syslog</span>からのログファイルを扱うことができます。
  </p><p>しかし、多くのシステムでは<span class="application">syslog</span>は特に巨大なログメッセージに関してあまり信頼できません。
必要なメッセージを切り詰めてしまったり、破棄してしまったりする可能性があります。
また、<span class="productname">Linux</span>では、<span class="application">syslog</span>はメッセージごとにディスクに書き出すため、性能が良くありません。
（同期化を無効にするため、<span class="application">syslog</span>設定ファイル内のファイル名の先頭に<code class="literal">-</code>を使うことができます。）
  </p><p>上述の手法は全て、新しいログファイルを開始する周期を設定することができますが、古い、既に役に立たなくなったログファイルの削除は扱わないことに注意してください。
おそらく定期的に古いログファイルを削除するバッチジョブを設定することになるでしょう。
他に、回転用プログラムを設定して古いログファイルを周期的に上書きさせるという方法もあります。
  </p><p><a class="ulink" href="http://dalibo.github.io/pgbadger/" target="_top"><span class="productname">pgBadger</span></a>という外部プロジェクトは洗練されたログファイルの解析を行います。
<a class="ulink" href="https://bucardo.org/check_postgres/" target="_top"><span class="productname">check_postgres</span></a>は、通常ではない多くの状態の検出を行うのと同時にログファイルに重要なメッセージが現れた時にNagiosで警告する機構を提供します。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="routine-reindex.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="maintenance.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="backup.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">24.2. 定常的なインデックスの再作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 25. バックアップとリストア</td></tr></table></div></body></html>