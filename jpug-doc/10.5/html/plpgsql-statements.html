<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.5. 基本的な文</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-expressions.html" title="42.4. 式" /><link rel="next" href="plpgsql-control-structures.html" title="42.6. 制御構造" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.5. 基本的な文</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-expressions.html" title="42.4. 式">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-control-structures.html" title="42.6. 制御構造">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-STATEMENTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.5. 基本的な文</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-ASSIGNMENT">42.5.1. 代入</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-NORESULT">42.5.2. 結果を伴わないコマンドの実行</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-ONEROW">42.5.3. 1行の結果を返す問い合わせの実行</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN">42.5.4. 動的コマンドの実行</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS">42.5.5. 結果ステータスの取得</a></span></dt><dt><span class="sect2"><a href="plpgsql-statements.html#PLPGSQL-STATEMENTS-NULL">42.5.6. まったく何もしない</a></span></dt></dl></div><p>本節および次節では、明示的に<span class="application">PL/pgSQL</span>で解釈される、全ての種類の文について説明します。
これらの種類の文として認められないものは全て、SQLコマンドであると仮定され、<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-NORESULT" title="42.5.2. 結果を伴わないコマンドの実行">Section 42.5.2</a>および<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-SQL-ONEROW" title="42.5.3. 1行の結果を返す問い合わせの実行">Section 42.5.3</a>において記述したように、メインデータベースエンジンに送信され実行されます。
   </p><div class="sect2" id="PLPGSQL-STATEMENTS-ASSIGNMENT"><div class="titlepage"><div><div><h3 class="title">42.5.1. 代入</h3></div></div></div><p>値を<span class="application">PL/pgSQL</span>変数に代入する場合は以下のように記述します。
</p><pre class="synopsis"><em class="replaceable"><code>variable</code></em> { := | = } <em class="replaceable"><code>expression</code></em>;</pre><p>
上述した通り、このような文中にある式は、メインデータベースエンジンに送信される<code class="command">SELECT</code> SQLコマンドによって評価されます。
式は1つの値を生成しなければなりません
(変数が行変数またはレコード変数の場合は行値となるかもしれません)。
対象の変数は単純な変数(ブロック名で修飾可能)、行変数またはレコード変数のフィールド、または単純な変数またはフィールドとなる配列要素とすることができます。
等号（<code class="literal">=</code>）がPL/SQLにおける代入記号（<code class="literal">:=</code>）の代わりに使用できます。
    </p><p>式の結果データ型が変数のデータ型に一致しない場合、値は代入キャスト（<a class="xref" href="typeconv-query.html" title="10.4. 値の格納">Section 10.4</a>を参照）と同様に変換されます。
関係する二つのデータ型のための代入キャストが無いときには、<span class="application">PL/pgSQL</span>インタプリタは結果値を、変数のデータ型の入力関数に続けて結果データ型の出力関数を適用することで、テキストとして変換しようとします。
結果値の文字列形式が入力関数で受け付けることができない場合に、入力関数において実行時エラーが発生するかもしれないことに注意してください。
    </p><p>例：
</p><pre class="programlisting">tax := subtotal * 0.06;
my_record.user_id := 20;</pre><p>
    </p></div><div class="sect2" id="PLPGSQL-STATEMENTS-SQL-NORESULT"><div class="titlepage"><div><div><h3 class="title">42.5.2. 結果を伴わないコマンドの実行</h3></div></div></div><p>例えば、<code class="literal">RETURNING</code>句のない<code class="command">INSERT</code>のように、行を返さない任意のSQLのコマンドについては、単にそのコマンドを記述することによって<span class="application">PL/pgSQL</span>関数の内部でコマンドを実行できます。
    </p><p>コマンドテキストに現れる全ての<span class="application">PL/pgSQL</span>変数名は、パラメータとして扱われます。
その後、実行時のパラメータ値として、その時点の変数値が提供されます。
これは以前に述べた式に関する処理と同じです。
<a class="xref" href="plpgsql-implementation.html#PLPGSQL-VAR-SUBST" title="42.10.1. 変数置換">Section 42.10.1</a>を参照してください。
    </p><p>SQLコマンドがこのように実行されると、<a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="42.10.2. 計画のキャッシュ">Section 42.10.2</a>に記述したように、<span class="application">PL/pgSQL</span>はコマンドのために、実行計画をキャッシュして再利用します。
    </p><p>式または<code class="command">SELECT</code>問い合わせを評価して結果を破棄することが、役に立つ場合があります。
例えば、関数の呼び出しにおいて、副次的な成果を取得できるが、結果は無用である場合です。
このような時<span class="application">PL/pgSQL</span>では、<code class="command">PERFORM</code>文を使用してください。

</p><pre class="synopsis">PERFORM <em class="replaceable"><code>query</code></em>;</pre><p>

これは<em class="replaceable"><code>query</code></em>を実行し、その結果を破棄します。
SQLの<code class="command">SELECT</code>文と同じ方法で<em class="replaceable"><code>query</code></em>を記述しますが、最初のキーワード<code class="command">SELECT</code>を<code class="command">PERFORM</code>に置き換えてください。
<code class="command">WITH</code>問い合わせに対しては、<code class="command">PERFORM</code> を使用して、問い合わせをカッコ内に配置してください。
（この場合、問い合わせは1行だけ返すことができます。）
結果を返さないコマンドと同様に、<span class="application">PL/pgSQL</span>変数は問い合わせ内に置き換えられ、計画は同様にキャッシュされます。
また、特殊な変数である<code class="literal">FOUND</code>は問い合わせ結果が1行でも生成された場合は真に設定され、生成されない場合は偽に設定されます（<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS" title="42.5.5. 結果ステータスの取得">Section 42.5.5</a>を参照してください）。
    </p><div class="note"><h3 class="title">Note</h3><p>直接<code class="command">SELECT</code>を記述すれば、この結果を得ることができると考えるかもしれませんが、現時点でこれを行う方法は<code class="command">PERFORM</code>しかありません。
<code class="command">SELECT</code>のように行を返すSQLコマンドは、エラーとして拒絶されます。
なお、<code class="literal">INTO</code>句を有する時は例外であり、次節で説明します。
     </p></div><p>以下に例を示します。
</p><pre class="programlisting">PERFORM create_mv('cs_session_page_requests_mv', my_query);</pre><p>
    </p></div><div class="sect2" id="PLPGSQL-STATEMENTS-SQL-ONEROW"><div class="titlepage"><div><div><h3 class="title">42.5.3. 1行の結果を返す問い合わせの実行</h3></div></div></div><a id="id-1.8.8.7.5.2" class="indexterm"></a><a id="id-1.8.8.7.5.3" class="indexterm"></a><p>（多分、複数列の）1行を返すSQLコマンドの結果は、レコード変数、行型の変数、スカラ変数のリストに代入することができます。
これは、基本的なSQLコマンドを記述して、それに<code class="literal">INTO</code>句を追加することによって行われます。
以下に例を示します。

</p><pre class="synopsis">SELECT <em class="replaceable"><code>select_expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em> FROM ...;
INSERT ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;
UPDATE ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;
DELETE ... RETURNING <em class="replaceable"><code>expressions</code></em> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em>;</pre><p>

ここで、<em class="replaceable"><code>target</code></em>はレコード変数、行変数、あるいは、単純な変数とレコード/行変数のフィールドをカンマで区切ったリストです。
<span class="application">PL/pgSQL</span>変数により残りの問い合わせが置換され、行を返さないコマンドにおいて述べたように計画がキャッシュされます。
このように作動するのは、<code class="literal">RETURNING</code>を伴った<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>と<code class="command">SELECT</code>および行セットの結果を返すユーティリティコマンド（例えば、<code class="command">EXPLAIN</code>）です。
<code class="literal">INTO</code>句以外では、SQLコマンドは<span class="application">PL/pgSQL</span>の外部に記述したものと同じです。
    </p><div class="tip"><h3 class="title">Tip</h3><p>通常の<span class="productname">PostgreSQL</span>の<code class="command">SELECT INTO</code>文では、<code class="literal">INTO</code>の対象は新しく作成されるテーブルです。
しかし、<code class="literal">INTO</code>を伴った<code class="command">SELECT</code>では、この解釈が通常と大きく異なることに注意してください。
<span class="application">PL/pgSQL</span>関数内部で<code class="command">SELECT</code>の結果からテーブルを作成したい場合は、<code class="command">CREATE TABLE ... AS SELECT</code>構文を使用してください。
    </p></div><p>行または変数リストが対象に使用された場合、列数とデータ型において問い合わせの結果と対象の構造が正確に一致しなければなりません。
さもないと、実行時エラーが発生します。
レコード変数が対象の場合は、問い合わせ結果の列の行型に自身を自動的に設定します。
    </p><p><code class="literal">INTO</code>句はSQLコマンドのほとんど任意の場所に記述することができます。
習慣的には、<code class="command">SELECT</code>文においては<em class="replaceable"><code>select_expressions</code></em>の直前または直後に、他のコマンドにおいては文の終わりに記述されます。
将来のバージョンで<span class="application">PL/pgSQL</span>のパーサがより厳格になる場合に備えて、この習慣に従うことを推奨します。
    </p><p><code class="literal">INTO</code>句において<code class="literal">STRICT</code>が指定されない場合、<em class="replaceable"><code>target</code></em>は問い合わせが返す最初の行となり、行を返さない時はNULLとなります。
（<span class="quote">“<span class="quote">最初の行</span>”</span>とは<code class="literal">ORDER BY</code>を使用しないと定義できないことに注意してください。）
2行目以降の行の結果は、全て破棄されます。
以下のように、特殊な<code class="literal">FOUND</code>変数（<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS" title="42.5.5. 結果ステータスの取得">Section 42.5.5</a>を参照してください）を調べて、行が返されたかどうかを検査することができます。

</p><pre class="programlisting">SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'employee % not found', myname;
END IF;</pre><p>

<code class="literal">STRICT</code>オプションが指定された場合、問い合わせは正確に1行を返さなければなりません。
さもないと、行がない時は<code class="literal">NO_DATA_FOUND</code>、2行以上が返った時は<code class="literal">TOO_MANY_ROWS</code>という実行時エラーが生じます。
エラーを捕捉したい時は、例外ブロックを使用できます。
以下に例を示します。

</p><pre class="programlisting">BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'employee % not found', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'employee % not unique', myname;
END;</pre><p>
<code class="literal">STRICT</code>を指定したコマンドが成功すると、<code class="literal">FOUND</code>変数は常に真に設定されます。
    </p><p><code class="literal">STRICT</code>が指定されない場合でも、<code class="literal">RETURNING</code>を伴った<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>が2行以上を返した時は、エラーとなります。
なぜなら、どの1行を返すか決定する<code class="literal">ORDER BY</code>のようなオプションが存在しないからです。
    </p><p><code class="literal">print_strict_params</code>が関数に利用可能であり、かつ要求がSTRICTでないためにエラーが発生した場合、エラーメッセージの<code class="literal">STRICT</code>部分は問い合わせに渡したパラメータに関する情報を含みます。
<code class="varname">plpgsql.print_strict_params</code>を指定することにより、全ての関数の<code class="literal">print_strict_params</code>設定を変更できます。
しかし、変更後にコンパイルした関数にだけ有効です。
コンパイルオプションを使用すれば、個々の関数を基準とした設定変更もできます。
例を示します。
</p><pre class="programlisting">CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;</pre><p>
失敗したとき、この関数は次のようなエラーメッセージを生成します。
</p><pre class="programlisting">ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement</pre><p>
    </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">STRICT</code>オプションは、OracleのPL/SQLの<code class="command">SELECT INTO</code>および関連した文に対応します。
     </p></div><p>SQLの問い合わせが返す複数行の結果を処理したい場合は、<a class="xref" href="plpgsql-control-structures.html#PLPGSQL-RECORDS-ITERATING" title="42.6.4. 問い合わせ結果による繰り返し">Section 42.6.4</a>を参照してください。
    </p></div><div class="sect2" id="PLPGSQL-STATEMENTS-EXECUTING-DYN"><div class="titlepage"><div><div><h3 class="title">42.5.4. 動的コマンドの実行</h3></div></div></div><p><span class="application">PL/pgSQL</span>関数の内部で、動的コマンド、つまり実行する度に別のテーブルや別のデータ型を使用するコマンドを生成したいということがよくあるでしょう。
<span class="application">PL/pgSQL</span>が通常行うコマンドの計画のキャッシュは（<a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="42.10.2. 計画のキャッシュ">Section 42.10.2</a>で述べたように）このような状況では動作しません。
この種の問題を扱うために、以下の<code class="command">EXECUTE</code>文が用意されています。

</p><pre class="synopsis">EXECUTE <em class="replaceable"><code>command-string</code></em> [<span class="optional"> INTO [<span class="optional">STRICT</span>] <em class="replaceable"><code>target</code></em> </span>] [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>];</pre><p>

ここで、<em class="replaceable"><code>command-string</code></em>は実行されるコマンドを含む（<code class="type">text</code>型の）文字列を生成する式です。
オプションの<em class="replaceable"><code>target</code></em>はレコード変数、行変数、あるいは、単純な変数とレコード/行変数のフィールドをカンマで区切ったリストで、その中にコマンドの結果が格納されます。
オプションの<code class="literal">USING</code>式は コマンドに挿入される値を与えます。
    </p><p><span class="application">PL/pgSQL</span>変数は、この演算用のコマンド文字列へ置換されません。
必要な変数の値はすべてコマンド文字列を作成する時に埋め込まなければなりません。
もしくは、以下に説明するパラメータを使用することもできます。
    </p><p>また、<code class="command">EXECUTE</code>を介して実行されるコマンド計画をキャッシュすることはありません。
代わりに、コマンドは文が実行されるとき常に計画されます。
したがって、異なるテーブルと列に対する操作を実行できるように、コマンド文字列を関数内部で動的に作成することができます。
    </p><p><code class="literal">INTO</code>句は、行を返すSQLコマンドの結果を代入するべき場所を指定します。
行または変数リストが用いられる時、それは問い合わせの結果の構造と正確に一致しなければなりません
(レコード変数が使用される時、自動的に結果の構造と一致するように自身を構築させます）。
複数の行が返された時、最初の行だけが<code class="literal">INTO</code>変数に代入されます。
1行も返されない時、NULL が<code class="literal">INTO</code>変数に代入されます。
<code class="literal">INTO</code>句が指定されない時、問い合わせの結果は捨てられます。
    </p><p><code class="literal">STRICT</code>オプションが指定された時、問い合わせの結果が正確に1行の場合を除き、エラーとなります。
    </p><p>コマンド文字列はパラメータ値を使用可能で、それらは<code class="literal">$1</code>、<code class="literal">$2</code>等としてコマンドの中で参照されます。
これらの記号は<code class="literal">USING</code>で与えられる値を参照します。
この方式はデータの値をテキストとしてコマンド文字列の中に挿入する際、よく好まれます。
それは値をテキストに変換、そしてその逆を行う場合の実行時オーバーヘッドを防止するとともに、引用符付けするとか、エスケープをする必要がないため、SQLインジェクション攻撃に対してより襲われにくくなります。
以下に例を示します。
</p><pre class="programlisting">EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</pre><p>
    </p><p>パラメータ記号はデータ値のみ使用可能です。
もし動的に決定されるテーブルや列名を使用したい場合、テキストでコマンド文字列にそれらを挿入する必要があります。
例えば、先行する問い合わせが、動的に選択されたテーブルに対して処理される必要がある時は、次のようにします。
</p><pre class="programlisting">EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;</pre><p>
よりきれいな方法は<code class="function">format()</code>の<code class="literal">%I</code>指定をテーブル名または列名に使うことです（改行で分かれた文字列は連結されます）。
</p><pre class="programlisting">EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted &lt;= $2', tabname)
   INTO c
   USING checked_user, checked_date;</pre><p>
他にもパラメータ記号は<code class="command">SELECT</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>コマンドでしか動作しない、という制限があります。
他の種類の文(一般的にユーティリティ文と呼ばれます)では、単なるデータ値であったとしてもテキストの値として埋め込まなければなりません。
    </p><p>最初の例のように、単純な定数コマンドと<code class="literal">USING</code>パラメータを使った<code class="command">EXECUTE</code>は、コマンドを直接<span class="application">PL/pgSQL</span>で書いて、<span class="application">PL/pgSQL</span>変数を自動的に置換したものと機能的に同じです。
重要な差異として、<code class="command">EXECUTE</code>が現在のパラメータ値に特化した計画を生成し、コマンドを実行する度に計画を再作成することです。
一方、<span class="application">PL/pgSQL</span>はその他に一般的な計画を作成し、再使用に備えキャッシュします。
最適な計画がパラメータ値に大きく依存する場合、一般的な計画が選択されないことを確保するために、<code class="command">EXECUTE</code>の使用は助けになります。
    </p><p><code class="command">SELECT INTO</code>は<code class="command">EXECUTE</code>では現在サポートされません。
代わりに、普通の<code class="command">SELECT</code>コマンドを実行し、<code class="command">EXECUTE</code>の一部として<code class="literal">INTO</code>を記述してください。
    </p><div class="note"><h3 class="title">Note</h3><p><span class="application">PL/pgSQL</span> <code class="command">EXECUTE</code>文は<span class="productname">PostgreSQL</span>サーバでサポートされている<a class="xref" href="sql-execute.html" title="EXECUTE"><span class="refentrytitle">EXECUTE</span></a>SQL文とは関連がありません。
サーバの<code class="command">EXECUTE</code>文は<span class="application">PL/pgSQL</span>関数内で使用することはできません（使用する必要もありません）。
    </p></div><div class="example" id="PLPGSQL-QUOTE-LITERAL-EXAMPLE"><p class="title"><strong>Example 42.1. 動的問い合わせの中の値の引用符付け</strong></p><div class="example-contents"><a id="id-1.8.8.7.6.12.2" class="indexterm"></a><a id="id-1.8.8.7.6.12.3" class="indexterm"></a><a id="id-1.8.8.7.6.12.4" class="indexterm"></a><a id="id-1.8.8.7.6.12.5" class="indexterm"></a><p>動的コマンドを使用する時、しばしば<span class="application">PL/pgSQL</span>では単一引用符をエスケープしなければなりません。
関数本体における固定のテキストを引用符付けする推奨方法は、ドル引用符を使用する方法です。
（ドル引用符を用いない旧式のコードを保有している場合は、<a class="xref" href="plpgsql-development-tips.html#PLPGSQL-QUOTE-TIPS" title="42.11.1. 引用符の扱い">Section 42.11.1</a>の概要を参照することが、理解しやすいコードへの変換作業の手助けになります）。
    </p><p>動的な値は引用符を含んでいる可能性があるので注意深い取り扱いが必要です。
以下に<code class="function">format()</code>を使う例を示します（ここでは関数にドル引用符を用いる方法を使用すると仮定しているので、引用符を二重化する必要はありません）。
</p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = $1 '
   'WHERE key = $2', colname) USING newvalue, keyvalue;</pre><p>
クオート関数を直接呼び出すことも可能です。
</p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);</pre><p>
    </p><p>この例は、<code class="function">quote_ident</code>と<code class="function">quote_literal</code>関数（<a class="xref" href="functions-string.html" title="9.4. 文字列関数と演算子">Section 9.4</a>を参照）の使用方法を示しています。
安全のため、列またはテーブル識別子を含む式は動的問い合わせに挿入する前に<code class="function">quote_ident</code>を介して渡されなくてはなりません。
組み立てられるコマンドの中のリテラル文字列となるはずの値を含む式は、<code class="function">quote_literal</code>を介して渡されなければなりません。
これらの関数は、すべての特殊文字を適切にエスケープして埋め込んだ、二重引用符または単一引用符で囲まれた入力テキストを返すために、適切な手順を踏みます。
    </p><p><code class="function">quote_literal</code>は<code class="literal">STRICT</code>ラベル付けされているため、NULL引数で呼び出された場合、常にNULLを返します。
上記の例で、<code class="literal">newvalue</code>または<code class="literal">keyvalue</code>がNULLの場合、動的問合せ文字列全体がNULLとなり、<code class="command">EXECUTE</code>からのエラーを導きます。
<code class="function">quote_nullable</code>関数を使用することで、この問題を回避することができます。
その動作は、NULL引数付きで呼び出された場合に文字列<code class="literal">NULL</code>を返すことを除いて<code class="function">quote_literal</code>と同一です。
以下に例を示します。
</p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);</pre><p>
NULLの可能性のある値を処理するのであれば、通常<code class="function">quote_literal</code>の代わりに<code class="function">quote_nullable</code>を使用しなければなりません。
    </p><p>いつものように、問い合わせの中のNULL値は意図しない結果を確実にもたらさないよう配慮をしなければなりません。
例えば次のような<code class="literal">WHERE</code>句の結果はどうなるのでしょう。
</p><pre class="programlisting">'WHERE key = ' || quote_nullable(keyvalue)</pre><p>
これは<code class="literal">keyvalue</code>がNULLである限り成功しません。
その理由は、等価演算子<code class="literal">=</code>をNULLオペランドで使用するとその結果は常にNULLとなるからです。
NULLを通常のキーの値と同じように動作させたい場合、上記を、以下のように書き換えなければなりません。
</p><pre class="programlisting">'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)</pre><p>
（現時点では、<code class="literal">IS NOT DISTINCT FROM</code>は<code class="literal">=</code>よりもより効率性が少なく扱われますので、必要に迫られた場合以外は行わないようにしてください。
NULLと<code class="literal">IS DISTINCT</code>についての更なる情報は<a class="xref" href="functions-comparison.html" title="9.2. 比較関数および演算子">Section 9.2</a>を参照してください。）
    </p><p>ドル引用符は固定のテキストを引用符付けする場合のみ有用であるということに注意してください。
この例を次のように記述するのは非常に悪い考えです。
</p><pre class="programlisting">EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);</pre><p>
なぜなら、<code class="literal">newvalue</code>の内容がたまたま<code class="literal">$$</code>を含む時は、途中で次の処理へ移ってしまうからです。
同様の不測事態は、ドル引用符の他の区切り文字を選んだ時も起こります。
したがって、テキストの内容を把握していない時は、安全にテキストを引用符付けするために、<code class="function">quote_literal</code>、<code class="function">quote_nullable</code>、または<code class="function">quote_ident</code>関数を適切に使用<span class="emphasis"><em>しなければなりません</em></span>。
    </p><p>動的 SQL 文は<code class="function">format</code>関数を使用しても安全に作成できます（<a class="xref" href="functions-string.html" title="9.4. 文字列関数と演算子">Section 9.4</a>参照）。
例を示します。
</p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = %L '
   'WHERE key = %L', colname, newvalue, keyvalue);</pre><p>
<code class="literal">%I</code>は<code class="function">quote_ident</code>と同等で、<code class="literal">%L</code>は<code class="function">quote_nullable</code>と同等です。
<code class="function">format</code>関数は<code class="literal">USING</code>句と共に使用できます。
</p><pre class="programlisting">EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;</pre><p>
変数が、無条件にテキストに変換されて<code class="literal">%L</code>で引用符付けされることなく、固有のデータ形式で処理されるため、この形式はより優れています。
    </p></div></div><br class="example-break" /><p>動的問い合わせと<code class="command">EXECUTE</code>の長大な例は<a class="xref" href="plpgsql-porting.html#PLPGSQL-PORTING-EX2" title="Example 42.10. 他の関数を生成するPL/SQLをPL/pgSQLに移植">Example 42.10</a>にあります。
それは新しい関数を定義するために<code class="command">CREATE FUNCTION</code>コマンドを組み立て実行するものです。
    </p></div><div class="sect2" id="PLPGSQL-STATEMENTS-DIAGNOSTICS"><div class="titlepage"><div><div><h3 class="title">42.5.5. 結果ステータスの取得</h3></div></div></div><p>コマンドの効果を判断するにはいくつか方法があります。
最初の方法は以下のような形式の<code class="command">GET DIAGNOSTICS</code>を使用する方法です。

</p><pre class="synopsis">GET [<span class="optional"> CURRENT </span>] DIAGNOSTICS <em class="replaceable"><code>variable</code></em> { = | := } <em class="replaceable"><code>item</code></em> [<span class="optional"> , ... </span>];</pre><p>

このコマンドによってシステムステータスインジケータを取り出すことができます。
<code class="literal">CURRENT</code>は無意味な単語です（しかし<a class="xref" href="plpgsql-control-structures.html#PLPGSQL-EXCEPTION-DIAGNOSTICS" title="42.6.6.1. エラーに関する情報の取得">Section 42.6.6.1</a>の<code class="command">GET STACKED DIAGNOSTICS</code>も参照してください）。
各<em class="replaceable"><code>item</code></em>は、指定された<em class="replaceable"><code>variable</code></em>（これは受け取るために正しいデータ型でなければなりません）に代入されるステータス値を識別するキーワードです。
現在使用可能なステータス項目は、<a class="xref" href="plpgsql-statements.html#PLPGSQL-CURRENT-DIAGNOSTICS-VALUES" title="Table 42.1. 使用できるステータス項目">Table 42.1</a>で示されています。
代入記号（<code class="literal">:=</code>）が標準SQLにおける等号（<code class="literal">=</code>）の代わりに使用できます。
以下に例を示します。
</p><pre class="programlisting">GET DIAGNOSTICS integer_var = ROW_COUNT;</pre><p>
    </p><div class="table" id="PLPGSQL-CURRENT-DIAGNOSTICS-VALUES"><p class="title"><strong>Table 42.1. 使用できるステータス項目</strong></p><div class="table-contents"><table class="table" summary="使用できるステータス項目" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名前</th><th>型</th><th>説明</th></tr></thead><tbody><tr><td><code class="varname">ROW_COUNT</code></td><td><code class="type">bigint</code></td><td>最後の<acronym class="acronym">SQL</acronym>コマンドにより処理された行数</td></tr><tr><td><code class="varname">RESULT_OID</code></td><td><code class="type">oid</code></td><td>最後の<acronym class="acronym">SQL</acronym>コマンドにより挿入された最後の行のOID
        （OIDを持つテーブルへの<code class="command">INSERT</code>コマンドの後でのみ有用です）
          </td></tr><tr><td><code class="literal">PG_CONTEXT</code></td><td><code class="type">text</code></td><td>現在の呼び出しスタックを記述したテキストの行
          （<a class="xref" href="plpgsql-control-structures.html#PLPGSQL-CALL-STACK" title="42.6.7. 実行位置情報の取得">Section 42.6.7</a>を参照）</td></tr></tbody></table></div></div><br class="table-break" /><p>コマンドの効果を判断する2番目の方法は、<code class="literal">FOUND</code>という<code class="type">boolean</code>型の特殊な変数を検査することです。
<span class="application">PL/pgSQL</span>の各関数呼び出しで使用される際、<code class="literal">FOUND</code>は最初は偽に設定されています。
以下のように、それぞれの文の種類によって設定が変更されます。

         </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="command">SELECT INTO</code>文は、行が代入された場合は真、返されなかった場合は偽を<code class="literal">FOUND</code>に設定します。
           </p></li><li class="listitem"><p><code class="command">PERFORM</code>文は、1つ以上の行が生成（破棄）された場合は真、まったく生成されなかった場合は偽を<code class="literal">FOUND</code>に設定します。
           </p></li><li class="listitem"><p><code class="command">UPDATE</code>、<code class="command">INSERT</code>、および<code class="command">DELETE</code>文は、少なくとも1行が影響を受けた場合は真、まったく影響を受けなかった場合は偽を<code class="literal">FOUND</code>に設定します。
           </p></li><li class="listitem"><p><code class="command">FETCH</code>文は、行が返された場合は真、まったく返されなかった場合は偽を<code class="literal">FOUND</code>に設定します。
           </p></li><li class="listitem"><p><code class="command">MOVE</code>文は、カーソルの移動が成功した場合は真、失敗した場合は偽を<code class="literal">FOUND</code>に設定します。
           </p></li><li class="listitem"><p><code class="command">FOR</code>文または<code class="command">FOREACH</code>文は、1回以上繰り返しが行われた場合は真、行われなかった場合は偽を<code class="literal">FOUND</code>に設定します。
<code class="literal">FOUND</code>はループが終了した際、このように設定されます。
ループ実行中はループ文による<code class="literal">FOUND</code>の変更はありません。
ただし、ループ本体内の他種類の文を実行することによって、変更されるかもしれません。
           </p></li><li class="listitem"><p><code class="command">RETURN QUERY</code>と<code class="command">RETURN QUERY EXECUTE</code>文は、問い合わせが行を１つでも返せば真、行が返されなければ偽を設定します。
           </p></li></ul></div><p>

他の<span class="application">PL/pgSQL</span>文は<code class="literal">FOUND</code>の状態を変更しません。
特に、<code class="command">EXECUTE</code>は<code class="command">GET DIAGNOSTICS</code>の出力を変更しますが、<code class="literal">FOUND</code>を変更しないことに注意してください。
    </p><p><code class="literal">FOUND</code>はそれぞれの<span class="application">PL/pgSQL</span>関数内部のローカル変数です。
<code class="literal">FOUND</code>に対して行われた全ての変更は、現在の関数にのみ影響します。
    </p></div><div class="sect2" id="PLPGSQL-STATEMENTS-NULL"><div class="titlepage"><div><div><h3 class="title">42.5.6. まったく何もしない</h3></div></div></div><p>何もしないプレースホルダ文が有用になることがあります。
例えば、IF/THEN/ELSE文の一部が空文であることを明示したい時です。
このような目的には<code class="command">NULL</code>文を使用します。

</p><pre class="synopsis">NULL;</pre><p>
    </p><p>例えば、次の2つのコードは同等です。
</p><pre class="programlisting">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- 誤りを無視する
END;</pre><p>

</p><pre class="programlisting">BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- 誤りを無視する
END;</pre><p>
どちらが望ましいと思うかは、好みの問題です。
    </p><div class="note"><h3 class="title">Note</h3><p>OracleのPL/SQLでは無記述の文は許されませんので、こうした状況では<code class="command">NULL</code>文が<span class="emphasis"><em>必須</em></span>です。
しかし<span class="application">PL/pgSQL</span>では無記述の文が許可されています。
     </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-expressions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-control-structures.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.4. 式 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.6. 制御構造</td></tr></table></div></body></html>