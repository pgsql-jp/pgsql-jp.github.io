<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.1. 字句の構造</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-syntax.html" title="Chapter 4. SQLの構文" /><link rel="next" href="sql-expressions.html" title="4.2. 評価式" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">4.1. 字句の構造</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-syntax.html" title="Chapter 4. SQLの構文">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-syntax.html" title="Chapter 4. SQLの構文">Up</a></td><th width="60%" align="center">Chapter 4. SQLの構文</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-expressions.html" title="4.2. 評価式">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SQL-SYNTAX-LEXICAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4.1. 字句の構造</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">4.1.1. 識別子とキーワード</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS">4.1.2. 定数</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS">4.1.3. 演算子</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-SPECIAL-CHARS">4.1.4. 特殊文字</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-SYNTAX-COMMENTS">4.1.5. コメント</a></span></dt><dt><span class="sect2"><a href="sql-syntax-lexical.html#SQL-PRECEDENCE">4.1.6. 演算子の優先順位</a></span></dt></dl></div><a id="id-1.5.3.5.2" class="indexterm"></a><p>SQLの入力は、ひと続きの<em class="firstterm">コマンド</em>からなります。
コマンドは<em class="firstterm">トークン</em>が繋がったもので構成され、最後はセミコロン（<span class="quote">“<span class="quote">;</span>”</span>）で終わります。
入力ストリームの終了もやはりコマンドを終わらせます。
どのトークンが有効かは特定のコマンドの構文によります。
  </p><p>トークンは<em class="firstterm">キーワード</em>、<em class="firstterm">識別子</em>、<em class="firstterm">引用符で囲まれた識別子</em>、<em class="firstterm">リテラル</em>（もしくは定数）、特別な文字シンボルです。
トークンは通常空白（スペース、タブ、改行）で区切られますが、曖昧さがなければ（一般的には特別な文字が他のトークン型と隣接している場合のみ）必要ありません。
  </p><p>例えば、以下のものは（構文的に）正しいSQLの入力です。
</p><pre class="programlisting">SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</pre><p>
この例は1行に1つのコマンドを記述した、3つのコマンドが連続しています（必ずしも1つのコマンドを1行で書く必要はありません。 1行に複数のコマンドを入力することも可能ですし、1つのコマンドを複数行に分けて記述することも可能です）。
   </p><p>さらに、入力されたSQLに<em class="firstterm">コメント</em>が付いていても構いません。
コメントはトークンではなく、その効果は空白と同じです。
  </p><p>SQL構文は、どのトークンがコマンドを識別し、どれがオペランドでどれがパラメータかに関してはさほど首尾一貫していません。
最初のいくつかのトークンは一般にコマンド名です。
したがって、上記の例において<span class="quote">“<span class="quote">SELECT</span>”</span>、<span class="quote">“<span class="quote">UPDATE</span>”</span>、<span class="quote">“<span class="quote">INSERT</span>”</span>コマンドについて通常説明することになります。
しかし、例えば<code class="command">UPDATE</code>コマンドでは、<code class="token">SET</code>トークンが特定の位置に常に記述されなければなりませんし、この例で使われている<code class="command">INSERT</code>コマンドを完結するためには<code class="token">VALUES</code>トークンが必要です。
それぞれのコマンドの正確な構文規則は<a class="xref" href="reference.html" title="Part VI. リファレンス">Part VI</a>で説明されています。
  </p><div class="sect2" id="SQL-SYNTAX-IDENTIFIERS"><div class="titlepage"><div><div><h3 class="title">4.1.1. 識別子とキーワード</h3></div></div></div><a id="id-1.5.3.5.8.2" class="indexterm"></a><a id="id-1.5.3.5.8.3" class="indexterm"></a><a id="id-1.5.3.5.8.4" class="indexterm"></a><p>上記の例に出てくる<code class="token">SELECT</code>、<code class="token">UPDATE</code>、もしくは<code class="token">VALUES</code>のようなトークンは、<em class="firstterm">キーワード</em>の一例です。
キーワードとは、SQL言語で決まった意味を持っている単語です。
<code class="token">MY_TABLE</code>トークンや<code class="token">A</code>トークンは<em class="firstterm">識別子</em>の一例です。
これらは、使われるコマンドによって、テーブル、列、他のデータベースオブジェクトの名前を識別します。
したがって、単に<span class="quote">“<span class="quote">名前</span>”</span>と呼ばれることもあります。
キーワードと識別子は同じ字句の構造を持つため、言語を知らなくてはトークンが識別子なのかキーワードなのかわからないということになります。
全てのキーワードのリストは<a class="xref" href="sql-keywords-appendix.html" title="Appendix C. SQLキーワード">Appendix C</a>にあります。
   </p><p>SQL識別子とキーワードは、文字（<code class="literal">a</code>〜<code class="literal">z</code>および発音区別符号付き文字と非Latin文字)、アンダースコア（<code class="literal">_</code>）で始まらなければいけません。
識別子またはキーワードの中で続く文字は、文字、アンダースコア、数字（<code class="literal">0</code>〜<code class="literal">9</code>）あるいはドル記号(<code class="literal">$</code>)を使用することができます。
標準SQLの記述に従うと、ドル記号は識別子内では使用できないことに注意してください。
ですから、これを使用するとアプリケーションの移植性は低くなる可能性があります。
標準SQLでは、数字を含む、あるいはアンダースコアで始まったり終わったりするキーワードは定義されていません。
したがって、この形式の識別子は標準の今後の拡張と競合する可能性がないという意味で安全と言えます。
   </p><p>    <a id="id-1.5.3.5.8.7.1" class="indexterm"></a>
システムは<code class="symbol">NAMEDATALEN</code>-1バイトより長い識別子を使いません。
より長い名前をコマンドで書くことはできますが、短く切られてしまいます。
デフォルトでは<code class="symbol">NAMEDATALEN</code>は64なので、識別子は最長で63バイトです。
この制限が問題になる場合は、<code class="filename">src/include/pg_config_manual.h</code>内の<code class="symbol">NAMEDATALEN</code>定数の値を変更して増やすことができます。
   </p><p>    <a id="id-1.5.3.5.8.8.1" class="indexterm"></a>
キーワードと引用符付きでない識別子は大文字と小文字を区別しません。
したがって、
</p><pre class="programlisting">UPDATE MY_TABLE SET A = 5;</pre><p>
は、以下の文と同じ意味になります。
</p><pre class="programlisting">uPDaTE my_TabLE SeT a = 5;</pre><p>
慣習的によく使われる方法では、キーワードを大文字で、名前を小文字で書きます。
例えば下記のようになります。
</p><pre class="programlisting">UPDATE my_table SET a = 5;</pre><p>
   </p><p>    <a id="id-1.5.3.5.8.9.1" class="indexterm"></a>
識別子には副次的な種類もあります。
<em class="firstterm">区切り識別子</em>あるいは<em class="firstterm">引用符付き識別子</em>です。
任意の文字の連なりを二重引用符（<code class="literal">"</code>）で囲んだものです。
区切り識別子は常に識別子であって、キーワードではありません。
ですから、<code class="literal">"select"</code>は<span class="quote">“<span class="quote">select</span>”</span>という名前の列あるいはテーブルを問い合わせるために使えますが、引用符の付かない<code class="literal">select</code>はキーワードとして理解されるので、テーブルもしくは列名が期待される部分では解析エラーを起こします。
引用符付き識別子は下記の例のように書くことができます。
</p><pre class="programlisting">UPDATE "my_table" SET "a" = 5;</pre><p>
   </p><p>引用符付き識別子は、コード0の文字以外であればどのような文字でも使えます
（二重引用符を含めたい場合は、二重引用符を2つ入力します）。
これにより、空白やアンパサンド（&amp;）を含むテーブル名や列名など、この方法がなければ作れないような名前のものを作ることが可能になります。
この場合においても長さの制限は適用されます。
   </p><a id="id-1.5.3.5.8.11" class="indexterm"></a><p>引用符付き識別子には異形があり、コード番号で識別されるエスケープされたUnicode文字を含むことができます。
この異形は、<code class="literal">U&amp;</code>（大文字または小文字のUの後にアンパサンド）で始まり、その直後に空白を間に入れずに二重引用符を続けます。
例えば、<code class="literal">U&amp;"foo"</code>となります。
（これにより演算子<code class="literal">&amp;</code>との不明確性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、識別子<code class="literal">"data"</code>は次のように書くことができます。
</p><pre class="programlisting">U&amp;"d\0061t\+000061"</pre><p>
次の少し意味のある例はロシア語の<span class="quote">“<span class="quote">slon</span>”</span>（象）をキリル文字で書いたものです。
</p><pre class="programlisting">U&amp;"\0441\043B\043E\043D"</pre><p>
   </p><p>バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<code class="literal">UESCAPE</code><a id="id-1.5.3.5.8.13.2" class="indexterm"></a>句を使用して指定することが可能です。例をあげます。
</p><pre class="programlisting">U&amp;"d!0061t!+000061" UESCAPE '!'</pre><p>
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
エスケープ文字には二重引用符ではなく単一引用符で記述していることに注意してください。
   </p><p>識別子内にエスケープ文字をそのまま含めるためには、それを２つ記述してください。
   </p><p>Unicodeエスケープ構文はサーバの符号化方式が<code class="literal">UTF8</code>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<code class="literal">\007F</code>まで）のコードポイントのみ指定できます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の形式の両方を使用することができますが、技術的には6桁形式の機能によりこれは不要になります。
（サロゲートペアは直接格納されるわけではなく、一つのコードポイントに結合されてから、UTF-8に符号化されます。）
   </p><p>引用符が付かない名前は常に小文字に解釈されますが、識別子を引用符で囲むことによって大文字と小文字が区別されるようになります。
例えば、識別子<code class="literal">FOO</code>、<code class="literal">foo</code>、<code class="literal">"foo"</code>は<span class="productname">PostgreSQL</span>によれば同じものとして解釈されますが、<code class="literal">"Foo"</code>と<code class="literal">"FOO"</code>は、これら3つとも、またお互いに違ったものとして解釈されます
（<span class="productname">PostgreSQL</span>が引用符の付かない名前を小文字として解釈することは標準SQLと互換性がありません。標準SQLでは引用符の付かない名前は大文字に解釈されるべきだとされています。
したがって標準SQLによれば、<code class="literal">foo</code>は<code class="literal">"FOO"</code>と同じであるべきで、<code class="literal">"foo"</code>とは異なるはずなのです。
もし移植可能なアプリケーションを書きたいならば、特定の名前は常に引用符で囲むか、あるいはまったく囲まないかのいずれかに統一することをお勧めします）。
   </p></div><div class="sect2" id="SQL-SYNTAX-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">4.1.2. 定数</h3></div></div></div><a id="id-1.5.3.5.9.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>には、3つの<em class="firstterm">暗黙に型付けされる定数</em>があります。
文字列、ビット文字列、そして数字です。
定数は明示的な型で指定することもでき、その場合はシステムによる、より正確な表現と効率の良い操作が可能になります。
こうした他の方法については後ほど説明します。
   </p><div class="sect3" id="SQL-SYNTAX-STRINGS"><div class="titlepage"><div><div><h4 class="title">4.1.2.1. 文字列定数</h4></div></div></div><a id="id-1.5.3.5.9.4.2" class="indexterm"></a><p>     <a id="id-1.5.3.5.9.4.3.1" class="indexterm"></a>
     
SQLにおける文字列定数は、単一引用符（<code class="literal">'</code>）で括られた任意の文字の並びです。
例えば、<code class="literal">'This is a string'</code>です。
文字列定数内に単一引用符を含めるには、2つ続けて単一引用符を記述します。
例えば、<code class="literal">'Dianne''s horse'</code>です。
二重引用符(<code class="literal">"</code>)とは同一では<span class="emphasis"><em>ない</em></span>点に注意してください。
    </p><p>2つの文字列定数が、<span class="emphasis"><em>少なくとも1つの改行</em></span>を含んだ空白のみで区切られている場合は、2つの定数は連結され、実質的に1つの定数として書かれたように処理されます。
例を示します。
</p><pre class="programlisting">SELECT 'foo'
'bar';</pre><p>
は、
</p><pre class="programlisting">SELECT 'foobar';</pre><p>
と同じです。しかし、
</p><pre class="programlisting">SELECT 'foo'      'bar';</pre><p>
は有効な構文ではありません
（このちょっとした奇妙な振舞いは<acronym class="acronym">SQL</acronym>で決められているもので、<span class="productname">PostgreSQL</span>ではこの標準に従っています）。
    </p></div><div class="sect3" id="SQL-SYNTAX-STRINGS-ESCAPE"><div class="titlepage"><div><div><h4 class="title">4.1.2.2. C形式エスケープでの文字列定数</h4></div></div></div><a id="id-1.5.3.5.9.5.2" class="indexterm"></a><a id="id-1.5.3.5.9.5.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>では、また、<span class="quote">“<span class="quote">エスケープ</span>”</span>文字列定数を受け付けます。
これは標準SQLの拡張です。
エスケープ文字列定数は、<code class="literal">E</code>(大文字でも小文字でもかまいません)を開始単一引用符の直前に記述することで指定されます。
例えば<code class="literal">E'foo'</code>です。
（複数行に渡るエスケープ文字列定数では、最初の開始引用符の前にのみ<code class="literal">E</code>を記述してください。）
エスケープ文字列の中では、バックスラッシュ文字（<code class="literal">\</code>）によりC言語のような<em class="firstterm">バックスラッシュ</em>シーケンスが開始し、その中でバックスラッシュとそれに続く文字の組み合わせが（<a class="xref" href="sql-syntax-lexical.html#SQL-BACKSLASH-TABLE" title="Table 4.1. バックスラッシュエスケープシーケンス">Table 4.1</a>で示したように）特別なバイト値を表現します。
    </p><div class="table" id="SQL-BACKSLASH-TABLE"><p class="title"><strong>Table 4.1. バックスラッシュエスケープシーケンス</strong></p><div class="table-contents"><table class="table" summary="バックスラッシュエスケープシーケンス" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>バックスラッシュエスケープシーケンス</th><th>解釈</th></tr></thead><tbody><tr><td><code class="literal">\b</code></td><td>後退</td></tr><tr><td><code class="literal">\f</code></td><td>改ページ</td></tr><tr><td><code class="literal">\n</code></td><td>改行</td></tr><tr><td><code class="literal">\r</code></td><td>復帰</td></tr><tr><td><code class="literal">\t</code></td><td>タブ</td></tr><tr><td>         <code class="literal">\<em class="replaceable"><code>o</code></em></code>,
         <code class="literal">\<em class="replaceable"><code>oo</code></em></code>,
         <code class="literal">\<em class="replaceable"><code>ooo</code></em></code>
         (<em class="replaceable"><code>o</code></em> = 0 - 7)
        </td><td>８進数バイト値</td></tr><tr><td>         <code class="literal">\x<em class="replaceable"><code>h</code></em></code>,
         <code class="literal">\x<em class="replaceable"><code>hh</code></em></code>
         (<em class="replaceable"><code>h</code></em> = 0 - 9, A - F)
        </td><td>１６進数バイト値</td></tr><tr><td>         <code class="literal">\u<em class="replaceable"><code>xxxx</code></em></code>,
         <code class="literal">\U<em class="replaceable"><code>xxxxxxxx</code></em></code>
         (<em class="replaceable"><code>x</code></em> = 0 - 9, A - F)
        </td><td>16もしくは32ビットの16進数 Unicode 文字値</td></tr></tbody></table></div></div><br class="table-break" /><p>バックスラッシュの後のそのほかの全ての文字はそのまま扱われます。
従って、バックスラッシュ文字を含ませるときは２つのバックスラッシュ（<code class="literal">\\</code>）を記載します。
同時に、エスケープ文字列の中では、単一引用符を、通常の方法の<code class="literal">''</code>に加え、<code class="literal">\'</code>としても含めることができます。
    </p><p>特に8進数や16進数エスケープを用いて作成されるバイトシーケンスが、サーバ文字セット符号化方式において有効な文字で構成されていることはコードを書く人の責任です。
サーバ符号化方式がUTF-8の場合、Unicodeエスケープか、<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE" title="4.1.2.3. Unicodeエスケープがある文字列定数">Section 4.1.2.3</a>で説明するもう一つのUnicodeエスケープ構文を代わりとして使用すべきです。
（後者は手作業でUTF-8符号化を行い、書き出さなくてはならないのでとても厄介です。）
    </p><p>Unicodeエスケープ構文は、サーバの符号化方式が<code class="literal">UTF8</code>である場合のみ、完全に動作します。
他のサーバ符号化方式が使用されている場合、ASCII範囲（<code class="literal">\u007F</code>まで）のコードポイントのみを指定することができます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と8桁の両方の形式を使用することができますが、技術的には8桁形式の機能によりこれは不要になります。
（サーバの符号化方式が<code class="literal">UTF8</code>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </p><div class="caution"><h3 class="title">Caution</h3><p>設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>が <code class="literal">off</code>の場合、<span class="productname">PostgreSQL</span>はバックスラッシュエスケープを通常の文字列定数とエスケープ文字列定数の両方で認識します。
しかし、<span class="productname">PostgreSQL</span>9.1からデフォルトは<code class="literal">on</code>になりました。これはバックスラッシュエスケープはエスケープ文字列でのみ認識されるということになります。
この振る舞いはSQL標準仕様に即していますが、バックスラッシュエスケープを常に認識するという歴史的な動作に依存しているアプリケーションは動作しなくなるでしょう。
回避策として、このパラメータを<code class="literal">off</code>にすることはできますが、バックスラッシュエスケープの使用を避けるよう移植するのが良いでしょう。
特殊文字を表現するためにバックスラッシュを使用する必要がある場合、<code class="literal">E</code>をつけて文字列定数を記述してください。
    </p><p><code class="varname">standard_conforming_strings</code>の他に、設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-ESCAPE-STRING-WARNING">escape_string_warning</a>および<a class="xref" href="runtime-config-compatible.html#GUC-BACKSLASH-QUOTE">backslash_quote</a>が文字定数内のバックスラッシュの動作を決定します。
    </p></div><p>コードゼロの文字は文字列定数の中に入れられません。
    </p></div><div class="sect3" id="SQL-SYNTAX-STRINGS-UESCAPE"><div class="titlepage"><div><div><h4 class="title">4.1.2.3. Unicodeエスケープがある文字列定数</h4></div></div></div><a id="id-1.5.3.5.9.6.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は同時に、文字コード番号で任意のUnicode文字を指定可能な文字列に対するもう一つのエスケープ構文を提供します。
Unicodeエスケープ文字列定数は、<code class="literal">U&amp;</code>（大文字・小文字のUの後にアンパサンド）で始まり、その直後に、空白を間にはさまず、開始引用符が続きます。
例えば、<code class="literal">U&amp;'foo'</code>となります。
（これにより演算子<code class="literal">&amp;</code>との曖昧性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、文字列<code class="literal">'data'</code>は次のように書かれます。
</p><pre class="programlisting">U&amp;'d\0061t\+000061'</pre><p>
次の少し意味のある例はロシア語の<span class="quote">“<span class="quote">slon</span>”</span>（象）をキリル文字で書いたものです。
</p><pre class="programlisting">U&amp;'\0441\043B\043E\043D'</pre><p>
    </p><p>バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<code class="literal">UESCAPE</code><a id="id-1.5.3.5.9.6.4.2" class="indexterm"></a>句を使用して指定することが可能です。例をあげます。
</p><pre class="programlisting">U&amp;'d!0061t!+000061' UESCAPE '!'</pre><p>
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
    </p><p>Unicodeエスケープ構文はサーバの符号化方式が<code class="literal">UTF8</code>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<code class="literal">\007F</code>まで）のコードポイントのみ指定できます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の両方の形式を使用することができますが、技術的には6桁形式の機能によりこれは不要になります。
（サーバの符号化方式が<code class="literal">UTF8</code>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </p><p>また、文字列定数に対するユニコードエスケープ構文は設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>が有効なときのみ動作します。
そうでないとこの構文は、SQL文を構文解釈するクライアントを混乱させ、SQLインジェクションや、それに類似したセキュリティ問題に繋がることさえあるからです。
パラメータがoffに設定されていれば、この構文はエラーメッセージを出して拒絶されます。
    </p><p>文字列の中に、エスケープ文字をそのまま含めるにはエスケープ文字を２回書きます。
    </p></div><div class="sect3" id="SQL-SYNTAX-DOLLAR-QUOTING"><div class="titlepage"><div><div><h4 class="title">4.1.2.4. ドル記号で引用符付けされた文字列定数</h4></div></div></div><a id="id-1.5.3.5.9.7.2" class="indexterm"></a><p>文字列定数の標準の構文はたいていの場合便利ですが、対象とする文字列内に多くの単一引用符やバックスラッシュがあると、それらを全て二重にしなければなりませんので理解しづらくなります。
こうした状況においても問い合わせの可読性をより高めるために<span class="productname">PostgreSQL</span>は、<span class="quote">“<span class="quote">ドル引用符付け</span>”</span>という他の文字列定数の指定方法を提供します。
ドル引用符付けされた文字列定数は、ドル記号（<code class="literal">$</code>）、省略可能な0個以上の文字からなる<span class="quote">“<span class="quote">タグ</span>”</span>、ドル記号、文字列定数を構成する任意の文字の並び、ドル記号、この引用符付けの始めに指定したものと同じタグ、ドル記号から構成されます。
例えば、<span class="quote">“<span class="quote">Dianne's horse</span>”</span>という文字列をドル引用符付けを使用して指定する方法を、以下に2つ示します。
</p><pre class="programlisting">$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$</pre><p>
ドル引用符付けされた文字列の内側では、単一引用符をエスケープすることなく使用できることを理解して下さい。
実際には、ドル引用符付けされた文字列の内側の文字はまったくエスケープが必要なく、文字列定数はすべてそのまま記述することができます。
その並びが開始タグに一致しない限り、バックスラッシュもドル記号も特別なものではありません。
    </p><p>各入れ子レベルに異なるタグを付けることで、ドル引用符付けされた文字列を入れ子にすることができます。
これは、関数定義を作成する時に非常によく使用されます。
以下に例を示します。
</p><pre class="programlisting">$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</pre><p>
ここで、<code class="literal">$q$[\t\r\n\v\\]$q$</code>は、ドル引用符付けされた<code class="literal">[\t\r\n\v\\]</code>リテラル文字列を表し、<span class="productname">PostgreSQL</span>がこの関数本体を実行する時に認識されます。
しかし、この並びは、外側のドル引用符用の区切り文字<code class="literal">$function$</code>に一致しませんので、外側の文字列を対象としている場合は単なる文字の並びとなります。
    </p><p>もしあれば、ドル引用符付けされた文字列のタグは、引用符付けされていない識別子と同じ規則に従います。
ただし、タグにはドル記号を含めることはできません。
タグは大文字小文字を区別します。
したがって、<code class="literal">$tag$String content$tag$</code>は正しいのですが、<code class="literal">$TAG$String content$tag$</code>は間違いです。
    </p><p>キーワードや識別子の後にドル引用符付けされた文字列を続ける場合は、空白でそれを区切らなければなりません。
さもないと、ドル引用符の区切り文字は、直前の識別子の一部として解釈されます。
    </p><p>ドル引用符付けは、標準SQLで定義されていません。
しかし、複雑な文字列リテラルを記述する場合は標準準拠の単一引用符構文よりも便利なことがよくあります。
特に、他の定数の内部に文字列定数を記述するような場合は役に立ちます。
こうした状況は手続き関数の定義でよく必要とされます。
単一引用符構文では、上の例のバックスラッシュはそれぞれ、4個のバックスラッシュで記述しなければなりません。
この4つのバックスラッシュは、元の文字列定数を解析する際に2つに減少され、そして、関数を実行する際に内部の文字列定数が再解析され1つに減少します。
    </p></div><div class="sect3" id="SQL-SYNTAX-BIT-STRINGS"><div class="titlepage"><div><div><h4 class="title">4.1.2.5. ビット文字列定数</h4></div></div></div><a id="id-1.5.3.5.9.8.2" class="indexterm"></a><p>ビット文字列定数は<code class="literal">B</code>（大文字もしくは小文字）が始まりの引用符の前に付いている（間に空白はありません）通常の文字列定数のように見えます。
例えば<code class="literal">B'1001'</code>のようになります。
ビット文字列定数の中で許可される文字は<code class="literal">0</code>と<code class="literal">1</code>のみです。
    </p><p>その他にも、ビット文字列定数は<code class="literal">X'1FF'</code>といった具合に、先頭に<code class="literal">X</code>（大文字または小文字）を使用して16進表記で指定することもできます。
この表記は、各16進数値をそれぞれ4つの2進数値に置き換えたビット文字列定数と同等です。
    </p><p>どちらの形式のビット文字列定数でも、通常の文字列定数と同じように複数行にわたって続けて書くことができます。
ドル引用符付けはビット文字列定数では使用できません。
    </p></div><div class="sect3" id="SQL-SYNTAX-CONSTANTS-NUMERIC"><div class="titlepage"><div><div><h4 class="title">4.1.2.6. 数値定数</h4></div></div></div><a id="id-1.5.3.5.9.9.2" class="indexterm"></a><p>数値定数は下記の一般的な形で受け付けられます。
</p><pre class="synopsis"><em class="replaceable"><code>digits</code></em>
<em class="replaceable"><code>digits</code></em>.[<span class="optional"><em class="replaceable"><code>digits</code></em></span>][<span class="optional">e[<span class="optional">+-</span>]<em class="replaceable"><code>digits</code></em></span>]
[<span class="optional"><em class="replaceable"><code>digits</code></em></span>].<em class="replaceable"><code>digits</code></em>[<span class="optional">e[<span class="optional">+-</span>]<em class="replaceable"><code>digits</code></em></span>]
<em class="replaceable"><code>digits</code></em>e[<span class="optional">+-</span>]<em class="replaceable"><code>digits</code></em></pre><p>
ここで<em class="replaceable"><code>digits</code></em>は1つ以上の10進数字（0〜9）です。
小数点を使用する場合は、少なくとも1つの数字が小数点の前か後になくてはなりません。
指数記号<code class="literal">e</code>の付く形式を使う場合には<code class="literal">e</code>の後に少なくとも1つの数字がなければいけません。
空白や他の文字は、定数の中に埋め込むことはできません。
プラスまたはマイナスの符号を先頭につけても、定数の一部とはみなされないことに注意してください。
これらの符号は定数に適用される演算子とみなされます。
    </p><p>下記は有効な数値定数のいくつかの例です。
</p><div class="literallayout"><p>42<br />
3.5<br />
4.<br />
.001<br />
5e2<br />
1.925e-3</p></div><p>
    </p><p>     <a id="id-1.5.3.5.9.9.5.1" class="indexterm"></a>
     <a id="id-1.5.3.5.9.9.5.2" class="indexterm"></a>
     <a id="id-1.5.3.5.9.9.5.3" class="indexterm"></a>
小数点も指数も含まない数値定数の場合、まずその値が<code class="type">integer</code>型（32ビット）に収まれば<code class="type">integer</code>型であるとみなされます。
そうでない場合、<code class="type">bigint</code>型（64ビット）で収まれば<code class="type">bigint</code>型とみなされます。
どちらでもない場合は、<code class="type">numeric</code>型とみなされます。
定数が小数点または指数あるいはその両方を含む場合は、常に最初に<code class="type">numeric</code>型であるとみなされます。
    </p><p>数値定数に最初に割り振られるデータ型は、型解決アルゴリズムの開始点に過ぎません。
ほとんどの場合、定数は文脈に基づいて自動的に最も適切な型に変換されます。
必要であれば、特定のデータ型にキャストして、数値がそのデータ型として解釈されるように強制することができます。
<a id="id-1.5.3.5.9.9.6.1" class="indexterm"></a>
例えば、以下のようにして数値を<code class="type">real</code>型（<code class="type">float4</code>）として処理することができます。

</p><pre class="programlisting">REAL '1.23'  -- 文字列書式
1.23::REAL   -- （歴史的な）PostgreSQL書式</pre><p>

実のところ、これらは以下で説明する一般的なキャスト記法の特別な場合です。
    </p></div><div class="sect3" id="SQL-SYNTAX-CONSTANTS-GENERIC"><div class="titlepage"><div><div><h4 class="title">4.1.2.7. 他の型の定数</h4></div></div></div><a id="id-1.5.3.5.9.10.2" class="indexterm"></a><p><span class="emphasis"><em>任意の</em></span>型の定数は下記の表記のいずれかを使って入力することができます。
</p><pre class="synopsis"><em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'
'<em class="replaceable"><code>string</code></em>'::<em class="replaceable"><code>type</code></em>
CAST ( '<em class="replaceable"><code>string</code></em>' AS <em class="replaceable"><code>type</code></em> )</pre><p>
文字列定数のテキストは<em class="replaceable"><code>type</code></em>と呼ばれる型の入力変換ルーチンへと渡されます。
結果は指示された型の定数です。
明示的な型キャストは、定数がどの型でなければならないかについて曖昧な点がなければ（例えば定数が直接テーブル列に代入されている場合）省略しても構いません。
その場合自動的に型強制されます。
    </p><p>文字列定数は通常のSQL記法でもドル引用符付けでも記述することができます。
    </p><p>     関数のような構文を使って型強制を指定することも可能です。
</p><pre class="synopsis"><em class="replaceable"><code>typename</code></em> ( '<em class="replaceable"><code>string</code></em>' )</pre><p>
しかし、全ての型の名前でこの方法は使用できるというわけではありません。
詳細は<a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. 型キャスト">Section 4.2.9</a>を参照してください。
    </p><p><code class="literal">::</code>、<code class="literal">CAST()</code>や関数呼び出し構文は、<a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. 型キャスト">Section 4.2.9</a>で説明する通り、任意の式の実行時の型変換を指定するために使うこともできます。
構文的なあいまいさをなくすために、<code class="literal"><em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'</code>という形式は単なるリテラル定数を指定する場合にのみ使うことができます。
この他<code class="literal"><em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'</code>構文には、配列型では動作しないという制限があります。
配列型の定数の型を指定する場合は<code class="literal">::</code>か<code class="literal">CAST()</code>を使用してください。
    </p><p><code class="literal">CAST()</code>構文はSQLに従っています。
<code class="literal"><em class="replaceable"><code>type</code></em> '<em class="replaceable"><code>string</code></em>'</code>構文は、標準を一般化したものです。
SQLでは、この構文を数個のデータ型でのみ規定しています。
しかし、<span class="productname">PostgreSQL</span>ではすべての型で使用することができます。
<code class="literal">::</code>付きの構文は、歴史的に<span class="productname">PostgreSQL</span>で使用されてきました。
関数呼び出し構文も同じく歴史的に使用されているものです。
    </p></div></div><div class="sect2" id="SQL-SYNTAX-OPERATORS"><div class="titlepage"><div><div><h3 class="title">4.1.3. 演算子</h3></div></div></div><a id="id-1.5.3.5.10.2" class="indexterm"></a><p>演算子は<code class="symbol">NAMEDATALEN</code>-1（デフォルトは63）までの長さの、以下に示すリストに含まれる文字の並びです。
</p><div class="literallayout"><p>+ - * / &lt; &gt; = ~ ! @ # % ^ &amp; | ` ?</p></div><p>

しかし、演算子の名前にはいくつかの制約があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">--</code>と<code class="literal">/*</code>は演算子名の中に使うことができません。
なぜならこれらはコメントの始まりと解釈されるからです。
      </p></li><li class="listitem"><p>複数文字の演算子名は、その名前が少なくとも下記の文字の1つ以上を含まない限り、<code class="literal">+</code>や<code class="literal">-</code>で終わることができません。
</p><div class="literallayout"><p>~ ! @ # % ^ &amp; | ` ?</p></div><p>
例えば、<code class="literal">@-</code>は演算子名として認められていますが、<code class="literal">*-</code>は認められていません。
この制限により<span class="productname">PostgreSQL</span>は、SQLに準拠する問い合わせをトークン同士の間に空白を要求せず、解析することができます。
      </p></li></ul></div><p>
   </p><p>非SQL標準の演算子名を使う場合、通常は曖昧さを回避するために、隣り合った演算子を空白で区切る必要があります。
例えば<code class="literal">@</code>という左単項演算子を定義した場合、<code class="literal">X*@Y</code>とは書けません。
<span class="productname">PostgreSQL</span>がこれを確実に1つではなく2つの演算子名として解釈できるように、<code class="literal">X* @Y</code>と書く必要があります。
   </p></div><div class="sect2" id="SQL-SYNTAX-SPECIAL-CHARS"><div class="titlepage"><div><div><h3 class="title">4.1.4. 特殊文字</h3></div></div></div><p>英数字ではないいくつかの文字は、演算子であることとは異なる特殊な意味を持っています。
使用方法の詳細はそれぞれの構文要素についてのところで説明します。
本節では、単にその存在を知らせ、これらの文字の目的をまとめるに留めます。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>直後に数字が続くドル記号（<code class="literal">$</code>）は、関数定義の本体またはプリペアド文中の位置パラメータを表すために使われます。
他の文脈ではドル記号は識別子名の一部であるかもしれませんし、ドル引用符付けされた文字列定数の一部であるかもしれません。
     </p></li><li class="listitem"><p>括弧（<code class="literal">()</code>）は、通常通り式をまとめ優先するという意味を持ちます。
場合によっては括弧は、特定のSQLコマンドの固定構文の一部として要求されることがあります。
     </p></li><li class="listitem"><p>大括弧（<code class="literal">[]</code>）は、配列要素を選択するために使われます。
配列に関する詳しい情報は<a class="xref" href="arrays.html" title="8.15. 配列">Section 8.15</a>を参照してください。
     </p></li><li class="listitem"><p>カンマ（<code class="literal">,</code>）は、リストの要素を区切るために構文的構成体で使われることがあります。
     </p></li><li class="listitem"><p>セミコロン（<code class="literal">;</code>）は、SQLコマンドの終わりを意味します。
文字列定数または引用符付き識別子以外では、コマンドの途中では使うことができません。
     </p></li><li class="listitem"><p>コロン（<code class="literal">:</code>）は、配列から<span class="quote">“<span class="quote">一部分</span>”</span>を取り出すために使われます
(<a class="xref" href="arrays.html" title="8.15. 配列">Section 8.15</a>を参照してください）。
いくつかのSQL方言（埋め込みSQLなど）では、コロンは変数名の接頭辞として使われます。
     </p></li><li class="listitem"><p>アスタリスク（<code class="literal">*</code>）は、いくつかの文脈において、テーブル行や複合型の全てのフィールドを表現するために使用されます。
また、集約関数の引数として使われる場合も特殊な、つまり、その集約が明示的なパラメータをまったく必要としないという意味を持ちます。
     </p></li><li class="listitem"><p>ピリオド（<code class="literal">.</code>）は数値定数の中で使われます。
また、スキーマ名、テーブル名、列名を区切るためにも使われます。
     </p></li></ul></div><p>

   </p></div><div class="sect2" id="SQL-SYNTAX-COMMENTS"><div class="titlepage"><div><div><h3 class="title">4.1.5. コメント</h3></div></div></div><a id="id-1.5.3.5.12.2" class="indexterm"></a><p>コメントは二重ハイフンで始まる文字の並びで、行の終わりまで続きます。
例えば以下のようになります。
</p><pre class="programlisting">-- これは標準SQLのコメントです</pre><p>
   </p><p>他にも、C言語様式のブロックコメントも使用できます。
</p><pre class="programlisting">/* ネストされた複数行にわたる
 * コメント /* ネストされたブロックコメント */
 */</pre><p>
コメントは<code class="literal">/*</code>で始まり、対応する<code class="literal">*/</code>で終わります。
これらのブロックコメントはC言語とは異なり、標準SQLで規定されているように入れ子にすることができます。
したがって、既存のブロックコメントを含む可能性のある大きなコードのブロックをコメントアウトすることができます。
   </p><p>コメントは、その後の構文解析が行われる前に入力ストリームから取り去られ、事実上、空白で置き換えられます。
   </p></div><div class="sect2" id="SQL-PRECEDENCE"><div class="titlepage"><div><div><h3 class="title">4.1.6. 演算子の優先順位</h3></div></div></div><a id="id-1.5.3.5.13.2" class="indexterm"></a><p><a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE" title="Table 4.2. 演算子の優先順位（高いものから低いものへ）">Table 4.2</a>は、<span class="productname">PostgreSQL</span>の演算子の優先順位と結合性を示しています。
ほとんどの演算子は同じ優先順位を持ち、左結合します。
演算子の優先順位と結合性はパーサに組み込まれています。
   </p><p>二項演算子と単項演算子を組み合わせて使う場合は括弧を加える必要がある場合があります。
例えば下記のような場合です。
</p><pre class="programlisting">SELECT 5 ! - 6;</pre><p>
は、
</p><pre class="programlisting">SELECT 5 ! (- 6);</pre><p>
と解析されます。
なぜならば、パーサは<code class="token">!</code>が中置ではなく接尾演算子として定義されていることに最後まで気が付かないためです。
この場合、求める結果を得るためには下記のように書く必要があります。
</p><pre class="programlisting">SELECT (5 !) - 6;</pre><p>
これが拡張性を求める故の代償です。
   </p><div class="table" id="SQL-PRECEDENCE-TABLE"><p class="title"><strong>Table 4.2. 演算子の優先順位（高いものから低いものへ）</strong></p><div class="table-contents"><table class="table" summary="演算子の優先順位（高いものから低いものへ）" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>演算子/要素</th><th>結合性</th><th>説明</th></tr></thead><tbody><tr><td><code class="token">.</code></td><td>左</td><td>テーブル/列名の区切り文字</td></tr><tr><td><code class="token">::</code></td><td>左</td><td><span class="productname">PostgreSQL</span>方式の型キャスト</td></tr><tr><td><code class="token">[</code> <code class="token">]</code></td><td>左</td><td>配列要素選択</td></tr><tr><td><code class="token">+</code> <code class="token">-</code></td><td>右</td><td>単項加算、単項減算</td></tr><tr><td><code class="token">^</code></td><td>左</td><td>累乗</td></tr><tr><td><code class="token">*</code> <code class="token">/</code> <code class="token">%</code></td><td>左</td><td>掛け算、割り算、剰余</td></tr><tr><td><code class="token">+</code> <code class="token">-</code></td><td>左</td><td>加算、減算</td></tr><tr><td>(その他の演算子)</td><td>左</td><td>その他全ての組み込み、あるいはユーザ定義の演算子</td></tr><tr><td><code class="token">BETWEEN</code> <code class="token">IN</code> <code class="token">LIKE</code> <code class="token">ILIKE</code> <code class="token">SIMILAR</code></td><td> </td><td>範囲内に包含、集合の要素、文字列の一致</td></tr><tr><td><code class="token">&lt;</code> <code class="token">&gt;</code> <code class="token">=</code> <code class="token">&lt;=</code> <code class="token">&gt;=</code> <code class="token">&lt;&gt;</code></td><td> </td><td>比較演算子</td></tr><tr><td><code class="token">IS</code> <code class="token">ISNULL</code> <code class="token">NOTNULL</code></td><td> </td><td><code class="literal">IS TRUE</code>、<code class="literal">IS FALSE</code>、<code class="literal">IS NULL</code>、<code class="literal">IS DISTINCT FROM</code>、その他</td></tr><tr><td><code class="token">NOT</code></td><td>右</td><td>論理否定</td></tr><tr><td><code class="token">AND</code></td><td>左</td><td>論理積</td></tr><tr><td><code class="token">OR</code></td><td>左</td><td>論理和</td></tr></tbody></table></div></div><br class="table-break" /><p>演算子優先順位の規則は、上記で触れた組み込み演算子と同じ名前を持つユーザ定義演算子にも当てはまります。
例えばもし<span class="quote">“<span class="quote">+</span>”</span>演算子をある独自のデータ型に定義すると、新しい演算子が何をするかにかかわらず、<span class="quote">“<span class="quote">+</span>”</span>組み込み演算子と同じ優先順位を持つようになります。
   </p><p>次の例のように、<code class="literal">OPERATOR</code>構文でスキーマで修飾された演算子名を使用する場合、
</p><pre class="programlisting">SELECT 3 OPERATOR(pg_catalog.+) 4;</pre><p>
<code class="literal">OPERATOR</code>構文は、<a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE" title="Table 4.2. 演算子の優先順位（高いものから低いものへ）">Table 4.2</a>の<span class="quote">“<span class="quote">その他の演算子</span>”</span>で示されているデフォルトの優先順位を持つとみなされます。
これは、<code class="literal">OPERATOR()</code>にどの特定の演算子が入る場合でも変わりません。
   </p><div class="note"><h3 class="title">Note</h3><p>9.5より前の<span class="productname">PostgreSQL</span>のバージョンでは少し異なる演算子優先順位規則を使っていました。
特に<code class="token">&lt;=</code>、<code class="token">&gt;=</code>、<code class="token">&lt;&gt;</code>は一般的な演算子として扱われていました。<code class="literal">IS</code>テストは高い優先順位を持つとして使われていました。<code class="literal">NOT BETWEEN</code>とそれに関係する構文は振る舞いが一貫しておらず、<code class="literal">BETWEEN</code>ではなく<code class="literal">NOT</code>の優先順位を持つと見なされる場合がありました。
標準SQLにより準拠し、論理的に等しい構文の一貫しない扱いから来る混乱を減らすように、これらの規則は変更されました。
ほとんどの場合、これらの変更により振る舞いが変わることはないでしょうし、もし変わっても恐らく<span class="quote">“<span class="quote">no such operator</span>”</span>で失敗になるくらいでしょう。後者は括弧を追加することで解決できるでしょう。
しかしながら、稀に問い合わせがパースエラーを返すことなく振る舞いを変える場合があります。
これらの変更が黙って何かを壊してしまったかどうかが心配であれば、設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-OPERATOR-PRECEDENCE-WARNING">operator_precedence_warning</a>をオンにして、何か警告がログに書き込まれるかを見てください。
    </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-syntax.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-expressions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 4. SQLの構文 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.2. 評価式</td></tr></table></div></body></html>