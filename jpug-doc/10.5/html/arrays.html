<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.15. 配列</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="datatype-json.html" title="8.14. JSONデータ型" /><link rel="next" href="rowtypes.html" title="8.16. 複合型" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.15. 配列</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-json.html" title="8.14. JSONデータ型">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Chapter 8. データ型">Up</a></td><th width="60%" align="center">Chapter 8. データ型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="rowtypes.html" title="8.16. 複合型">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ARRAYS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.15. 配列</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="arrays.html#ARRAYS-DECLARATION">8.15.1. 配列型の宣言</a></span></dt><dt><span class="sect2"><a href="arrays.html#ARRAYS-INPUT">8.15.2. 配列の値の入力</a></span></dt><dt><span class="sect2"><a href="arrays.html#ARRAYS-ACCESSING">8.15.3. 配列へのアクセス</a></span></dt><dt><span class="sect2"><a href="arrays.html#ARRAYS-MODIFYING">8.15.4. 配列の変更</a></span></dt><dt><span class="sect2"><a href="arrays.html#ARRAYS-SEARCHING">8.15.5. 配列内の検索</a></span></dt><dt><span class="sect2"><a href="arrays.html#ARRAYS-IO">8.15.6. 配列の入出力構文</a></span></dt></dl></div><a id="id-1.5.7.23.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>ではテーブルの列を可変長多次元配列として定義できます。
あらゆる組み込み型、ユーザ定義基本型、列挙型または複合型の配列も作成可能です。
ドメインの配列はサポートされていません。
 </p><div class="sect2" id="ARRAYS-DECLARATION"><div class="titlepage"><div><div><h3 class="title">8.15.1. 配列型の宣言</h3></div></div></div><a id="id-1.5.7.23.4.2" class="indexterm"></a><p>実際に配列の使い方を説明するために、次のテーブルを作成します。
</p><pre class="programlisting">CREATE TABLE sal_emp (
    name            text,
    pay_by_quarter  integer[],
    schedule        text[][]
);</pre><p>
見ておわかりのように配列データ型は配列要素のデータ型の名前に大括弧（<code class="literal">[]</code>）を付けて指定します。
このコマンドは<code class="type">text</code>型文字列（<code class="structfield">name</code>）、従業員の四半期の給与を保存する<code class="type">integer</code>型の一次元配列（<code class="structfield">pay_by_quarter</code>）、そして従業員の週間スケジュールを保存する<code class="type">text</code>型の二次元配列（<code class="structfield">schedule</code>）の列を持つ<code class="structname">sal_emp</code>という名前のテーブルを作成します。
 </p><p><code class="command">CREATE TABLE</code>構文で指定する配列の正確な大きさを指定することができます。

</p><pre class="programlisting">CREATE TABLE tictactoe (
    squares   integer[3][3]
);</pre><p>

とは言っても現在の実装では指定された配列の大きさの制限を無視します。
つまり、長さの指定がない配列と同じ振舞いをします。
 </p><p>現在の実装では次元数の宣言も強制していません。
特定の要素型の配列はすべて大きさあるいは次元数とは無関係に同じ型とみなされます。
ですから<code class="command">CREATE TABLE</code>で配列の大きさや次元数を宣言することは、単なる説明です。
実行時の動作に影響を及ぼしません。
 </p><p>SQLに準拠し、<code class="literal">ARRAY</code>キーワードを使用したもう1つの構文を一次元配列に使うことができます。
<code class="structfield">pay_by_quarter</code>を次のように定義することもできます。

</p><pre class="programlisting">    pay_by_quarter  integer ARRAY[4],</pre><p>
または、もし配列の大きさが指定されない場合は次のようになります。
</p><pre class="programlisting">    pay_by_quarter  integer ARRAY,</pre><p>
しかし、前で触れたように<span class="productname">PostgreSQL</span>はどんな場合でも大きさの制限を強要しません。
 </p></div><div class="sect2" id="ARRAYS-INPUT"><div class="titlepage"><div><div><h3 class="title">8.15.2. 配列の値の入力</h3></div></div></div><a id="id-1.5.7.23.5.2" class="indexterm"></a><p>リテラル定数として配列の値を書き込むには、その要素の値を中括弧で囲み、それぞれの要素の値をカンマで区切ります
（C言語を知っているならば、構造体を初期化するための構文のようなものと考えてください）。
要素の値を二重引用符でくくることもでき、カンマもしくは中括弧がある時は必ずそのように書かなければなりません
（詳細は以下に出てきます）。
したがって配列定数の一般的書式は次のようになります。
</p><pre class="synopsis">'{ <em class="replaceable"><code>val1</code></em> <em class="replaceable"><code>delim</code></em> <em class="replaceable"><code>val2</code></em> <em class="replaceable"><code>delim</code></em> ... }'</pre><p>
ここで<em class="replaceable"><code>delim</code></em>はその<code class="literal">pg_type</code>項目に記録されている型の区切り文字です。
<span class="productname">PostgreSQL</span>配布物で提供されている標準データ型の内、セミコロン（<code class="literal">;</code>）を使用する<code class="type">box</code>型を除き、すべてはカンマ（<code class="literal">,</code>）を使います。
それぞれの<em class="replaceable"><code>val</code></em>は配列要素の型の定数か副配列です。
配列定数の例を以下に示します。
</p><pre class="programlisting">'{{1,2,3},{4,5,6},{7,8,9}}'</pre><p>
この定数は整数の3つの副配列を持っている二次元3×3の配列です。
  </p><p>配列定数の要素をNULLとするためには、その要素値に<code class="literal">NULL</code>と記載してください。
（<code class="literal">NULL</code>を大文字で書いても小文字で書いても構いません。）
<span class="quote">“<span class="quote">NULL</span>”</span>という文字列値を指定したければ、二重引用符でくくって記載しなければなりません。
  </p><p>（この種の配列定数は実際<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 他の型の定数">Section 4.1.2.7</a>で説明されている一般型定数の特別の場合に過ぎません。
この定数は元々文字列として扱われていて配列入力ルーチンに渡されます。
明示的な型指定が必要かもしれません。）
  </p><p>では、<code class="command">INSERT</code>文をいくつか紹介します。

</p><pre class="programlisting">INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"training", "presentation"}}');

INSERT INTO sal_emp
    VALUES ('Carol',
    '{20000, 25000, 25000, 25000}',
    '{{"breakfast", "consulting"}, {"meeting", "lunch"}}');</pre><p>
  </p><p>上に記載した2つの挿入文の結果は次のようになります。

</p><pre class="programlisting">SELECT * FROM sal_emp;
 name  |      pay_by_quarter       |                 schedule
-------+---------------------------+-------------------------------------------
 Bill  | {10000,10000,10000,10000} | {{meeting,lunch},{training,presentation}}
 Carol | {20000,25000,25000,25000} | {{breakfast,consulting},{meeting,lunch}}
(2 rows)</pre><p>
 </p><p>多次元配列では、各次元の範囲を合わせなければなりません。
一致しないと以下のようにエラーが発生します。

</p><pre class="programlisting">INSERT INTO sal_emp
    VALUES ('Bill',
    '{10000, 10000, 10000, 10000}',
    '{{"meeting", "lunch"}, {"meeting"}}');
ERROR:  multidimensional arrays must have array expressions with matching dimensions</pre><p>
 </p><p><code class="literal">ARRAY</code>生成子構文も使えます。
</p><pre class="programlisting">INSERT INTO sal_emp
    VALUES ('Bill',
    ARRAY[10000, 10000, 10000, 10000],
    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);

INSERT INTO sal_emp
    VALUES ('Carol',
    ARRAY[20000, 25000, 25000, 25000],
    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);</pre><p>
配列要素は通常のSQL定数もしくは演算式であることに注意してください。
例えば文字列リテラルは配列リテラルと同様、二重引用符ではなく単一引用符でくくられます。
<code class="literal">ARRAY</code>生成子構文は<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS" title="4.2.12. 配列コンストラクタ">Section 4.2.12</a>により詳しい説明があります。
 </p></div><div class="sect2" id="ARRAYS-ACCESSING"><div class="titlepage"><div><div><h3 class="title">8.15.3. 配列へのアクセス</h3></div></div></div><a id="id-1.5.7.23.6.2" class="indexterm"></a><p>ではテーブルに対していくつかの問い合わせを行ってみましょう。
初めに、配列の単一要素にアクセスする方法を示します。
この問い合わせは第2四半期に給与が更新された従業員の名前を抽出します。

</p><pre class="programlisting">SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2];

 name
-------
 Carol
(1 row)</pre><p>

配列の添字番号は大括弧で囲んで記述されます。
デフォルトで<span class="productname">PostgreSQL</span>は配列に対し「1始まり」の振り番規定を採用しています。
つまり要素が<em class="replaceable"><code>n</code></em>個ある配列は<code class="literal">array[1]</code>で始まり、<code class="literal">array[<em class="replaceable"><code>n</code></em>]</code>で終わります。
 </p><p>次の問い合わせは全ての従業員の第3四半期の給与を抽出します。

</p><pre class="programlisting">SELECT pay_by_quarter[3] FROM sal_emp;

 pay_by_quarter
----------------
          10000
          25000
(2 rows)</pre><p>
 </p><p>また、配列や副配列の任意の縦方向の部分を切り出すこともできます。
一次元以上の配列についてその一部を表現するには、<code class="literal"><em class="replaceable"><code>lower-bound</code></em>:<em class="replaceable"><code>upper-bound</code></em></code>と記述します。
例えばこの問い合わせはBillのその週の初めの2日に最初何が予定されているかを抽出します。

</p><pre class="programlisting">SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)</pre><p>

任意の次元を部分として、つまりコロンを含めて記述すると、すべての次元が部分として扱われます。
単一の番号のみ（コロンを持たない）を持つ次元はすべて、1から指定番号までと扱われます。
例えば、<code class="literal">[2]</code>は以下の例のように <code class="literal">[1:2]</code>と扱われます。

</p><pre class="programlisting">SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';

                 schedule
-------------------------------------------
 {{meeting,lunch},{training,presentation}}
(1 row)</pre><p>

切り出しのない場合と混乱を避けるため、すべての次元に対し切り出し構文を使用することが最善です。
例えば、<code class="literal">[2][1:1]</code>ではなく、<code class="literal">[1:2][1:1]</code>のようにします。
 </p><p>切り出し指定子の<em class="replaceable"><code>lower-bound</code></em>、<em class="replaceable"><code>upper-bound</code></em>は省略可能です。省略された上限または下限は、配列の添字の上限または下限で置き換えられます。
例えば、

</p><pre class="programlisting">SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{lunch},{presentation}}
(1 row)

SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill';

        schedule
------------------------
 {{meeting},{training}}
(1 row)</pre><p>
 </p><p>配列自体がNULLもしくはその添字式がNULLとなる場合、配列添字式はNULLを返します。
また、配列の範囲を超える添字の場合もNULLが返されます（この場合はエラーになりません）。
例えば、<code class="literal">schedule</code>が現在<code class="literal">[1:3][1:2]</code>次元であれば、<code class="literal">schedule[3][3]</code>の参照はNULLとなります。
同様にして、添字として間違った値を指定して配列を参照した場合もエラーではなく、NULLが返されます。
 </p><p>同様に、部分配列式も配列自体がNULLもしくはその添字式がNULLとなる場合にNULLを返します。
しかし、現在の配列範囲を完全に超えた部分配列を選択する場合では、部分配列式はNULLではなく空の（0次元）の配列を返します。
（これは切り出しなしの動作に一致せず、歴史的理由で行われるものです。）
要求された部分配列が配列の範囲に重なる場合、NULLを返さずに、警告なく重複部分だけに減少させます。
 </p><p><code class="function">array_dims</code>関数で任意の配列値の現在の次元を取り出せます。

</p><pre class="programlisting">SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';

 array_dims
------------
 [1:2][1:2]
(1 row)</pre><p>

<code class="function">array_dims</code>関数は<code class="type">text</code>型で結果を返します。
人間が結果を見るためには便利ですが、プログラムにとって都合がよくありません。
次元は<code class="function">array_upper</code>と<code class="function">array_lower</code>でも抽出することができ、それぞれ特定の配列の次元の上限と下限を返します。

</p><pre class="programlisting">SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_upper
-------------
           2
(1 row)</pre><p>

<code class="function">array_length</code>は指定された配列次元の長さを返します。

</p><pre class="programlisting">SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';

 array_length
--------------
            2
(1 row)</pre><p>

<code class="function">cardinality</code>は配列の全次元に渡る要素の総数を返します。
実質的に<code class="function">unnest</code>の呼び出しで生成される行の数です。

</p><pre class="programlisting">SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';

 cardinality
-------------
           4
(1 row)</pre><p>
 </p></div><div class="sect2" id="ARRAYS-MODIFYING"><div class="titlepage"><div><div><h3 class="title">8.15.4. 配列の変更</h3></div></div></div><a id="id-1.5.7.23.7.2" class="indexterm"></a><p>配列の値を全て置き換えることができます。

</p><pre class="programlisting">UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'
    WHERE name = 'Carol';</pre><p>

もしくは<code class="literal">ARRAY</code>演算構文を用いて次のように書きます。

</p><pre class="programlisting">UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]
    WHERE name = 'Carol';</pre><p>

配列の1つの要素を更新することも可能です。

</p><pre class="programlisting">UPDATE sal_emp SET pay_by_quarter[4] = 15000
    WHERE name = 'Bill';</pre><p>

あるいは一部分の更新も可能です。

</p><pre class="programlisting">UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'
    WHERE name = 'Carol';</pre><p>

<em class="replaceable"><code>lower-bound</code></em>や<em class="replaceable"><code>upper-bound</code></em>が省略された切り出し構文も使用可能ですが、NULLや0次元でない配列の値を更新する場合に限ります(さもなければ、置き換えるべき添字の上限、下限が存在しません)。
 </p><p>保存されている配列の値は、存在しない要素に代入することで拡張することができます。
過去に存在した位置と新しく代入された位置との間はNULLで埋められます。
例えば、現在配列<code class="literal">myarray</code>の要素数が4の場合、<code class="literal">myarray[6]</code>を割り当てる更新の後6要素を持つことなり、<code class="literal">myarray[5]</code>はNULLを含みます。
現在、こうした方法での拡張は、1次元配列でのみ許されます。
多次元配列では行うことができません。
 </p><p>添字指定の代入で1始まり以外の添字がある配列を作れます。
例えば添字が-2から7までの値を持つ配列を<code class="literal">array[-2:7]</code>で指定できます。
 </p><p>新規の配列の値は連結演算子<code class="literal">||</code>を用いて作成することもできます。
</p><pre class="programlisting">SELECT ARRAY[1,2] || ARRAY[3,4];
 ?column?
-----------
 {1,2,3,4}
(1 row)

SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]];
      ?column?
---------------------
 {{5,6},{1,2},{3,4}}
(1 row)</pre><p>
 </p><p>連結演算子を使うと、一次元配列の最初もしくは最後に1つの要素を押し込むことができます。
さらには2つの<em class="replaceable"><code>N</code></em>-次元配列もしくは<em class="replaceable"><code>N</code></em>-次元配列と<em class="replaceable"><code>N+1</code></em>-次元配列にも対応しています。
 </p><p>1つの要素が1次元配列の先頭や末尾に押し込まれた時、結果は配列演算項目と同じ下限添字を持つ配列となります。
以下に例を示します。
</p><pre class="programlisting">SELECT array_dims(1 || '[0:1]={2,3}'::int[]);
 array_dims
------------
 [0:2]
(1 row)

SELECT array_dims(ARRAY[1,2] || 3);
 array_dims
------------
 [1:3]
(1 row)</pre><p>
 </p><p>等しい次元を持った2つの配列が連結された場合、結果は左側演算項目の外側の次元の下限添字を引き継ぎます。
結果は右側被演算子のすべての要素に左側被演算子が続いた配列となります。
例を挙げます。
</p><pre class="programlisting">SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);
 array_dims
------------
 [1:5]
(1 row)

SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]]);
 array_dims
------------
 [1:5][1:2]
(1 row)</pre><p>
 </p><p><em class="replaceable"><code>N</code></em>-次元配列が<em class="replaceable"><code>N+1</code></em>-次元配列の最初または最後に押し込まれると、結果は上記と似通った要素配列になります。
それぞれの<em class="replaceable"><code>N</code></em>-次元副配列は本質的に<em class="replaceable"><code>N+1</code></em>-次元配列の外側の次元の要素となります。
例を挙げます。
</p><pre class="programlisting">SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);
 array_dims
------------
 [1:3][1:2]
(1 row)</pre><p>
 </p><p>配列は<code class="function">array_prepend</code>、<code class="function">array_append</code>、もしくは<code class="function">array_cat</code>を使って構築することもできます。
初めの2つは一次元配列にしか対応していませんが、<code class="function">array_cat</code>は多次元配列でも使えます。
例を挙げます。

</p><pre class="programlisting">SELECT array_prepend(1, ARRAY[2,3]);
 array_prepend
---------------
 {1,2,3}
(1 row)

SELECT array_append(ARRAY[1,2], 3);
 array_append
--------------
 {1,2,3}
(1 row)

SELECT array_cat(ARRAY[1,2], ARRAY[3,4]);
 array_cat
-----------
 {1,2,3,4}
(1 row)

SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6]);
      array_cat
---------------------
 {{1,2},{3,4},{5,6}}
(1 row)

SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]]);
      array_cat
---------------------
 {{5,6},{1,2},{3,4}}</pre><p>
 </p><p>単純な状況では、上で説明した連結演算子はそれぞれの関数を直接実行することよりも望ましいです。
とは言っても、連結演算子は3つの場合すべてに対応するようオーバーロードされていますので、その関数の1つを使うとあいまいさを避けるのに役立つ場合があります。
例えば、以下のような状況を考えてください。

</p><pre class="programlisting">SELECT ARRAY[1, 2] || '{3, 4}';  -- 型指定のないリテラルは配列と見なされる
 ?column?
-----------
 {1,2,3,4}

SELECT ARRAY[1, 2] || '7';                 -- これも同様
ERROR:  malformed array literal: "7"

SELECT ARRAY[1, 2] || NULL;                -- 修飾されていないNULLも同様
 ?column?
----------
 {1,2}
(1 row)

SELECT array_append(ARRAY[1, 2], NULL);    -- これがやりたかった事かも
 array_append
--------------
 {1,2,NULL}</pre><p>

上の例では、パーサは連結演算子の一方の側に整数の配列を見つけ、もう一方の側に型の決まらない定数を見つけます。
パーサが定数の型を解決するのに使う発見的手法は、演算子のもう一方の入力と同じ型(この場合には整数の配列)だと仮定することです。
そのため、連結演算子は<code class="function">array_append</code>ではなく、<code class="function">array_cat</code>と推定されます。
これが誤った選択である場合には、定数を配列の要素の型にキャストすることで直せるかもしれません。ですが、<code class="function">array_append</code>を明示的に使うのが好ましい解決法であるかもしれません。
 </p></div><div class="sect2" id="ARRAYS-SEARCHING"><div class="titlepage"><div><div><h3 class="title">8.15.5. 配列内の検索</h3></div></div></div><a id="id-1.5.7.23.8.2" class="indexterm"></a><p>配列内のある値を検索するにはそれぞれの値が検証されなければなりません。
もし配列の大きさがわかっているならば手作業でも検索できます。
例を挙げます。

</p><pre class="programlisting">SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR
                            pay_by_quarter[2] = 10000 OR
                            pay_by_quarter[3] = 10000 OR
                            pay_by_quarter[4] = 10000;</pre><p>

とは言ってもこの方法では大きい配列では大変な作業となりますし、配列の大きさが不明な場合この方法は使えません。
代わりになる方法が<a class="xref" href="functions-comparisons.html" title="9.23. 行と配列の比較">Section 9.23</a>で説明されています。
上の問い合わせは以下のように書くことができます。

</p><pre class="programlisting">SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);</pre><p>

さらに配列で行の値が全て10000に等しいものを見つけることもできます。

</p><pre class="programlisting">SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);</pre><p>

 </p><p>代わりとして、<code class="function">generate_subscripts</code>関数を使うことができます。
以下はその例です。

</p><pre class="programlisting">SELECT * FROM
   (SELECT pay_by_quarter,
           generate_subscripts(pay_by_quarter, 1) AS s
      FROM sal_emp) AS foo
 WHERE pay_by_quarter[s] = 10000;</pre><p>

この関数は<a class="xref" href="functions-srf.html#FUNCTIONS-SRF-SUBSCRIPTS" title="Table 9.59. 添え字生成関数">Table 9.59</a>に記載されています。
 </p><p><code class="literal">&amp;&amp;</code>演算子を使って配列を検索することもできます。
この演算子は左辺が右辺と重なるかどうかを調べます。
例えば、

</p><pre class="programlisting">SELECT * FROM sal_emp WHERE pay_by_quarter &amp;&amp; ARRAY[10000];</pre><p>

この演算子やその他の配列の演算子は<a class="xref" href="functions-array.html" title="9.18. 配列関数と演算子">Section 9.18</a>により詳しく書かれています。
<a class="xref" href="indexes-types.html" title="11.2. インデックスの種類">Section 11.2</a>に書いてあるように、適切なインデックスにより高速化されます。
 </p><p>関数<code class="function">array_position</code>や<code class="function">array_positions</code>を使って、配列内の特定の値を検索することもできます。
前者は配列内で初めてその値が現れる添字を返し、後者は配列内でその値が現れる添字すべての配列を返します。
例えば、以下の通りです。

</p><pre class="programlisting">SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');
 array_positions
-----------------
 2

SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1);
 array_positions
-----------------
 {1,4,8}</pre><p>
 </p><div class="tip"><h3 class="title">Tip</h3><p>配列は集合ではありません。
特定の配列要素に検索をかけることはデータベース設計が誤っている可能性があります。
配列の要素とみなされるそれぞれの項目を行に持つ別のテーブルを使うことを検討してください。
この方が検索がより簡単になり要素数が大きくなっても規模的拡張性があります。
  </p></div></div><div class="sect2" id="ARRAYS-IO"><div class="titlepage"><div><div><h3 class="title">8.15.6. 配列の入出力構文</h3></div></div></div><a id="id-1.5.7.23.9.2" class="indexterm"></a><p>配列の値の外部表現は配列の要素の型に対するI/O変換ルールに基づいて解釈された項目と配列の構造を示す装飾項目で構成されています。
装飾は配列の値を中括弧（<code class="literal">{</code>と<code class="literal">}</code>）で囲んだものと次の項目との間を区切り文字で区切ったものです。
区切り文字は通常カンマ（<code class="literal">,</code>）ですが他の文字でも構いません。
配列の要素の型<code class="literal">typdelim</code>を設定することで決まります。
<span class="productname">PostgreSQL</span>配布物における標準のデータ型の中でセミコロン（<code class="literal">;</code>）を使う<code class="type">box</code>型を除いて、すべてはカンマを使います。
多次元配列ではそれぞれの次元（行、面、立体など）はそれ自身の階層において中括弧、同じ階層の中括弧でくくられた次の塊との間に区切り文字が書かれていなければなりません。
  </p><p>空の文字列や中括弧や区切り文字、二重引用符、バックスラッシュ、空白、<code class="literal">NULL</code>という単語が含まれていると、配列出力処理は要素の値を二重引用符でくくります。
要素の値に組み込まれている二重引用符とバックスラッシュはバックスラッシュでエスケープされます。
数値データ型に対しては二重引用符が出現しないと想定するのが安全ですが、テキストデータ型の場合引用符がある場合とない場合に対処できるようにしておくべきです。
  </p><p>デフォルトでは配列の次元の下限インデックス値は1に設定されています。
他の下限値を持つ配列を表現したければ、配列定数を作成する前に明示的に配列添字範囲を指定することで実現できます。
修飾項目はそれぞれの配列次元の上限と下限をコロン（<code class="literal">:</code>）で区切って前後を大括弧（<code class="literal">[]</code>）でくくった形式になっています。
代入演算子（<code class="literal">=</code>）の後に配列次元修飾項目が続きます。
例を示します。
</p><pre class="programlisting">SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2
 FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;

 e1 | e2
----+----
  1 |  6
(1 row)</pre><p>
1とは異なる下限を持つ場合にのみ、配列出力関数はその結果に明示的な次元を含めます。
  </p><p>要素に指定された値が<code class="literal">NULL</code>（またはその亜種）の場合、要素はNULLとして扱われます。
引用符やバックスラッシュがあると、これは無効となり、<span class="quote">“<span class="quote">NULL</span>”</span>という文字列リテラルを入力することができます。
また、8.2以前の<span class="productname">PostgreSQL</span>との後方互換性のため、<a class="xref" href="runtime-config-compatible.html#GUC-ARRAY-NULLS">array_nulls</a>設定パラメータを<code class="literal">off</code>にして、<code class="literal">NULL</code>をNULLとして認識しないようにすることができます。
  </p><p>前に示したように配列に値を書き込む場合は独立した配列要素を二重引用符でくくります。
配列値パーサが配列要素値によって混乱を来さないように<span class="emphasis"><em>必ず</em></span>この形式を守ってください。
例えば、中括弧、カンマ（もしくはデータ型の区切り文字）、二重引用符、バックスラッシュもしくは前後に付いた空白を含む要素は必ず二重引用符でくくらなければなりません。
空文字列や<code class="literal">NULL</code>という単語自体も同様に引用符でくくらなければなりません。
二重引用符もしくはバックスラッシュを引用符付きの配列要素に付け加えたい場合、エスケープ文字列構文を使用し、そしてその直前にバックスラッシュを付けます。
別の方法として配列構文とみなされるような全てのデータ文字を、引用符を使用しないでバックスラッシュでエスケープしても構いません。
  </p><p>括弧の右側もしくは左側それぞれの前と後に空白を追加することができます。
同様に独立した項目の文字列の前後に空白を付け加えることもできます。
これらすべての場合において空白は無視されます。
とは言っても二重引用符で囲まれた要素の中の空白、もしくは要素の空白文字以外により両側がくくられているものは無視されません。
  </p><div class="note"><h3 class="title">Note</h3><p>SQLコマンドで書かれたものは最初に文字列リテラルとして解釈され、その次に配列として解釈されることを覚えておいてください。
と言うことは、バックスラッシュの数が倍になることを意味します。
例えばバックスラッシュと二重引用符を含んだ<code class="type">text</code>配列値を挿入する場合、次のようになります。
</p><pre class="programlisting">INSERT ... VALUES (E'{"\\\\","\\""}');</pre><p>
エスケープ文字列プロセッサは1つの階層のバックスラッシュを取り除きますので、配列値パーサに渡された時は<code class="literal">{"\\","\""}</code>のようになります。
さらに<code class="type">text</code>データ型入力ルーチンに与えられた文字列はそれぞれ<code class="literal">\</code>と<code class="literal">"</code>になります
（もし入力ルーチンがバックスラッシュを特別に取り扱うデータ型を操作している場合（例えば<code class="type">bytea</code>）、1つのバックスラッシュを配列要素に保存したい時はコマンドの中に8つのバックスラッシュが必要です）。
ドル引用符付け（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. ドル記号で引用符付けされた文字列定数">Section 4.1.2.4</a>参照）を使用して、バックスラッシュを二重化する必要性をなくすことができます。
  </p></div><div class="tip"><h3 class="title">Tip</h3><p>SQLコマンドの中で配列値を書く時、配列リテラル構文よりも<code class="literal">ARRAY</code>生成子構文（<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS" title="4.2.12. 配列コンストラクタ">Section 4.2.12</a>を参照）の方が往々にして扱いやすい場合があります。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-json.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="rowtypes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.14. <acronym class="acronym">JSON</acronym>データ型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 8.16. 複合型</td></tr></table></div></body></html>