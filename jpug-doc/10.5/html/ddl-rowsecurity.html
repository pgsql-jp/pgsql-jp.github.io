<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.7. 行セキュリティポリシー</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ddl-priv.html" title="5.6. 権限" /><link rel="next" href="ddl-schemas.html" title="5.8. スキーマ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.7. 行セキュリティポリシー</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-priv.html" title="5.6. 権限">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Chapter 5. データ定義">Up</a></td><th width="60%" align="center">Chapter 5. データ定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-schemas.html" title="5.8. スキーマ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="DDL-ROWSECURITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.7. 行セキュリティポリシー</h2></div></div></div><a id="id-1.5.4.9.2" class="indexterm"></a><a id="id-1.5.4.9.3" class="indexterm"></a><p><a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>によって利用できるSQL標準の<a class="link" href="ddl-priv.html" title="5.6. 権限">権限システム</a>に加えて、通常の問い合わせでどの行が戻され、データ更新のコマンドでどの行を挿入、更新、削除できるかをユーザ単位で制限する<em class="firstterm">行セキュリティポリシー</em>をテーブルに定義できます。
この機能は<em class="firstterm">行単位セキュリティ</em>としても知られています。
デフォルトではテーブルには何もポリシーはなく、SQLの権限システムによってテーブルのアクセス権限があるユーザは、テーブル内のすべての行について同じように、問い合わせや更新をすることができます。
  </p><p>テーブルの行セキュリティが有効の場合（<a class="link" href="sql-altertable.html" title="ALTER TABLE">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</a>を使います）、行の検索や行の更新のための通常のテーブルアクセスはすべて、行セキュリティポリシーによって許可される必要があります。
（ただし、テーブルの所有者は典型的には行セキュリティポリシーの対象とはなりません。）
テーブルにポリシーが存在しない場合は、デフォルト拒否のポリシーが使われて、どの行も見ることも更新することもできなくなります。
<code class="command">TRUNCATE</code>や<code class="literal">REFERENCES</code>など、テーブル全体に対する操作は行セキュリティの対象とはなりません。
  </p><p>行セキュリティポリシーは特定のコマンド、特定のロール、あるいはその両方に対して定義できます。
ポリシーは<code class="literal">ALL</code>つまりすべてのコマンドに対して適用、あるいは<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>に適用することを指定できます。
1つのポリシーを複数のロールに割り当てることができ、通常のロールのメンバ資格と継承の規則が当てはまります。
  </p><p>ポリシーでどの行が可視である、あるいは更新可能であるかを指定するために、ブーリアン値を返す式が必要です。
ユーザの問い合わせにあるどの条件や関数よりも前に、この式が各行について評価されます。
（この規則の例外は、情報リークがないことが保証される<code class="literal">leakproof</code>関数だけです。
行セキュリティの確認の前にこのような関数を適用することをオプティマイザが選択することがあります。）
式が<code class="literal">true</code>を返さない行は処理対象になりません。
可視である行と変更可能な行について独立した制御ができるように、別々の式を指定することも可能です。
ポリシーの式は問い合わせの一部分として、問い合わせをしているユーザの権限で実行されます。
ただし、呼び出しユーザに利用できないデータにアクセスするために、セキュリティ定義関数を使うことができます。
  </p><p>スーパーユーザ、および<code class="literal">BYPASSRLS</code>属性のあるロールは、テーブルへのアクセス時に、常に行セキュリティシステムを無視します。
テーブルの所有者も通常は行セキュリティを無視しますが、<a class="link" href="sql-altertable.html" title="ALTER TABLE">ALTER TABLE ... FORCE ROW LEVEL SECURITY</a>により、テーブルの所有者も行セキュリティの対象となることができます。
  </p><p>行セキュリティの有効化、無効化、およびポリシーのテーブルへの追加は、常に、テーブルの所有者のみの権限です。
  </p><p>ポリシーは<a class="xref" href="sql-createpolicy.html" title="CREATE POLICY"><span class="refentrytitle">CREATE POLICY</span></a>コマンドで作成され、<a class="xref" href="sql-alterpolicy.html" title="ALTER POLICY"><span class="refentrytitle">ALTER POLICY</span></a>コマンドで変更され、<a class="xref" href="sql-droppolicy.html" title="DROP POLICY"><span class="refentrytitle">DROP POLICY</span></a>コマンドで削除されます。
テーブルの行セキュリティを有効に、あるいは無効にするには<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>コマンドを使います。
  </p><p>各ポリシーには名前があり、1つのテーブルに複数のポリシーを定義することができます。
ポリシーはテーブルごとに定義されるので、1つのテーブルの各ポリシーは異なる名前でなければなりません。
異なるテーブルであれば、同じ名前のポリシーが存在しても構いません。
  </p><p>ある問い合わせに複数のポリシーが適用される場合、（デフォルトの許容(permissive)ポリシーについては）<code class="literal">OR</code>または（制限(restrictive)ポリシーについては） <code class="literal">AND</code>を使って結合されます。
これは、あるロールが、それが属するすべてのロールの権限を合わせ持つのと類似しています。
許容ポリシーと制限ポリシーについては以下で更に説明します。
  </p><p>簡単な例として、<code class="literal">managers</code>ロールのメンバーだけが行にアクセスでき、かつ自分のアカウントの行のみアクセスできるポリシーを<code class="literal">account</code>リレーション上に作成する方法を以下に示します。
  </p><pre class="programlisting">CREATE TABLE accounts (manager text, company text, contact_email text);

ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);</pre><p>ロールが指定されなかった場合、あるいは特別なユーザ名<code class="literal">PUBLIC</code>が指定された場合、ポリシーはシステム上の全ユーザに適用されます。
すべてのユーザが<code class="literal">users</code>テーブルの自分自身の行にだけアクセスできるようにするためには、次の簡単なポリシーが使用できます。
  </p><p>   If no role is specified, or the special user name
   <code class="literal">PUBLIC</code> is used, then the policy applies to all
   users on the system.  To allow all users to access only their own row in
   a <code class="literal">users</code> table, a simple policy can be used:
  </p><pre class="programlisting">CREATE POLICY user_policy ON users
    USING (user_name = current_user);</pre><p>   This works similarly to the previous example.
  </p><p>テーブルに追加される行に対し、可視である行とは異なるポリシーを使用する場合は、<code class="literal">WITH CHECK</code>句を使うことができます。
次のポリシーでは、すべてのユーザが<code class="literal">users</code>テーブルのすべての行を見ることができますが、自分自身の行だけしか更新できません。
  </p><pre class="programlisting">CREATE POLICY user_sel_policy ON users
    FOR SELECT
    USING (true);
CREATE POLICY user_mod_policy ON users
    USING (user_name = current_user);</pre><p>   In a <code class="command">SELECT</code> command, these two policies are combined
   using <code class="literal">OR</code>, with the net effect being that all rows
   can be selected.  In other command types, only the second policy applies,
   so that the effects are the same as before.
  </p><p>行セキュリティは<code class="command">ALTER TABLE</code>で無効にすることもできます。
行セキュリティを無効にしても、テーブルに定義されているポリシーは削除されず、単に無視されるだけになります。
このときは標準的なSQLの権限システムに従って、すべての行が可視で更新可能になります。
  </p><p>以下のより大きな例で、この機能が実運用の環境で如何にして使えるかを示します。
<code class="literal">passwd</code>テーブルはUnixのパスワードファイルと同等のものです。
  </p><pre class="programlisting">-- passwdファイルに基づく簡単な例
CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  extra_info            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);

CREATE ROLE admin;  -- 管理者
CREATE ROLE bob;    -- 一般ユーザ
CREATE ROLE alice;  -- 一般ユーザ


-- テーブルに値を入れる
INSERT INTO passwd VALUES
  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');
INSERT INTO passwd VALUES
  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');
INSERT INTO passwd VALUES
  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');

-- テーブルの行単位セキュリティを有効にする
ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;

-- ポリシーを作成する
-- 管理者はすべての行を見ることができ、どんな行でも追加できる
CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);
-- 一般ユーザはすべての行を見ることができる
CREATE POLICY all_view ON passwd FOR SELECT USING (true);
-- 一般ユーザは自身のレコードを更新できるが、
-- 変更できるのは使用するシェルだけに制限する
CREATE POLICY user_mod ON passwd FOR UPDATE
  USING (current_user = user_name)
  WITH CHECK (
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  );

-- adminにはすべての通常の権限を付与する
GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;
-- 一般ユーザは公開列にSELECTでアクセスできるだけとする
GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)
  ON passwd TO public;
-- 特定の列についてはユーザによる更新を許可する
GRANT UPDATE
  (pwhash, real_name, home_phone, extra_info, shell)
  ON passwd TO public;</pre><p>どんなセキュリティ設定でも同じですが、システムが期待通りに動作していることをテストして確認することが重要です。
上の例を利用して、以下ではパーミッションのシステムが適切に動作していることを示します。
  </p><pre class="programlisting">-- adminはすべての行と列を見ることができる
postgres=&gt; set role admin;
SET
postgres=&gt; table passwd;
 user_name | pwhash | uid | gid | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+--------+-----+-----+-----------+--------------+------------+-------------+-----------
 admin     | xxx    |   0 |   0 | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | xxx    |   1 |   1 | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | xxx    |   2 |   1 | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

-- Test what Alice is able to do
postgres=&gt; set role alice;
SET
postgres=&gt; table passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; select user_name,real_name,home_phone,extra_info,home_dir,shell from passwd;
 user_name | real_name |  home_phone  | extra_info | home_dir    |   shell
-----------+-----------+--------------+------------+-------------+-----------
 admin     | Admin     | 111-222-3333 |            | /root       | /bin/dash
 bob       | Bob       | 123-456-7890 |            | /home/bob   | /bin/zsh
 alice     | Alice     | 098-765-4321 |            | /home/alice | /bin/zsh
(3 rows)

postgres=&gt; update passwd set user_name = 'joe';
ERROR:  permission denied for relation passwd
-- Aliceは自分のreal_nameを変更できるが、他は変更できない
postgres=&gt; update passwd set real_name = 'Alice Doe';
UPDATE 1
postgres=&gt; update passwd set real_name = 'John Doe' where user_name = 'admin';
UPDATE 0
postgres=&gt; update passwd set shell = '/bin/xx';
ERROR:  new row violates WITH CHECK OPTION for "passwd"
postgres=&gt; delete from passwd;
ERROR:  permission denied for relation passwd
postgres=&gt; insert into passwd (user_name) values ('xxx');
ERROR:  permission denied for relation passwd
-- Aliceは自分のパスワードを変更できる。
-- RLSにより他の行は更新されないが、何も報告されない。
postgres=&gt; update passwd set pwhash = 'abc';
UPDATE 1</pre><p>ここまでで作成したポリシーはすべて許容ポリシーで、つまり複数のポリシーが適用される場合、それらは論理演算子<span class="quote">“<span class="quote">OR</span>”</span>を使って結合されるものでした。
意図した場合にのみ行へのアクセスが許されるよう許容ポリシーを構築することは可能ですが、許容ポリシーを制限ポリシーと組み合わせることで、より単純にすることが可能です（制限ポリシーはレコードが満たさなければならないポリシーで、論理演算子<span class="quote">“<span class="quote">AND</span>”</span>を使って結合されます）。
上記の例に重ねて、管理者がローカルのUnixソケットを通して接続して<code class="literal">passwd</code>テーブルのレコードにアクセスすることを要求する制限ポリシーを追加してみます。
  </p><pre class="programlisting">CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin
    USING (pg_catalog.inet_client_addr() IS NULL);</pre><p>こうすると以下のように、制限ポリシーにより、ネットワーク経由で接続している管理者にはレコードが見えないことがわかります。
  </p><pre class="programlisting">=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; select inet_client_addr();
 inet_client_addr 
------------------
 127.0.0.1
(1 row)

=&gt; SELECT current_user;
 current_user 
--------------
 admin
(1 row)

=&gt; TABLE passwd;
 user_name | pwhash | uid | gid | real_name | home_phone | extra_info | home_dir | shell
-----------+--------+-----+-----+-----------+------------+------------+----------+-------
(0 rows)

=&gt; UPDATE passwd set pwhash = NULL;
UPDATE 0</pre><p>一意性制約、主キー制約、外部キー制約などの参照整合性確認は、データの整合性を維持するため、常に行セキュリティを無視します。
スキーマと行単位セキュリティの開発において、このような参照整合性確認により<span class="quote">“<span class="quote">カバートチャネル(covert channel)</span>”</span>の情報漏洩が起こらないようにするため、注意が必要です。
  </p><p>状況によっては、行セキュリティが適用されないことを確実にするのが重要になります。
例えばバックアップを取るとき、行セキュリティのために、何のエラーや警告もなしに一部の行がバックアップされないとすると、破滅的です。
このような状況では、設定パラメータ<a class="xref" href="runtime-config-client.html#GUC-ROW-SECURITY">row_security</a>を<code class="literal">off</code>にすることができます。
これ自体は行セキュリティを無視するわけではなく、問い合わせの結果がポリシーによって影響を受ける場合にエラーを発生させます。
その後でエラーの原因を調査して解決することができます。
  </p><p>上の例では、ポリシーの式はアクセス対象または更新対象の行の現在の値のみを考慮していました。
これは最も単純で、しかも効率の良い場合です。
可能であれば、行セキュリティの適用はこのように動作するよう設計するのが最善です。
ポリシーの決定をするために他の行あるいは他のテーブルを参照する必要がある場合は、ポリシーの式で副<code class="command">SELECT</code>を使う、あるいは<code class="command">SELECT</code>を含む関数を使うことができます。
ただし、そのようなアクセスは注意深く設計しなければ、情報漏洩を起こすような競合条件を作り出す場合があることに注意して下さい。
例えば、以下のテーブル設計を考えます。
  </p><pre class="programlisting">-- 権限グループの定義
CREATE TABLE groups (group_id int PRIMARY KEY,
                     group_name text NOT NULL);

INSERT INTO groups VALUES
  (1, 'low'),
  (2, 'medium'),
  (5, 'high');

GRANT ALL ON groups TO alice;  -- aliceが管理者
GRANT SELECT ON groups TO public;

-- ユーザの権限レベルの定義
CREATE TABLE users (user_name text PRIMARY KEY,
                    group_id int NOT NULL REFERENCES groups);

INSERT INTO users VALUES
  ('alice', 5),
  ('bob', 2),
  ('mallory', 2);

GRANT ALL ON users TO alice;
GRANT SELECT ON users TO public;

-- 保護される情報を保持するテーブル
CREATE TABLE information (info text,
                          group_id int NOT NULL REFERENCES groups);

INSERT INTO information VALUES
  ('barely secret', 1),
  ('slightly secret', 2),
  ('very secret', 5);

ALTER TABLE information ENABLE ROW LEVEL SECURITY;

-- セキュリティのgroup_idが行のgroup_idより大きいか等しいユーザは
-- その行を見ること、更新することが可能
CREATE POLICY fp_s ON information FOR SELECT
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));
CREATE POLICY fp_u ON information FOR UPDATE
  USING (group_id &lt;= (SELECT group_id FROM users WHERE user_name = current_user));

-- informationテーブルを保護するのにRLSのみに依存する
GRANT ALL ON information TO public;</pre><p>ここで<code class="literal">alice</code>が<span class="quote">“<span class="quote">slightly secret</span>”</span>の情報を更新したいが、この行の新しい内容に関して<code class="literal">mallory</code>は信頼すべきでないと判断しました。
そこで、彼女は次のようにします。
  </p><pre class="programlisting">BEGIN;
UPDATE users SET group_id = 1 WHERE user_name = 'mallory';
UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;
COMMIT;</pre><p>これは安全なように見えます。
<code class="literal">mallory</code>が<span class="quote">“<span class="quote">secret from mallory</span>”</span>の文字列を見ることができる隙はありません。
しかし、ここには競合条件があります。
例えば、<code class="literal">mallory</code>が同時に以下を実行していたとしましょう。
</p><pre class="programlisting">SELECT * FROM information WHERE group_id = 2 FOR UPDATE;</pre><p>
ここで彼女のトランザクションが<code class="literal">READ COMMITTED</code>モードなら、彼女は<span class="quote">“<span class="quote">secret from mallory</span>”</span>を見ることが可能です。
それは彼女のトランザクションが、<code class="literal">alice</code>のトランザクションの直後に<code class="structname">information</code>の行にアクセスした場合に発生します。
それは<code class="literal">alice</code>のトランザクションがコミットされるのを待ってブロックされ、次に<code class="literal">FOR UPDATE</code>句があるため、更新後の行の内容をフェッチします。
しかし、<code class="structname">users</code>からの暗示的な<code class="command">SELECT</code>では更新後の行をフェッチ<span class="emphasis"><em>しません</em></span>。
なぜなら、その副<code class="command">SELECT</code>には<code class="literal">FOR UPDATE</code>がないため、<code class="structname">users</code>の行は問い合わせの開始時に取得したスナップショットから読まれるからです。
そのため、ポリシーの式は<code class="literal">mallory</code>の権限レベルの古い値について検査し、更新後の行を見ることを許してしまいます。
  </p><p>この問題を回避する方法はいくつかあります。
一つの簡単な答は行セキュリティポリシーの副<code class="command">SELECT</code>で<code class="literal">SELECT ... FOR SHARE</code>を使うことです。
しかし、これは影響を受けるユーザに対し、参照先テーブル（この場合は<code class="structname">users</code>）の<code class="literal">UPDATE</code>権限を付与する必要があり、望ましくないかもしれません。
（しかし、もう一つの行セキュリティポリシーを適用して、彼らが実際にその権限を行使することを防ぐことはできます。
また、副<code class="command">SELECT</code>をセキュリティ定義関数内に埋め込むことも可能です。）
また、参照先テーブルに行共有ロックが同時に大量に発生するとパフォーマンス問題が起きるかもしれません。
特にそのテーブルの更新が多いときは問題になるでしょう。
別の解決策で、参照先テーブルの更新が少ない場合に現実的なのは、参照先テーブルの更新時に排他ロックを取得するものです。
そうすれば、同時実行のトランザクションが行の古い値を調べることはできません。
あるいは、参照先のテーブルの更新をコミットした後、単にすべての同時実行トランザクションが終わるのを待ってから、新しいセキュリティ状況に依存する変更をする、ということもできます。
  </p><p>更なる詳細は<a class="xref" href="sql-createpolicy.html" title="CREATE POLICY"><span class="refentrytitle">CREATE POLICY</span></a>と<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>を参照して下さい。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-priv.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-schemas.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.6. 権限 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.8. スキーマ</td></tr></table></div></body></html>