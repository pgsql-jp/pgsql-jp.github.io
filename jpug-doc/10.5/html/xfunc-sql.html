<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.4. 問い合わせ言語（SQL）関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xfunc.html" title="37.3. ユーザ定義関数" /><link rel="next" href="xfunc-overload.html" title="37.5. 関数のオーバーロード" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.4. 問い合わせ言語（<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>）関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xfunc.html" title="37.3. ユーザ定義関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc-overload.html" title="37.5. 関数のオーバーロード">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="XFUNC-SQL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.4. 問い合わせ言語（<acronym class="acronym">SQL</acronym>）関数</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTION-ARGUMENTS">37.4.1. <acronym class="acronym">SQL</acronym>関数用の引数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-BASE-FUNCTIONS">37.4.2. 基本型を使用する<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-COMPOSITE-FUNCTIONS">37.4.3. 複合型を使用する<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-OUTPUT-PARAMETERS">37.4.4. 出力パラメータを持つ<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS">37.4.5. 可変長引数を取る<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-PARAMETER-DEFAULTS">37.4.6. 引数にデフォルト値を持つ<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS">37.4.7. テーブルソースとしての<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-SET">37.4.8. 集合を返す<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#XFUNC-SQL-FUNCTIONS-RETURNING-TABLE">37.4.9. <code class="literal">TABLE</code>を返す<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#id-1.8.3.7.18">37.4.10. 多様<acronym class="acronym">SQL</acronym>関数</a></span></dt><dt><span class="sect2"><a href="xfunc-sql.html#id-1.8.3.7.19">37.4.11. 照合順序を持つ<acronym class="acronym">SQL</acronym>関数</a></span></dt></dl></div><a id="id-1.8.3.7.2" class="indexterm"></a><p>SQL関数は、任意のSQL文のリストを実行し、そのリストの最後の問い合わせの結果を返します。
単純な（集合ではない）場合、最後の問い合わせの結果の最初の行が返されます。
（複数行の結果のうちの<span class="quote">“<span class="quote">最初の行</span>”</span>は、<code class="literal">ORDER BY</code>を使用しない限り定義付けることができないことを覚えておいてください。）
最後の問い合わせが何も行を返さない時はNULL値が返されます。
   </p><p>他にも、SQL関数は、<code class="literal">SETOF</code> <em class="replaceable"><code>sometype</code></em>型を返すように指定すること、または同意の<code class="literal">RETURNS TABLE(<em class="replaceable"><code>columns</code></em>)</code>と宣言することにより、集合（つまり複数の行）を返すように宣言することもできます。
この場合、最後の問い合わせの結果のすべての行が返されます。
詳細は後で説明します。
   </p><p>SQL関数の本体は、セミコロンで区切ったSQL文のリストでなければなりません。
最後の文の後のセミコロンは省略可能です。
関数が<code class="type">void</code>を返すものと宣言されていない限り、最後の文は<code class="command">SELECT</code>、または<code class="literal">RETURNING</code>句を持つ<code class="command">INSERT</code>、<code class="command">UPDATE</code>、または<code class="command">DELETE</code>でなければなりません。
   </p><p><acronym class="acronym">SQL</acronym>言語で作成された、任意のコマンド群はまとめて、関数として定義することができます。
<code class="command">SELECT</code>問い合わせ以外に、データ変更用の問い合わせ（つまり、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>）やその他のSQLコマンドを含めることができます。
（<acronym class="acronym">SQL</acronym>関数では<code class="command">COMMIT</code>、<code class="command">SAVEPOINT</code>などのトランザクション制御コマンドおよび<code class="literal">VACUUM</code>などのユーティリティコマンドは使用することはできません。）
しかし、最後のコマンドは、関数の戻り値型として定義したものを返す<code class="command">SELECT</code>、または<code class="literal">RETURNING</code>句があるものでなければなりません。
その他にも、何か動作をさせるが、有用な値を返さないSQL関数を定義したいのであれば、<code class="type">void</code>を返すものと定義することで実現可能です。
たとえば、以下の関数は<code class="literal">emp</code>テーブルから負の給料となっている行を削除します。

</p><pre class="screen">CREATE FUNCTION clean_emp() RETURNS void AS '
    DELETE FROM emp
        WHERE salary &lt; 0;
' LANGUAGE SQL;

SELECT clean_emp();

 clean_emp
-----------

(1 row)</pre><p>
    </p><div class="note"><h3 class="title">Note</h3><p>SQL関数の本体全体は、その一部が実行される前に解析されます。
SQL関数はシステムカタログを変更するコマンド(例えば<code class="command">CREATE TABLE</code>)を含むことができますので、そのようなコマンドの効果は関数の以降のコマンドの解析中は可視ではありません。
それゆえ、例えば、<code class="literal">CREATE TABLE foo (...); INSERT INTO foo VALUES(...);</code>は単一のSQL関数にまとめられていると期待したようには動作しません。<code class="command">INSERT</code>コマンドが解析されている時には<code class="structname">foo</code>がまだ存在しないからです。
このような場合にはSQL関数の代わりに<span class="application">PL/pgSQL</span>を使うことを薦めます。
     </p></div><p><code class="command">CREATE FUNCTION</code>コマンドの構文では、関数本体は文字列定数として作成される必要があります。
この文字列定数の記述には、通常、ドル引用符付け（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. ドル記号で引用符付けされた文字列定数">Section 4.1.2.4</a>）が最も便利です。
文字列定数を単一引用符で括る通常の構文では、関数本体中で使用される単一引用符（<code class="literal">'</code>）とバックスラッシュ（<code class="literal">\</code>）（エスケープ文字列構文を仮定）を二重にしなければなりません（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">Section 4.1.2.1</a>を参照）。
   </p><div class="sect2" id="XFUNC-SQL-FUNCTION-ARGUMENTS"><div class="titlepage"><div><div><h3 class="title">37.4.1. <acronym class="acronym">SQL</acronym>関数用の引数</h3></div></div></div><a id="id-1.8.3.7.9.2" class="indexterm"></a><p>SQL関数の引数は関数本体内で名前または番号を用いて参照することができます。
両方の方法の例を後で示します。
    </p><p>名前を使用するためには、関数引数を名前を持つものとして宣言し、その名前を関数本体内で記述するだけです。
引数名が関数内の現在のSQLコマンドにおける任意の列名と同じ場合は、列名が優先されます。
これを上書きするためには、<code class="literal"><em class="replaceable"><code>function_name</code></em>.<em class="replaceable"><code>argument_name</code></em></code>のように、引数名を関数自身の名前を付けて修飾してください。
(もしこれも修飾された列名と競合する場合は、列名が優先されます。
SQLコマンド内でテーブルに他の別名を付けることで、この曖昧さを防止することができます。)
    </p><p>古い番号による方法では、引数は関数本体内で<code class="literal">$<em class="replaceable"><code>n</code></em></code>という構文を用いて表すことができます。
つまり、$1は第1引数を示し、$2は第2引数のようになります。
これは特定の引数が名前付きで宣言されているかどうかに関係なく動作します。
    </p><p>引数が複合型の場合、<code class="literal"><em class="replaceable"><code>argname</code></em>.<em class="replaceable"><code>fieldname</code></em></code>や<code class="literal">$1.<em class="replaceable"><code>fieldname</code></em></code>のようなドット表記を用いて引数の属性にアクセスすることができます。
ここでも、引数名を持つ形式で曖昧さが発生する場合には関数名で引数名を修飾してください。
    </p><p>SQL関数の引数は、識別子としてではなく、データ値としてのみ使用することができます。
したがって、例えば
</p><pre class="programlisting">INSERT INTO mytable VALUES ($1);</pre><p>
は正しいものですが、以下は動作しません。
</p><pre class="programlisting">INSERT INTO $1 VALUES (42);</pre><p>
    </p><div class="note"><h3 class="title">Note</h3><p>SQL関数の引数を参照するために名前を使用できる機能は、<span class="productname">PostgreSQL</span> 9.2で追加されました。
これより古いサーバ内で使われる関数は<code class="literal">$<em class="replaceable"><code>n</code></em></code>記法を使用しなければなりません。
     </p></div></div><div class="sect2" id="XFUNC-SQL-BASE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">37.4.2. 基本型を使用する<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><p>最も簡単な<acronym class="acronym">SQL</acronym>関数は、引数を取らずに単に<code class="type">integer</code>のような基本型を返すものです。

</p><pre class="screen">CREATE FUNCTION one() RETURNS integer AS $$
    SELECT 1 AS result;
$$ LANGUAGE SQL;

-- 文字列リテラルの別の構文では
CREATE FUNCTION one() RETURNS integer AS '
    SELECT 1 AS result;
' LANGUAGE SQL;

SELECT one();

 one
-----
   1</pre><p>
    </p><p>関数本体内で関数の結果用に列の別名を（<code class="literal">result</code>という名前で）定義したことに注目してください。
しかし、この列の別名はこの関数の外部からは可視ではありません。
したがって、その結果は<code class="literal">result</code>ではなく、<code class="literal">one</code>というラベルで表示されています。
    </p><p>基本型を引数として取る、<acronym class="acronym">SQL</acronym>関数を定義することはほとんどの場合簡単です。

</p><pre class="screen">CREATE FUNCTION add_em(x integer, y integer) RETURNS integer AS $$
    SELECT x + y;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3</pre><p>
    </p><p>この他に、引数に名前を付けることを省くことができます。この場合は番号を使用します。

</p><pre class="screen">CREATE FUNCTION add_em(integer, integer) RETURNS integer AS $$
    SELECT $1 + $2;
$$ LANGUAGE SQL;

SELECT add_em(1, 2) AS answer;

 answer
--------
      3</pre><p>
    </p><p>以下にもう少し役に立つ関数を示します。
これは銀行口座からの引き落としに使用できます。

</p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT 1;
$$ LANGUAGE SQL;</pre><p>

以下のように、ユーザはこの関数を使用して、口座番号17から100ドルを引き出すことが可能です。

</p><pre class="programlisting">SELECT tf1(17, 100.0);</pre><p>
    </p><p>この例では、第一引数の名前に<code class="literal">accountno</code>を選びましたが、これは<code class="literal">bank</code>テーブルの列の名前と同じです。
<code class="command">UPDATE</code>コマンドの中では、<code class="literal">accountno</code>は<code class="literal">bank.accountno</code>列を参照しますので、引数を参照するためには<code class="literal">tf1.accountno</code>を使用しなければなりません。
もちろんこれは、引数に別の名前を使用することで防ぐことができます。
    </p><p>実際には、関数の結果を定数1よりもわかりやすい形にするために、以下のように定義するとよいでしょう。

</p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno;
    SELECT balance FROM bank WHERE accountno = tf1.accountno;
$$ LANGUAGE SQL;</pre><p>

これは残高を調整し、更新後の残高を返します。
同じことは<code class="literal">RETURNING</code>を使用して１つのコマンドで行えます。

</p><pre class="programlisting">CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$
    UPDATE bank
        SET balance = balance - debit
        WHERE accountno = tf1.accountno
    RETURNING balance;
$$ LANGUAGE SQL;</pre><p>
    </p></div><div class="sect2" id="XFUNC-SQL-COMPOSITE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">37.4.3. 複合型を使用する<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><p>関数の引数に複合型を記述した場合、必要な引数を指定するだけではなく、必要とする引数の属性（フィールド）も指定する必要があります。
例えば、<code class="type">emp</code>が従業員データを持つテーブルとすると、この名前はそのテーブル内の各行を表す複合型の名前でもあります。
以下に示す<code class="function">double_salary</code>関数は、該当する従業員の給料が倍増したらどうなるかを計算します。

</p><pre class="screen">CREATE TABLE emp (
    name        text,
    salary      numeric,
    age         integer,
    cubicle     point
);

INSERT INTO emp VALUES ('Bill', 4200, 45, '(2,1)');

CREATE FUNCTION double_salary(emp) RETURNS numeric AS $$
    SELECT $1.salary * 2 AS salary;
$$ LANGUAGE SQL;

SELECT name, double_salary(emp.*) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';

 name | dream
------+-------
 Bill |  8400</pre><p>
    </p><p><code class="literal">$1.salary</code>という構文を使用して、引数の行値の1フィールドを選択していることに注目してください。
また、<em class="replaceable"><code>table_name</code></em><code class="literal">.*</code>を使用した<code class="command">SELECT</code>コマンドの呼び出しでは、複合型の値として、現在のテーブル行全体を表すテーブル名を使用していることにも注目してください。
別の方法として、テーブル行は以下のようにテーブル名だけを使用して参照することができます。
</p><pre class="screen">SELECT name, double_salary(emp) AS dream
    FROM emp
    WHERE emp.cubicle ~= point '(2,1)';</pre><p>
しかし、この使用方法は混乱しやすいためお勧めしません。
(テーブル行の複合型の値に対するこの二つの表記の詳細は<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>を参照してください)
    </p><p>その場で複合型の引数値を作成することが便利な場合があります。
これは<code class="literal">ROW</code>式で行うことができます。
例えば、以下のようにして関数に渡すデータを調整することができます。
</p><pre class="screen">SELECT name, double_salary(ROW(name, salary*1.1, age, cubicle)) AS dream
    FROM emp;</pre><p>
    </p><p>複合型を返す関数を作成することもできます。
以下に単一の<code class="type">emp</code>行を返す関数の例を示します。

</p><pre class="programlisting">CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT text 'None' AS name,
        1000.0 AS salary,
        25 AS age,
        point '(2,2)' AS cubicle;
$$ LANGUAGE SQL;</pre><p>

ここでは、各属性を定数で指定していますが、この定数を何らかの演算に置き換えることもできます。
    </p><p>関数を定義する上で、2つの重要な注意点を以下に示します。

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>問い合わせにおける選択リストの順番は、複合型と関連したテーブル内で現れる列の順番と正確に一致する必要があります。
（上で行ったように列に名前を付けても、システムは認識しません。）
       </p></li><li class="listitem"><p>複合型定義と一致するように式を型キャストしなければなりません。
さもなくば、以下のようなエラーとなります。
</p><pre class="screen"><code class="computeroutput">ERROR:  function declared to return emp returns varchar instead of text at column 1</code></pre><p>
       </p></li></ul></div><p>
    </p><p>同じ関数を以下のように定義することもできます。

</p><pre class="programlisting">CREATE FUNCTION new_emp() RETURNS emp AS $$
    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;
$$ LANGUAGE SQL;</pre><p>

ここで、正しい複合型の単一の列を単に返す<code class="command">SELECT</code>を記述しました。
今回の例ではこれはより優れたものとはいえませんが、例えば、必要な複合値を返す他の関数を呼び出して結果を計算しなければならない場合など、便利な解法になることがあります。
    </p><p>この関数を、評価式で使って直接呼び出せますし、

</p><pre class="screen">SELECT new_emp();

         new_emp
--------------------------
 (None,1000.0,25,"(2,2)")</pre><p>

テーブル関数として呼び出しても直接呼び出せます。

</p><pre class="screen">SELECT * FROM new_emp();

 name | salary | age | cubicle
------+--------+-----+---------
 None | 1000.0 |  25 | (2,2)</pre><p>

2番目の方法については、<a class="xref" href="xfunc-sql.html#XFUNC-SQL-TABLE-FUNCTIONS" title="37.4.7. テーブルソースとしてのSQL関数">Section 37.4.7</a>でより詳しく説明します。
    </p><p>複合型を返す関数を使用する時に、その結果から1つのフィールド（属性）のみを使用したいという場合があります。
これは、以下のような構文で行うことができます。

</p><pre class="screen">SELECT (new_emp()).name;

 name
------
 None</pre><p>

パーサが混乱しないように、括弧を追加する必要があります。
括弧なしで行おうとすると、以下のような結果になります。

</p><pre class="screen">SELECT new_emp().name;
ERROR:  syntax error at or near "."
LINE 1: SELECT new_emp().name;
                        ^</pre><p>
    </p><p>また、関数表記を使用して属性を抽出することもできます。

</p><pre class="screen">SELECT name(new_emp());

 name
------
 None</pre><p>

<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>で述べるように、フィールド表記と関数表記は等価です。
    </p><p>複合型を結果として返す関数を使用する他の方法は、その結果を、その行型を入力として受け付ける関数に渡す、以下のような方法です。

</p><pre class="screen">CREATE FUNCTION getname(emp) RETURNS text AS $$
    SELECT $1.name;
$$ LANGUAGE SQL;

SELECT getname(new_emp());
 getname
---------
 None
(1 row)</pre><p>
    </p></div><div class="sect2" id="XFUNC-OUTPUT-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">37.4.4. 出力パラメータを持つ<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.12.2" class="indexterm"></a><p>関数の結果の記述方法には、他にも<em class="firstterm">出力パラメータ</em>を使用して定義する方法があります。
以下に例を示します。

</p><pre class="screen">CREATE FUNCTION add_em (IN x int, IN y int, OUT sum int)
AS 'SELECT x + y'
LANGUAGE SQL;

SELECT add_em(3,7);
 add_em
--------
     10
(1 row)</pre><p>

<a class="xref" href="xfunc-sql.html#XFUNC-SQL-BASE-FUNCTIONS" title="37.4.2. 基本型を使用するSQL関数">Section 37.4.2</a>で示した<code class="literal">add_em</code>版と基本的な違いはありません。
複数列を返す関数を定義する簡単な方法を提供することが出力パラメータの本来の価値です。
以下に例を示します。

</p><pre class="screen">CREATE FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int)
AS 'SELECT x + y, x * y'
LANGUAGE SQL;

 SELECT * FROM sum_n_product(11,42);
 sum | product
-----+---------
  53 |     462
(1 row)</pre><p>

これは基本的に、関数結果用の無名の複合型の作成を行います。
上の例では、

</p><pre class="screen">CREATE TYPE sum_prod AS (sum int, product int);

CREATE FUNCTION sum_n_product (int, int) RETURNS sum_prod
AS 'SELECT $1 + $2, $1 * $2'
LANGUAGE SQL;</pre><p>
と同じ最終結果になります。

しかし、独立した複合型定義に悩まされることがなくなり、便利であるともいえます。
出力パラメータに割り振られた名前が単なる飾りではなく、無名複合型の列名を決定するものであることに注意してください。
（出力パラメータの名前を省略した場合、システム自身が名前を選びます。）
    </p><p>SQLからこうした関数を呼び出す時、出力パラメータが呼び出し側の引数リストに含まれないことに注意してください。
<span class="productname">PostgreSQL</span>では入力パラメータのみが関数の呼び出しシグネチャを定義するとみなしているためです。
これはまた、関数を削除することなどを目的に関数を参照する場合、入力パラメータのみが考慮されることを意味しています。
上の関数は、次のいずれかの方法で削除することができます。

</p><pre class="screen">DROP FUNCTION sum_n_product (x int, y int, OUT sum int, OUT product int);
DROP FUNCTION sum_n_product (int, int);</pre><p>
    </p><p>パラメータには、<code class="literal">IN</code>（デフォルト）、<code class="literal">OUT</code>、<code class="literal">INOUT</code>、または<code class="literal">VARIADIC</code>という印を付与できます。
<code class="literal">INOUT</code>パラメータは、入力パラメータ（呼び出し引数リストの一部）と出力パラメータ（結果のレコード型の一部）の両方を提供します。
<code class="literal">VARIADIC</code>パラメータは入力パラメータですが、次に説明するように特別に扱われます。
    </p></div><div class="sect2" id="XFUNC-SQL-VARIADIC-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">37.4.5. 可変長引数を取る<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.13.2" class="indexterm"></a><a id="id-1.8.3.7.13.3" class="indexterm"></a><p>すべての<span class="quote">“<span class="quote">オプションの</span>”</span>引数が同じデータ型の場合、<acronym class="acronym">SQL</acronym>関数は可変長の引数を受け付けるように宣言できます。
オプションの引数は配列として関数に渡されます。
この関数は最後のパラメータを<code class="literal">VARIADIC</code>と印を付けて宣言されます。
このパラメータは配列型であるとして宣言されなければなりません。
例をあげます。

</p><pre class="screen">CREATE FUNCTION mleast(VARIADIC arr numeric[]) RETURNS numeric AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT mleast(10, -1, 5, 4.4);
 mleast 
--------
     -1
(1 row)</pre><p>

実際、<code class="literal">VARIADIC</code>の位置以降の実引数はすべて、あたかも以下のように記述したかのように、1次元の配列としてまとめられます。

</p><pre class="screen">SELECT mleast(ARRAY[10, -1, 5, 4.4]);    -- 動作しません</pre><p>

しかし、実際にこのように記述することはできません。
少なくとも、この関数定義に一致しません。
<code class="literal">VARIADIC</code>印の付いたパラメータは、自身の型ではなく、その要素型が１つ以上存在することに一致します。
    </p><p>時として、variadic関数に既に構築された配列を渡せることは有用です。
１つのvariadic関数が、自身の配列パラメータを他のものに渡したいとき特に便利です。
呼び出しに<code class="literal">VARIADIC</code>を指定することで行えます。

</p><pre class="screen">SELECT mleast(VARIADIC ARRAY[10, -1, 5, 4.4]);</pre><p>

これは関数のvariadicパラメータがその要素型に拡張するのを防ぎます。
その結果、配列引数値が標準的にマッチされるようになります。
<code class="literal">VARIADIC</code>は関数呼び出しの最後の実引数としてのみ付加できます。
    </p><p>呼び出しで<code class="literal">VARIADIC</code>を指定することは、variadic関数に空の配列を渡す唯一の方法でもあります。例えば、

</p><pre class="screen">SELECT mleast(VARIADIC ARRAY[]::numeric[]);</pre><p>

variadicパラメータが少なくとも1つの実引数と一致しなければなりませんので、単に<code class="literal">SELECT mleast()</code>と書くだけでは上手くいきません。
(もしそのような呼び出しを許可したいのなら、<code class="literal">mleast</code>という名前のパラメータのない第2の関数を定義することもできます。)
    </p><p>variadicパラメータから生成される配列要素パラメータは、それ自身にはまったく名前を持たないものとして扱われます。
これは、名前付き引数（<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">Section 4.3</a>）を使用して可変長の関数を呼び出すことができないことを意味します。
ただし、<code class="literal">VARIADIC</code>を指定する場合は例外です。
たとえば、

</p><pre class="screen">SELECT mleast(VARIADIC arr =&gt; ARRAY[10, -1, 5, 4.4]);</pre><p>

は動作しますが、

</p><pre class="screen">SELECT mleast(arr =&gt; 10);
SELECT mleast(arr =&gt; ARRAY[10, -1, 5, 4.4]);</pre><p>
は動作しません。
    </p></div><div class="sect2" id="XFUNC-SQL-PARAMETER-DEFAULTS"><div class="titlepage"><div><div><h3 class="title">37.4.6. 引数にデフォルト値を持つ<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.14.2" class="indexterm"></a><p>一部またはすべての入力引数にデフォルト値を持つ関数を宣言することができます。
デフォルト値は、関数が実際の引数の数に足りない数の引数で呼び出された場合に挿入されます。
引数は実引数リストの終端から省略することができますので、デフォルト値を持つパラメータの後にあるパラメータはすべて、同様にデフォルト値を持たなければなりません。
（名前付きの引数記法を使用してこの制限を緩和させることもできますが、まだ位置引数記法が実用的に動作できることが強制されています。）
    </p><p>以下に例を示します。
</p><pre class="screen">CREATE FUNCTION foo(a int, b int DEFAULT 2, c int DEFAULT 3)
RETURNS int
LANGUAGE SQL
AS $$
    SELECT $1 + $2 + $3;
$$;

SELECT foo(10, 20, 30);
 foo 
-----
  60
(1 row)

SELECT foo(10, 20);
 foo 
-----
  33
(1 row)

SELECT foo(10);
 foo 
-----
  15
(1 row)

SELECT foo();  -- 最初の引数にデフォルトがないため失敗
ERROR:  function foo() does not exist</pre><p>
<code class="literal">=</code>記号を<code class="literal">DEFAULT</code>キーワードの代わりに使用することもできます。
    </p></div><div class="sect2" id="XFUNC-SQL-TABLE-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">37.4.7. テーブルソースとしての<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><p>すべてのSQL関数は問い合わせの<code class="command">FROM</code>句で使用できますが、複合型を返す関数に特に便利です。
関数が基本型を返すよう定義されている場合、テーブル関数は1列からなるテーブルを作成します。
関数が複合型を返すよう定義されている場合、テーブル関数は複合型の列のそれぞれに対して1つの列を作成します。
    </p><p>以下に例を示します。

</p><pre class="screen">CREATE TABLE foo (fooid int, foosubid int, fooname text);
INSERT INTO foo VALUES (1, 1, 'Joe');
INSERT INTO foo VALUES (1, 2, 'Ed');
INSERT INTO foo VALUES (2, 1, 'Mary');

CREATE FUNCTION getfoo(int) RETURNS foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT *, upper(fooname) FROM getfoo(1) AS t1;

 fooid | foosubid | fooname | upper
-------+----------+---------+-------
     1 |        1 | Joe     | JOE
(1 row)</pre><p>

例からわかる通り、関数の結果の列を通常のテーブルの列と同じように扱うことができます。
    </p><p>この関数の結果得られたのは1行のみであることに注意してください。
これは<code class="literal">SETOF</code>を指定しなかったためです。
これについては次節で説明します。
    </p></div><div class="sect2" id="XFUNC-SQL-FUNCTIONS-RETURNING-SET"><div class="titlepage"><div><div><h3 class="title">37.4.8. 集合を返す<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.16.2" class="indexterm"></a><p>SQL関数が<code class="literal">SETOF</code> <em class="replaceable"><code>sometype</code></em>を返すよう宣言されている場合、関数の最後の問い合わせは最後まで実行され、各出力行は結果集合の要素として返されます。
    </p><p>この機能は通常、関数を<code class="literal">FROM</code>句内で呼び出す時に使用されます。
この場合、関数によって返される各行は、問い合わせによって見えるテーブルの行になります。
例えば、テーブル<code class="literal">foo</code>の内容が上記と同じであれば以下のようになります。

</p><pre class="programlisting">CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;</pre><p>

この出力は以下の通りです。

</p><pre class="screen"> fooid | foosubid | fooname
-------+----------+---------
     1 |        1 | Joe
     1 |        2 | Ed
(2 rows)</pre><p>
    </p><p>また、以下のように出力パラメータで定義された列を持つ複数の行を返すことも可能です。

</p><pre class="programlisting">CREATE TABLE tab (y int, z int);
INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);

CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)
RETURNS SETOF record
AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;

SELECT * FROM sum_n_product_with_tab(10);
 sum | product
-----+---------
  11 |      10
  13 |      30
  15 |      50
  17 |      70
(4 rows)</pre><p>

ここで重要な点は、関数が1行だけではなく複数行を返すことを示すために<code class="literal">RETURNS SETOF record</code>を記述しなければならない点です。
出力パラメータが１つしか存在しない場合は、<code class="type">record</code>ではなく、そのパラメータの型を記述してください。
    </p><p>集合を返す関数を、それぞれの呼び出し時に連続するテーブル行または副問い合わせに由来するパラメータを付けて、複数回呼び出すことで問い合わせ結果を構築することはしばしば有用です。
お勧めする方法は、<a class="xref" href="queries-table-expressions.html#QUERIES-LATERAL" title="7.2.1.5. LATERAL 副問い合わせ">Section 7.2.1.5</a>で説明する<code class="literal">LATERAL</code>キーワードを使用することです。
以下は集合を返す関数を使用して、ツリー構造の要素を模擬する例です。

</p><pre class="screen">SELECT * FROM nodes;
   name    | parent
-----------+--------
 Top       |
 Child1    | Top
 Child2    | Top
 Child3    | Top
 SubChild1 | Child1
 SubChild2 | Child1
(6 rows)

CREATE FUNCTION listchildren(text) RETURNS SETOF text AS $$
    SELECT name FROM nodes WHERE parent = $1
$$ LANGUAGE SQL STABLE;

SELECT * FROM listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, child FROM nodes, LATERAL listchildren(name) AS child;
  name  |   child
--------+-----------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)</pre><p>

この例は単純な結合でできない何かを行うものではありません。
しかしより複雑な計算では、何らかの作業を関数内に押し込むオプションはかなり便利です。
    </p><p>集合を返す関数は問い合わせの選択リスト内でも呼び出すことができます。
問い合わせ自身によって生成する各行に対し、集合を返す関数が呼び出され、関数の結果集合の各要素に対して出力行が生成されます。
上の例は以下のような問い合わせでも実現することができます。

</p><pre class="screen">SELECT listchildren('Top');
 listchildren
--------------
 Child1
 Child2
 Child3
(3 rows)

SELECT name, listchildren(name) FROM nodes;
  name  | listchildren
--------+--------------
 Top    | Child1
 Top    | Child2
 Top    | Child3
 Child1 | SubChild1
 Child1 | SubChild2
(5 rows)</pre><p>

最後の<code class="command">SELECT</code>において、<code class="literal">Child2</code>と<code class="literal">Child3</code>などが出力行に表示されていないことに注意してください。
これは、<code class="function">listchildren</code>がこの入力に対して空の集合を返すため出力行が生成されないからです。
<code class="literal">LATERAL</code>構文を使用した時の関数の結果との内部結合から得る場合と同じ動作です。
    </p><p>選択リストにある集合を返す関数に対する<span class="productname">PostgreSQL</span>の振舞いは、集合を返す関数が<code class="literal">LATERAL FROM</code>句に書かれている場合とほとんど同じです。
例えば
</p><pre class="programlisting">SELECT x, generate_series(1,5) AS g FROM tab;</pre><p>
は
</p><pre class="programlisting">SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;</pre><p>
とほぼ同じです。
この特定の例では、<code class="structname">g</code>は実際には<code class="structname">tab</code>にLATERALには依存しませんので、プランナがネステッドループ結合の外に<code class="structname">g</code>を置くことを選ぶかもしれないという点を除いて、全く同じです。
そのため、出力行の順番が異なる結果になるかもしれません。
選択リスト内の集合を返す関数は、<code class="literal">FROM</code>句からの次の行が考慮される前に関数の実行が完了するよう、<code class="literal">FROM</code>句の残りとのネステッドループ結合の中にあるかのように必ず評価されます。
    </p><p>問い合わせの選択リスト内に集合を返す関数が2つ以上ある場合には、振舞いは一つの<code class="literal">LATERAL ROWS FROM( ... )</code> <code class="literal">FROM</code>句に関数を置いた場合に得られるものと似ています。
元となる問い合わせからの各行に対して、各関数からの最初の結果を使った出力行、2番目の結果を使った出力行、と続きます。
集合を返す関数の中に他のものより出力の数が少ないものがある場合には、欠けたデータの代わりにNULL値が使われますので、1つの元となる行から作られる行の合計の数は、一番多くの出力を出力する集合を返す関数に対するのと同じだけになります。
そのため、集合を返す関数はすべてが尽きるまで<span class="quote">“<span class="quote">歩調を合わせて</span>”</span>実行され、それから次の元となる行へと実行が続きます。
    </p><p>集合を返す関数は、<code class="literal">FROM</code>句内では許されていませんが、選択リスト内では入れ子にできます。
その場合、入れ子の各階層は、別々の<code class="literal">LATERAL ROWS FROM( ... )</code>であるかのように別々に扱われます。
例えば、
</p><pre class="programlisting">SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;</pre><p>
では、集合を返す関数<code class="function">srf2</code>、<code class="function">srf3</code>、<code class="function">srf5</code>は<code class="structname">tab</code>の各行に対して歩調を合わせて実行され、次に階層の低い関数が生成した各行に対して<code class="function">srf1</code>と<code class="function">srf4</code>が歩調を合わせて適用されます。
    </p><p>集合を返す関数は<code class="literal">CASE</code>や<code class="literal">COALESCE</code>のような条件を評価する構成の中では使えません。
例えば、
</p><pre class="programlisting">SELECT x, CASE WHEN x &gt; 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;</pre><p>
を考えてください。
これは、<code class="literal">x &gt; 0</code>である入力行の5回の繰り返しとそうでないものの1回の繰り返しを生成するように思えるかもしれません。しかし、実際には、<code class="function">generate_series(1, 5)</code>は<code class="literal">CASE</code>が評価される前に暗黙の<code class="literal">LATERAL FROM</code>の中で実行されますので、各入力行に対して5回の繰り返しを生成します。
混乱を減らすため、そのような場合にはその代わりに解析時エラーになります。
    </p><div class="note"><h3 class="title">Note</h3><p>もし関数の最後のコマンドが<code class="literal">RETURNING</code>を持つ<code class="command">INSERT</code>、<code class="command">UPDATE</code>、または<code class="command">DELETE</code>である場合、関数が<code class="literal">SETOF</code>付きで宣言されていない、または呼び出す問い合わせがすべての結果行を取り出さなくても、そのコマンドは完了まで実行されます。
<code class="literal">RETURNING</code>句で生成される余計な行はすべて警告無しに削除されますが、コマンド対象のテーブルの変更はそれでも起こります（そして、関数から戻る前にすべて完了します）。
     </p></div><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span> 10より前では、集合を返す関数を2つ以上同じ選択リストに置くと常に等しい数の行を生成しない限りあまり賢くは振舞いませんでした。
そうでなければ、得られるのは、集合を返す関数が生成する行の数の最小公倍数に等しい数の出力行でした。
また、入れ子の集合を返す関数は上に書いたようには動作しませんでした。代わりに、集合を返す関数は多くても1つの集合を返す引数を持ち、集合を返す関数の各入れ子は独立に実行されました。
また、条件実行(<code class="literal">CASE</code>等の内側にある集合を返す関数)は以前は認められており、事態をより複雑にしていました。
<span class="productname">PostgreSQL</span>の古いバージョンで動作することが必要な問い合わせを書く場合には、バージョンが異なっても一貫した結果を返しますので、<code class="literal">LATERAL</code>構文を使うことを勧めます。
集合を返す関数の条件実行に頼った問い合わせがあるのなら、条件確認を独自の集合を返す関数の中に移動することで修正できます。
例えば
</p><pre class="programlisting">SELECT x, CASE WHEN y &gt; 0 THEN generate_series(1, z) ELSE 5 END FROM tab;</pre><p>
は
</p><pre class="programlisting">CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)
  RETURNS SETOF int AS $$
BEGIN
  IF cond THEN
    RETURN QUERY SELECT generate_series(start, fin);
  ELSE
    RETURN QUERY SELECT els;
  END IF;
END$$ LANGUAGE plpgsql;

SELECT x, case_generate_series(y &gt; 0, 1, z, 5) FROM tab;</pre><p>
になります。
この定式化は<span class="productname">PostgreSQL</span>のバージョンすべてで同じように動作します。
     </p></div></div><div class="sect2" id="XFUNC-SQL-FUNCTIONS-RETURNING-TABLE"><div class="titlepage"><div><div><h3 class="title">37.4.9. <code class="literal">TABLE</code>を返す<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.17.2" class="indexterm"></a><p>集合を返すものとして関数を宣言するには、他にも方法があります。
<code class="literal">RETURNS TABLE(<em class="replaceable"><code>columns</code></em>)</code>構文を使用することです。
これは１つ以上の<code class="literal">OUT</code>パラメータを使い、さらに、関数を<code class="literal">SETOF record</code>（または、適切ならば単一の出力パラメータの型の<code class="literal">SETOF</code>）を返すものと印を付けることと等価です。
この記法は標準SQLの最近の版で規定されたものですので、<code class="literal">SETOF</code>を使用するより移植性がより高いかもしれません。
    </p><p>例えば前述の合計と積の例はこのように書けます。

</p><pre class="programlisting">CREATE FUNCTION sum_n_product_with_tab (x int)
RETURNS TABLE(sum int, product int) AS $$
    SELECT $1 + tab.y, $1 * tab.y FROM tab;
$$ LANGUAGE SQL;</pre><p>

<code class="literal">RETURNS TABLE</code>記法と一緒に、明示的<code class="literal">OUT</code>または<code class="literal">INOUT</code>パラメータを使用することはできません。
すべての出力列を<code class="literal">TABLE</code>リストに含めなければなりません。
    </p></div><div class="sect2" id="id-1.8.3.7.18"><div class="titlepage"><div><div><h3 class="title">37.4.10. 多様<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><p><acronym class="acronym">SQL</acronym>関数は、多様型<code class="type">anyelement</code>、<code class="type">anyarray</code>、<code class="type">anynonarray</code>、<code class="type">anyenum</code>および<code class="type">anyrange</code>を受け付け、返すように宣言することができます。
多様関数の詳細説明については<a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="37.2.5. 多様型">Section 37.2.5</a>を参照してください。
以下の<code class="function">make_array</code>多様関数は、任意の2つのデータ型要素から配列を作成します。
</p><pre class="screen">CREATE FUNCTION make_array(anyelement, anyelement) RETURNS anyarray AS $$
    SELECT ARRAY[$1, $2];
$$ LANGUAGE SQL;

SELECT make_array(1, 2) AS intarray, make_array('a'::text, 'b') AS textarray;
 intarray | textarray
----------+-----------
 {1,2}    | {a,b}
(1 row)</pre><p>
    </p><p><code class="literal">'a'::text</code>という型キャストを使用して、引数が<code class="type">text</code>型であることを指定していることに注目してください。
これは引数が単なる文字列リテラルである場合に必要です。
さもないと、<code class="type">unknown</code>型として扱われてしまうため、無効な<code class="type">unknown</code>の配列を返そうとしてしまいます。
型キャストがないと、以下のようなエラーが発生します。
</p><pre class="screen"><code class="computeroutput">ERROR:  could not determine polymorphic type because input has type "unknown"</code></pre><p>
    </p><p>固定の戻り値型を持ちながら多様引数を持つことは許されますが、逆は許されません。
以下に例を示します。
</p><pre class="screen">CREATE FUNCTION is_greater(anyelement, anyelement) RETURNS boolean AS $$
    SELECT $1 &gt; $2;
$$ LANGUAGE SQL;

SELECT is_greater(1, 2);
 is_greater
------------
 f
(1 row)

CREATE FUNCTION invalid_func() RETURNS anyelement AS $$
    SELECT 1;
$$ LANGUAGE SQL;
ERROR:  cannot determine result data type
DETAIL:  A function returning a polymorphic type must have at least one polymorphic argument.</pre><p>
    </p><p>出力引数を持つ関数でも多様性を使用することができます。
以下に例を示します。
</p><pre class="screen">CREATE FUNCTION dup (f1 anyelement, OUT f2 anyelement, OUT f3 anyarray)
AS 'select $1, array[$1,$1]' LANGUAGE SQL;

SELECT * FROM dup(22);
 f2 |   f3
----+---------
 22 | {22,22}
(1 row)</pre><p>
    </p><p>多様性はvariadic関数とともに使用できます。例をあげます。

</p><pre class="screen">CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i]) FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;

SELECT anyleast(10, -1, 5, 4);
 anyleast 
----------
       -1
(1 row)

SELECT anyleast('abc'::text, 'def');
 anyleast 
----------
 abc
(1 row)

CREATE FUNCTION concat_values(text, VARIADIC anyarray) RETURNS text AS $$
    SELECT array_to_string($2, $1);
$$ LANGUAGE SQL;

SELECT concat_values('|', 1, 4, 2);
 concat_values 
---------------
 1|4|2
(1 row)</pre><p>
    </p></div><div class="sect2" id="id-1.8.3.7.19"><div class="titlepage"><div><div><h3 class="title">37.4.11. 照合順序を持つ<acronym class="acronym">SQL</acronym>関数</h3></div></div></div><a id="id-1.8.3.7.19.2" class="indexterm"></a><p>SQL関数が照合順序の変更が可能なデータ型のパラメータを１つ以上持つ場合、それぞれの関数呼び出しに対して、実引数に割り当てられた照合順序に応じて、照合順序が識別されます。
照合順序の識別に成功した（つまり、暗黙的な照合順序がすべての引数で競合しない）場合、すべての照合順序の変更が可能なパラメータは暗黙的に照合順序を持つものとして扱われます。
これは関数内の照合順序に依存する操作の振舞いに影響します。
例えば、上記の<code class="function">anyleast</code>を使って考えます。
</p><pre class="programlisting">SELECT anyleast('abc'::text, 'ABC');</pre><p>
この結果はデータベースのデフォルト照合順序に依存します。
<code class="literal">C</code>ロケールでは<code class="literal">ABC</code>という結果になりますが、他の多くのロケールでは<code class="literal">abc</code>になります。
使用される照合順序を<code class="literal">COLLATE</code>句を付与することで強制することができます。
例を以下に示します。
</p><pre class="programlisting">SELECT anyleast('abc'::text, 'ABC' COLLATE "C");</pre><p>
この他、呼び出し元の照合順序とは関係なく特定の照合順序で動作する関数にしたければ、関数定義において必要な所に<code class="literal">COLLATE</code>句を付けてください。
以下の<code class="function">anyleast</code>では、文字列を比較する際に常に<code class="literal">en_US</code>を使用します。
</p><pre class="programlisting">CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$
    SELECT min($1[i] COLLATE "en_US") FROM generate_subscripts($1, 1) g(i);
$$ LANGUAGE SQL;</pre><p>
しかし、もし照合順序の変更ができないデータ型が与えられた場合にエラーになってしまうことに注意してください。
    </p><p>実引数全体で共通の照合順序を識別できない場合、SQL関数はパラメータがそのデータ型のデフォルト照合順序（通常はデータベースのデフォルトの照合順序ですが、ドメイン型のパラメータでは異なる可能性があります）を持つものとみなします。
    </p><p>照合順序の変更ができるパラメータの動作は、テキストのデータ型にのみ適用できる、限定された多様性と考えることができます。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xfunc.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc-overload.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.3. ユーザ定義関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.5. 関数のオーバーロード</td></tr></table></div></body></html>