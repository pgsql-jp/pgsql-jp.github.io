<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.2. どのような時にパラレルクエリは使用できるのか？</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="how-parallel-query-works.html" title="15.1. パラレルクエリはどのように動くのか" /><link rel="next" href="parallel-plans.html" title="15.3. パラレルプラン" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.2. どのような時にパラレルクエリは使用できるのか？</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="how-parallel-query-works.html" title="15.1. パラレルクエリはどのように動くのか">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Chapter 15. パラレルクエリ">Up</a></td><th width="60%" align="center">Chapter 15. パラレルクエリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="parallel-plans.html" title="15.3. パラレルプラン">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="WHEN-CAN-PARALLEL-QUERY-BE-USED"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.2. どのような時にパラレルクエリは使用できるのか？</h2></div></div></div><p>どのような状況においても、プランナにパラレルクエリプランを生成させなくしてしまう設定があります。
とにかくパラレルクエリプランを生成させるためには、次に示すように設定しなければなりません。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>は0より大きい値に設定しなければなりません。
<code class="varname">max_parallel_workers_per_gather</code>で設定した数以上のワーカーは使用されないという一般原則に含まれる個別のケースです。
      </p></li><li class="listitem"><p><a class="xref" href="runtime-config-resource.html#GUC-DYNAMIC-SHARED-MEMORY-TYPE">dynamic_shared_memory_type</a>は<code class="literal">none</code>以外に設定しなければなりません。
パラレルクエリは、協調動作するプロセスの間でデータのやり取りを行うために、動的な共有メモリが必要です。
      </p></li></ul></div><p>加えて、システムはシングルユーザーモードで動いていてはいけません。
この場合はデータベースシステム全体が一つのプロセスで動いているので、バックグラウンドワーカーが使えません。
  </p><p>一般にパラレルクエリプランが生成可能な場合でも、以下のうち一つでも真であると、プランナはクエリに対するパラレルクエリプランを生成しません。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>クエリがデータを書き込むか、データベースの行をロックする場合。
クエリがデータ更新操作をトップレベルあるいはCTE内で含むと、そのクエリに対するパラレルプランは生成されません。
これは現在の実装の制限で、将来のリリースでは解除される可能性があります。
      </p></li><li class="listitem"><p>クエリが実行中に一時停止する場合。
クエリの一部あるいは増分の実行が発生するとシステムが判断すると、パラレルプランは生成されません。
たとえば、<a class="link" href="sql-declare.html" title="DECLARE">DECLARE CURSOR</a>で作られるカーソルは、決してパラレルプランを使用しません。
同様に、<code class="literal">FOR x IN query LOOP .. END LOOP</code>のPL/pgSQLループは、決してパラレルプランを使用しません。
パラレルクエリが実行中に、ループの中のコードを実行しても安全かどうか、パラレルクエリシステムが判断できないからです。
      </p></li><li class="listitem"><p>クエリが<code class="literal">PARALLEL UNSAFE</code>とマーク付されている関数を使っています。
ほとんどのシステム定義の関数は<code class="literal">PARALLEL SAFE</code>です。
しかし、ユーザ定義関数はデフォルトで<code class="literal">PARALLEL UNSAFE</code>とマーク付されます。
<a class="xref" href="parallel-safety.html" title="15.4. パラレル安全">Section 15.4</a>の議論をご覧ください。
      </p></li><li class="listitem"><p>クエリが、すでにパラレル実行している別のクエリの内部で走っている場合。
たとえば、パラレルクエリから呼ばれている関数自身がSQLクエリを発行すると、そのクエリは決してパラレルプランを使用しません。
これは現在の実装の制限によるものですが、この制限を取り外すのは好ましくないかもしれません。
なぜなら、単一のクエリが非常に大きな数のプロセスを使用する結果となることがあり得るからです。
      </p></li><li class="listitem"><p>トランザクション分離レベルがシリアライザブルである場合。
これは現在の実装の制限によるものです。
      </p></li></ul></div><p>あるクエリに対してパラレルクエリプランが生成された場合でも、実行時にプランを並列に実行できないような状況があります。
この状況においては、まるで<code class="literal">Gather</code>ノードが存在しなかったかのように、リーダは<code class="literal">Gather</code>ノード以下部分のプランのすべてを自分自身で実行します。
これは、以下の条件のどれかが当てはまると起こります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>バックグラウンドワーカー数の合計が<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>を超えてはいけない、という制限によってバックグラウンドワーカーが得られない場合。
      </p></li><li class="listitem"><p>パラレルクエリ目的で起動されたバックグラウンドワーカー数の合計が<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>を超えてはいけない、という制限によってバックグラウンドワーカーが得られない場合。
      </p></li><li class="listitem"><p>クライアントが0ではないフェッチカウント付きのExecuteメッセージを送信した場合。
<a class="link" href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" title="52.2.3. 拡張問い合わせ">拡張問い合わせプロトコル</a>の議論をご覧ください。
現在の<a class="link" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">libpq</a>にはそのようなメッセージを送る方法がないため、これはlibpqに依存しないクライアントを使った時にだけ起こります。
これが頻繁に起こるようなら、順次実行したときに最適ではないプランが生成されるのを防ぐために、それが起こりそうなセッションの中で、<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>を0に設定すると良いかもしれません。
      </p></li><li class="listitem"><p>準備された文が<code class="literal">CREATE TABLE .. AS EXECUTE ..</code>文を使って実行される場合。
この構文は、読み取り専用操作であったはずのものを、読み書き操作に変換し、パラレルクエリには適さないものにします。
      </p></li><li class="listitem"><p>トランザクション分離レベルがシリアライザブルである場合。
この状況は通常は起こりません。
なぜならトランザクション分離レベルがシリアライザブルのときにはパラレルクエリプランは生成されないからです。
しかし、プランが生成されてから、実行されるまでの間にトランザクション分離レベルが変更されると起こる可能性があります。
      </p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-parallel-query-works.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-plans.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">15.1. パラレルクエリはどのように動くのか </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 15.3. パラレルプラン</td></tr></table></div></body></html>