<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>66.2. TOAST</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="storage-file-layout.html" title="66.1. データベースファイルのレイアウト" /><link rel="next" href="storage-fsm.html" title="66.3. 空き領域マップ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">66.2. TOAST</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="storage-file-layout.html" title="66.1. データベースファイルのレイアウト">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="storage.html" title="Chapter 66. データベースの物理的な格納">Up</a></td><th width="60%" align="center">Chapter 66. データベースの物理的な格納</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="storage-fsm.html" title="66.3. 空き領域マップ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="STORAGE-TOAST"><div class="titlepage"><div><div><h2 class="title" style="clear: both">66.2. TOAST</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="storage-toast.html#STORAGE-TOAST-ONDISK">66.2.1. 行外ディスク上のTOAST格納</a></span></dt><dt><span class="sect2"><a href="storage-toast.html#STORAGE-TOAST-INMEMORY">66.2.2. 行外インメモリのTOAST格納</a></span></dt></dl></div><a id="id-1.10.19.4.2" class="indexterm"></a><a id="id-1.10.19.4.3" class="indexterm"></a><p>本節では<acronym class="acronym">TOAST</acronym>（過大属性格納技法：The Oversized-Attribute Storage Technique）の概要について説明します。</p><p><span class="productname">PostgreSQL</span>は固定長のページサイズ（通常8キロバイト）を使用し、複数ページにまたがるタプルを許しません。
そのため、大規模なフィールド値を直接格納できません。
この限界を克服するため、大規模なフィールド値を圧縮したり、複数の物理的な行に分割したりしています。
これはユーザからは透過的に発生し、また、バックエンドのコード全体には小さな影響しか与えません。
この技法は<acronym class="acronym">TOAST</acronym>（または<span class="quote">“<span class="quote">パンをスライスして以来最善のもの</span>”</span>）という愛称で呼ばれます。
[訳注：TOASTはパンのトーストと綴りが同じなので、スライスしたパンを美味しく食べる方法に掛けて洒落ています。]
<acronym class="acronym">TOAST</acronym>の基盤は大きなデータ値のインメモリで処理の改善にも使用されています。</p><p>一部のデータ型のみが<acronym class="acronym">TOAST</acronym>をサポートします。
大規模なフィールド値を生成することがないデータ型にオーバーヘッドを負わせる必要はありません。
<acronym class="acronym">TOAST</acronym>をサポートするためには、データ型は可変長（<em class="firstterm">varlena</em>）表現を持たなければなりません。
通常は、格納する値の最初の4バイトワードには値の長さ（このワード自体を含む）がバイト単位で含まれます。
<acronym class="acronym">TOAST</acronym>は残りのデータ型の表現について制限しません。
<em class="firstterm"><acronym class="acronym">TOAST</acronym>化された値</em>として集合的に呼ばれる特別な表現は、この先頭の長さのワードを更新または再解釈することで動作します。
したがって、<acronym class="acronym">TOAST</acronym>可能なデータ型をサポートするC言語関数は、潜在的に<acronym class="acronym">TOAST</acronym>化されている入力値の扱い方に注意しなければなりません。
つまり、入力が<em class="firstterm">TOAST解除</em>されなければ、それは実際には4バイトの長さのワードと内容から構成されていないかもしれないのです。
（通常これは、入力に対して何か作業をする前に<code class="function">PG_DETOAST_DATUM</code>を呼び出すことで行われますが、もっと効率的な方法が可能な場合もあります
詳しくは<a class="xref" href="xtypes.html#XTYPES-TOAST" title="37.11.1. TOASTの考慮">Section 37.11.1</a>を参照してください）。</p><p><acronym class="acronym">TOAST</acronym>はvarlenaの長さワードの2ビット(ビッグエンディアンのマシンでは上位ビット、リトルエンディアンのマシンでは下位ビット)を勝手に使用します。
そのため、すべての<acronym class="acronym">TOAST</acronym>可能なデータ型の値の論理サイズは1ギガバイト（2<sup>30</sup> - 1バイト）までになります。
両ビットが0の場合、値はそのデータ型の普通の<acronym class="acronym">TOAST</acronym>化されていない値となり、長さワードの残りのビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
上位側または下位側のどちらか片方のビットが設定された場合、値は通常の4バイトのヘッダを持たず1バイトのヘッダを持ちます。
また、そのバイトの残りビットはデータの（長さワードを含む）総サイズ（バイト単位）となります。
この方式により、127バイトより短い値の効率的な格納をサポートする一方で、データ型が必要なら1GBにまで大きくなることを可能にしています。
1バイトのヘッダを持つ値は特定の境界に整列されませんが、4バイトのヘッダを持つ値は少なくとも4バイト境界の上に整列されます。
このように整列のためのパディングを省略することで、短い値と比べて重要な追加のスペース節約ができます。
特殊な状況として、1バイトのヘッダの残りビットがすべて0（自身の長さを含む場合はありえません）の場合、その値は行外データへのポインタで、以下に述べるようにいくつかの可能性があります。
そのような<em class="firstterm">TOASTポインタ</em>の型とサイズはデータの2番目のバイトに格納されるコードによって決定されます。
最後に上位側または下位側のビットが0で隣のビットが設定されている場合、データの内容は圧縮され、使用前に伸長しなければなりません。
この場合、4バイトの長さワードの残りビットは元データのサイズではなく圧縮したデータの総サイズになります。
圧縮が行外データでも起こりえますが、varlenaヘッダには圧縮されているかどうかについての情報がないことに注意してください。
その代わり<acronym class="acronym">TOAST</acronym>ポインタの内容にこの情報が含まれています。</p><p>前に触れたように、<acronym class="acronym">TOAST</acronym>ポインタデータにはいくつかの型があります。
最も古くて一般的な型は<em class="firstterm"><acronym class="acronym">TOAST</acronym>テーブル</em>に格納されている行外データへのポインタです。
<acronym class="acronym">TOAST</acronym>テーブルは、<acronym class="acronym">TOAST</acronym>ポインタデータ自体を含むテーブルとは別の、しかし関連付けられるテーブルです。
これらの<em class="firstterm">ディスク上</em>のポインタデータは、ディスク上に格納されるタプルが、そのまま格納するには大きすぎる時に、<acronym class="acronym">TOAST</acronym>管理コード（<code class="filename">access/heap/tuptoaster.c</code>にあります）によって作られます。
更なる詳細は<a class="xref" href="storage-toast.html#STORAGE-TOAST-ONDISK" title="66.2.1. 行外ディスク上のTOAST格納">Section 66.2.1</a>に記述されています。
あるいは<acronym class="acronym">TOAST</acronym>ポインタデータは、メモリ内のどこかにある行外データへのポインタのこともあります。
そのようなデータは短命で、ディスク上に現れることは決してありませんが、大きなデータ値を複製し、余分な処理をするのを避けるために有用です。
更なる詳細は<a class="xref" href="storage-toast.html#STORAGE-TOAST-INMEMORY" title="66.2.2. 行外インメモリのTOAST格納">Section 66.2.2</a>に記述されています。</p><p>行内あるいは行外の圧縮データで使用される圧縮技術は、LZ系の圧縮技術の1つで単純かつ非常に高速なものです。
詳細は<code class="filename">src/common/pg_lzcompress.c</code>を参照してください。</p><div class="sect2" id="STORAGE-TOAST-ONDISK"><div class="titlepage"><div><div><h3 class="title">66.2.1. 行外ディスク上のTOAST格納</h3></div></div></div><p>テーブルの列に1つでも<acronym class="acronym">TOAST</acronym>可能なものがあれば、そのテーブルには連携した<acronym class="acronym">TOAST</acronym>テーブルがあり、そのOIDがテーブルの<code class="structname">pg_class</code>.<code class="structfield">reltoastrelid</code>エントリに格納されます。
ディスク上の<acronym class="acronym">TOAST</acronym>化された値は以下で詳しく説明する通り、<acronym class="acronym">TOAST</acronym>テーブルに保持されます。</p><p>行外の値は（圧縮される場合は圧縮後に）最大<code class="literal">TOAST_MAX_CHUNK_SIZE</code>バイトの塊に分割されます
（デフォルトではこの値は4チャンク行が1ページに収まり、およそ2000バイトになるように選ばれます）。
各塊は、データを持つテーブルと連携する<acronym class="acronym">TOAST</acronym>テーブル内に個別の行として格納されます。
すべての<acronym class="acronym">TOAST</acronym>テーブルは<code class="structfield">chunk_id</code>列（特定の<acronym class="acronym">TOAST</acronym>化された値を識別するOID）、<code class="structfield">chunk_seq</code>列（値の塊に対する連番）、<code class="structfield">chunk_data</code>（塊の実際のデータ）列を持ちます。
<code class="structfield">chunk_id</code>と<code class="structfield">chunk_seq</code>に対する一意性インデックスは値の抽出を高速化します。
したがって、行外のディスク上の<acronym class="acronym">TOAST</acronym>化された値を示すポインタデータには、検索先となる<acronym class="acronym">TOAST</acronym>テーブルのOIDと指定した値のOID(<code class="structfield">chunk_id</code>)を格納しなければなりません。
簡便性のために、ポインタデータには論理データサイズ（元々の非圧縮のデータ長）と物理的な格納サイズ（圧縮時には異なります）も格納されます。
varlenaヘッダバイトに収納するためにディスク上の<acronym class="acronym">TOAST</acronym>ポインタデータの総サイズは、表現される値の実サイズに関係なく、18バイトになります。</p><p><acronym class="acronym">TOAST</acronym>管理のコードは、テーブル内に格納される値が<code class="symbol">TOAST_TUPLE_THRESHOLD</code>バイト（通常2キロバイト）を超える時にのみ実行されます。
<acronym class="acronym">TOAST</acronym>コードは、行の値が<code class="symbol">TOAST_TUPLE_TARGET</code>バイト（こちらも通常2キロバイト）より小さくなるかそれ以上の縮小ができなくなるまで、フィールド値の圧縮や行外への移動を行います。
更新操作中、変更されない値は通常そのまま残ります。
行外の値を持つ行の更新では、行外の値の変更がなければ<acronym class="acronym">TOAST</acronym>するコストはかかりません。</p><p><acronym class="acronym">TOAST</acronym>管理のコードでは、ディスク上に<acronym class="acronym">TOAST</acronym>可能な列を格納するために、以下の4つの異なる戦略を認識します。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">PLAIN</code>は圧縮や行外の格納を防止します。
さらにvarlena型での単一バイトヘッダの使用を無効にします。
これは<acronym class="acronym">TOAST</acronym>化不可能のデータ型の列に対してのみ取り得る戦略です。
     </p></li><li class="listitem"><p><code class="literal">EXTENDED</code>では、圧縮と行外の格納を許します。
これはほとんどの<acronym class="acronym">TOAST</acronym>可能のデータ型のデフォルトです。
圧縮がまず行われ、それでも行が大き過ぎるのであれば行外に格納します。
     </p></li><li class="listitem"><p><code class="literal">EXTERNAL</code>は非圧縮の行外格納を許します。
<code class="literal">EXTERNAL</code>を使用すると、<code class="type">text</code>と<code class="type">bytea</code>列全体に対する部分文字列操作が高速化されます。
こうした操作は非圧縮の行外の値から必要な部分を取り出す時に最適化されるためです
（格納領域が増加するという欠点があります）。
     </p></li><li class="listitem"><p><code class="literal">MAIN</code>は圧縮を許しますが、行外の格納はできません
（実際にはこうした列についても行外の格納は行われます。
しかし、他に行を縮小させページに合わせる方法がない場合の最後の手段としてのみです）。
     </p></li></ul></div><p>

<acronym class="acronym">TOAST</acronym>可能なデータ型はそれぞれ、そのデータ型の列用のデフォルトの戦略を指定します。
しかし<a class="link" href="sql-altertable.html" title="ALTER TABLE"><code class="command">ALTER TABLE ... SET STORAGE</code></a>を使用して、あるテーブル列の戦略を変更することができます。</p><p>この機構には、ページをまたがる行の値を許可するといった素直な手法に比べて多くの利点があります。
通常問い合わせは比較的小さなキー値に対する比較で条件付けされるものと仮定すると、エクゼキュータの仕事のほとんどは主だった行の項目を使用して行われることになります。
<acronym class="acronym">TOAST</acronym>化属性の大規模な値は、（それが選択されている時）結果集合をクライアントに戻す時に引き出されるだけです。
このため、主テーブルは行外の格納を使用しない場合に比べて、かなり小さくなり、その行は共有バッファキャッシュにより合うようになります。
ソート集合もまた小さくなり、ソートが完全にメモリ内で行われる頻度が高くなります。
小規模な試験結果ですが、典型的なHTMLページとそのURLを持つテーブルでは、<acronym class="acronym">TOAST</acronym>テーブルを含め、元々のデータサイズのおよそ半分で格納でき、さらに、主テーブルには全体のデータのおよそ10%のみ（URLと一部の小さなHTMLページ）が格納されました。
すべてのHTMLページを7キロバイト程度に切り詰めた<acronym class="acronym">TOAST</acronym>化されない比較用テーブルと比べ、実行時間に違いはありませんでした。</p></div><div class="sect2" id="STORAGE-TOAST-INMEMORY"><div class="titlepage"><div><div><h3 class="title">66.2.2. 行外インメモリのTOAST格納</h3></div></div></div><p><acronym class="acronym">TOAST</acronym>ポインタは、ディスク上にあるデータだけでなく、現在のサーバプロセスのメモリ内の場所を指すこともできます。
そのようなポインタは明らかに短命ですが、それでも有用です。
現在のところ、<em class="firstterm">間接</em>データへのポインタと、<em class="firstterm">展開</em>データへのポインタの2つのケースがあります。</p><p>間接<acronym class="acronym">TOAST</acronym>ポインタは、単にメモリ上のどこかに格納されている間接的でないvarlena値を指すだけです。
このケースは元々は単なる概念実証として作られたのですが、現在はロジカルデコーディング時に1GBを越える物理的タプルを作成する可能性を防ぐために使用されています。
（すべての行外フィールド値をタプルに持ってこようとすると、そうなるかもしれません。）
このケースでは、ポインタデータの作成者はポインタが存在可能な限り参照データが存在し続けることに全責任を負うため、利用が限られ、またこれを支援するための基盤もありません。</p><p>展開<acronym class="acronym">TOAST</acronym>ポインタは、ディスク上の表現が計算目的にあまり適さない複雑なデータ型で有用です。
例えば<span class="productname">PostgreSQL</span>の配列の標準varlena表現には、次元の情報、NULLの要素があればNULLのビットマップ、そしてすべての要素の値が順番どおりに含まれます。
要素型自体が可変長だと、<em class="replaceable"><code>N</code></em>番目の要素を探す唯一の方法は前にある要素のすべてをスキャンすることです。
この表現は、そのサイズの小ささからディスク上の記録には適していますが、配列を使った計算では、すべての要素の開始位置が特定されている<span class="quote">“<span class="quote">展開</span>”</span>または<span class="quote">“<span class="quote">解体</span>”</span>された表現があるとずっと良いです。
<acronym class="acronym">TOAST</acronym>ポインタの機構では、参照渡しのデータが、標準のvarlena値（ディスク上の表現）あるいはメモリ上のどこかにある展開表現を指す<acronym class="acronym">TOAST</acronym>ポインタを指すことを許すことで、このニーズに応えています。
この展開表現の詳細はデータ型に依存しますが、標準ヘッダを持ち、<code class="filename">src/include/utils/expandeddatum.h</code>にある他のAPIの要求を満たす必要があります。
データ型を処理するc言語の関数は、どちらかの表現を扱うことを選ぶことができます。
展開表現を認識せず、入力データに単に<code class="function">PG_DETOAST_DATUM</code>を適用するだけの関数は、自動的に伝統的なvarlena表現を受け取ります。
従って、展開表現のサポートは徐々に、1回に1つの関数だけ導入することができます。</p><p>展開された値への<acronym class="acronym">TOAST</acronym>ポインタは、さらに<em class="firstterm">読み書き</em>のポインタと<em class="firstterm">読み取りのみ</em>のポインタに分類されます。
指された先の表現はどちらでも同じですが、読み書きのポインタを受け取った関数は、そこにある参照値を変更できるのに対し、読み取りのみのポインタを受け取った関数では変更が許されないため、値を変更したバージョンを作りたければ、まずその複製を作る必要があります。
この区別と、関連したいくつかの慣習により、問い合わせの実行時に展開された値を不必要に複製するのを避けることが可能になります。</p><p>すべてのタイプのインメモリの<acronym class="acronym">TOAST</acronym>ポインタについて、<acronym class="acronym">TOAST</acronym>管理のコードはそのようなポインタデータが偶然、ディスクに保存されてしまうことが決して起こらないようにします。
インメモリの<acronym class="acronym">TOAST</acronym>ポインタは保存される前に自動的に展開されて通常の行内のvarlena値になります。
その後、含んでいるタプルが大きすぎるような時には、ディスク上の<acronym class="acronym">TOAST</acronym>ポインタに変換されることもあります。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-file-layout.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="storage.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="storage-fsm.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">66.1. データベースファイルのレイアウト </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 66.3. 空き領域マップ</td></tr></table></div></body></html>