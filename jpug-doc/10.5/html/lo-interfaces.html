<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>34.3. クライアントインタフェース</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="lo-implementation.html" title="34.2. 実装機能" /><link rel="next" href="lo-funcs.html" title="34.4. サーバ側の関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">34.3. クライアントインタフェース</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="lo-implementation.html" title="34.2. 実装機能">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="largeobjects.html" title="Chapter 34. ラージオブジェクト">Up</a></td><th width="60%" align="center">Chapter 34. ラージオブジェクト</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="lo-funcs.html" title="34.4. サーバ側の関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LO-INTERFACES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">34.3. クライアントインタフェース</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="lo-interfaces.html#LO-CREATE">34.3.1. ラージオブジェクトの作成</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-IMPORT">34.3.2. ラージオブジェクトのインポート</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-EXPORT">34.3.3. ラージオブジェクトのエクスポート</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-OPEN">34.3.4. 既存のラージオブジェクトのオープン</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-WRITE">34.3.5. ラージオブジェクトへのデータの書き込み</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-READ">34.3.6. ラージオブジェクトからのデータの読み込み</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-SEEK">34.3.7. ラージオブジェクトのシーク</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TELL">34.3.8. ラージオブジェクトのシーク位置の入手</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TRUNCATE">34.3.9. ラージオブジェクトを切り詰める</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-CLOSE">34.3.10. ラージオブジェクト記述子を閉じる</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-UNLINK">34.3.11. ラージオブジェクトの削除</a></span></dt></dl></div><p>本節では、<span class="productname">PostgreSQL</span>の<span class="application">libpq</span>クライアントインタフェースライブラリで提供されるラージオブジェクトへのアクセス手段について説明します。
<span class="productname">PostgreSQL</span>ラージオブジェクトインタフェースは、<acronym class="acronym">Unix</acronym>ファイルシステムインタフェースに因んで設計されており、<code class="function">open</code>、<code class="function">read</code>、<code class="function">write</code>、<code class="function">lseek</code>など同様のインタフェースを有しています。
   </p><p>ラージオブジェクトファイル記述子はトランザクションの間でしか有効でありませんので、これらの関数を使用したラージオブジェクトの操作はすべてSQLトランザクションブロック内で行われ<span class="emphasis"><em>なければなりません</em></span>。
   </p><p>これらの関数のいずれか１つの実行時にエラーが発生した場合、関数は他ではあり得ない値、通常は0または-1を返します。
エラーを説明するメッセージは接続オブジェクト内に格納され、<code class="function">PQerrorMessage</code>を用いて取り出すことができます。
   </p><p>これらの関数を使用するクライアントアプリケーションは、<code class="filename">libpq/libpq-fs.h</code>ヘッダファイルをインクルードし、<span class="application">libpq</span>ライブラリとリンクしなければなりません。
   </p><div class="sect2" id="LO-CREATE"><div class="titlepage"><div><div><h3 class="title">34.3.1. ラージオブジェクトの作成</h3></div></div></div><p>     <a id="id-1.7.4.8.6.2.1" class="indexterm"></a>
</p><pre class="synopsis">Oid lo_creat(PGconn *conn, int mode);</pre><p>
この関数はラージオブジェクトを新規に作成します。
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<code class="symbol">InvalidOid</code>（0）が返されます。
<span class="productname">PostgreSQL</span> 8.1では、<em class="replaceable"><code>mode</code></em>は使用されず、無視されます。
しかし、以前のリリースとの後方互換性を保持するために、これを<code class="symbol">INV_READ</code>、<code class="symbol">INV_WRITE</code>、<code class="symbol">INV_READ</code> <code class="literal">|</code> <code class="symbol">INV_WRITE</code>に設定することが最善です。
（これらの定数シンボルは<code class="filename">libpq/libpq-fs.h</code>ヘッダファイルで定義されています。）
    </p><p>以下に例を示します。
</p><pre class="programlisting">inv_oid = lo_creat(conn, INV_READ|INV_WRITE);</pre><p>
    </p><p>     <a id="id-1.7.4.8.6.4.1" class="indexterm"></a>
</p><pre class="synopsis">Oid lo_create(PGconn *conn, Oid lobjId);</pre><p>
この関数もラージオブジェクトを新規に作成します。
割り当てられるOIDを<em class="replaceable"><code>lobjId</code></em>で指定することができます。
こうした場合、そのOIDが他のラージオブジェクトですでに使用されていた場合、失敗します。
<em class="replaceable"><code>lobjId</code></em>が<code class="symbol">InvalidOid</code>（0）の場合、<code class="function">lo_create</code>は未使用のOIDを割り当てます。
（これは<code class="function">lo_creat</code>と同じ動作です。）
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<code class="symbol">InvalidOid</code>（0）が返されます。
    </p><p><code class="function">lo_create</code>は<span class="productname">PostgreSQL</span> 8.1から導入されました。
この関数を古いバージョンで実行させると失敗し、<code class="symbol">InvalidOid</code>が返されます。
    </p><p>例を示します。
</p><pre class="programlisting">inv_oid = lo_create(conn, desired_oid);</pre><p>
    </p></div><div class="sect2" id="LO-IMPORT"><div class="titlepage"><div><div><h3 class="title">34.3.2. ラージオブジェクトのインポート</h3></div></div></div><p>     <a id="id-1.7.4.8.7.2.1" class="indexterm"></a>
オペレーティングシステム上のファイルをラージオブジェクトとしてインポートするには、以下の関数を呼び出します。
</p><pre class="synopsis">Oid lo_import(PGconn *conn, const char *filename);</pre><p>
<em class="replaceable"><code>filename</code></em>には、ラージオブジェクトとしてインポートするオペレーティングシステム上のファイルのパス名を指定します。
戻り値は、新規ラージオブジェクトに割り当てられたOIDです。
失敗時は<code class="symbol">InvalidOid</code>（0）が返されます。
このファイルがサーバではなく、クライアントインタフェースライブラリから読み取られることに注意してください。
ですから、このファイルはクライアントのファイルシステム上に存在し、クライアントアプリケーションから読み取り可能でなければなりません。
    </p><p>     <a id="id-1.7.4.8.7.3.1" class="indexterm"></a>
</p><pre class="synopsis">Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);</pre><p>
この関数も新規のラージオブジェクトをインポートします。
割り当てられるOIDを<em class="replaceable"><code>lobjId</code></em>で指定することができます。
こうした場合、そのOIDが他のラージオブジェクトですでに使用されていた場合、失敗します。
<em class="replaceable"><code>lobjId</code></em>が<code class="symbol">InvalidOid</code>（0）の場合、<code class="function">lo_import_with_oid</code>は未使用のOIDを割り当てます（これは<code class="function">lo_import</code>と同じ動作です）。
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<code class="symbol">InvalidOid</code>（0）が返されます。
    </p><p><code class="function">lo_import_with_oid</code>は<span class="productname">PostgreSQL</span> 8.4から導入され、8.1から導入された<code class="function">lo_create</code>を内部で使用しています。
この関数を8.0以前のバージョンで実行させると失敗し、<code class="symbol">InvalidOid</code>が返されます。
    </p></div><div class="sect2" id="LO-EXPORT"><div class="titlepage"><div><div><h3 class="title">34.3.3. ラージオブジェクトのエクスポート</h3></div></div></div><p>     <a id="id-1.7.4.8.8.2.1" class="indexterm"></a>
ラージオブジェクトをオペレーティングシステム上のファイルにエクスポートするには、以下の関数を呼び出します。
</p><pre class="synopsis">int lo_export(PGconn *conn, Oid lobjId, const char *filename);</pre><p>
<em class="parameter"><code>lobjId</code></em>引数には、エクスポートさせるラージオブジェクトのOIDを指定し、<em class="parameter"><code>filename</code></em>引数には、オペレーティングシステム上のファイルのパス名を指定します。
このファイルはサーバではなく、クライアントインタフェースライブラリによって書き込まれることに注意してください。
成功時には1、失敗時には-1が返されます。
    </p></div><div class="sect2" id="LO-OPEN"><div class="titlepage"><div><div><h3 class="title">34.3.4. 既存のラージオブジェクトのオープン</h3></div></div></div><p>     <a id="id-1.7.4.8.9.2.1" class="indexterm"></a>
読み取りまたは書き込みのために既存のラージオブジェクトを開く場合は、以下の関数を呼び出します。
</p><pre class="synopsis">int lo_open(PGconn *conn, Oid lobjId, int mode);</pre><p>
<em class="parameter"><code>lobjId</code></em>引数には開きたいラージオブジェクトのOIDを指定します。
<em class="parameter"><code>mode</code></em>の各ビットは、そのオブジェクトを読み取りのみ（<code class="symbol">INV_READ</code>）、書き込みのみ（<code class="symbol">INV_WRITE</code>）、またはその両方できるように開くのかを制御するものです。
（これらの定数シンボルは<code class="filename">libpq/libpq-fs.h</code>ヘッダファイルで定義されています。）
<code class="function">lo_open</code>は、<code class="function">lo_read</code>、<code class="function">lo_write</code>、<code class="function">lo_lseek</code>、<code class="function">lo_lseek64</code>、<code class="function">lo_tell</code>、<code class="function">lo_tell64</code>、<code class="function">lo_truncate</code>、<code class="function">lo_truncate64</code>、<code class="function">lo_close</code>で使用する（非負の）ラージオブジェクト記述子を返します。
この記述子は現在のトランザクション期間のみで有効です。
失敗時には-1が返されます。
    </p><p>現時点では、サーバは<code class="symbol">INV_WRITE</code>モードと<code class="symbol">INV_READ</code> <code class="literal">|</code> <code class="symbol">INV_WRITE</code>モードとを区別しません。
どちらの場合でも記述子から読み取り可能です。
しかし、これらのモードと<code class="symbol">INV_READ</code>だけのモードとの間には大きな違いがあります。
<code class="symbol">INV_READ</code>モードでは記述子に書き込むことができません。
そして、読み込んだデータは、このトランザクションや他のトランザクションで後で書き込んだかどうかは関係なく、<code class="function">lo_open</code>を実行した時に有効だったトランザクションスナップショットの時点のラージオブジェクトの内容を反映したものになります。
<code class="symbol">INV_WRITE</code>を付けて開いた記述子から読み取ると、現在のトランザクションによる書き込みや他のトランザクションがコミットした書き込みすべてを反映したデータが返されます。
これは、通常の<code class="command">SELECT</code> SQLコマンドにおける<code class="literal">REPEATABLE READ</code>トランザクションの動作と<code class="literal">READ COMMITTED</code>トランザクションの動作の違いに似ています。
    </p><p>以下に例を示します。
</p><pre class="programlisting">inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);</pre><p>
    </p></div><div class="sect2" id="LO-WRITE"><div class="titlepage"><div><div><h3 class="title">34.3.5. ラージオブジェクトへのデータの書き込み</h3></div></div></div><p>     <a id="id-1.7.4.8.10.2.1" class="indexterm"></a>
</p><pre class="synopsis">int lo_write(PGconn *conn, int fd, const char *buf, size_t len);</pre><p>
<em class="parameter"><code>len</code></em>バイトを、<em class="parameter"><code>buf</code></em>（<em class="parameter"><code>len</code></em>サイズでなければなりません）から<em class="parameter"><code>fd</code></em>ラージオブジェクト記述子に書き込みます。
<em class="parameter"><code>fd</code></em>引数は事前に実行した<code class="function">lo_open</code>の戻り値でなければいけません。
実際に書き込まれたバイト数が返されます（現在の実装ではエラーが発生しない限り<em class="parameter"><code>len</code></em>と常に等しくなります）。
エラーイベントが発生した場合は、-1を返します。</p><p><em class="parameter"><code>len</code></em>パラメータは<code class="type">size_t</code>として宣言されていますが、この関数は<code class="literal">INT_MAX</code>より大きな値を拒絶します。
実際には、多くても数メガバイトのチャンクでデータを転送することが最善です。</p></div><div class="sect2" id="LO-READ"><div class="titlepage"><div><div><h3 class="title">34.3.6. ラージオブジェクトからのデータの読み込み</h3></div></div></div><p>     <a id="id-1.7.4.8.11.2.1" class="indexterm"></a>
</p><pre class="synopsis">int lo_read(PGconn *conn, int fd, char *buf, size_t len);</pre><p>
<em class="parameter"><code>len</code></em>長のバイトを、<em class="parameter"><code>fd</code></em>ラージオブジェクト記述子から<em class="parameter"><code>buf</code></em>（<em class="parameter"><code>len</code></em>サイズでなければなりません）に読み込みます。
<em class="parameter"><code>fd</code></em>引数は事前に実行した<code class="function">lo_open</code>の戻り値でなければいけません。
実際に読み込まれたバイト数が返されます。
ラージオブジェクトの最後に先に達した場合は<em class="parameter"><code>len</code></em>より小さな値になります。
エラーイベントが発生した場合は、-1値を返します。</p><p><em class="parameter"><code>len</code></em>パラメータは<code class="type">size_t</code>として宣言されていますが、この関数は<code class="literal">INT_MAX</code>より大きな値を拒絶します。
実際には、多くても数メガバイトをチャンク内にデータを転送することが最善です。</p></div><div class="sect2" id="LO-SEEK"><div class="titlepage"><div><div><h3 class="title">34.3.7. ラージオブジェクトのシーク</h3></div></div></div><p>     <a id="id-1.7.4.8.12.2.1" class="indexterm"></a>
ラージオブジェクト記述子に関連付けされている、現在の読み取りまたは書き込みを行う位置を変更するには、以下の関数を呼び出します。
</p><pre class="synopsis">int lo_lseek(PGconn *conn, int fd, int offset, int whence);</pre><p>
この関数は<em class="parameter"><code>fd</code></em>で識別されるラージオブジェクト識別子の現在の位置を指すポインタを、<em class="parameter"><code>offset</code></em>で指定した新しい位置に変更します。
<em class="parameter"><code>whence</code></em>に指定可能な値は、<code class="symbol">SEEK_SET</code>（オブジェクトの先頭位置からシーク）、<code class="symbol">SEEK_CUR</code>（現在位置からシーク）、<code class="symbol">SEEK_END</code>（オブジェクトの末尾位置からシーク）のいずれかです。
戻り値は新しい位置ポインタで、エラー時に-1が返されます。</p><p>     <a id="id-1.7.4.8.12.3.1" class="indexterm"></a>
2GBを超えるサイズのラージオブジェクトを取り扱う場合は代わりに以下を使用してください。
</p><pre class="synopsis">pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);</pre><p>
この関数は<code class="function">lo_lseek</code>と同じ動作をしますが、<em class="parameter"><code>offset</code></em>として2GBを超える値を受付け、2GBより大きな結果を出力します。
<code class="function">lo_lseek</code>は2GBを超える新しい位置ポインタが指定された場合に失敗することに注意してください。</p><p><code class="function">lo_lseek64</code>は<span class="productname">PostgreSQL</span> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</p></div><div class="sect2" id="LO-TELL"><div class="titlepage"><div><div><h3 class="title">34.3.8. ラージオブジェクトのシーク位置の入手</h3></div></div></div><p>     <a id="id-1.7.4.8.13.2.1" class="indexterm"></a>
ラージオブジェクト記述子の現在の読み取り、書き込み位置を入手するには、以下の関数を呼び出します。
</p><pre class="synopsis">int lo_tell(PGconn *conn, int fd);</pre><p>
エラーが発生した場合は-1が返されます。</p><p>     <a id="id-1.7.4.8.13.3.1" class="indexterm"></a>
サイズが2GBを超える可能性があるラージオブジェクトを取り扱う場合は代わりに以下を使用します。
</p><pre class="synopsis">pg_int64 lo_tell64(PGconn *conn, int fd);</pre><p>
この関数は<code class="function">lo_tell</code>と同じ動作をしますが、2GBより大きな結果を出力します。
<code class="function">lo_tell</code>は2GBを超える新しい位置での読み書きに失敗します。</p><p><code class="function">lo_tell64</code>は<span class="productname">PostgreSQL</span> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</p></div><div class="sect2" id="LO-TRUNCATE"><div class="titlepage"><div><div><h3 class="title">34.3.9. ラージオブジェクトを切り詰める</h3></div></div></div><p>     <a id="id-1.7.4.8.14.2.1" class="indexterm"></a>
ラージオブジェクトを指定した長さに切り詰めるには、以下を呼び出します。
</p><pre class="synopsis">int lo_truncate(PGcon *conn, int fd, size_t len);</pre><p>
この関数はラージオブジェクト記述子<em class="parameter"><code>fd</code></em>を<em class="parameter"><code>len</code></em>長に切り詰めます。
<em class="parameter"><code>fd</code></em>引数は前もって<code class="function">lo_open</code>が返したものでなければなりません。
<em class="parameter"><code>len</code></em>が現在のラージオブジェクト長より大きければ、ラージオブジェクトは指定された長さまでヌルバイト('\0')で拡張されます。
成功時<code class="function">lo_truncate</code>はゼロを返します。
失敗時の戻り値は-1です。</p><p><em class="parameter"><code>fd</code></em>ディスクリプタの読み取り/書き出し位置は変わりません。</p><p><em class="parameter"><code>len</code></em>パラメータは<code class="type">size_t</code>として宣言されていますが、<code class="function">lo_truncate</code>は<code class="literal">INT_MAX</code>より大きな値を拒絶します。</p><p>     <a id="id-1.7.4.8.14.5.1" class="indexterm"></a>
2GBを超える可能性があるラージオブジェクトを取り扱う場合は代わりに以下を使用します。
</p><pre class="synopsis">int lo_truncate64(PGcon *conn, int fd, pg_int64 len);</pre><p>
この関数は<code class="function">lo_truncate</code>と同じ動作をしますが、2GBを超える<em class="parameter"><code>len</code></em>を受け付けることができます。</p><p><code class="function">lo_truncate</code>は<span class="productname">PostgreSQL</span> 8.3で新規に導入されました。
この関数を古いバージョンのサーバに対して実行した場合は失敗し、-1が返されます。</p><p><code class="function">lo_truncate64</code>は<span class="productname">PostgreSQL</span> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</p></div><div class="sect2" id="LO-CLOSE"><div class="titlepage"><div><div><h3 class="title">34.3.10. ラージオブジェクト記述子を閉じる</h3></div></div></div><p>     <a id="id-1.7.4.8.15.2.1" class="indexterm"></a>
以下を呼び出すことでラージオブジェクト記述子を閉ざすことができます。
</p><pre class="synopsis">int lo_close(PGconn *conn, int fd);</pre><p>
ここで、<em class="parameter"><code>fd</code></em>は<code class="function">lo_open</code>の戻り値であるラージオブジェクト記述子です。
成功すると、<code class="function">lo_close</code>は0を返します。
失敗すると、-1を返します。</p><p>開いたままのラージオブジェクト記述子は全てトランザクションの終了時に自動的に閉ざされます。</p></div><div class="sect2" id="LO-UNLINK"><div class="titlepage"><div><div><h3 class="title">34.3.11. ラージオブジェクトの削除</h3></div></div></div><p>     <a id="id-1.7.4.8.16.2.1" class="indexterm"></a>
データベースからラージオブジェクトを削除するには、以下の関数を呼び出します。
</p><pre class="synopsis">int lo_unlink(PGconn *conn, Oid lobjId);</pre><p>
<em class="parameter"><code>lobjId</code></em>引数は削除するラージオブジェクトのOIDを指定します。
成功時に1を、失敗時に-1を返します。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lo-implementation.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="largeobjects.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="lo-funcs.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">34.2. 実装機能 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 34.4. サーバ側の関数</td></tr></table></div></body></html>