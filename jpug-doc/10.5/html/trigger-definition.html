<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.1. トリガ動作の概要</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="triggers.html" title="Chapter 38. トリガ" /><link rel="next" href="trigger-datachanges.html" title="38.2. データ変更の可視性" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.1. トリガ動作の概要</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="triggers.html" title="Chapter 38. トリガ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="triggers.html" title="Chapter 38. トリガ">Up</a></td><th width="60%" align="center">Chapter 38. トリガ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="trigger-datachanges.html" title="38.2. データ変更の可視性">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TRIGGER-DEFINITION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.1. トリガ動作の概要</h2></div></div></div><p>トリガとは、データベースが、ある特定の操作が行われた時に常に自動的に実行しなければならない特定の機能に関する規定です。
トリガはテーブル（パーティション化されているかどうかにかかわらず）、ビュー、外部テーブルに付与することができます。
  </p><p>テーブルおよび外部テーブル上では、トリガを<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>操作の前後に、行を変更する度、あるいは<acronym class="acronym">SQL</acronym>文ごとに実行するように定義することができます。
<code class="command">INSERT</code>が<code class="literal">ON CONFLICT DO UPDATE</code>句を含む場合、<code class="varname">EXCLUDED</code>列への参照があるなら、BEFORE INSERTトリガとBEFORE UPDATEトリガの両方が適用されることもあります。
さらに、UPDATEトリガについては、特定のカラムがUPDATE文のSET句の対象になった時のみ発動するよう設定することができます。
また、トリガはTRUNCATE文についても発動できます。
トリガイベントが起こると、トリガ関数がそのイベントを扱う適切な時点で呼び出されます。
   </p><p>ビュー上では、トリガを<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>操作の代わりに実行するものとして定義できます。
そうした<code class="literal">INSTEAD OF</code>トリガは、ビュー内の変更を行うために必要となる行それぞれに対して一度発行されます。
ビューの元になっている基底テーブルへの必要な変更の実施、そして必要に応じて、ビュー上で見えるであろう変更された行を返却するのは、トリガ関数の責任です。
ビューへのトリガは、<acronym class="acronym">SQL</acronym>文ごとに、<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>操作の前後で実行させるよう定義することもできます。
しかし、そうしたトリガは、ビューに<code class="literal">INSTEAD OF</code>トリガがあるときにだけ発行されます。
<code class="literal">INSTEAD OF</code>トリガを定義しない場合は、ビューを操作しようとする文は、元になる基底テーブルに影響を与える文に書き換えなければなりません。
その結果、発行されるトリガは、基底テーブルに付けられたトリガとなります。
   </p><p>トリガ関数は、トリガ自体が作成される前までに定義しておく必要があります。
トリガ関数は、引数を取らない、<code class="literal">trigger</code>型を返す関数として宣言される必要があります
（トリガ関数は、通常の関数で使用される引数という形ではなく、<code class="structname">TriggerData</code>構造体で入力を受け取ります）。
   </p><p>適切なトリガ関数が作成されると、<a class="xref" href="sql-createtrigger.html" title="CREATE TRIGGER"><span class="refentrytitle">CREATE TRIGGER</span></a>を使用してトリガを構築することができます。
同一のトリガ関数を複数のトリガに使用することができます。
   </p><p><span class="productname">PostgreSQL</span>は、<em class="firstterm">行単位の</em>トリガと<em class="firstterm">文単位の</em>トリガの両方を提供します。
行単位のトリガでは、トリガを発行した文によって影響を受ける行ごとにトリガ関数が呼び出されます。
反対に、文単位のトリガでは、適切な文が実行された時に、その文で何行が影響を受けたかどうかは関係なく、一度だけ呼び出されます。
特に、行に影響を与えない文であっても、適切な文単位のトリガがあれば実行されます。
この2種類のトリガはそれぞれ<em class="firstterm">行レベル</em>トリガと<em class="firstterm">文レベル</em>トリガと呼ばれることがあります。
<code class="command">TRUNCATE</code>に対するトリガは、行単位ではなく、文レベルにのみに定義することができます。
   </p><p>また、トリガはそれらが操作の<em class="firstterm">前</em>、<em class="firstterm">後</em>または<em class="firstterm">代わり</em>のどれで実行されるかに応じて分けられます。
これらはそれぞれ<code class="literal">BEFORE</code>トリガ、<code class="literal">AFTER</code>トリガ、そして<code class="literal">INSTEAD OF</code>トリガと呼ばれます。
文レベルの<code class="literal">BEFORE</code>トリガは、もちろん文が何かを始める前に発行され、文レベルの<code class="literal">AFTER</code>トリガは文の本当に最後に発行されます。
これらのタイプのトリガはテーブル、ビュー、あるいは外部テーブルに定義できます。
行レベルの<code class="literal">BEFORE</code>トリガは、特定の行が操作される直前に発行され、行レベルの<code class="literal">AFTER</code>トリガは文の終わり（ただし、全ての文レベルの<code class="literal">AFTER</code>トリガの前）に発行されます。
これらのタイプのトリガは、非パーティションテーブル、外部テーブルに定義できますが、ビューには定義できません。
<code class="literal">INSTEAD OF</code>トリガはビューにのみ定義され、行レベルのみが許されます。
つまり、ビュー上のそれぞれの行で処理が必要と判断された場合には、即座に発動します。
   </p><p>継承あるいはパーティション階層において、親テーブルをターゲットとする文は、影響を受けた子テーブルの行レベルトリガを発動しません。
すなわち、親テーブルの行レベルトリガのみが発動します。
しかし、影響を受けた子テーブルの行レベルトリガは発動します。
   </p><p><code class="command">INSERT</code>が<code class="literal">ON CONFLICT DO UPDATE</code>句を含む場合、<code class="varname">EXCLUDED</code>列が参照されていると、行単位<code class="literal">BEFORE</code> <code class="command">INSERT</code>トリガおよび行単位<code class="literal">BEFORE</code> <code class="command">UPDATE</code>トリガの両方の効果が適用され、それが更新後の行の最後の状態から明らかな場合がありえます。
ただし、両方の行レベルの<code class="literal">BEFORE</code>トリガを実行するために<code class="varname">EXCLUDED</code>の参照が必要なわけではありません。
驚くような結果の可能性について、<code class="literal">BEFORE</code> <code class="command">INSERT</code>と<code class="literal">BEFORE</code> <code class="command">UPDATE</code>の両方の文単位トリガーがあり、それらがいずれも挿入あるいは更新対象の行に影響を与える場合に考慮すべきです（これは更新が冪等ではないが、ほぼ同等であるときには、それでも問題になります）。
文単位の<code class="command">UPDATE</code>トリガは<code class="literal">ON CONFLICT DO UPDATE</code>が指定されたとき、その<code class="command">UPDATE</code>によって行が影響を受けたかどうかに関わらず（そしてその代替である<code class="command">UPDATE</code>部分が実行されたかどうかに関わらず）実行されることに注意してください。
<code class="literal">ON CONFLICT DO UPDATE</code>句のある<code class="command">INSERT</code>では、まず文単位の<code class="literal">BEFORE</code> <code class="command">INSERT</code>トリガ、次に文単位の<code class="literal">BEFORE</code> <code class="command">UPDATE</code>トリガ、次いで文単位の<code class="literal">AFTER</code> <code class="command">UPDATE</code>トリガ、最後に文単位の<code class="literal">AFTER</code> <code class="command">INSERT</code>トリガを実行します。
   </p><p>文単位のトリガによって呼び出されるトリガ関数は常に<code class="symbol">NULL</code>を返さなければなりません。
行単位のトリガによって呼び出されるトリガ関数は呼び出し元のエクゼキュータにテーブル行（<code class="structname">HeapTuple</code>型の値）を返すように選択することができます。
操作前に発行された行レベルのトリガでは以下の選択肢があります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="symbol">NULL</code>を返して、現在の行への操作を飛ばすことができます。
これは、エクゼキュータにトリガの元になった行レベルの操作（特定のテーブル行の挿入、更新、削除）を行わないよう指示します。
      </p></li><li class="listitem"><p>行レベルの<code class="command">INSERT</code>および<code class="command">UPDATE</code>トリガの場合のみ、返される行が挿入される、もしくは実際に更新される行になります。
これにより、トリガ関数で、挿入される行もしくは更新される行を変更することができます。
      </p></li></ul></div><p>

これらの動作をさせたくない行レベルの<code class="literal">BEFORE</code>トリガについては、渡された行（つまり、<code class="command">INSERT</code>および<code class="command">UPDATE</code>トリガでは<code class="varname">NEW</code>行、<code class="command">DELETE</code>の場合は<code class="varname">OLD</code>行）と同じ行結果を返すように気を付ける必要があります。
   </p><p>行レベルの<code class="literal">INSTEAD OF</code>トリガは、ビューの元となった元テーブルのデータをまったく変更しないことを表す<code class="symbol">NULL</code>、または、渡されたビューの行（<code class="command">INSERT</code>と<code class="command">UPDATE</code>操作の場合<code class="varname">NEW</code>行、<code class="command">DELETE</code>操作の場合<code class="varname">OLD</code>行）を返さなければなりません。
非NULLの戻り値は、そのトリガがビューにおいて必要なデータ変更を実行したことを通知するために使用されます。
これにより影響を受けた行数を数えるカウンタは増加されます。
<code class="command">INSERT</code>と<code class="command">UPDATE</code>操作では、トリガは戻す前に<code class="varname">NEW</code>行を変更することができます。
これは<code class="command">INSERT RETURNING</code>または<code class="command">UPDATE RETURNING</code>で返されるデータを変更しますので、ビューが提供されたデータと正確に同じ結果を返さない場合に有益です。
   </p><p>操作の後に発生する行レベルトリガでは戻り値は無視されますので、これらは<code class="symbol">NULL</code>を返すことができます。
   </p><p>同一リレーション、同一イベントに対して1つ以上のトリガが定義された場合、トリガはその名前のアルファベット順に発生します。
<code class="literal">BEFORE</code>トリガと<code class="literal">INSTEAD OF</code>トリガの場合では、各トリガで返される、変更された可能性がある行が次のトリガの入力となります。
もし、ある<code class="literal">BEFORE</code>トリガや<code class="literal">INSTEAD OF</code>トリガが<code class="symbol">NULL</code>を返したら、(いまのところ)操作はその行で中断し、残りのトリガは発生しません。
   </p><p>トリガ定義は、トリガを発動するかどうかを<code class="literal">WHEN</code>句の論理条件で指定することも可能です。行レベルトリガにおいて、<code class="literal">WHEN</code>条件は行の列の古い値と(あるいは)新しい値を検索することができます。(あまり有用ではありませんが、文レベルトリガでも<code class="literal">WHEN</code>条件で同じことができます。)<code class="literal">BEFORE</code>トリガでは、実質的にトリガ関数の開始時と同じ条件で検査できるように、<code class="literal">WHEN</code>条件の評価が関数の実施直前になされます。しかし<code class="literal">AFTER</code>トリガでは、<code class="literal">WHEN</code>条件の評価は行の更新直後に行われ、文の終わり(コミット時)にトリガを発動するためのイベントを待ち行列に入れるかどうかを決めます。そのため、ある<code class="literal">AFTER</code>トリガの<code class="literal">WHEN</code>条件が真を返さなかった場合は、イベントを待ち行列に入れる必要も文の終わりに行を再取得する必要もありません。これは、大量の行の変更が発生するけれども、トリガがその内の少数の行に対してのみ発動させる必要がある、といった文の処理速度を大幅に上げる効果があります。<code class="literal">INSTEAD OF</code>トリガは<code class="literal">WHEN</code>条件をサポートしていません。
   </p><p>通常、行レベルの<code class="literal">BEFORE</code>トリガは、挿入あるいは更新される予定のデータの検査や変更のために使用されます。
例えば、<code class="literal">BEFORE</code>トリガは、<code class="type">timestamp</code>型の列に現在時刻を挿入するために、あるいは行の2つの要素の整合性を検査するために使用される可能性があります。
行レベルの<code class="literal">AFTER</code>トリガは、ほとんど常識的に他のテーブルに更新を伝播させるために、あるいは他のテーブルとの整合性を検査するために使用されます。
こうした仕事の切り分け理由は、<code class="literal">AFTER</code>トリガは行の最終値を見ることができ、<code class="literal">BEFORE</code>トリガは見ることができないという点です。
トリガを<code class="literal">BEFORE</code>にするか<code class="literal">AFTER</code>にするかを決める時に特別な理由がないのであれば、操作の情報を行が終わるまで保持する必要がない分、<code class="literal">BEFORE</code>を使う方が効率的です。
   </p><p>トリガ関数がSQLコマンドを処理する場合、これらの問い合わせがトリガを再度発行することがあります。
これはカスケードされたトリガと呼ばれます。
カスケードの段数に直接的な制限はありません。
カスケードの場合、同じトリガを再帰的に呼び出すことが可能です。
例えば、<code class="command">INSERT</code>トリガで同じテーブルに追加の行を挿入する問い合わせが実行された場合、その結果として<code class="command">INSERT</code>トリガが再度発行されます。
こうした状況で無限再帰を防ぐのは、トリガプログラマの責任です。
   </p><p>    <a id="id-1.8.4.5.18.1" class="indexterm"></a>
トリガを定義する時、そのトリガ用の引数を指定することができます。
トリガ定義に引数を含めた目的は、似たような要求の異なるトリガに同じ関数を呼び出すことができるようにすることです。
例えば、2つの列名を引数とし、片方に現在のユーザをもう片方に現在のタイムスタンプを取る、汎化トリガ関数があるとします。
適切に作成すれば、この関数が特定のトリガの発行元となるテーブルに依存することはなくなります。
同じ関数を使用して、例えば、トランザクションテーブルに作成記録を自動的に登録させるために、適切な列を持つ任意のテーブルの<code class="command">INSERT</code>イベントに使用することができます。
また、<code class="command">UPDATE</code>として定義すれば、最終更新イベントを追跡するために使用することも可能です。
   </p><p>トリガをサポートするプログラミング言語はそれぞれ独自の方法で、トリガ関数で利用できるトリガの入力データを作成します。
この入力データにはトリガイベント種類（例えば<code class="command">INSERT</code>や<code class="command">UPDATE</code>など、<code class="command">CREATE TRIGGER</code>で指定された全ての引数）が含まれます。
行レベルトリガの入力データには、<code class="command">INSERT</code>および<code class="command">UPDATE</code>トリガの場合は<code class="varname">NEW</code>行が、<code class="command">UPDATE</code>および<code class="command">DELETE</code>トリガの場合は<code class="varname">OLD</code>行が含まれます。
   </p><p>デフォルトでは、文レベルトリガには文によって変更された個々の行を検査するための手段がありません。
しかし、トリガがアクセスできる影響を受けた行の集合を作成するために、<code class="literal">AFTER STATEMENT</code>トリガは、<em class="firstterm">遷移テーブル(transition tables)</em>の作成を依頼することができます。
<code class="literal">AFTER ROW</code>トリガも遷移テーブルを依頼できるので、発動中の個々の行における変更だけでなく、テーブル全体におけるすべての変更を見ることができます。
遷移テーブルを検査する方法も使用中のプログラミング言語に依存しますが、典型的な方法は、トリガ関数の中で発行するSQLコマンドでアクセスできる、読み込み専用の一時テーブルのように振る舞う遷移テーブルを作成することです。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="triggers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="triggers.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="trigger-datachanges.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 38. トリガ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 38.2. データ変更の可視性</td></tr></table></div></body></html>