<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.4. インデックスとORDER BY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-multicolumn.html" title="11.3. 複数列インデックス" /><link rel="next" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.4. インデックスと<code xmlns="http://www.w3.org/1999/xhtml" class="literal">ORDER BY</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-multicolumn.html" title="11.3. 複数列インデックス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-ORDERING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.4. インデックスと<code class="literal">ORDER BY</code></h2></div></div></div><a id="id-1.5.10.7.2" class="indexterm"></a><p>単に問い合わせによって返される行を見つけ出すだけではなく、インデックスは、その行を指定した順番で取り出すことができます。
これにより、別途ソート処理を行うことなく、問い合わせの<code class="literal">ORDER BY</code>指定に従うことが可能です。
<span class="productname">PostgreSQL</span>が現在サポートするインデックスの種類の中で、B-Treeのみがソート出力を行うことができます。
他の種類のインデックスでは指定なし、または、実装固有の順序でマッチした行を返します。
  </p><p>プランナは、<code class="literal">ORDER BY</code>指定を満足させるために、指定に一致し利用可能なインデックスでスキャンするか、または、テーブルを物理的な順番でスキャンし明示的なソートを行うかを考慮します。
テーブルの大部分のスキャンが必要な問い合わせでは、後に発生するシーケンシャルなアクセスパターンのために要求されるディスクI/Oが少ないため、インデックスを使用するよりも、明示的なソートの方が高速です。
数行を取り出す必要がある場合のみ、インデックスの方が有用になります。
<code class="literal">ORDER BY</code>と<code class="literal">LIMIT</code> <em class="replaceable"><code>n</code></em>が組み合わされた場合が、重要かつ特別です。
先頭の<em class="replaceable"><code>n</code></em>行を識別するために、明示的なソートを全データに対して行う必要があります。
しかし、もし<code class="literal">ORDER BY</code>に合うインデックスが存在すれば、残りの部分をスキャンすることなく、先頭の<em class="replaceable"><code>n</code></em>行の取り出しを直接行うことができます。
  </p><p>デフォルトでは、B-treeインデックスは項目を昇順で格納し、NULLを最後に格納します。
これは、<code class="literal">x</code>列に対するインデックスの前方方向のスキャンで<code class="literal">ORDER BY x</code>（より冗長にいえば<code class="literal">ORDER BY x ASC NULLS LAST</code>）を満たす出力を生成することを意味します。
また、インデックスを後方方向にスキャンすることもでき、この場合、<code class="literal">ORDER BY x DESC</code>（より冗長にいえば<code class="literal">ORDER BY x DESC NULLS FIRST</code>。<code class="literal">NULLS FIRST</code>が<code class="literal">ORDER BY DESC</code>のデフォルトだからです。）を満たす出力を生成します。
  </p><p>インデックスを作成する時に、以下のように<code class="literal">ASC</code>、<code class="literal">DESC</code>、<code class="literal">NULLS FIRST</code>、<code class="literal">NULLS LAST</code>オプションを組み合わせて指定することにより、B-treeインデックスの順序を調整することができます。
</p><pre class="programlisting">CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);</pre><p>
昇順かつNULL先頭という順で格納されたインデックスは、スキャンされる方向に依存して<code class="literal">ORDER BY x ASC NULLS FIRST</code>または<code class="literal">ORDER BY x DESC NULLS LAST</code>を満たすことができます。
  </p><p>4つの全方向を提供する理由が何か、後方方向へのスキャンの可能性があることを考慮した2方向で、すべての種類の<code class="literal">ORDER BY</code>を網羅できるのではないかと疑問を持つかもしれません。
単一列に対するインデックスでは、このオプションは実際冗長ですが、複数列に対するインデックスでは有用になります。
<code class="literal">(x, y)</code>という2つの列に対するインデックスを仮定します。
これを前方方向にスキャンすれば<code class="literal">ORDER BY x, y</code>を満たし、後方方向にスキャンすれば<code class="literal">ORDER BY x DESC, y DESC</code>を満たします。
しかし、<code class="literal">ORDER BY x ASC, y DESC</code>をよく使用しなければならないアプリケーションが存在する可能性があります。
簡素なインデックスからこの順序を取り出す方法がありません。
しかし、インデックスが<code class="literal">(x ASC, y DESC)</code>または<code class="literal">(x DESC, y ASC)</code>として定義されていれば、取り出すことができます。
  </p><p>明確なことですが、デフォルト以外のソート順を持つインデックスはかなり特殊な機能です。
しかし、特定の問い合わせにおいては恐ろしいほどの速度を向上させることがあります。
こうしたインデックスを維持する価値があるかどうかは、特殊なソート順を要求する問い合わせを使用する頻度に依存します。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-multicolumn.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-bitmap-scans.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.3. 複数列インデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.5. 複数のインデックスの組み合わせ</td></tr></table></div></body></html>