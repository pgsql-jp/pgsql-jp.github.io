<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.7. 式に対するインデックス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-unique.html" title="11.6. 一意インデックス" /><link rel="next" href="indexes-partial.html" title="11.8. 部分インデックス" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.7. 式に対するインデックス</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-unique.html" title="11.6. 一意インデックス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-partial.html" title="11.8. 部分インデックス">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-EXPRESSIONAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.7. 式に対するインデックス</h2></div></div></div><a id="id-1.5.10.10.2" class="indexterm"></a><p>インデックス列は、基礎をなすテーブルにある列である必要はなく、そのテーブルの１つ以上の列から計算される関数やスカラ式とすることもできます。
この機能は、ある演算結果に基づいた高速テーブルアクセスを行う時に有用です。
  </p><p>例えば、大文字小文字を区別せずに比較するための一般的な方法である、<code class="function">lower</code>関数での使用例を以下に示します。
</p><pre class="programlisting">SELECT * FROM test1 WHERE lower(col1) = 'value';</pre><p>
<code class="literal">lower(column)</code>関数の結果にインデックスが定義されていれば、この問い合わせでインデックスを使用することができます。
</p><pre class="programlisting">CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));</pre><p>
  </p><p>このインデックスを<code class="literal">UNIQUE</code>と宣言したとすると、<code class="literal">col1</code>の値が同一となる行だけでなく、<code class="literal">col1</code>の大文字小文字だけが違う行の生成を防ぐことになります。
したがって、式に対するインデックスを使用して、単なる一意性制約では定義できないような制約を強制することができます。
  </p><p>別の例として、以下のような問い合わせが頻繁に行われる場合を考えます。
</p><pre class="programlisting">SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';</pre><p>
この場合、以下のようなインデックスを作成する価値があるでしょう。
</p><pre class="programlisting">CREATE INDEX people_names ON people ((first_name || ' ' || last_name));</pre><p>
  </p><p>２番目の例に示すように<code class="command">CREATE INDEX</code>コマンドの構文は通常、インデックス式を括弧で括る必要があります。
最初の例のように、式が単なる関数呼び出しの場合には括弧を省略することができます。
  </p><p>派生した式が、行が挿入、更新される度に実行されなければなりませんので、インデックス式は相対的に見て維持が高価です。
しかし、インデックス式はインデックス内にすでに格納されているため、インデックスを使用する検索の間は再計算<span class="emphasis"><em>されません</em></span>。
上の両方の例では、システムは問い合わせを単なる<code class="literal">WHERE indexedcolumn = 'constant'</code>と理解しますので、この検索速度は他の単純なインデックス問い合わせと同じです。
したがって、式に対するインデックスは取り出し速度が挿入、更新速度より重要な場合に有用です。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-unique.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-partial.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.6. 一意インデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.8. 部分インデックス</td></tr></table></div></body></html>