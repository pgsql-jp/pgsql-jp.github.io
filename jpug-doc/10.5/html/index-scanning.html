<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>60.3. インデックススキャン</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="index-functions.html" title="60.2. インデックスアクセスメソッド関数" /><link rel="next" href="index-locking.html" title="60.4. インデックスのロック処理に関する検討" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">60.3. インデックススキャン</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-functions.html" title="60.2. インデックスアクセスメソッド関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Up</a></td><th width="60%" align="center">Chapter 60. インデックスアクセスメソッドのインタフェース定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="index-locking.html" title="60.4. インデックスのロック処理に関する検討">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEX-SCANNING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">60.3. インデックススキャン</h2></div></div></div><p>インデックススキャンでは、<em class="firstterm">スキャンキー</em>に一致するものと示したすべてのタプルのTIDを繰り返すことに関する責任をインデックスアクセスメソッドが持ちます。
アクセスメソッドには、実際のインデックスの親テーブルからのタプルの取り出しやタプルがスキャンの時間制限試験や他の条件を通過したかどうかの決定は含まれ<span class="emphasis"><em>ません</em></span>。
  </p><p>スキャンキーは、<em class="replaceable"><code>index_key</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>という形式の<code class="literal">WHERE</code>句の内部的表現です。
ここで、<em class="replaceable"><code>index_key</code></em>は、インデックス列の1つで、<em class="replaceable"><code>operator</code></em>はインデックス列に関連した演算子族のメンバの1つです。
インデックススキャンは、暗黙的にAND演算される0個以上のスキャンキーを持ちます。
返されるタプルは指定された条件を満たすものと想定されます。
  </p><p>アクセスメソッドはインデックスがある特定の問い合わせに対し<em class="firstterm">非可逆</em>、または再検査を要求するかどうかを報告することができます。
これは、インデックススキャンがスキャンキーを満たすすべての項目と、それに加えて、満たさない可能性のある項目を返すことを意味します。
コアシステムのインデックススキャン機構はヒープタプルに対し、本当に選択されるべきかどうかを検証するためにその演算子をインデックス条件に再度適用します。
再検査オプションが指定されない場合、インデックススキャンは一致する項目の集合を返さなければなりません。
  </p><p>確実に、指定されたスキャンキーすべてに一致するもののみをすべて正しく見つけ出すことは、完全にアクセスメソッドの責任であることに注意してください。
また、コアシステムは、冗長かどうかや矛盾するかどうかを決定するための意味的な解析を行わず、単にインデックスキーと演算子族に一致する<code class="literal">WHERE</code>句をすべて渡します。
例えば、<code class="literal">WHERE x &gt; 4 AND x &gt; 14</code>があり、<code class="literal">x</code>がB-treeインデックス列であったとすると、これは、B-tree <code class="function">amrescan</code>関数に任されて、最初のスキャンキーが冗長であり、無視できることが認知されます。
<code class="function">amrescan</code>における前処理の必要性は、インデックスアクセスメソッドがスキャンキーを<span class="quote">“<span class="quote">正規化</span>”</span>形式にする必要があるかどうかに依存します。
  </p><p>一部のアクセスメソッドは、他では行いませんが、十分に定義された順序でインデックス項目を返します。
アクセスメソッドが出力の順序付けをサポートできるようにする方法は、実質２種類存在します。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>常にそのデータ（btreeなど）の自然な順序で項目を返すアクセスメソッドは<code class="structfield">amcanorder</code>を真に設定しなければなりません。
現在、こうしたアクセスメソッドは、その等価性と順序付け演算子でbtree互換の戦略番号を使用しなければなりません。
      </p></li><li class="listitem"><p>順序付け演算子をサポートするアクセスメソッドは<code class="structfield">amcanorderbyop</code>を真に設定しなければなりません。
これは、インデックスが<code class="literal">ORDER BY</code> <em class="replaceable"><code>index_key</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>を満たす順序で項目を返すことができることを示します。
前述の通り、この形式のスキャン修飾子を<code class="function">amrescan</code>に渡すことができます。
      </p></li></ul></div><p>
  </p><p><code class="function">amgettuple</code>関数は<code class="literal">direction</code>引数を持ちます。
これは<code class="literal">ForwardScanDirection</code>（通常の場合）または<code class="literal">BackwardScanDirection</code>のいずれかを取ることができます。
<code class="function">amrescan</code>後の最初の呼び出しが<code class="literal">BackwardScanDirection</code>を指定していた場合、一致したインデックス項目は通常の前から後ろという方向ではなく、後ろから前という方向でスキャンされます。
そのため、<code class="function">amgettuple</code>は通常ならばインデックス内の最初に一致したタプルを返すところですが、最後に一致したタプルを返さなければなりません。
（これは<code class="structfield">amcanorder</code>が真に設定されたアクセスメソッドでのみ発生します。）
最初の呼び出しの後、<code class="function">amgettuple</code>は、最も最近に返された項目からどちらの方向にスキャンを進めるかを準備しなければなりません。
（しかし<code class="structfield">amcanbackward</code>が偽であれば、引き続くすべての呼び出しは最初のものと同じ方向を持ちます。）
  </p><p>順序付けされたスキャンを提供するアクセスメソッドはスキャン内位置の<span class="quote">“<span class="quote">記録</span>”</span>をサポートしなければならず、また、後でその記録された位置に戻ることをサポートしなければなりません。
同じ位置が複数回記録されるかもしれません。
しかし、スキャン内の1つの位置のみを記録する必要があります。
新しい<code class="function">ammarkpos</code>呼び出しにより前回記録された位置は上書きされます。
順序付けされたスキャンをサポートしないアクセスメソッドは<code class="structname">IndexAmRoutine</code>で<code class="function">ammarkpos</code>関数および<code class="function">amrestrpos</code>関数を提供する必要はないので、これらのポインタをNULLにセットしてください。
  </p><p>スキャン位置と記録された位置（もしあれば）の両方は、インデックス内の同時挿入や削除という観点における一貫性を保持しなければなりません。
スキャンが始まった時に存在していた場合、項目を見つけ出したスキャンが新しく挿入された項目を返さなかったとしても問題ありません。
このような場合のスキャンでは、再スキャンやバックアップによって、あたかも最初の時点で返されたものとして項目が返されます。
同様に、同時実行削除によってスキャンの結果に影響が出るかもしれません。
重要なことは、挿入や削除によって、その項目自体が挿入・削除されていない項目がスキャンで失われたり二重になったりすることが起こらないという点です。
  </p><p>インデックスが設定された列値がインデックスに格納されている(かつ、不可逆表現ではない)場合、ヒープタプルのTIDではなくインデックスに格納された実際のデータを返す<a class="link" href="indexes-index-only-scans.html" title="11.11. インデックスオンリースキャン">インデックスオンリースキャン</a>をサポートするのに有用です。
これは、可視性マップによってTIDが全可視のページ上にあると判断できる場合にI/Oを避けるだけのことです。
判断できない場合はMVCCを確認するためにヒープタプルにアクセスしなくてはなりません。
しかしその動作はアクセスメソッドでは考慮されていません。
  </p><p><code class="function">amgettuple</code>を使用する代わりに、<code class="function">amgetbitmap</code>を使用して、一回の呼出しですべてのタプルを取り出してインデックススキャンを行うことができます。
これはアクセスメソッド内でのロック/ロック解除という過程を防ぐことができますので、<code class="function">amgettuple</code>よりもかなり効率的です。
実際には、<code class="function">amgetbitmap</code>は<code class="function">amgettuple</code>呼び出しを繰り返すことと同じ効果を持つはずですが、物事を単純化するために複数の制限を加えています。
まず第一に、<code class="function">amgetbitmap</code>は一回ですべてのタプルを返し、スキャン位置の記録と位置戻しをサポートしません。
第二に、特定の順序付けをまったく持たないビットマップの中にタプルが返されます。
これは<code class="function">amgetbitmap</code>が<code class="literal">direction</code>引数を取らない理由です。
（順序付け演算子はこのようなスキャンでは決して与えられません。）
また、<code class="function">amgetbitmap</code>によるインデックスオンリースキャンは提供されていません。なぜなら、インデックスタプルの内容を返す手段がないからです。
最後に、<code class="function">amgetbitmap</code>は返されたタプルに関し、<a class="xref" href="index-locking.html" title="60.4. インデックスのロック処理に関する検討">Section 60.4</a>に記載した意味でのロックを保証しません。
  </p><p>アクセスメソッドの内部実装がどちらか片方のAPIにそぐわない場合、<code class="function">amgettuple</code>を実装せず<code class="function">amgetbitmap</code>のみを実装、またはその逆も許されていることに注意してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-functions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="index-locking.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">60.2. インデックスアクセスメソッド関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 60.4. インデックスのロック処理に関する検討</td></tr></table></div></body></html>