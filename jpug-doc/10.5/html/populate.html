<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.4. データベースへのデータ投入</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する" /><link rel="next" href="non-durability.html" title="14.5. 永続性がない設定" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.4. データベースへのデータ投入</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="Chapter 14. 性能に関するヒント">Up</a></td><th width="60%" align="center">Chapter 14. 性能に関するヒント</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="non-durability.html" title="14.5. 永続性がない設定">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="POPULATE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.4. データベースへのデータ投入</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="populate.html#DISABLE-AUTOCOMMIT">14.4.1. 自動コミットをオフにする</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-COPY-FROM">14.4.2. <code class="command">COPY</code>の使用</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-INDEXES">14.4.3. インデックスを削除する</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-FKEYS">14.4.4. 外部キー制約の削除</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-WORK-MEM">14.4.5. <code class="varname">maintenance_work_mem</code>を増やす</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-MAX-WAL-SIZE">14.4.6. <code class="varname">max_wal_size</code>を増やす</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PITR">14.4.7. WALアーカイブ処理とストリーミングレプリケーションの無効化</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-ANALYZE">14.4.8. 最後に<code class="command">ANALYZE</code>を実行</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PG-DUMP">14.4.9. <span class="application">pg_dump</span>に関するいくつかの注意</a></span></dt></dl></div><p>データベースにデータを初期投入するために、大量のテーブル挿入操作を行う必要がままあります。
本節では、この作業を効率良く行うためのちょっとした提言を示します。
  </p><div class="sect2" id="DISABLE-AUTOCOMMIT"><div class="titlepage"><div><div><h3 class="title">14.4.1. 自動コミットをオフにする</h3></div></div></div><a id="id-1.5.13.7.3.2" class="indexterm"></a><p>複数回の<code class="command">INSERT</code>を実行するのであれば、自動コミットを無効にして最後に1回だけコミットしてください。
（普通のSQLでは、これは<code class="command">BEGIN</code>を開始時に、<code class="command">COMMIT</code>を最後に発行することを意味します。
クライアント用ライブラリの中にはこれを背後で実行するものもあります。
その場合は、要望通りにライブラリが行っているかどうかを確認しなければなりません。）
各挿入操作で個別にコミットすることを許すと、<span class="productname">PostgreSQL</span>は行を追加する度に多くの作業をしなければなりません。
1つのトランザクションですべての挿入を行うことによるもう1つの利点は、1つの行の挿入に失敗した場合、その時点までに挿入されたすべての行がロールバックされることです。
その結果、一部のみがロードされたデータの対処に困ることはありません。
   </p></div><div class="sect2" id="POPULATE-COPY-FROM"><div class="titlepage"><div><div><h3 class="title">14.4.2. <code class="command">COPY</code>の使用</h3></div></div></div><p>単一コマンドですべての行をロードするために一連の<code class="command">INSERT</code>コマンドではなく、<a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>を使用してください。
<code class="command">COPY</code>コマンドは行を大量にロードすることに最適化されています。
このコマンドは<code class="command">INSERT</code>に比べ柔軟性に欠けていますが、大量のデータロードにおけるオーバーヘッドを大きく低減します。
<code class="command">COPY</code>コマンドでテーブルにデータを投入する場合、コマンドは1つなので、自動コミットを無効にする必要はありません。
   </p><p><code class="command">COPY</code>を使用できない場合、準備された<code class="command">INSERT</code>文を<a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>を使用して作成し、必要数回だけ<code class="command">EXECUTE</code>を実行する方が良いでしょう。
これにより、繰り返し行われる<code class="command">INSERT</code>の解析と計画作成分のオーバーヘッドを省くことになります。
この機能のための方法はインタフェースによって異なります。
このインタフェースの文書の<span class="quote">“<span class="quote">準備された文</span>”</span>を参照してください。
   </p><p><code class="command">COPY</code>を使用した大量の行のロードは、ほとんどすべての場合において、<code class="command">INSERT</code>を使用するロードよりも高速です。
たとえ複数の挿入を単一トランザクションにまとめたとしても、またその際に<code class="command">PREPARE</code>を使用したとしても、これは当てはまります。
   </p><p><code class="command">COPY</code>は、前もって行われる<code class="command">CREATE TABLE</code>または<code class="command">TRUNCATE</code>コマンドと同一トランザクションで行った場合に、最速です。
この場合、エラーが起きた場合に新しくロードされるデータを含むファイルがとにかく削除されますので、WALを書き出す必要がありません。
しかし、<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>が<code class="literal">minimal</code>に設定されている場合のみにこの方法は当てはまります。
この他の場合には、すべてのコマンドをWALに書き出さなければならないためです。
   </p></div><div class="sect2" id="POPULATE-RM-INDEXES"><div class="titlepage"><div><div><h3 class="title">14.4.3. インデックスを削除する</h3></div></div></div><p>新規に作成したテーブルをロードする時、最速の方法は、テーブルを作成し、<code class="command">COPY</code>を使用した一括ロードを行い、そのテーブルに必要なインデックスを作成することです。
既存のデータに対するインデックスを作成する方が、各行がロードされる度に段階的に更新するよりも高速です。
   </p><p>既存のテーブルに大量のデータを追加しているのであれば、インデックスを削除し、テーブルをロード、その後にインデックスを再作成する方がよいかもしれません。
もちろん、他のユーザから見ると、インデックスが存在しない間データベースの性能は悪化します。
また、一意性インデックスを削除する前には熟考しなければなりません。
一意性制約によるエラー検査がその期間行われないからです。
   </p></div><div class="sect2" id="POPULATE-RM-FKEYS"><div class="titlepage"><div><div><h3 class="title">14.4.4. 外部キー制約の削除</h3></div></div></div><p>インデックスの場合と同様、外部キー制約は一行一行検査するよりも効率的に、<span class="quote">“<span class="quote">まとめて</span>”</span>検査することができます。
従って、外部キー制約を削除し、データをロード、そして、制約を再作成する方法は有用となることがあります。
繰り返しますが、データロードの速度と、制約が存在しない間のエラー検査がないという点とのトレードオフがあります。
   </p><p>外部キー制約をすでに持つテーブルにデータをロードする時、新しい行はそれぞれ(行の外部キー制約を検査するトリガを発行しますので)サーバの待機中トリガイベントのリスト内に項目を要求します。
数百万の行をロードすると、トリガイベントのキューが利用可能なメモリをオーバーフローさせてしまい、耐えられないほどのスワッピングが発生してしまう、最悪はそのコマンドが完全に失敗してしまう可能性があります。
したがって単に好ましいだけでなく、大量のデータをロードする時には外部キーを削除し再度適用することが<span class="emphasis"><em>必要</em></span>かもしれません。
一時的な制約削除が受け入れられない場合に他に取り得る手段は、ロード操作をより小さなトランザクションに分割することだけかもしれません。
   </p></div><div class="sect2" id="POPULATE-WORK-MEM"><div class="titlepage"><div><div><h3 class="title">14.4.5. <code class="varname">maintenance_work_mem</code>を増やす</h3></div></div></div><p>大規模なデータをロードする時<a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>設定変数を一時的に増やすことで性能を向上させることができます。
これは、<code class="command">CREATE INDEX</code>コマンドと<code class="command">ALTER TABLE ADD FOREIGN KEY</code>の速度向上に役立ちます。
<code class="command">COPY</code>自体には大して役立ちませんので、この助言は、上述の技法の片方または両方を使用している時にのみ有用です。
   </p></div><div class="sect2" id="POPULATE-MAX-WAL-SIZE"><div class="titlepage"><div><div><h3 class="title">14.4.6. <code class="varname">max_wal_size</code>を増やす</h3></div></div></div><p>大規模なデータをロードする時<a class="xref" href="runtime-config-wal.html#GUC-MAX-WAL-SIZE">max_wal_size</a>設定変数を一時的に増やすことで高速化することができます。
大量のデータを<span class="productname">PostgreSQL</span>にロードすることで、通常のチェックポイントの頻度（<code class="varname">checkpoint_timeout</code>設定変数により指定されます）よりも頻繁にチェックポイントが発生するためです。
チェックポイントが発生すると、すべてのダーティページ（ディスクに未書き込みの変更済みメモリページ）はディスクに吐き出されなければなりません。
大量のデータロードの際に一時的に<code class="varname">max_wal_size</code>を増加させることで、必要なチェックポイント数を減らすことができます。
   </p></div><div class="sect2" id="POPULATE-PITR"><div class="titlepage"><div><div><h3 class="title">14.4.7. WALアーカイブ処理とストリーミングレプリケーションの無効化</h3></div></div></div><p>大量のデータをWALアーカイブ処理またはストリーミングレプリケーションを使用するインストレーションにロードする時、増加する大量のWALデータを処理するより、ロードが完了した後に新しくベースバックアップを取る方が高速です。
ロード中のWALログの増加を防ぐためには、<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>を<code class="literal">minimal</code>に、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>を<code class="literal">off</code>に、<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>をゼロに設定することにより、アーカイブ処理とストリーミングレプリケーションを無効にしてください。
しかし、これらの変数を変更するにはサーバの再起動が必要な点に注意してください。
   </p><p>こうすると、WALデータを処理する保管処理またはWAL送信処理にかかる時間がかからないことの他に、実際のところ、特定のコマンドをより高速にします。
<code class="varname">wal_level</code>が<code class="literal">minimal</code>の場合、これらのコマンドではWALへの書き出しは全く予定されないためです。
（これらは最後に<code class="function">fsync</code>を実行することで、WALへの書き込みより安価にクラッシュした場合の安全性を保証することができます。）
これは以下のコマンドで当てはまります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>       <code class="command">CREATE TABLE AS SELECT</code>
      </p></li><li class="listitem"><p><code class="command">CREATE INDEX</code> (または<code class="command">ALTER TABLE ADD PRIMARY KEY</code>などの亜種）
      </p></li><li class="listitem"><p>       <code class="command">ALTER TABLE SET TABLESPACE</code>
      </p></li><li class="listitem"><p>       <code class="command">CLUSTER</code>
      </p></li><li class="listitem"><p>同一トランザクションで前もって対象テーブルが作成された、あるいは、消去された場合の<code class="command">COPY FROM</code>
      </p></li></ul></div><p>
   </p></div><div class="sect2" id="POPULATE-ANALYZE"><div class="titlepage"><div><div><h3 class="title">14.4.8. 最後に<code class="command">ANALYZE</code>を実行</h3></div></div></div><p>テーブル内のデータ分布を大きく変更した時は毎回、<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>を実行することを強く勧めます。
これは、テーブルに大量のデータをまとめてロードする場合も含まれます。
<code class="command">ANALYZE</code>（または<code class="command">VACUUM ANALYZE</code>）を実行することで、確実にプランナがテーブルに関する最新の統計情報を持つことができます。
統計情報が存在しない、または古い場合、プランナは、そのテーブルに対する問い合わせの性能を損なわせる、お粗末な問い合わせ計画を選択する可能性があります。
自動バキュームデーモンが有効な場合、<code class="command">ANALYZE</code>が自動的に実行されます。
詳細は<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="24.1.3. プランナ用の統計情報の更新">Section 24.1.3</a>および<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">Section 24.1.6</a>を参照してください。
   </p></div><div class="sect2" id="POPULATE-PG-DUMP"><div class="titlepage"><div><div><h3 class="title">14.4.9. <span class="application">pg_dump</span>に関するいくつかの注意</h3></div></div></div><p><span class="application">pg_dump</span>で生成されるダンプスクリプトは自動的に上のガイドラインのいくつかを適用します（すべてではありません）。
<span class="application">pg_dump</span>ダンプをできる限り高速にリロードするには、手作業で更に数作業が必要です。
（これらは<span class="emphasis"><em>作成</em></span>時に適用するものではなく、ダンプを<span class="emphasis"><em>復元</em></span>する時に適用するものです。
<span class="application">psql</span>を使用してテキスト形式のダンプをロードする時と<span class="application">pg_dump</span>のアーカイブファイルから<span class="application">pg_restore</span>を使用してロードする時にも同じことが適用できます。）
   </p><p>デフォルトでは、<span class="application">pg_dump</span>は<code class="command">COPY</code>を使用します。
スキーマとデータのダンプ全体を生成する場合、インデックスと外部キー制約を作成する前にデータをロードすることに注意してください。
ですので、この場合、ガイドラインのいくつかは自動的に行われます。
残された作業は以下のとおりです。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="varname">maintenance_work_mem</code>および<code class="varname">max_wal_size</code>を適切な（つまり通常よりも大きな）値に設定します。
      </p></li><li class="listitem"><p>WALアーカイブ処理またはストリーミングレプリケーションを使用する場合は、リストア時にこれを無効にすることを検討してください。
このためにはダンプをロードする前に<code class="varname">archive_mode</code>を<code class="literal">off</code>に、<code class="varname">wal_level</code>を<code class="literal">minimal</code>に、<code class="varname">max_wal_senders</code>をゼロに設定してください。
その後それらを正しい値に戻し、新規にベースバックアップを取ってください。
      </p></li><li class="listitem"><p><span class="application">pg_dump</span>と<span class="application">pg_restore</span>で、並列ダンプとリストア方式を実験して、利用する並列なジョブの最適な数を見つけて下さい。
<code class="option">-j</code>オプションでダンプとリストアを並列に行なうのは逐次方式よりも大きく性能を向上させるでしょう。
      </p></li><li class="listitem"><p>ダンプ全体を単一トランザクションとしてリストアすべきかどうか検討してください。
このためには<span class="application">psql</span>または<span class="application">pg_restore</span>に<code class="option">-1</code>または<code class="option">--single-transaction</code>コマンドラインオプションを指定してください。
このモードを使用する場合、たとえ小さなエラーであっても、エラーがあればリストア全体がロールバックされます。
データ同士の関連性がどの程度あるかに依存しますが、手作業での整理の際には好まれるかと思います。さもなくばあまり勧めません。
単一トランザクションで実行し、WALアーカイブを無効にしている場合、<code class="command">COPY</code>コマンドは最も高速に行われます。
      </p></li><li class="listitem"><p>データベースサーバで複数のCPUが利用できるのであれば、<span class="application">pg_restore</span>の<code class="option">--jobs</code>オプションの利用を検討してください。
これによりデータのロードとインデックスの作成を同時に行うことができます。
      </p></li><li class="listitem"><p>この後で<code class="command">ANALYZE</code>を実行してください。
      </p></li></ul></div><p>
   </p><p>データのみのダンプも<code class="command">COPY</code>コマンドを使用しますが、インデックスの削除と再作成を行いません。
また、通常は外部キー制約を変更しません。

     <a href="#ftn.id-1.5.13.7.11.4.2" class="footnote"><sup class="footnote" id="id-1.5.13.7.11.4.2">[12]</sup></a>

したがって、データのみのダンプをロードする時、上の技法を使用したければ自らインデックスと外部キーを削除、再作成しなければなりません。
データをロードする時に<code class="varname">max_wal_size</code>を増やすことも有用です。
しかし、<code class="varname">maintenance_work_mem</code>を増やすことは考えないでください。
これは、後でインデックスと外部キーを手作業で再作成する時に行う方がよいでしょう。
また、実行した後で<code class="command">ANALYZE</code>を行うことを忘れないでください。
詳細は<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="24.1.3. プランナ用の統計情報の更新">Section 24.1.3</a>および<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">Section 24.1.6</a>を参照してください。
   </p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.13.7.11.4.2" class="footnote"><p><a href="#id-1.5.13.7.11.4.2" class="para"><sup class="para">[12] </sup></a><code class="option">--disable-triggers</code>オプションを使用して、外部キーを無効にさせることができます。
しかし、これは外部キー制約を遅らせるのではなく、除去することに注意してください。
そのため、これを使用すると不正なデータを挿入することができてしまいます。
      </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="explicit-joins.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="non-durability.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.3. 明示的な<code class="literal">JOIN</code>句でプランナを制御する </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 14.5. 永続性がない設定</td></tr></table></div></body></html>