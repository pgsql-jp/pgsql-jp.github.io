<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.1. パラレルクエリはどのように動くのか</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="parallel-query.html" title="Chapter 15. パラレルクエリ" /><link rel="next" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.1. パラレルクエリはどのように動くのか</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="parallel-query.html" title="Chapter 15. パラレルクエリ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Chapter 15. パラレルクエリ">Up</a></td><th width="60%" align="center">Chapter 15. パラレルクエリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="when-can-parallel-query-be-used.html" title="15.2. どのような時にパラレルクエリは使用できるのか？">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="HOW-PARALLEL-QUERY-WORKS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.1. パラレルクエリはどのように動くのか</h2></div></div></div><p>あるクエリの最速の実行戦略がパラレルクエリであるとオプティマイザが決定すると、<em class="firstterm">Gather</em>または<em class="firstterm">Gather Merge</em>ノードを含むクエリプランを作成します。
単純な例を示します。

</p><pre class="screen">EXPLAIN SELECT * FROM pgbench_accounts WHERE filler LIKE '%x%';
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Gather  (cost=1000.00..217018.43 rows=1 width=97)
   Workers Planned: 2
   -&gt;  Parallel Seq Scan on pgbench_accounts  (cost=0.00..216018.33 rows=1 width=97)
         Filter: (filler ~~ '%x%'::text)
(4 rows)</pre><p>
   </p><p>どの場合でも、<code class="literal">Gather</code>または<code class="literal">Gather Merge</code>ノードは、正確に一つの子ノードを持ちます。
子プランは、プランの中で並列に実行される部分です。
<code class="literal">Gather</code>または<code class="literal">Gather Merge</code>ノードがプランツリーの中で最上位にある場合は、クエリ全体が並列に実行されます。
<code class="literal">Gather</code>または<code class="literal">Gather Merge</code>ノードがプランツリーの他の部分にある場合は、その部分だけが並列に実行されます。
上の例では、クエリはただ一つのテーブルにアクセスするので、<code class="literal">Gather</code>ノード自身以外では、たった一つのプランノードだけが存在します。
そのプランノードは<code class="literal">Gather</code>ノードの子ノードなので、並列に実行されます。
   </p><p><a class="link" href="using-explain.html" title="14.1. EXPLAINの利用">EXPLAINを使って</a>、プランナが選択したワーカーの数を見ることができます。
クエリの実行中に<code class="literal">Gather</code>ノードに到達すると、ユーザのセッションに対応しているプロセスは、プランナが選択したワーカーと同じ数の<a class="link" href="bgworker.html" title="Chapter 47. バックグラウンドワーカプロセス">バックグラウンドワーカープロセス</a>を要求します。
プランナが使用を検討するバックグラウンドワーカーの数は、最大でも<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>に制限されます。
ある時点で存在できるバックグラウンドワーカーの数は、<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>と<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>の両方を満たすように制限されます。
ですから、あるパラレルクエリが、プラン時よりも少ない数のワーカープロセスによって実行されたり、まったくワーカープロセスなしに実行されることがあり得ます。
最適なプランは利用可能なワーカーの数に依存することもあるので、これは低い性能をもたらす結果になるかもしれません。
これがしばしば起こるようなら、<code class="varname">max_worker_processes</code>と<code class="varname">max_parallel_workers</code>を増やしてより多くのワーカーが同時に実行できるようにするか、 <code class="varname">max_parallel_workers_per_gather</code>を減らして、プランナがより少ない数のワーカーを要求するようにすることを考慮してください。
   </p><p>与えられたパラレルクエリから起動されたすべてのバックグラウンドワーカープロセスは、そのプランの一部を実行します。
リーダーはそうしたプランの部分を実行するだけでなく、追加の任務が与えられます。
つまり、ワーカーが生成したすべてのタプルを読み込まなければなりません。
プラン中のパラレル部分が少数のタプルしか生成しない場合は、リーダーは追加のワーカーとほぼ同じように振る舞い、クエリの実行を高速化します。
反対にプラン中のパラレル部分が大量のタプルを生成する場合は、リーダーはワーカーが生成したタプルの読み込みと、<code class="literal">Gather</code>ノードあるいは<code class="literal">Gather Merge</code>より上位のプランノードが要求する追加の処理ステップに忙殺されるかもしれません。
そのような場合は、リーダーはプランの並列実行部分のごく一部しか処理しません。
   </p><p>プランの並列部分の最上位ノードが<code class="literal">Gather</code>ではなくて<code class="literal">Gather Merge</code>なら、プランの並列部分を実行する各プロセスはタプルをソート順に生成し、リーダーはソート順を保存するマージを実行していることを意味します。
対照的に、<code class="literal">Gather</code>は、ワーカーから都合の良い順でタプルを読み込むので、ソート順が存在しているとしても、それを壊してしまいます。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="parallel-query.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="when-can-parallel-query-be-used.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 15. パラレルクエリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 15.2. どのような時にパラレルクエリは使用できるのか？</td></tr></table></div></body></html>