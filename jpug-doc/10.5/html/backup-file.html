<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.2. ファイルシステムレベルのバックアップ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="backup-dump.html" title="25.1. SQLによるダンプ" /><link rel="next" href="continuous-archiving.html" title="25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">25.2. ファイルシステムレベルのバックアップ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="backup-dump.html" title="25.1. SQLによるダンプ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="backup.html" title="Chapter 25. バックアップとリストア">Up</a></td><th width="60%" align="center">Chapter 25. バックアップとリストア</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="continuous-archiving.html" title="25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="BACKUP-FILE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.2. ファイルシステムレベルのバックアップ</h2></div></div></div><p>バックアップ戦略の代替案として<span class="productname">PostgreSQL</span>がデータベース内のデータを保存するために使用しているファイルを直接コピーする方法があります。
<a class="xref" href="creating-cluster.html" title="18.2. データベースクラスタの作成">Section 18.2</a>にこれらのファイルがどこにあるか解説されています。
下記のような通常のファイルシステムのバックアップを行うどんな方法でも問題ありません。

</p><pre class="programlisting">tar -cf backup.tar /usr/local/pgsql/data</pre><p>
  </p><p>しかしこの方法には2つの制約があり、そのためにあまり実用的ではなく、少なくとも<span class="application">pg_dump</span>より劣ると言わざるを得ません。

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>有効なバックアップを行うにはデータベースサーバを<span class="emphasis"><em>必ず</em></span>停止しなければなりません。
全ての接続を無効とするような中途半端な対策では作用しません
（<code class="command">tar</code>やその類似ツールはある時点におけるファイルシステムの原子的なスナップショットを取らないことと同時に、サーバ内の内部バッファリングの理由によるからです）。
サーバの停止に関しては<a class="xref" href="server-shutdown.html" title="18.5. サーバのシャットダウン">Section 18.5</a>を参照してください。
言うまでもありませんが、データをリストアする前にもサーバを停止させる必要があります。
     </p></li><li class="listitem"><p>データベースのファイルシステムレイアウトの詳細を熟知している場合、ある個別のテーブルやデータベースをそれぞれのファイルやディレクトリからバックアップしたり復元したりすることを試みたいと思うかもしれません。
しかし、それらのファイル内の情報はすべてのトランザクションのコミット状態を保持するコミットログファイル<code class="filename">pg_xact/*</code>なしでは使えないため、この方法では正常なバックアップは<span class="emphasis"><em>行えません</em></span>。
テーブルファイルはこの情報があって初めて意味をなします。
もちろんテーブルとそれに付帯する<code class="filename">pg_xact</code>データだけで復元することも、データベースクラスタにある他のテーブルを無効としてしまうのでできません。
ですので、ファイルシステムバックアップは、データベースクラスタ全体の完全なバックアップとリストア処理にのみ動作します。
     </p></li></ol></div><p>
  </p><p>その他のファイルシステムバックアップ方法として、ファイルシステムが<span class="quote">“<span class="quote">整合性を維持したスナップショット</span>”</span>機能をサポートしている場合（かつ、正しく実装されていると信用する場合）、データディレクトリのスナップショットを作成する方法があります。
典型的な手順では、データベースを含むボリュームの<span class="quote">“<span class="quote">凍結スナップショット</span>”</span>を作成し、データディレクトリ全体（上述のように、一部だけではいけません）をスナップショットからバックアップデバイスにコピーし、そして、凍結スナップショットを解放します。
これはデータベースサーバが稼動中であっても動作します。
しかし、こうして作成されたバックアップは、データベースサーバが適切に停止されなかった状態のデータベースファイルを保存します。
そのため、このバックアップデータでデータベースサーバを起動する時、直前のサーバインスタンスがクラッシュしたものとみなされ、WALログが取り直されます。
これは問題ではありません。
単に注意してください（そして、確実にバックアップにWALファイルを含めてください）。
CHECKPOINTコマンドをスナップショット取得前に発行することでリカバリ時間を減らすこともできます。
  </p><p>対象のデータベースが複数のファイルシステムにまたがって分散している場合、全てのボリュームに対して完全に同期した凍結スナップショットを得る方法が存在しない可能性があります。
例えば、データファイルとWALログが異なったディスク上にあったり、テーブル空間が異なるファイルシステム上にある場合、スナップショットは同時でなければ<span class="emphasis"><em>なりません</em></span>ので、スナップショットのバックアップを使用できない可能性があります。
こうした状況では、整合性を維持したスナップショット技術を信用する前に使用するファイルシステムの文書を熟読してください。
  </p><p>同時実行のスナップショットができない場合、選択肢の１つとして、全ての機能の停止したスナップショットを確定させるのに充分な時間、データベースサーバをシャットダウンさせることが挙げられます。
他の選択肢は、継続的なベースバックアップの保管（<a class="xref" href="continuous-archiving.html#BACKUP-BASE-BACKUP" title="25.3.2. ベースバックアップの作成">Section 25.3.2</a>）を行うことです。
こうしたバックアップには、バックアップ中のファイルシステムの変更を心配する必要がないためです。
これにはバックアップ処理期間のみに継続的な保管を行う必要があり、継続的なアーカイブリカバリ（<a class="xref" href="continuous-archiving.html#BACKUP-PITR-RECOVERY" title="25.3.4. 継続的アーカイブによるバックアップを使用した復旧">Section 25.3.4</a>）を使用してリストアを行います。
  </p><p>ファイルシステムをバックアップするその他の選択肢として<span class="application">rsync</span>の使用が挙げられます。
これを行うには、先ずデータベースサーバが稼働中に<span class="application">rsync</span>を実行し、そして<code class="command">rsync --checksum</code>を実行するのに充分な間だけデータベースサーバを停止します。
(<code class="command">rsync</code>はファイルの更新時刻に関して1秒の粒度しかありませんので、<code class="option">--checksum</code>が必要です。)
次の<span class="application">rsync</span>は、比較的転送するデータ量が少なく、サーバが稼働していないため最終結果に矛盾がない事から、最初の<span class="application">rsync</span>よりも迅速です。
この方法で最小の稼働停止時間でファイルシステムのバックアップを行う事ができます。
  </p><p>ファイルシステムバックアップは、概してSQLによるダンプより大きくなることに注意してください。
（<span class="application">pg_dump</span>では、例えばインデックスの内容をダンプする必要はありません。単にコマンドで再作成します。）
しかし、ファイルシステムのバックアップを取るほうがより高速でしょう。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-dump.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="backup.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="continuous-archiving.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">25.1. <acronym class="acronym">SQL</acronym>によるダンプ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</td></tr></table></div></body></html>