<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>30.1. 信頼性</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み" /><link rel="next" href="wal-intro.html" title="30.2. ログ先行書き込み(WAL)" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">30.1. 信頼性</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み">Up</a></td><th width="60%" align="center">Chapter 30. 信頼性とログ先行書き込み</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="wal-intro.html" title="30.2. ログ先行書き込み(WAL)">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="WAL-RELIABILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">30.1. 信頼性</h2></div></div></div><p>信頼性は、すべての本格的なデータベースシステムで重要な特性です。
<span class="productname">PostgreSQL</span>は信頼できる操作を保証するためにできることは何でもします。
信頼できる操作の一面は、コミットされたトランザクションにより記録されたデータはすべて不揮発性の領域に格納され、電源断、オペレーティングシステムの障害、ハードウェアの障害（当然ですが、不揮発性の領域自体の障害は除きます。）があっても安全であるという点です。
通常、コンピュータの永続的格納領域（ディスク装置など）へのデータ書き込みの成功がこの条件を満たします。
実際、コンピュータに致命的な障害が発生したとしても、もしディスク装置が無事ならば、類似のハードウェアを持つ別のコンピュータに移すことができ、コミットされたトランザクションを元通りに復元できます。
  </p><p>データを周期的にディスクプラッタに書き出すことは簡単な操作に思われるかもしれませんが、そうではありません。
ディスク装置は主メモリ、CPU、コンピュータの主メモリとディスクプラッタの間にある各種のキャッシュ層と比べ非常に低速であるからです。
まず、オペレーティングシステムのバッファキャッシュが存在します。
これは頻繁にアクセス要求があるディスクブロックをキャッシュし、ディスクへの書き込みをまとめます。
好運にもすべてのオペレーティングシステムがバッファキャッシュをディスクに強制書き込みさせる方法をアプリケーションに提供しています。
<span class="productname">PostgreSQL</span>はこの機能を使用します。
（これを調整する方法については<a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a>パラメータを参照してください。）
  </p><p>次に、ディスク装置のコントローラキャッシュが存在する可能性があります。
特に、<acronym class="acronym">RAID</acronym>コントローラカードでは、これは一般的です。
これらの中には<em class="firstterm">write-through</em>キャッシュがあり、つまり、データが届いた時に即座に書き込みがディスク装置に対して行なわれます。
他には<em class="firstterm">write-back</em>キャッシュがあり、多少遅れて書き込みがディスク装置に対して行なわれます。
こうしたキャッシュでは、ディスクコントローラキャッシュが揮発性で、電源障害の際にその内容が失われてしまい、信頼性に関して致命的な問題になる可能性があります。
より優れたコントローラカードには<em class="firstterm">バッテリバックアップ付き装置</em>(<acronym class="acronym">BBU</acronym>s)があり、システムの電源が落ちた場合もキャッシュに電源を供給します。
後で電源が復旧した後に、データがディスク装置に書き出されます。
  </p><p>最後に、ほとんどのディスク装置がキャッシュを持っています。一部はwrite-throughであり、一部はwrite-backです。
ディスクコントローラキャッシュの場合と同様にwrite-backのディスク装置キャッシュの場合にはデータが損失する恐れがあります。
一般消費者向けのIDEおよびSATA装置では、電源障害時にデータが残らないwrite-backキャッシュを使用している可能性がとりわけ高いです。
多くのソリッドステートドライブ(SSD)も同様に揮発性のwrite-backキャッシュを持っています。
  </p><p>これらのキャッシュは、大抵は無効にできます。しかしながらオペレーティングシステムやドライブの種類によってその方法は異なります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="productname">Linux</span>上で<code class="command">hdparm -I</code>を使用することでIDEおよびSATAドライブのキャッシュについて調べることができます。
<code class="literal">Write cache</code>の次に <code class="literal">*</code>があれば書き込みキャッシュが有効になっています。
<code class="command">hdparm -W 0</code>により書き込みキャッシュを無効にできます。
SCSIドライブであれば<a class="ulink" href="http://sg.danny.cz/sg/sdparm.html" target="_top"><span class="application">sdparm</span></a>を使うことで調査が可能です。
<code class="command">sdparm --get=WCE</code>によりキャッシュが有効かどうかの確認ができ、<code class="command">sdparm --clear=WCE</code>により無効にすることができます。
      </p></li><li class="listitem"><p><span class="productname">FreeBSD</span>では、IDEドライブに対して<code class="command">atacontrol</code>により確認ができ、そして書き込みキャッシュを無効にするには<code class="filename">/boot/loader.conf</code>の<code class="literal">hw.ata.wc=0</code>を利用します。SCSIドライブに対しては<code class="command">camcontrol identify</code>を確認に使用することができ、<code class="command">sdparm</code>を使用できる場合にはそれを用いて書き込みキャッシュの確認と変更が可能です。
      </p></li><li class="listitem"><p><span class="productname">Solaris</span>では、ディスクの書き込みキャッシュは<code class="command">format -e</code>で制御できます。
(Solarisの<acronym class="acronym">ZFS</acronym>ファイルシステムは、独自のディスクキャッシュ書き出しコマンドを発行しているため、ディスクの書き込みキャッシュを有効にしても安全です。)
      </p></li><li class="listitem"><p><span class="productname">Windows</span>では、もし<code class="varname">wal_sync_method</code>が<code class="literal">open_datasync</code>(デフォルト)の場合、
<code class="literal">My Computer\Open\<em class="replaceable"><code>disk drive</code></em>\Properties\Hardware\Properties\Policies\Enable write caching on the disk</code>のチェックを外すことで、書き込みキャッシュを無効にできます。
もう一つの方法としては、<code class="varname">wal_sync_method</code>を<code class="literal">fsync</code>か<code class="literal">fsync_writethrough</code>に設定し、書き込みキャッシュを使用しないようにします。
      </p></li><li class="listitem"><p><span class="productname">macOS</span>では、<code class="varname">wal_sync_method</code>を<code class="literal">fsync_writethrough</code>に設定することで書き込みキャッシュを使用しないようにします。
      </p></li></ul></div><p>最近のSATAドライブ(<acronym class="acronym">ATAPI-6</acronym>またはそれ以降)はドライブキャッシュの書き出しコマンド(<code class="command">FLUSH CACHE EXT</code>)を提供している一方、
SCSIドライブでは従来から類似の<code class="command">SYNCHRONIZE CACHE</code>コマンドをサポートしていました。
これらのコマンドは、直接PostgreSQLに発行されませんが、いくつかのファイルシステム(例えば<acronym class="acronym">ZFS</acronym>や<acronym class="acronym">ext4</acronym>)では、
それらをwrite-backが有効なドライブへデータを書き出すために使います。
不幸なことに、このようなwriteバリアを持つファイルシステムは、バッテリバックアップ付き装置
(<acronym class="acronym">BBU</acronym>)のディスクコントローラと組み合わせた際に、好ましい動作をしません。
このような処理の流れにおいて、同期コマンドはコントローラキャッシュにあるデータを全てディスクへ強制的に書き込みを行うため、
BBUのメリットの大半を失わせています。<a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a>プログラムを
使うことで、あなたの環境が影響を受けるかどうかを確認できます。もし影響を受けるようであれば、
ファイルシステムのwriteバリアを無効にするか、(オプションがあれば)ディスクコントローラを再設定することで、
BBUによる性能上の効果を得ることできるでしょう。もしwriteバリアを無効にした場合は、バッテリが
動作していることを確認しておきましょう。バッテリの欠陥はデータロスの可能性に繋がります。
ファイルシステムやディスクコントローラの設計者が、いずれはこの動作を修正してくれることが望まれます。
  </p><p>オペレーティングシステムが、ストレージハードウェアに書き込み要求を送信した時、データが不揮発性のストレージ領域に本当に届いたかどうかを確認することはほぼできません。
ですので、全てのストレージ構成品がデータとファイルシステムのメタデータの整合性を保証することをよく確認しておくことは、管理者の責任です。
バッテリバックアップされた書き込みキャッシュを持たないコントローラの使用は避けてください。
装置レベルでは、もし装置が停止前にデータが書き出されることを保証できないのであれば、write-backキャッシュを無効にしてください。
もしSSDを使っている場合、多くのドライブはデフォルトでキャッシュ書き出しコマンドを無視することに注意して下さい。
<a class="ulink" href="http://brad.livejournal.com/2116715.html" target="_top"><code class="filename">diskchecker.pl</code></a>を使うことで、I/Oサブシステムの動作の信頼性をテストすることができます。
  </p><p>ディスクプラッタの書き込み操作自体によってもデータ損失が発生することがあります。
ディスクプラッタは、通常512バイトのセクタに分割されています。
物理的な読み込み操作、書き込み操作はすべて、セクタ全体を処理します。
書き込み要求がディスクに達した時、その要求は512バイトの倍数になるでしょう(<span class="productname">PostgreSQL</span>では大抵一度に8192バイトすなわち16セクタを書き込みます)。そして電源断により、任意のタイミングで書き込み処理が失敗することがありえます。これは一部の512バイトのセクタに書き込みが行なわれたのに、残りのセクタには書き込みが行なわれていない状況を意味します。
こうした問題の対策として、<span class="productname">PostgreSQL</span>は、ディスク上の実際のページを変更する<span class="emphasis"><em>前</em></span>に定期的にページ全体のイメージを永続的なWAL格納領域に書き出します。
これにより、<span class="productname">PostgreSQL</span>はクラッシュリカバリ時に部分的に書き出されたページをWALから復旧させることができます。
もし、部分的なページ書き込みを防止できるファイルシステムソフトウェア（例えばZFS）を使うのであれば、<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>を無効にしてページイメージ作成を無効にすることができます。バッテリバックアップ付き（BBU）のディスクコントローラでは、フルページ（8kB）がBBUへ書き込まれることを保証できなければ、部分的なページ書き出しを防止できません。
  </p><p>さらに<span class="productname">PostgreSQL</span>は、ハードウェアエラーや経時変化によるメディア障害により発生する、ごみデータ読み書きしてしまうようなストレージ装置内のある種のデータ破損を防ぎます。
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>WALファイルのそれぞれのレコードは、レコードの内容が正確かどうかを伝えるためCRC-32 (32-bit)チェックにより保護されています。
CRCの値はそれぞれのWALレコードを書き込み、クラッシュ回復の過程で検証され、アーカイブの回復とレプリケーション時に設定されます。
     </p></li><li class="listitem"><p>今のところ、デフォルトではデータページはチェックサム計算はされませんが、WALレコードに記録されているページ全体のイメージは保護されます。
詳細は<a class="link" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS"><span class="application">initdb</span></a>を参照してください。
     </p></li><li class="listitem"><p><code class="filename">pg_xact</code>、<code class="filename">pg_subtrans</code>、<code class="filename">pg_multixact</code>、<code class="filename">pg_serial</code>、<code class="filename">pg_notify</code>、<code class="filename">pg_stat</code>、<code class="filename">pg_snapshots</code>のような内部データ構造は直接チェックサム計算もされず、全ページ書き込みによる保護もされていません。
しかし、そのようなデータ構造が持続する場所は、WALレコードはクラッシュ回復時に正確に最新の変更を行えるようWALレコードが書き出され、それらのWALレコードは上記のように保護されます。
     </p></li><li class="listitem"><p><code class="filename">pg_twophase</code>にある個別の状態ファイルはCRC-32で保護されています。
     </p></li><li class="listitem"><p>大きな問い合わせの中でソート、具現化、および中間結果用に使用される暫定的なデータファイルは現在チェックサム計算されず、それらのファイルに対する変更もWALレコードに書き込まれません。
     </p></li></ul></div><p>
  </p><p><span class="productname">PostgreSQL</span>は修復可能なメモリーエラーに対して保護を行いません。工業規格の誤り検出訂正（Error Correcting Codes -ECC-）またはバッテリー保護付きのRAM使用が想定されています。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="wal-intro.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 30. 信頼性とログ先行書き込み </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 30.2. ログ先行書き込み(<acronym class="acronym">WAL</acronym>)</td></tr></table></div></body></html>