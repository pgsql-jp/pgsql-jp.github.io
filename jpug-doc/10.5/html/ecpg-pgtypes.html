<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.6. pgtypes ライブラリ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ecpg-dynamic.html" title="35.5. 動的SQL" /><link rel="next" href="ecpg-descriptors.html" title="35.7. 記述子領域の使用" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.6. pgtypes ライブラリ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-dynamic.html" title="35.5. 動的SQL">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Chapter 35. ECPG - C言語による埋め込みSQL">Up</a></td><th width="60%" align="center">Chapter 35. <span xmlns="http://www.w3.org/1999/xhtml" class="application">ECPG</span> - C言語による埋め込み<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-descriptors.html" title="35.7. 記述子領域の使用">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ECPG-PGTYPES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.6. pgtypes ライブラリ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-CSTRINGS">35.6.1. Character Strings</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-NUMERIC">35.6.2. numeric 型</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-DATE">35.6.3. 日付型</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-TIMESTAMP">35.6.4. timestamp型</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-INTERVAL">35.6.5. interval型</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-DECIMAL">35.6.6. decimal型</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-ERRNO">35.6.7. pgtypeslibのerrno値</a></span></dt><dt><span class="sect2"><a href="ecpg-pgtypes.html#ECPG-PGTYPES-CONSTANTS">35.6.8. pgtypeslibの特殊な定数</a></span></dt></dl></div><p>pgtypesライブラリは<span class="productname">PostgreSQL</span>データベースの型をCプログラムで使用できるようにC言語に対応させます。
また、これらの型を使用したCの基本的な計算を行う関数も提供します。
この計算には、<span class="productname">PostgreSQL</span>サーバを使用しません。
以下の例を参照してください。
</p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&amp;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&amp;ts1, &amp;iv1, &amp;tsout);
out = PGTYPEStimestamp_to_asc(&amp;tsout);
printf("Started + duration: %s\n", out);
PGTYPESchar_free(out);</pre><p>
  </p><div class="sect2" id="ECPG-PGTYPES-CSTRINGS"><div class="titlepage"><div><div><h3 class="title">35.6.1. Character Strings</h3></div></div></div><p>   Some functions such as <code class="function">PGTYPESnumeric_to_asc</code> return
   a pointer to a freshly allocated character string. These results should be
   freed with <code class="function">PGTYPESchar_free</code> instead of
   <code class="function">free</code>. (This is important only on Windows, where
   memory allocation and release sometimes need to be done by the same
   library.)
   </p></div><div class="sect2" id="ECPG-PGTYPES-NUMERIC"><div class="titlepage"><div><div><h3 class="title">35.6.2. numeric 型</h3></div></div></div><p>numeric 型では任意の精度での計算機能を提供します。
<span class="productname">PostgreSQL</span>サーバにおける対応する型については<a class="xref" href="datatype-numeric.html" title="8.1. 数値データ型">Section 8.1</a>を参照してください。
任意の精度を持つために、この変数は動的に拡張、縮小できなければなりません。
これが、<code class="function">PGTYPESnumeric_new</code>や<code class="function">PGTYPESnumeric_free</code>関数では、ヒープ領域上にのみしか numeric 変数を作成できない理由です。
decimal 型も似ていますが精度が限定されていますので、ヒープ領域以外にスタック領域上でも作成可能です。
   </p><p>以下の関数は numeric 型で使用することができます:
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">PGTYPESnumeric_new</code></span></dt><dd><p>新規割当ての numeric 型へのポインタを要求します。
</p><pre class="synopsis">numeric *PGTYPESnumeric_new(void);</pre><p>
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_free</code></span></dt><dd><p>numeric 型を解放し、そのメモリをすべて解放します。
</p><pre class="synopsis">void PGTYPESnumeric_free(numeric *var);</pre><p>
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_from_asc</code></span></dt><dd><p>文字列表記から numeric 型に変換します。
</p><pre class="synopsis">numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);</pre><p>
有効な書式の例を示します。
<code class="literal">-2</code>、<code class="literal">.794</code>、<code class="literal">+3.44</code>、<code class="literal">592.49E07</code>、<code class="literal">-32.84e-4</code>。
値への変換に成功した場合、有効なポインタが返されます。
失敗した場合は NULL ポインタが返されます。
現在ECPGは文字列全体を解析しますので、現時点では<code class="literal">*endptr</code>内に最初の無効な文字のアドレスを格納することをサポートしません。
このため<code class="literal">endptr</code>を安全に NULL にすることができます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_to_asc</code></span></dt><dd><p>numeric 型<code class="literal">num</code>の文字列表現を持つ、<code class="function">malloc</code>で割り当てられた文字列へのポインタを返します。
</p><pre class="synopsis">char *PGTYPESnumeric_to_asc(numeric *num, int dscale);</pre><p>
numeric の値は、必要に応じて四捨五入され、<code class="literal">dscale</code> 桁の十進数で出力されます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_add</code></span></dt><dd><p>2つの numeric 変数を加算し、3番目の numeric 変数に格納します。
</p><pre class="synopsis">int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);</pre><p>
この関数は変数<code class="literal">var1</code>と変数<code class="literal">var2</code>を加算し、その結果を<code class="literal">result</code>に格納します。
成功時0を、エラー時-1を返します。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_sub</code></span></dt><dd><p>2つの numeric 型変数を減算し、3番目の numeric 型変数に結果を格納します。
</p><pre class="synopsis">int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);</pre><p>
この関数は変数<code class="literal">var1</code>から変数<code class="literal">var2</code>を差し引きます。
演算結果を変数<code class="literal">result</code>に格納します。
成功時0を、エラー時-1を返します。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_mul</code></span></dt><dd><p>2つの numeric 型変数を乗算し、3番目の numeric 型変数に結果を格納します。
</p><pre class="synopsis">int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);</pre><p>
この関数は変数<code class="literal">var1</code>と変数<code class="literal">var2</code>を掛け合わせます。
演算結果を変数<code class="literal">result</code>に格納します。
成功時0を、エラー時-1を返します。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_div</code></span></dt><dd><p>2つの numeric 型変数で除算し、3番目の numeric 型変数に結果を格納します。
</p><pre class="synopsis">int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);</pre><p>
この関数は変数<code class="literal">var1</code>を変数<code class="literal">var2</code>で割ります。
演算結果を変数<code class="literal">result</code>に格納します。
成功時0を、エラー時-1を返します。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_cmp</code></span></dt><dd><p>2つのnumeric型変数を比較します。
</p><pre class="synopsis">int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)</pre><p>
この関数は2つのnumeric型変数を比較します。
エラーの場合<code class="literal">INT_MAX</code>が返ります。
成功時、この関数は以下のいずれかを返します:
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>          <code class="literal">var1</code>が<code class="literal">var2</code>より大きければ1。
         </p></li><li class="listitem"><p>          <code class="literal">var1</code>が<code class="literal">var2</code>より小さければ-1。
         </p></li><li class="listitem"><p>          <code class="literal">var1</code>が<code class="literal">var2</code>と等しければ0。
         </p></li></ul></div><p>
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_from_int</code></span></dt><dd><p>int型変数をnumeric型変数に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_from_int(signed int int_val, numeric *var);</pre><p>
この関数はsigned int型の変数を受付け、numeric型変数<code class="literal">var</code>内に格納します。
成功時0、失敗時-1が返ります。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_from_long</code></span></dt><dd><p>long int型変数をnumeric型変数に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);</pre><p>
この関数は符号付long int型の変数を受付け、numeric 型変数<code class="literal">var</code>内に格納します。
成功時0、失敗時-1が返ります。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_copy</code></span></dt><dd><p>numeric 型変数を他の numeric 型変数にコピーします。
</p><pre class="synopsis">int PGTYPESnumeric_copy(numeric *src, numeric *dst);</pre><p>
この関数は、<code class="literal">src</code>が指し示す変数の値を<code class="literal">dst</code>が指し示す変数にコピーします。
成功時0、失敗時-1が返ります。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_from_double</code></span></dt><dd><p>double型の変数を numeric 型変数に変換します。
</p><pre class="synopsis">int  PGTYPESnumeric_from_double(double d, numeric *dst);</pre><p>
この関数はdouble型の変数を受付け、変換結果を<code class="literal">dst</code>が指し示す変数内に格納します。
成功時0、失敗時-1が返ります。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_to_double</code></span></dt><dd><p>numeric 型変数をdouble型に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_to_double(numeric *nv, double *dp)</pre><p>
この関数は<code class="literal">nv</code>が指し示す numeric 型変数の値を<code class="literal">dp</code>が指し示すdouble型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<code class="literal">errno</code>は<code class="literal">PGTYPES_NUM_OVERFLOW</code>に設定されます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_to_int</code></span></dt><dd><p>numeric 型変数をint型に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_to_int(numeric *nv, int *ip);</pre><p>
この関数は<code class="literal">nv</code>が指し示す numeric 型変数の値を<code class="literal">ip</code>が指し示す整数型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<code class="literal">errno</code>は<code class="literal">PGTYPES_NUM_OVERFLOW</code>に設定されます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_to_long</code></span></dt><dd><p>numeric 型変数をlong型に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_to_long(numeric *nv, long *lp);</pre><p>
この関数は<code class="literal">nv</code>が指し示す numeric 型変数の値を<code class="literal">lp</code>が指し示すlong変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<code class="literal">errno</code>は<code class="literal">PGTYPES_NUM_OVERFLOW</code>に設定されます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_to_decimal</code></span></dt><dd><p>numeric 型変数を decimal 型に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);</pre><p>
この関数は<code class="literal">src</code>が指し示す numeric 型変数の値を<code class="literal">dst</code>が指し示す decimal 型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<code class="literal">errno</code>は<code class="literal">PGTYPES_NUM_OVERFLOW</code>に設定されます。
      </p></dd><dt><span class="term"><code class="function">PGTYPESnumeric_from_decimal</code></span></dt><dd><p>decimal 型変数を numeric 型に変換します。
</p><pre class="synopsis">int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);</pre><p>
この関数は<code class="literal">src</code>が指し示す decimal 型変数の値を<code class="literal">dst</code>が指し示す numeric 型変数に変換します。
成功時0、エラーが発生した時-1が返ります。
decimal 型は制限付の numeric 型として実装されていますので、この変換ではオーバーフローは起きません。
      </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-DATE"><div class="titlepage"><div><div><h3 class="title">35.6.3. 日付型</h3></div></div></div><p>Cの日付型を使用して、プログラムからSQLの日付型を取り扱うことができます。
<span class="productname">PostgreSQL</span>サーバにおける対応する型については<a class="xref" href="datatype-datetime.html" title="8.5. 日付/時刻データ型">Section 8.5</a>を参照してください。
   </p><p>日付型を操作するために以下の関数を使用することができます:
    </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESDATEFROMTIMESTAMP"><span class="term"><code class="function">PGTYPESdate_from_timestamp</code></span></dt><dd><p>タイムスタンプから日付部分を取り出します。
</p><pre class="synopsis">date PGTYPESdate_from_timestamp(timestamp dt);</pre><p>
この関数は唯一の引数としてタイムスタンプを受付け、そこから日付部分を取り出します。
       </p></dd><dt id="PGTYPESDATEFROMASC"><span class="term"><code class="function">PGTYPESdate_from_asc</code></span></dt><dd><p>テキスト表現から日付型に変換します。
</p><pre class="synopsis">date PGTYPESdate_from_asc(char *str, char **endptr);</pre><p>
この関数はCのchar*型文字列<code class="literal">str</code>とCのchar*型文字列<code class="literal">endptr</code>へのポインタを受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<code class="literal">*endptr</code>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<code class="literal">endptr</code>を安全にNULLにすることができます。
       </p><p>この関数が常にMDY書式の日付を前提としている点に注意してください。
現在ECPGにはこれを変更するための変数がありません。
       </p><p>        <a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FROM-ASC-TABLE" title="Table 35.2. 有効なPGTYPESdate_from_ascの入力書式">Table 35.2</a>に許される入力書式を示します。
       </p><div class="table" id="ECPG-PGTYPESDATE-FROM-ASC-TABLE"><p class="title"><strong>Table 35.2. 有効な<code class="function">PGTYPESdate_from_asc</code>の入力書式</strong></p><div class="table-contents"><table class="table" summary="有効なPGTYPESdate_from_ascの入力書式" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>入力</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">January 8, 1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1999-01-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1/8/1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">1/18/1999</code></td><td><code class="literal">January 18, 1999</code></td></tr><tr><td><code class="literal">01/02/03</code></td><td><code class="literal">February 1, 2003</code></td></tr><tr><td><code class="literal">1999-Jan-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">Jan-08-1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-1999</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">99-Jan-08</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-99</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">08-Jan-06</code></td><td><code class="literal">January 8, 2006</code></td></tr><tr><td><code class="literal">Jan-08-99</code></td><td><code class="literal">January 8, 1999</code></td></tr><tr><td><code class="literal">19990108</code></td><td><code class="literal">ISO 8601; January 8, 1999</code></td></tr><tr><td><code class="literal">990108</code></td><td><code class="literal">ISO 8601; January 8, 1999</code></td></tr><tr><td><code class="literal">1999.008</code></td><td><code class="literal">年と年内日数</code></td></tr><tr><td><code class="literal">J2451187</code></td><td><code class="literal">Jユリウス日</code></td></tr><tr><td><code class="literal">January 8, 99 BC</code></td><td><code class="literal">紀元前99年</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESDATETOASC"><span class="term"><code class="function">PGTYPESdate_to_asc</code></span></dt><dd><p>        日付型変数のテキスト表現を返します。
</p><pre class="synopsis">char *PGTYPESdate_to_asc(date dDate);</pre><p>
この関数は唯一の引数として日付型<code class="literal">dDate</code>を受付けます。
この関数は<code class="literal">1999-01-18</code>、つまり<code class="literal">YYYY-MM-DD</code>書式で日付を出力します。
       </p></dd><dt id="PGTYPESDATEJULMDY"><span class="term"><code class="function">PGTYPESdate_julmdy</code></span></dt><dd><p>        日付型の変数から、日、月、年の値を取り出します。
</p><pre class="synopsis">void PGTYPESdate_julmdy(date d, int *mdy);</pre><p>
       
この関数は日付型の<code class="literal">d</code>と、3つの整数値を持つ配列<code class="literal">mdy</code>へのポインタを受付けます。
この変数名はその並びを表し、<code class="literal">mdy[0]</code>には月数、<code class="literal">mdy[1]</code>には日数が、<code class="literal">mdy[2]</code>には年が入ります。
       </p></dd><dt id="PGTYPESDATEMDYJUL"><span class="term"><code class="function">PGTYPESdate_mdyjul</code></span></dt><dd><p>日付の日、月、年を指定した3つの整数からなる配列から日付値を作成します。
</p><pre class="synopsis">void PGTYPESdate_mdyjul(int *mdy, date *jdate);</pre><p>
この関数は、1番目の引数として3つの整数からなる配列(<code class="literal">mdy</code>)、2番目の引数として処理結果を格納する日付型の変数へのポインタを受付けます。
       </p></dd><dt id="PGTYPESDATEDAYOFWEEK"><span class="term"><code class="function">PGTYPESdate_dayofweek</code></span></dt><dd><p>日付値から週内日数を表す数を返します。
</p><pre class="synopsis">int PGTYPESdate_dayofweek(date d);</pre><p>
この関数は唯一の引数としてdate型変数<code class="literal">d</code>を受付け、その日付の週内日数を表す整数を返します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           0 - 日曜
          </p></li><li class="listitem"><p>           1 - 月曜
          </p></li><li class="listitem"><p>           2 - 火曜
          </p></li><li class="listitem"><p>           3 - 水曜
          </p></li><li class="listitem"><p>           4 - 木曜
          </p></li><li class="listitem"><p>           5 - 金曜
          </p></li><li class="listitem"><p>           6 - 土曜
          </p></li></ul></div><p>
       </p></dd><dt id="PGTYPESDATETODAY"><span class="term"><code class="function">PGTYPESdate_today</code></span></dt><dd><p>現在の日付を取得します。
</p><pre class="synopsis">void PGTYPESdate_today(date *d);</pre><p>
この関数は現在の日付に設定されるdate型変数(<code class="literal">d</code>)を指し示すポインタを受付けます。
       </p></dd><dt id="PGTYPESDATEFMTASC"><span class="term"><code class="function">PGTYPESdate_fmt_asc</code></span></dt><dd><p>date型変数を書式マスクを使用したテキスト表現に変換します。
</p><pre class="synopsis">int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);</pre><p>
この関数は変換対象のdate型(<code class="literal">dDate</code>)、書式マスク(<code class="literal">fmtstring</code>)、日付のテキスト表現を格納するための文字列(<code class="literal">outbuf</code>)を受付けます。
       </p><p>成功時に0、エラーが発生した場合は負の値が返ります。
       </p><p>以下のリテラルを使用して、フィールドを指定することができます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           <code class="literal">dd</code> - 月内の日数。
          </p></li><li class="listitem"><p>           <code class="literal">mm</code> - 年内の月数。
          </p></li><li class="listitem"><p>           <code class="literal">yy</code> - 二桁表記の年数
          </p></li><li class="listitem"><p>           <code class="literal">yyyy</code> - 四桁表記の年数
          </p></li><li class="listitem"><p>           <code class="literal">ddd</code> - 曜日の名前（省略形）
          </p></li><li class="listitem"><p>           <code class="literal">mmm</code> - 月の名前（省略形）
          </p></li></ul></div><p>
他の文字はすべて出力文字列にそのままコピーされます。
       </p><p><a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE" title="Table 35.3. 有効なPGTYPESdate_fmt_ascの入力書式">Table 35.3</a>にいくつかの可能性のある書式を示します。
この関数の使用方法に関するアイディアを提供しています。
出力行はすべて同じ日付、1959年11月23日に基づいています。
       </p><div class="table" id="ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE"><p class="title"><strong>Table 35.3. 有効な<code class="function">PGTYPESdate_fmt_asc</code>の入力書式</strong></p><div class="table-contents"><table class="table" summary="有効なPGTYPESdate_fmt_ascの入力書式" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>書式</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">mmddyy</code></td><td><code class="literal">112359</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">231159</code></td></tr><tr><td><code class="literal">yymmdd</code></td><td><code class="literal">591123</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">59/11/23</code></td></tr><tr><td><code class="literal">yy mm dd</code></td><td><code class="literal">59 11 23</code></td></tr><tr><td><code class="literal">yy.mm.dd</code></td><td><code class="literal">59.11.23</code></td></tr><tr><td><code class="literal">.mm.yyyy.dd.</code></td><td><code class="literal">.11.1959.23.</code></td></tr><tr><td><code class="literal">mmm. dd, yyyy</code></td><td><code class="literal">Nov. 23, 1959</code></td></tr><tr><td><code class="literal">mmm dd yyyy</code></td><td><code class="literal">Nov 23 1959</code></td></tr><tr><td><code class="literal">yyyy dd mm</code></td><td><code class="literal">1959 23 11</code></td></tr><tr><td><code class="literal">ddd, mmm. dd, yyyy</code></td><td><code class="literal">Mon, Nov. 23, 1959</code></td></tr><tr><td><code class="literal">(ddd) mmm. dd, yyyy</code></td><td><code class="literal">(Mon) Nov. 23, 1959</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESDATEDEFMTASC"><span class="term"><code class="function">PGTYPESdate_defmt_asc</code></span></dt><dd><p>書式マスクを使用してCの<code class="type">char*</code>文字列からdate型の値に変換します。
</p><pre class="synopsis">int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);</pre><p>
        
この関数は、処理結果を格納するための日付型へのポインタ(<code class="literal">d</code>)、日付を解析するための書式マスク(<code class="literal">fmt</code>)、日付のテキスト表現を含むCのchar*文字列(<code class="literal">str</code>)を受付けます。
テキスト表現は書式マスクに合った表現であることが仮定されています。
しかし、文字列と書式マスクを1:1に対応付けする必要はありません。
この関数は並んだ順番に解析し、年の位置を表す<code class="literal">yy</code>または<code class="literal">yyyy</code>を、月の位置を表す<code class="literal">mm</code>を、日の位置を表す<code class="literal">dd</code>を検索します。
       </p><p><a class="xref" href="ecpg-pgtypes.html#ECPG-RDEFMTDATE-EXAMPLE-TABLE" title="Table 35.4. 有効なrdefmtdateの入力書式">Table 35.4</a>はいくつかの可能性のある書式を示します。
これはこの関数の使用方法に関するアイディアを提供します。
       </p><div class="table" id="ECPG-RDEFMTDATE-EXAMPLE-TABLE"><p class="title"><strong>Table 35.4. 有効な<code class="function">rdefmtdate</code>の入力書式</strong></p><div class="table-contents"><table class="table" summary="有効なrdefmtdateの入力書式" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>書式</th><th>文字列</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">21-2-54</code></td><td><code class="literal">1954-02-21</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">2-12-54</code></td><td><code class="literal">1954-12-02</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">20111954</code></td><td><code class="literal">1954-11-20</code></td></tr><tr><td><code class="literal">ddmmyy</code></td><td><code class="literal">130464</code></td><td><code class="literal">1964-04-13</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">MAR-12-1967</code></td><td><code class="literal">1967-03-12</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">1954, February 3rd</code></td><td><code class="literal">1954-02-03</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">041269</code></td><td><code class="literal">1969-04-12</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">In the year 2525, in the month of July, mankind will be alive on the 28th day</code></td><td><code class="literal">2525-07-28</code></td></tr><tr><td><code class="literal">dd-mm-yy</code></td><td><code class="literal">I said on the 28th of July in the year 2525</code></td><td><code class="literal">2525-07-28</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">9/14/58</code></td><td><code class="literal">1958-09-14</code></td></tr><tr><td><code class="literal">yy/mm/dd</code></td><td><code class="literal">47/03/29</code></td><td><code class="literal">1947-03-29</code></td></tr><tr><td><code class="literal">mmm.dd.yyyy</code></td><td><code class="literal">oct 28 1975</code></td><td><code class="literal">1975-10-28</code></td></tr><tr><td><code class="literal">mmddyy</code></td><td><code class="literal">Nov 14th, 1985</code></td><td><code class="literal">1985-11-14</code></td></tr></tbody></table></div></div><br class="table-break" /></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-TIMESTAMP"><div class="titlepage"><div><div><h3 class="title">35.6.4. timestamp型</h3></div></div></div><p>Cのタイムスタンプ型を使用してプログラムからSQLのタイムスタンプ型データを扱うことができます。
<span class="productname">PostgreSQL</span>における対応する型については<a class="xref" href="datatype-datetime.html" title="8.5. 日付/時刻データ型">Section 8.5</a>を参照してください。
   </p><p>以下の関数を使用してタイムスタンプ型を扱うことができます:
    </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESTIMESTAMPFROMASC"><span class="term"><code class="function">PGTYPEStimestamp_from_asc</code></span></dt><dd><p>テキスト表現のタイムスタンプをタイムスタンプ型変数に変換します。
</p><pre class="synopsis">timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);</pre><p>
この関数は変換対象の文字列(<code class="literal">str</code>)とC char*へのポインタ(<code class="literal">endptr</code>)を受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<code class="literal">*endptr</code>に最初の無効な文字の場所を格納をすることサポートしません。
このため<code class="literal">endptr</code>を安全に NULL にすることができます。
       </p><p>この関数は成功時変換後のタイムスタンプを返します。
エラー時、<code class="literal">PGTYPESInvalidTimestamp</code>が返され、<code class="varname">errno</code>が<code class="literal">PGTYPES_TS_BAD_TIMESTAMP</code>に設定されます。
この値についての重要な注意書きについて<a class="xref" href="ecpg-pgtypes.html#PGTYPESINVALIDTIMESTAMP"><code class="literal">PGTYPESInvalidTimestamp</code></a>を参照してください。
       </p><p>通常、入力文字列には許される日付指定の任意の組み合わせ、空白文字、許される時間指定を含むことができます。
時間帯はECPGでサポートされていない点に注意してください。
変換することはできますが、例えば<span class="productname">PostgreSQL</span>サーバが行うような計算を行うことはできません。
時間帯指定は警告無しに無視されます。
       </p><p><a class="xref" href="ecpg-pgtypes.html#ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE" title="Table 35.5. 有効なPGTYPEStimestamp_from_ascの入力書式">Table 35.5</a>に入力文字列の例をいくつか示します。
       </p><div class="table" id="ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE"><p class="title"><strong>Table 35.5. 有効な<code class="function">PGTYPEStimestamp_from_asc</code>の入力書式</strong></p><div class="table-contents"><table class="table" summary="有効なPGTYPEStimestamp_from_ascの入力書式" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>入力</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">1999-01-08 04:05:06</code></td><td><code class="literal">1999-01-08 04:05:06</code></td></tr><tr><td><code class="literal">January 8 04:05:06 1999 PST</code></td><td><code class="literal">1999-01-08 04:05:06</code></td></tr><tr><td><code class="literal">1999-Jan-08 04:05:06.789-8</code></td><td><code class="literal">1999-01-08 04:05:06.789 (時間帯指定は無視されます。)</code></td></tr><tr><td><code class="literal">J2451187 04:05-08:00</code></td><td><code class="literal">1999-01-08 04:05:00 (時間帯指定は無視されます。)</code></td></tr></tbody></table></div></div><br class="table-break" /></dd><dt id="PGTYPESTIMESTAMPTOASC"><span class="term"><code class="function">PGTYPEStimestamp_to_asc</code></span></dt><dd><p>date型をC char*文字列に変換します。
</p><pre class="synopsis">char *PGTYPEStimestamp_to_asc(timestamp tstamp);</pre><p>
この関数はtimestamp型の<code class="literal">tstamp</code>を唯一の引数として受付け、timestamp型のテキスト表現を含む割り当てられた文字列を返します。
       </p></dd><dt id="PGTYPESTIMESTAMPCURRENT"><span class="term"><code class="function">PGTYPEStimestamp_current</code></span></dt><dd><p>現在のタイムスタンプを取り出します。
</p><pre class="synopsis">void PGTYPEStimestamp_current(timestamp *ts);</pre><p>
この関数は現在のタイムスタンプを取り出し、<code class="literal">ts</code>が指し示すtimestamp型変数に格納します。
       </p></dd><dt id="PGTYPESTIMESTAMPFMTASC"><span class="term"><code class="function">PGTYPEStimestamp_fmt_asc</code></span></dt><dd><p>書式マスクを使用してtimestamp型変数をC char*に変換します。
</p><pre class="synopsis">int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);</pre><p>
この関数は、最初の引数として変換対象のtimestamp型 (<code class="literal">ts</code>)を、出力バッファのポインタ(<code class="literal">output</code>)、出力バッファで割当て可能な最大長 (<code class="literal">str_len</code>)、変換に使用する書式マスク(<code class="literal">fmtstr</code>)を受付けます。
       </p><p>成功するとこの関数は0を返します。
エラーが発生した場合は負の値が返ります。
       </p><p>書式マスクには以下の書式指定を使用することができます。
書式指定は<span class="productname">libc</span>の<code class="function">strftime</code>関数で使用されるものと同じです。
書式指定以外は出力バッファにコピーされます。
        
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">%A</code> - 各言語の曜日名称に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%a</code> - 各言語の曜日略称に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%B</code> - 各言語の月名称に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%b</code> - 各言語の月略称に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%C</code> - 年を100で割った10進数に置換されます。1桁の場合は先頭に0が付与されます。
          </p></li><li class="listitem"><p><code class="literal">%c</code> - 各言語の日付時刻表現に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%D</code> - <code class="literal">%m/%d/%y</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%d</code> - 月内の10進日数(01-31)に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%E*</code> <code class="literal">%O*</code> - POSIXロケール拡張です。
           <code class="literal">%Ec</code>
           <code class="literal">%EC</code>
           <code class="literal">%Ex</code>
           <code class="literal">%EX</code>
           <code class="literal">%Ey</code>
           <code class="literal">%EY</code>
           <code class="literal">%Od</code>
           <code class="literal">%Oe</code>
           <code class="literal">%OH</code>
           <code class="literal">%OI</code>
           <code class="literal">%Om</code>
           <code class="literal">%OM</code>
           <code class="literal">%OS</code>
           <code class="literal">%Ou</code>
           <code class="literal">%OU</code>
           <code class="literal">%OV</code>
           <code class="literal">%Ow</code>
           <code class="literal">%OW</code>
           <code class="literal">%Oy</code>
という並びは別の表現を提供するものと仮定されています。
          </p><p>さらに、<code class="literal">%OB</code>は、（日に関する仕様がない単体で使用される）別の月名を表すものとして実装されています。
          </p></li><li class="listitem"><p><code class="literal">%e</code> - 月内10進日数(1-31)に置換されます。1桁の場合は前に空白が付けられます。
          </p></li><li class="listitem"><p><code class="literal">%F</code> - <code class="literal">%Y-%m-%d</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%G</code> - 世紀付の10進数として年に置換されます。
この年は週の部分がより多く含まれます。（月曜が週の最初の日です。）
          </p></li><li class="listitem"><p><code class="literal">%g</code> -<code class="literal">%G</code>同様に年に置換されますが、世紀の部分を除く10進数(00-99)になります。
          </p></li><li class="listitem"><p><code class="literal">%H</code> - 10進の時間(24時間単位)に置換されます(00-23)。
          </p></li><li class="listitem"><p>           <code class="literal">%h</code> - <code class="literal">%b</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%I</code> - 10進の時間（12時間単位）に置換されます(01-12)。
          </p></li><li class="listitem"><p><code class="literal">%j</code> - 10進の年内日数に置換されます(001-366)。
          </p></li><li class="listitem"><p><code class="literal">%k</code> - 10進の時間(24時間単位)に置換されます(0-23)。1桁の場合は先頭に空白が付けられます。
          </p></li><li class="listitem"><p><code class="literal">%l</code> - 10進の時間（12時間単位）に置換されます(1-12)。1桁の場合は先頭に空白が付けられます。
          </p></li><li class="listitem"><p><code class="literal">%M</code> - 10進の分数に置換されます(00-59)。
          </p></li><li class="listitem"><p><code class="literal">%m</code> -10進の月数に置換されます(01-12)。
          </p></li><li class="listitem"><p><code class="literal">%n</code> - 改行に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%O*</code> - <code class="literal">%E*</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%p</code> - 各言語の"午前"または"午後"に適切に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%R</code> - <code class="literal">%H:%M</code>と同じです。
          </p></li><li class="listitem"><p>           <code class="literal">%r</code> - <code class="literal">%I:%M:%S %p</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%S</code> - 10進の秒数に置換されます(00-60)。
          </p></li><li class="listitem"><p><code class="literal">%s</code> - エポック、UTCからの秒数に置換されます。
          </p></li><li class="listitem"><p>           <code class="literal">%T</code> - <code class="literal">%H:%M:%S</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%t</code> - タブに置換されます。
          </p></li><li class="listitem"><p>           <code class="literal">%U</code> - 10進の週番号（日曜が週の先頭です）に置換されます。
          </p></li><li class="listitem"><p>           <code class="literal">%u</code> - 10進の週番号（月曜が週の先頭です）に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%V</code> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(01-53)。
新しい年で、1月1日を含む週が4日以上存在する場合、その週が1となります。
さもなくば、この週は前年の週となり、次の週が1となります。
          </p></li><li class="listitem"><p>           <code class="literal">%v</code> - <code class="literal">%e-%b-%Y</code>と同じです。
          </p></li><li class="listitem"><p><code class="literal">%W</code> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(00-53)。
          </p></li><li class="listitem"><p><code class="literal">%w</code> - 10進の週内日数（日曜が週の先頭です）に置換されます(0-6)。
          </p></li><li class="listitem"><p><code class="literal">%X</code> - 各言語の時間表現に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%x</code> - 各言語の日付表現に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%Y</code> - 10進の世紀付年に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%y</code> - 10進の世紀なし年に置換されます(00-99)。
          </p></li><li class="listitem"><p><code class="literal">%Z</code> - 時間帯名称に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%z</code> - UTCからの時間帯オフセットに置換されます。
UTCより東では正符号が先頭に付き、西では負符号が付きます。
それぞれ2桁の時間と分がその後に続きますが、その区切りはありません。（この形式はRFC 822の日付ヘッダでよく使用されます。）
          </p></li><li class="listitem"><p><code class="literal">%+</code> - 各言語の日付時刻表現に置換されます。
          </p></li><li class="listitem"><p><code class="literal">%-*</code> - GNU libc拡張です。数値出力を行う際に何も文字を詰めません。
          </p></li><li class="listitem"><p>$_* - GNU libcの拡張です。明示的に空白文字を使用して文字を詰めます。
          </p></li><li class="listitem"><p><code class="literal">%0*</code> - GNU libcの拡張です。明示的に0を使用して文字を詰めます。
          </p></li><li class="listitem"><p>           <code class="literal">%%</code> - <code class="literal">%</code>に置換されます。
          </p></li></ul></div><p>
       </p></dd><dt id="PGTYPESTIMESTAMPSUB"><span class="term"><code class="function">PGTYPEStimestamp_sub</code></span></dt><dd><p>タイムスタンプの減算を行い、その結果をinterval型の変数に格納します。
</p><pre class="synopsis">int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);</pre><p>
この関数は<code class="literal">ts1</code>が指し示すタイムスタンプ型変数から<code class="literal">ts2</code>が指し示すタイムスタンプ型変数を差し引き、<code class="literal">iv</code>が指し示すinterval型変数に結果を格納します。
       </p><p>成功すると、この関数は0を返し、エラーが発生した場合は負の値を返します。
       </p></dd><dt id="PGTYPESTIMESTAMPDEFMTASC"><span class="term"><code class="function">PGTYPEStimestamp_defmt_asc</code></span></dt><dd><p>書式マスクを使用して、テキスト表現からtimestamp値へ変換します。
</p><pre class="synopsis">int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);</pre><p>
この関数は<code class="literal">str</code>変数内に格納されたタイムスタンプのテキスト表現、<code class="literal">fmt</code>変数内に格納された使用される書式マスクを受付けます。
結果は<code class="literal">d</code>が指し示す変数内に格納されます。
       </p><p>書式マスク<code class="literal">fmt</code>が NULL ならば、この関数はデフォルトの書式マスク<code class="literal">%Y-%m-%d %H:%M:%S</code>を使用するようになります。
       </p><p>これは<a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"><code class="function">PGTYPEStimestamp_fmt_asc</code></a>関数の逆です。
使用できる書式マスク項目についてはその文書を参照してください。
       </p></dd><dt id="PGTYPESTIMESTAMPADDINTERVAL"><span class="term"><code class="function">PGTYPEStimestamp_add_interval</code></span></dt><dd><p>timestamp型変数にinterval型変数を加算します。
</p><pre class="synopsis">int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);</pre><p>
この関数はtimestamp型変数<code class="literal">tin</code>へのポインタとinterval型変数<code class="literal">span</code>へのポインタを受付けます。
これは、interval値をtimestamp値に加算し、その結果のtimestamp値を<code class="literal">tout</code>が指し示す変数に格納します。
       </p><p>成功するとこの関数は0を返します。
エラーが発生した場合は負の値を返します。
       </p></dd><dt id="PGTYPESTIMESTAMPSUBINTERVAL"><span class="term"><code class="function">PGTYPEStimestamp_sub_interval</code></span></dt><dd><p>timestamp型変数からinterval型変数の値を引きます。
</p><pre class="synopsis">int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);</pre><p>
この関数は<code class="literal">tin</code>が指し示すtimestamp型変数から<code class="literal">span</code>が指し示すinterval型変数を引きます。
結果は<code class="literal">tout</code>が指し示す変数に保存されます。
       </p><p>成功するとこの関数は0を、エラーが発生した場合は負の値を返します。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-INTERVAL"><div class="titlepage"><div><div><h3 class="title">35.6.5. interval型</h3></div></div></div><p>Cにおけるinterval型を用いることにより、プログラムからSQLのinterval型のデータを扱うことができます。
<span class="productname">PostgreSQL</span>サーバにおける対応する型については<a class="xref" href="datatype-datetime.html" title="8.5. 日付/時刻データ型">Section 8.5</a>を参照してください。
   </p><p>以下の関数を使用して、interval型を扱うことができます。
    </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESINTERVALNEW"><span class="term"><code class="function">PGTYPESinterval_new</code></span></dt><dd><p>新しく割り当てたinterval型変数へのポインタを返します。
</p><pre class="synopsis">interval *PGTYPESinterval_new(void);</pre><p>
       </p></dd><dt id="PGTYPESINTERVALFREE"><span class="term"><code class="function">PGTYPESinterval_free</code></span></dt><dd><p>以前に割り当てられたinterval型変数のメモリを解放します。
</p><pre class="synopsis">void PGTYPESinterval_new(interval *intvl);</pre><p>
       </p></dd><dt id="PGTYPESINTERVALFROMASC"><span class="term"><code class="function">PGTYPESinterval_from_asc</code></span></dt><dd><p>テキスト表現からinterval型に変換します。
</p><pre class="synopsis">interval *PGTYPESinterval_from_asc(char *str, char **endptr);</pre><p>
この関数は入力文字列<code class="literal">str</code>を変換し、割当てられたinterval型へのポインタを返します。
現在ECPGは文字列全体を解析しますので、現時点では<code class="literal">*endptr</code>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<code class="literal">endptr</code>を安全に NULL にすることができます。
       </p></dd><dt id="PGTYPESINTERVALTOASC"><span class="term"><code class="function">PGTYPESinterval_to_asc</code></span></dt><dd><p>interval型変数をテキスト表現に変換します。
</p><pre class="synopsis">char *PGTYPESinterval_to_asc(interval *span);</pre><p>
この関数は<code class="literal">span</code>が指し示すinterval型変数をC char*に変換します。
出力は<code class="literal">@ 1 day 12 hours 59 mins 10 secs</code>のようになります。
       </p></dd><dt id="PGTYPESINTERVALCOPY"><span class="term"><code class="function">PGTYPESinterval_copy</code></span></dt><dd><p>interval型変数をコピーします。
</p><pre class="synopsis">int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);</pre><p>
この関数は、<code class="literal">intvlsrc</code>が指し示すinterval型変数を <code class="literal">intvldest</code>が指し示す変数にコピーします。
事前に格納先の変数用のメモリを割り当てる必要があることに注意してください。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-DECIMAL"><div class="titlepage"><div><div><h3 class="title">35.6.6. decimal型</h3></div></div></div><p>decimal型はnumeric型に似ています。
しかし、その最大精度は30有効桁に制限されています。
ヒープ上にしか作成できないnumeric型と比べ、decimal型はスタックまたはヒープ上に作成することができます。
（このためには<code class="function">PGTYPESdecimal_new</code>および<code class="function">PGTYPESdecimal_free</code>関数を使用します。）
<a class="xref" href="ecpg-informix-compat.html" title="35.15. Informix互換モード">Section 35.15</a>で説明する<span class="productname">Informix</span>互換モードではdecimal型を扱う関数がより多く存在します。
   </p><p>以下の関数を使用してdecimal型を扱うことができます。
これらは<code class="literal">libcompat</code>ライブラリに含まれるものだけではありません。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">PGTYPESdecimal_new</code></span></dt><dd><p>新しく割り当てられたdecimal型変数へのポインタを要求します。
</p><pre class="synopsis">decimal *PGTYPESdecimal_new(void);</pre><p>
       </p></dd><dt><span class="term"><code class="function">PGTYPESdecimal_free</code></span></dt><dd><p>decimal型を解放し、そのメモリをすべて解放します。
</p><pre class="synopsis">void PGTYPESdecimal_free(decimal *var);</pre><p>
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-ERRNO"><div class="titlepage"><div><div><h3 class="title">35.6.7. pgtypeslibのerrno値</h3></div></div></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">PGTYPES_NUM_BAD_NUMERIC</code></span></dt><dd><p>引数はnumeric型変数（またはnumeric型変数へのポインタ）を含んでいるはずですが、実際のメモリ上の表現は無効でした。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_NUM_OVERFLOW</code></span></dt><dd><p>オーバーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではオーバーフローが発生する可能性があります。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_NUM_UNDERFLOW</code></span></dt><dd><p>アンダーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではアンダーフローが発生する可能性があります。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_NUM_DIVIDE_ZERO</code></span></dt><dd><p>ゼロ除算をしようとしました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_BAD_DATE</code></span></dt><dd><p><code class="function">PGTYPESdate_from_asc</code>関数に無効な日付文字列が渡されました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_ERR_EARGS</code></span></dt><dd><p><code class="function">PGTYPESdate_defmt_asc</code>関数に無効な引数が渡されました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_ERR_ENOSHORTDATE</code></span></dt><dd><p><code class="function">PGTYPESdate_defmt_asc</code>関数により入力文字列内に無効なトークンが見つかりました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_INTVL_BAD_INTERVAL</code></span></dt><dd><p><code class="function">PGTYPESinterval_from_asc</code>関数に無効な内部文字列が渡されました。
もしくは<code class="function">PGTYPESinterval_to_asc</code>関数に無効な内部値が渡されました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_ERR_ENOTDMY</code></span></dt><dd><p><code class="function">PGTYPESdate_defmt_asc</code>関数内の日/月/年の代入において不整合がありました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_BAD_DAY</code></span></dt><dd><p><code class="function">PGTYPESdate_defmt_asc</code>関数により無効な月内日数が見つかりました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_DATE_BAD_MONTH</code></span></dt><dd><p><code class="function">PGTYPESdate_defmt_asc</code>関数によって無効な月値が見つかりました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_TS_BAD_TIMESTAMP</code></span></dt><dd><p><code class="function">PGTYPEStimestamp_from_asc</code>関数に無効なタイムスタンプ文字列が渡されました。
もしくは<code class="function">PGTYPEStimestamp_to_asc</code>関数に無効なtimestamp値が渡されました。
       </p></dd><dt><span class="term"><code class="literal">PGTYPES_TS_ERR_EINFTIME</code></span></dt><dd><p>コンテキスト内で扱うことができない、無限なタイムスタンプ値がありました。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-PGTYPES-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">35.6.8. pgtypeslibの特殊な定数</h3></div></div></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt id="PGTYPESINVALIDTIMESTAMP"><span class="term"><code class="literal">PGTYPESInvalidTimestamp</code></span></dt><dd><p>無効なタイムスタンプを表すtimestamp型の値です。
これは解析エラーの場合に<code class="function">PGTYPEStimestamp_from_asc</code>関数によって返されます。
<code class="type">timestamp</code>データ型の内部表現のため、<code class="literal">PGTYPESInvalidTimestamp</code>はまた同時に有効なタイムスタンプでもあります。
これは<code class="literal">1899-12-31 23:59:59</code>に設定されます。
エラーを検知するためには、<code class="function">PGTYPEStimestamp_from_asc</code>を呼び出す度にその後、<code class="literal">PGTYPESInvalidTimestamp</code>を試験するだけではなく、<code class="literal">errno != 0</code>も試験してください。
       </p></dd></dl></div><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-dynamic.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-descriptors.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">35.5. 動的SQL </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 35.7. 記述子領域の使用</td></tr></table></div></body></html>