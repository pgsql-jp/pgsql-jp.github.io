<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.5. ログ先行書き込み（WAL）</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="runtime-config-resource.html" title="19.4. 資源の消費" /><link rel="next" href="runtime-config-replication.html" title="19.6. レプリケーション" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">19.5. ログ先行書き込み（WAL）</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-resource.html" title="19.4. 資源の消費">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Chapter 19. サーバの設定">Up</a></td><th width="60%" align="center">Chapter 19. サーバの設定</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-replication.html" title="19.6. レプリケーション">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="RUNTIME-CONFIG-WAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">19.5. ログ先行書き込み（WAL）</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS">19.5.1. 諸設定</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-CHECKPOINTS">19.5.2. チェックポイント</a></span></dt><dt><span class="sect2"><a href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-ARCHIVING">19.5.3. アーカイビング</a></span></dt></dl></div><p>   
    これらの設定をチューニングする追加情報は<a class="xref" href="wal-configuration.html" title="30.4. WALの設定">Section 30.4</a>を参照してください。
   </p><div class="sect2" id="RUNTIME-CONFIG-WAL-SETTINGS"><div class="titlepage"><div><div><h3 class="title">19.5.1. 諸設定</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-WAL-LEVEL"><span class="term"><code class="varname">wal_level</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.8.3.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p><code class="varname">wal_level</code>はどれだけの情報がWALに書かれるかを決定します。
デフォルト値は<code class="literal">replica</code>で、WALアーカイビングおよびレプリケーションをサポートするために十分なデータを書き出し、これにはスタンバイサーバで読み取り専用の問い合わせを実行することも含みます。
<code class="literal">minimal</code>はクラッシュまたは即時停止から回復するのに必要な情報を除き、すべてのログを削除します。
最後に、<code class="literal">logical</code>は、更にロジカルデコーディングをサポートするのに必要な情報を追加します。
それぞれのレベルは、下位のレベルのログ出力を含んでいます。
このパラメータはサーバ起動時のみ設定可能です。
       </p><p>       
<code class="literal">minimal</code>レベルでは、一部の巨大な操作でのWAL出力は安全に省略でき、そうすることで、それらの操作が大幅に高速になります（<a class="xref" href="populate.html#POPULATE-PITR" title="14.4.7. WALアーカイブ処理とストリーミングレプリケーションの無効化">Section 14.4.7</a>を参照してください）。
この最適化が適用される操作には以下のものがあげられます。
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td><code class="command">CREATE TABLE AS</code></td></tr><tr><td><code class="command">CREATE INDEX</code></td></tr><tr><td><code class="command">CLUSTER</code></td></tr><tr><td>同一トランザクション内で作成されたか、もしくは切り詰められたテーブルに対する<code class="command">COPY</code></td></tr></table><p>
しかしminimal WALはベースバックアップとWALログからデータを再構築するための充分な情報を持ち合わせていません。
したがって、WALアーカイビング（<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>）とストリーミングレプリケーションを有効にするには、<code class="literal">replica</code>以上を使用しなければなりません。
       </p><p><code class="literal">logical</code>レベルでは、<code class="literal">replica</code>と同じ情報がログされるのに加え、ロジカルチェンジセットをWALから取り出すのに必要な情報が追加されます。
<code class="literal">logical</code>を使うとWALの量が増えます。
とりわけ、多数のテーブルが<code class="literal">REPLICA IDENTITY FULL</code>と設定されていて(訳注: ALTER TABLE参照)、多くの<code class="command">UPDATE</code>と<code class="command">DELETE</code>文が実行される場合はこのことが言えます。
       </p><p>9.6よりも前のリリースでは、このパラメータは<code class="literal">archive</code>と<code class="literal">hot_standby</code>という設定値も可能でした。
引き続きこれらも受け付けられますが、<code class="literal">replica</code>へとマップされます。
       </p></dd><dt id="GUC-FSYNC"><span class="term"><code class="varname">fsync</code> (<code class="type">boolean</code>)
      <a id="id-1.6.6.8.3.2.2.1.3" class="indexterm"></a>
      </span></dt><dd><p>このパラメータがオンの場合、<span class="productname">PostgreSQL</span>サーバは<code class="function">fsync()</code>システムコールを発行するか、もしくはこれに相当する方法（<a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a>を参照）で、更新が物理的にディスクに確実に書き込まれるように試みます。
これは、オペレーティングシステムもしくはハードウェアがクラッシュした後、データベースクラスタを一貫した状態に復旧させることを確実にします。
       </p><p>       
<code class="varname">fsync</code>を停止することはしばしば性能上の利益になるとは言っても、停電やクラッシュの際に回復不可能なデータ破壊になることがあります。
従って外部データから全てのデータベースを簡単に再構築できる場合のみ<code class="varname">fsync</code>を停止してください。
       </p><p>       
<code class="varname">fsync</code>を停止しても安全な状況の例としては、以下があげられます。
バックアップファイルから新しいデータベースクラスタにデータの初期読み込みを行う場合、バッチデータの処理のためにデータベースクラスタを使用し、その後データベースを削除して再構築する場合、読み込み専用のデータベースのクローンを頻繁に再作成するが、それをフェイルオーバーに使用しない場合、などです。
高性能なハードウェアであるからと言って、<code class="varname">fsync</code>を停止することは正当性を主張する十分な理由とはなりません。
       </p><p><code class="varname">fsync</code>を無効(off)から有効(on）に変更したときの信頼できるリカバリのためには、カーネル内の全ての変更されたバッファを恒久的ストレージに強制的に吐き出させることが必要です。
これは、クラスタがシャットダウンしている間、または<code class="varname">fsync</code>が有効のときに、<code class="command">initdb --sync-only</code>を実行する、<code class="command">sync</code>を実行する、ファイルシステムをアンマウントする、またはサーバを再起動することによって可能となります。
       </p><p>       
多くの場合、重要でないトランザクションに対して<a class="xref" href="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT">synchronous_commit</a>を無効にすることにより、データ破壊という付随的危険性を伴うことなく、<code class="varname">fsync</code>を無効にすることで得られるであろう性能上のメリットの多くを得ることができます。
       </p><p>       
<code class="varname">fsync</code> は<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
このパラメータを無効にする場合、<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>も同時に無効にすることを検討してください。
       </p></dd><dt id="GUC-SYNCHRONOUS-COMMIT"><span class="term"><code class="varname">synchronous_commit</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.8.3.2.3.1.3" class="indexterm"></a>
      </span></dt><dd><p>トランザクションのコミットがクライアントに<span class="quote">“<span class="quote">成功</span>”</span>の報告を返す前に、WALレコードがディスク上に書き込まれるまで待つかどうかの指定をします。
有効な値は<code class="literal">on</code>、<code class="literal">remote_apply</code>、<code class="literal">remote_write</code>、<code class="literal">local</code>、および<code class="literal">off</code>です。
デフォルトかつ安全な設定は<code class="literal">on</code>です。
<code class="literal">off</code>の場合、クライアントに成功を報告する時点とトランザクションが本当にサーバクラッシュに対して安全になるまでの間に遅延が発生する場合があります。
（遅延は最大で、<a class="xref" href="runtime-config-wal.html#GUC-WAL-WRITER-DELAY">wal_writer_delay</a>の3倍です。）
<a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>と異なり、このパラメータを<code class="literal">off</code>に設定することによって、データベースの一貫性が損なわれる可能性はありません。
オペレーティングシステムやデータベースのクラッシュにより最近コミットされたということになっているトランザクションの一部が失われる可能性がありますが、これらのトランザクションが正常にアボートされた時とデータベースの状態は変わりません。
ですので、<code class="varname">synchronous_commit</code>を無効にすることは、トランザクションの信頼性が確実であることよりも性能が重要である場合に有効な方法です。
詳細は<a class="xref" href="wal-async-commit.html" title="30.3. 非同期コミット">Section 30.3</a>を参照してください。
       </p><p><a class="xref" href="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES">synchronous_standby_names</a>が空文字でない場合は、このパラメータは、WALレコードが、スタンバイサーバに複製されるまでトランザクションコミットを待機するか否かも制御します。
<code class="literal">on</code>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取り、記憶装置に吐き出したことを報告するまでコミットは待機します。
このモードでは、プライマリおよびすべての同期スタンバイがデータベース記憶装置の故障を被った場合を除いて、トランザクションが失われないことが保証されます。
<code class="literal">remote_apply</code>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取って適用し、スタンバイ上で発行されたクエリから見えるようになったことを報告するまでコミットは待機します。
<code class="literal">remote_write</code>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取り、スタンバイのオペレーティングシステムに書き出したことを報告するまでコミットは待機します。
この設定は仮に<span class="productname">PostgreSQL</span>のスタンバイインスタンスがクラッシュしたとしても、データ保護を保証するのに充分です。
しかし、スタンバイがオペレーティングシステムのレベルでクラッシュした場合はこの限りではありません。
データが必ずしもスタンバイの永続的な記憶装置に到達したとは言えないからです。
最後に、<code class="literal">local</code>設定は、コミットがローカルにディスクに吐出されるまで待機しますが、レプリケーションされるまでは待機しません。
これは通常同期レプリケーションが使用されている場合は望ましい設定ではありませんが、完全さのために提供されています。
       </p><p>もし <code class="varname">synchronous_standby_names</code> が設定されていなければ、<code class="literal">on</code>、<code class="literal">remote_apply</code>、<code class="literal">remote_write</code> および <code class="literal">local</code> の設定は全て同一の同期レベルを提供します。
すなわちトランザクションのコミットはローカルディスクへの吐き出しのみを待機します。
       </p><p>       
このパラメータはいつでも変更可能です。
どのトランザクションの動作も、コミット時に有効であった設定によって決まります。
したがって、一部のトランザクションのコミットを同期的に、その他を非同期的にすることが可能で、かつ、有用です。
例えば、デフォルトが同期コミットの場合に複数文トランザクションを一つだけ非同期にコミットさせるためには、トランザクション内で<code class="command">SET LOCAL synchronous_commit TO OFF</code>を発行します。
       </p></dd><dt id="GUC-WAL-SYNC-METHOD"><span class="term"><code class="varname">wal_sync_method</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.8.3.2.4.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       WALの更新をディスクへ強制するのに使用される方法です。<code class="varname">fsync</code>がオフの場合この設定は役に立ちません。と言うのはWALファイルの更新が全く強制されないからです。取り得る値は以下のものです。
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>       
        <code class="literal">open_datasync</code>（<code class="function">open()</code>のオプション<code class="symbol">O_DSYNC</code>でWALファイルに書き込む）
        </p></li><li class="listitem"><p>       
        <code class="literal">fdatasync</code>（コミット毎に<code class="function">fdatasync()</code>を呼び出す）
        </p></li><li class="listitem"><p>        
        <code class="literal">fsync</code>（コミット毎に<code class="function">fsync()</code>を呼び出す）
        </p></li><li class="listitem"><p>       
        <code class="literal">fsync_writethrough</code>（すべてのディスク書き込みキャッシュをライトスルーさせるため、コミット毎に<code class="function">fsync()</code>を呼び出す）
        </p></li><li class="listitem"><p>       
        <code class="literal">open_sync</code>（<code class="function">open()</code>のオプション<code class="symbol">O_SYNC</code>でWALファイルに書き込む）
        </p></li></ul></div><p>       
可能なら<code class="literal">open_</code>*オプションも<code class="literal">O_DIRECT</code>を使用します。
全てのプラットフォームでこれら全ての選択肢が使えるわけではありません。
デフォルトは、上のリストのプラットフォームでサポートされるものの最初に列挙されているものです。
ただしLinuxでは<code class="literal">fdatasync</code>がデフォルトです。
デフォルトは必ずしも理想的なものではありません。
クラッシュに適応した構成にする、あるいはアーカイブの最適性能を導くためには、この設定あるいはシステム構成の他の部分を変更することが必要かもしれません。
これらの側面は <a class="xref" href="wal-reliability.html" title="30.1. 信頼性">Section 30.1</a>で解説されます。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-FULL-PAGE-WRITES"><span class="term"><code class="varname">full_page_writes</code> (<code class="type">boolean</code>)
      <a id="id-1.6.6.8.3.2.5.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
このパラメータが有効の場合、<span class="productname">PostgreSQL</span>サーバは、チェックポイントの後にそのページが最初に変更された過程で、ディスクページの全ての内容をWALに書き込みます。
オペレーティングシステムがクラッシュした時に進行中のページ書き込みは途中までしか終わっていない可能性があり、ディスク上のページが古いデータと新しいデータが混在する状態になるため、この機能が必要です。
通常WAL内に保存される行レベルの変更データは、クラッシュ後のリカバリ時にこうしたページを完全に復旧させるには不十分です。
完全なページイメージを保存することにより、ページを正しく復旧できることを保証しますが、その代わりに、WALに書き込まなければならないデータ量が増加することになります。
（WAL再生は常にチェックポイントから始まるため、チェックポイント後のそれぞれのページの最初の変更時にこれを行えば十分です。
従って、完全ページ書き出しのコストを低減する方法の1つは、チェックポイント間隔パラメータを大きくすることです。）
       </p><p>       
       このパラメータを無効にすると、通常の操作速度が上がりますが、システム障害後に、回復不能なデータ破損、あるいは警告なしのデータ損壊をもたらすかもしれません。
このリスクは小さいながら<code class="varname">fsync</code>を無効にした場合と似ています。そしてその<code class="varname">fsync</code>に対して推奨されている同一の状況に基づく限りにおいて停止されなければなりません。
       </p><p>       
       このパラメータを無効にしてもポイントインタイムリカバリ（PITR）用のWALアーカイブの使用に影響ありません（ <a class="xref" href="continuous-archiving.html" title="25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）">Section 25.3</a>を参照してください）。
       </p><p>       
       このパラメータは<code class="filename">postgresql.conf</code>ファイル内、または、サーバのコマンドラインでのみ設定可能です。
デフォルトは<code class="literal">on</code>です。
       </p></dd><dt id="GUC-WAL-LOG-HINTS"><span class="term"><code class="varname">wal_log_hints</code> (<code class="type">boolean</code>)
      <a id="id-1.6.6.8.3.2.6.1.3" class="indexterm"></a>
      </span></dt><dd><p>        このパラメータが<code class="literal">on</code>の場合、<span class="productname">PostgreSQL</span>サーバはチェックポイント後にはじめてページを変更する際に、ディスクページの全内容をWALに書き出します。
これは、あまり重要でない、ヒントビットと呼ばれるものに対する変更にさえ当てはまります。
       </p><p>        データチェックサムが有効であると、ヒントビットの更新は常にWALにログされ、この設定パラメータは無視されます。この設定パラメータを使って、データチェックサムが有効なときにどれだけのWALログは余計に書きだされるかをテストすることができます。
       </p><p>       このパラメータはサーバ起動時のみ設定可能です。
デフォルト値は<code class="literal">off</code>です。
       </p></dd><dt id="GUC-WAL-COMPRESSION"><span class="term"><code class="varname">wal_compression</code> (<code class="type">boolean</code>)
      <a id="id-1.6.6.8.3.2.7.1.3" class="indexterm"></a>
      </span></dt><dd><p>このパラメータが<code class="literal">on</code>なら、<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>がonあるいはベースバックアップの際、<span class="productname">PostgreSQL</span>サーバはWALに書き出すフルページイメージを圧縮します。
圧縮されたページイメージは、WALリプレイのときに伸張されます。
デフォルト値は<code class="literal">off</code>です。
スーパーユーザだけがこの設定を変更できます。
       </p><p>このパラメータを有効にすると、回復不可能なデータ破壊のリスクを増やすこと無しにWALの量を減らすことができます。
しかし、WALロギングの際の圧縮のため、またWALリプレイの際には伸張のために余分なCPUを使用するというコストが発生します。
       </p></dd><dt id="GUC-WAL-BUFFERS"><span class="term"><code class="varname">wal_buffers</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.3.2.8.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       未だディスクに書き込まれていないWALデータに対して使用される共有メモリ容量です。
       デフォルトの設定である-1は、<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>の1/32（約3%）の容量に等しい大きさを選択します。
       しかし、<code class="literal">64kB</code>未満ではなく、かつ典型的に<code class="literal">16MB</code>であるWALセグメントの大きさを越えることはありません。
       もし、自動設定による選択が大きすぎたり、小さすぎる場合この値は手作業で設定可能です。
       しかし、<code class="literal">32kB</code>未満のどんな正の値であっても、<code class="literal">32kB</code>
として取り扱われます。
このパラメータはサーバ起動時のみ設定可能です。
       </p><p>       
       WALバッファの内容はトランザクションのコミット毎にディスクに書き込まれます。
       したがって、極端に大きな値は有意な効果を期待できません。
       しかし、この値を数メガバイトに設定することにより、多くのクライアントが同時にコミットするトラフィック量の多いサーバでは書き込み性能が向上します。
       デフォルト設定の-1で選択される自動チューニングによると、ほとんどの場合妥当な結果が得られます。
       </p></dd><dt id="GUC-WAL-WRITER-DELAY"><span class="term"><code class="varname">wal_writer_delay</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.3.2.9.1.3" class="indexterm"></a>
      </span></dt><dd><p>WALライタがWALを吐き出す頻度を指定します。
WALを吐き出したとあと、非同期コミットしているトランザクションに起こされない限り、<code class="varname">wal_writer_delay</code>ミリ秒待機します。
最後の吐き出しが過去<code class="varname">wal_writer_delay</code>ミリ秒以内に起こなわれ、かつそれ以降<code class="varname">wal_writer_flush_after</code>バイト以内のWALが生成されている場合は、WALはオペレーティングシステムに書き込まれますが、ディスクには吐出されません。
デフォルト値は200ミリ秒（<code class="literal">200ms</code>）です。
多くのシステムでは、待機間隔の実質的な分解能は10ミリ秒です。
10の倍数以外の値を<code class="varname">wal_writer_delay</code>に設定しても、その次に大きい10の倍数を設定した場合と同じ結果となります。
このパラメータは<code class="filename">postgresql.conf</code>ファイル内またはサーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-WAL-WRITER-FLUSH-AFTER"><span class="term"><code class="varname">wal_writer_flush_after</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.3.2.10.1.3" class="indexterm"></a>
      </span></dt><dd><p>WALライタがWALを吐き出す頻度を指定します。
最後の吐き出しが過去<code class="varname">wal_writer_delay</code>ミリ秒以内に起こなわれ、かつそれ以降<code class="varname">wal_writer_flush_after</code>バイト以内のWALが生成されている場合は、WALはオペレーティングシステムに書き込まれますが、ディスクには吐出されません。
<code class="varname">wal_writer_flush_after</code>が<code class="literal">0</code>に設定されている場合は、WALが書かれるたびにWALが吐出されます。
デフォルト値は<code class="literal">1MB</code>です。
このパラメータは<code class="filename">postgresql.conf</code>ファイル内またはサーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-COMMIT-DELAY"><span class="term"><code class="varname">commit_delay</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.3.2.11.1.3" class="indexterm"></a>
      </span></dt><dd><p><code class="varname">commit_delay</code>は、WALフラッシュを開始する前の時間遅延を追加します。単位はマイクロ秒です。
このことにより、もし追加のトランザクションが与えられた時間間隔内でコミットが可能になるほどシステム負荷が充分に高い場合、一回のWALフラッシュでより多くの数のトランザクションをコミットできるようになり、コミット群のスループットを改善できます。
とは言っても、それぞれのWALフラッシュに対して最大<code class="varname">commit_delay</code>マイクロ秒の待ち時間の増加をきたします。
コミットの準備が完了したトランザクションが他に存在しない場合、遅延は無駄になるため、遅延はフラッシュが開始されようとしている時点で少なくとも<code class="varname">commit_siblings</code>だけのトランザクションが活動している場合にだけ機能します。
同様に、<code class="varname">fsync</code>が無効の場合も遅延は機能しません。
デフォルトの<code class="varname">commit_delay</code>はゼロ（遅延無し）です。
この設定はスーパーユーザのみ変更可能です。
       </p><p>       
        9.3より前の<span class="productname">PostgreSQL</span>では、<code class="varname">commit_delay</code>の振る舞いは異なっており、あまり効果がありませんでした。
       全てのWALフラッシュではなく、コミットだけに影響していました。また、そしてWALフラッシュが早めに完了しても設定された遅延分待機していました。
       <span class="productname">PostgreSQL</span> 9.3以降では、フラッシュの準備が整った最初のプロセスが設定値分待機し、後続のプロセスは最初のプロセスがフラッシュ操作を完了するまでの間だけ待機をします。
       </p></dd><dt id="GUC-COMMIT-SIBLINGS"><span class="term"><code class="varname">commit_siblings</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.3.2.12.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
<code class="varname">commit_delay</code>の遅延を実行するときに必要とされる同時に開いているトランザクションの最小数です。
より大きい値にすると、遅延周期の間に、少なくとも1つの他のトランザクションのコミットの準備が整う確率が高くなります。
デフォルトは5トランザクションです。
       </p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-CHECKPOINTS"><div class="titlepage"><div><div><h3 class="title">19.5.2. チェックポイント</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-CHECKPOINT-TIMEOUT"><span class="term"><code class="varname">checkpoint_timeout</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.4.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
自動的WALチェックポイント間の最大間隔を秒単位で指定します。
有効な範囲は、30秒から1日の間です。
デフォルトは5分（<code class="literal">5min</code>）です。
このパラメータを増やすと、クラッシュリカバリで必要となる時間が増加します。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-CHECKPOINT-COMPLETION-TARGET"><span class="term"><code class="varname">checkpoint_completion_target</code> (<code class="type">floating point</code>)
      <a id="id-1.6.6.8.4.2.2.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       チェックポイントの完了目標をチェックポイント間の総時間の割合として指定します。
デフォルトは0.5です。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-CHECKPOINT-FLUSH-AFTER"><span class="term"><code class="varname">checkpoint_flush_after</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.4.2.3.1.3" class="indexterm"></a>
      </span></dt><dd><p>チェックポイント実行中に<code class="varname">checkpoint_flush_after</code>バイトより多く書く度に、OSが記憶装置に書き込むことを強制しようとします。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後に<code class="function">fsync</code>が実行される際、あるいはOSがバックグラウンドでデータを大きな塊で書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延が大幅に少なくなりますが、あるケース、特にワークロードが<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<code class="literal">0</code>から、<code class="literal">2MB</code>までです。
デフォルト値は、Linuxでは<code class="literal">256kB</code>で、それ以外は<code class="literal">0</code>です。
(<code class="symbol">BLCKSZ</code>が8kbでなければ、この設定のデフォルト値と最大値が<code class="symbol">BLCKSZ</code>に比例して変更されます。)
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </p></dd><dt id="GUC-CHECKPOINT-WARNING"><span class="term"><code class="varname">checkpoint_warning</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.4.2.4.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
チェックポイントセグメントファイルが溢れることが原因で起きるチェックポイントが、ここで指定した秒数よりも短い間隔で発生したとき、サーバログにメッセージを書き出します
（これは、<code class="varname">max_wal_size</code>を増やす必要があることを示唆しています）。
デフォルトは30秒（<code class="literal">30s</code>）です。
零の場合は警告を出しません。
<code class="varname">checkpoint_timeout</code>が<code class="varname">checkpoint_warning</code>より小さい場合は警告を出しません。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </p></dd><dt id="GUC-MAX-WAL-SIZE"><span class="term"><code class="varname">max_wal_size</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.4.2.5.1.3" class="indexterm"></a>
      </span></dt><dd><p>自動WALチェックポイントの間にWALが増加する最大サイズです。
これはソフトリミットです。特別な状況下、たとえば高負荷、<code class="varname">archive_command</code>の失敗、<code class="varname">wal_keep_segments</code>が大きな値に設定されている、などの時には、WALサイズは<code class="varname">max_wal_size</code>を超えることがあります。
デフォルトは1GBです。
このパラメータを大きくすると、クラッシュリカバリに必要な時間が長くなります。
このパラメータは、<code class="filename">postgresql.conf</code>ファイルで設定するか、サーバのコマンドラインでのみ指定できます。
       </p></dd><dt id="GUC-MIN-WAL-SIZE"><span class="term"><code class="varname">min_wal_size</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.4.2.6.1.3" class="indexterm"></a>
      </span></dt><dd><p>この設定以下にWALのディスク使用量が保たれる限り、古いWALファイルは、消去されることなく今後のチェックポイントで使用するために常にリサイクルされます。
この設定は、たとえば大きなバッチジョブを走らせる際のWALの利用スパイクを取り扱うために、十分なWALのスペースが予約されていることを保証するために使用できます。
デフォルトは80MBです。
このパラメータは、<code class="filename">postgresql.conf</code>ファイルで設定するか、サーバのコマンドラインでのみ指定できます。
       </p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-WAL-ARCHIVING"><div class="titlepage"><div><div><h3 class="title">19.5.3. アーカイビング</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-ARCHIVE-MODE"><span class="term"><code class="varname">archive_mode</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.8.5.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       <code class="varname">archive_mode</code>が有効な場合、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>を設定することにより、完了したWALセグメントはアーカイブ格納領域に送信されます。
無効にするための<code class="literal">off</code>に加え、2つのモードがあります。<code class="literal">on</code>と<code class="literal">always</code>です。
通常の運用ではこの2つのモードには違いはありませんが、<code class="literal">always</code>に設定すると、アーカイブリカバリおよびスタンバイモードでWALアーカイバが有効になります。
<code class="literal">always</code>モードでは、アーカイブからリストアされたファイルや、ストリーミングレプリケーションでストリームされたファイルもすべて(再び)アーカイブされます。
詳細は<a class="xref" href="warm-standby.html#CONTINUOUS-ARCHIVING-IN-STANDBY" title="26.2.9. スタンバイにおける継続的アーカイビング">Section 26.2.9</a>を参照してください。
       </p><p>アーカイブモードを抜けることなく<code class="varname">archive_command</code>を変更できるように、<code class="varname">archive_mode</code>と<code class="varname">archive_command</code>は分離されました。
このパラメータはサーバ起動時のみ設定可能です。
<code class="varname">wal_level</code> が
<code class="literal">minimal</code>に設定されている場合、<code class="varname">archive_mode</code>は有効になりません。
       </p></dd><dt id="GUC-ARCHIVE-COMMAND"><span class="term"><code class="varname">archive_command</code> (<code class="type">string</code>)
      <a id="id-1.6.6.8.5.2.2.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
完了したWALファイルセグメントのアーカイブを実行するローカルのシェルコマンドです。
文字列内のすべての<code class="literal">%p</code>は、格納されるファイルのパスで置き換えられ、そして、<code class="literal">%f</code>はファイル名のみ置換します。
（このパス名はサーバの作業用ディレクトリ、つまり、クラスタのデータディレクトリからの相対パスです。）
コマンド内に<code class="literal">%</code>文字そのものを埋め込むには<code class="literal">%%</code>を使用します。
コマンドが成功した場合にのみ終了ステータスゼロを返すことが重要です。
より詳しくは<a class="xref" href="continuous-archiving.html#BACKUP-ARCHIVING-WAL" title="25.3.1. WALアーカイブの設定">Section 25.3.1</a>を参照ください。
       </p><p>       
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみ設定可能です。
サーバ起動時に<code class="varname">archive_mode</code>が有効でなければ、これは無視されます。
<code class="varname">archive_command</code>が空文字列（デフォルト）、かつ、<code class="varname">archive_mode</code>が有効な場合、WALアーカイブ処理は一時的に無効になりますが、コマンドが後で提供されることを見越して、サーバはWALセグメントの蓄積を続けます。
例えば、<code class="literal">/bin/true</code>（Windowsでは<code class="literal">REM</code>）のように、真を返すだけで何もしないコマンドを<code class="varname">archive_command</code>に設定すると、実質的にアーカイブ処理が無効になりますが、アーカイブからの復帰に必要なWALファイルの連鎖も同時に断ち切るため、特別な場合のみ使用するようにしなければなりません。
       </p></dd><dt id="GUC-ARCHIVE-TIMEOUT"><span class="term"><code class="varname">archive_timeout</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.8.5.2.3.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>は完了したWALセグメントに対してのみ呼び出されます。
従って、サーバのWAL転送量が少ししかない（あるいは処理が少ないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
データが未アーカイブのままでいられる期間を制限するために、<code class="varname">archive_timeout</code>を設定して、強制的にサーバを新しいWALセグメントに定期的に切り替えるようにすることができます。
このパラメータが0より大きければ、サーバは前回のセグメントファイル切り替えから指定秒数経過し、かつ単一のチェックポイントを含む何らかのデータベース操作が行われた場合、新しいセグメントファイルに切り替えます。
（データベースが活動していなければ、チェックポイントはスキップされます。）
強制切り替えにより早期にクローズされたアーカイブ済みファイルは、完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<code class="varname">archive_timeout</code>を使用することは賢明ではなく、格納領域を膨張させてしまいます。
１分程度の<code class="varname">archive_timeout</code>設定が通常は妥当です。
もしそれより高速にデータをマスターサーバからコピーをしてしまいたいのであれば、アーカイブするよりストリーミングレプリケーションの選択を検討すべきです。
このパラメータは <code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-resource.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-replication.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">19.4. 資源の消費 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 19.6. レプリケーション</td></tr></table></div></body></html>