<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.11. インデックスオンリースキャン</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-collations.html" title="11.10. インデックスと照合順序" /><link rel="next" href="indexes-examine.html" title="11.12. インデックス使用状況の検証" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.11. インデックスオンリースキャン</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-collations.html" title="11.10. インデックスと照合順序">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-examine.html" title="11.12. インデックス使用状況の検証">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-INDEX-ONLY-SCANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.11. インデックスオンリースキャン</h2></div></div></div><a id="id-1.5.10.14.2" class="indexterm"></a><a id="id-1.5.10.14.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>におけるすべてのインデックスは<em class="firstterm">二次的な</em>インデックス、つまり各インデックスはテーブルの主要なデータ領域（<span class="productname">PostgreSQL</span>の用語ではテーブルの<em class="firstterm">ヒープ</em>と呼ばれます）とは別に格納されています。
このことは、通常のインデックススキャンにおいて、各行の検索にはインデックスとヒープの両方からデータを取得する必要があることを意味します。
さらに、指定のインデックス可能な<code class="literal">WHERE</code>条件に適合するインデックスのエントリは、通常、インデックス内の近い位置にあるのに対し、そこから参照されるテーブルの行はヒープ内のあらゆるところにあるかもしれません。
このため、インデックススキャンにおけるヒープアクセスの部分では、ヒープに対する多くのランダムアクセスがありますが、これは遅い可能性があり、特に伝統的な回転型メディアでは遅くなります。
（<a class="xref" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ">Section 11.5</a>で説明したように、ビットマップインデックスはヒープアクセスをソートした順で行うことでこのコストを緩和しようとするものですが、それはある程度までしかできません。）
  </p><p>このパフォーマンス問題を解決するため、<span class="productname">PostgreSQL</span>は<em class="firstterm">インデックスオンリースキャン</em>をサポートします。
これは、問い合わせに対してヒープアクセスをせずにインデックスのみで回答できるものです。
基本的な考え方は、関連するヒープのエントリを参照せずに、各インデクスエントリから直接に値を返すというものです。
この方法が使用できるためには2つの基本的な制限があります。

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>インデックスの種類がインデックスオンリースキャンをサポートする必要があります。
Bツリーインデックスはいつでもインデックスオンリースキャンをサポートします。
GiSTとSP-GiSTは一部の演算子クラスでインデックスオンリースキャンをサポートしますが、サポートしない演算子クラスもあります。
他のインデックスの種類はインデックスオンリースキャンをサポートしません。
根本的な必要条件は、インデックスが各インデックスのエントリに対応する元のデータ値を物理的に格納していなければならない、あるいはそれを再構築できる必要がある、ということです。
その反例として、GINインデックスでは、各インデックスエントリが通常は元のデータ値の一部しか保持していないため、インデックスオンリースキャンをサポートすることができません。
     </p></li><li class="listitem"><p>問い合わせはインデックスに格納されている列だけを参照しなければなりません。
例えばテーブルの列<code class="literal">x</code>と<code class="literal">y</code>にインデックスがあり、そのテーブルにはさらに列<code class="literal">z</code>がある場合、次の問い合わせはインデックスオンリースキャンを使用できます。
</p><pre class="programlisting">SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;</pre><p>
しかし、以下の問い合わせはインデックスオンリースキャンを使用できません。
</p><pre class="programlisting">SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;</pre><p>
（以下で説明するように、式によるインデックスや部分インデックスは、この規則を複雑にします。）
     </p></li></ol></div><p>
  </p><p>この2つの基本的な要件が満たされるなら、問い合わせで要求されるすべてのデータ値はインデックスから利用できるので、インデックスオンリースキャンが物理的に可能になります。
しかし、<span class="productname">PostgreSQL</span>のすべてのテーブルスキャンにおいて、さらなる必要条件があります。
それは、<a class="xref" href="mvcc.html" title="Chapter 13. 同時実行制御">Chapter 13</a>で説明するように、検索された各行が問い合わせのMVCCスナップショットに対して<span class="quote">“<span class="quote">可視</span>”</span>であることを確認しなければならない、ということです。
可視性の情報はインデックスのエントリには格納されず、ヒープのエントリにのみあります。
そのため、一見すると、すべての行検索はいずれにせよヒープアクセスが必要なように思われます。
そして、テーブルの行が最近に更新された場合は、まさにその通りなのです。
しかし、あまり更新されないデータについてはこの問題を回避する方法があります。
<span class="productname">PostgreSQL</span>ではテーブルのヒープの各ページについて、そのページに格納されているすべての行が、十分に古く、すべての現在および将来のトランザクションに対して可視であるかどうかを追跡しています。
この情報はテーブルの<em class="firstterm">可視性マップ</em>のビットに格納されます。
インデックスオンリースキャンでは、候補となるインデックスのエントリを見つけた後、対応するヒープページの可視性マップのビットを検査します。
それがセットされていれば、行が可視であることがわかるので、それ以上の作業をすることなく、データを返すことができます。
セットされていない場合は、それが可視かどうかを調べるためにヒープエントリにアクセスする必要があり、そのため標準的なインデックススキャンに対するパフォーマンス上の利点はありません。
うまくいく場合であっても、この方法はヒープアクセスと引き換えに可視性マップにアクセスします。
しかし、可視性マップはヒープに比べ、4桁の規模で小さいため、アクセスに必要な物理的I/Oははるかに少ないです。
ほとんどの状況では、可視性マップは常にメモリ内にキャッシュされて残っています。
  </p><p>要するに、2つの基本的条件が満たされていればインデックスオンリースキャンが可能ですが、テーブルのヒープページのかなりの部分に対し、その全可視のビットがセットされている場合にのみ、性能が向上します。
しかし大部分の行が変化しないテーブルは一般的であり、現実にはこの種のスキャンは非常に有効です。
  </p><p>インデックスオンリースキャンの機能を有効に利用するため、先頭の列のみが<code class="literal">WHERE</code>句に適合し、残りの列は問い合わせによって返される<span class="quote">“<span class="quote">ペイロード</span>”</span>データとなっているインデックスを作成することを選択するかもしれません。
例えば、次のような問い合わせをよく実行する場合を考えます。
</p><pre class="programlisting">SELECT y FROM tab WHERE x = 'key';</pre><p>
このような問い合わせを高速化する伝統的な手法は、<code class="literal">x</code>のみにインデックスを作成することです。
しかし<code class="literal">(x, y)</code>にインデックスを作ることで、この問い合わせをインデックスオンリースキャンとして実現できる可能性が出てきます。
前に説明した通り、そのようなインデックスは大きくなり、<code class="literal">x</code>だけのインデックスよりも高価になるため、このテーブルがほぼ静的であることがわかっている場合にのみ魅力的です。
インデックスを<code class="literal">(y, x)</code>ではなく<code class="literal">(x, y)</code>と宣言するのが重要であることに注意してください。
ほとんどの種類のインデックス（特にBツリー）において、先頭のインデックスによる制約がない検索はあまり効率的ではないからです。
  </p><p>原則として、インデックスオンリースキャンは式によるインデックスでも使うことができます。
例えば、<code class="literal">x</code>がテーブルの列で、<code class="literal">f(x)</code>上にインデックスがある場合、次の問い合わせをインデックスオンリースキャンとして実行できるはずです。
</p><pre class="programlisting">SELECT f(x) FROM tab WHERE f(x) &lt; 1;</pre><p>
そして、関数<code class="literal">f()</code>の計算が高価なら、この方法は非常に魅力的です。
しかし<span class="productname">PostgreSQL</span>のプランナは現在のところ、このような場合についてあまり賢くありません。
プランナは、問い合わせで必要となるすべての<span class="emphasis"><em>列</em></span>がインデックスから利用可能な場合にのみ、その問い合わせが潜在的にインデックスオンリースキャンで実行可能と考えます。
この例では、<code class="literal">f(x)</code>という文脈でしか<code class="literal">x</code>は必要になりませんが、プランナはそのことに気付かないため、インデックスオンリースキャンは不可能であると結論します。
インデックスオンリースキャンは十分に価値があると思われるなら、これはインデックスを<code class="literal">(f(x), x)</code>上に宣言することで回避できます。
ここで2番目の列は現実には使用されないでしょうが、プランナにインデックスオンリースキャンが可能であると確信させるためだけに存在しています。
目的が<code class="literal">f(x)</code>の再計算を避けることの場合、さらなる注意として、プランナはインデックス可能な<code class="literal">WHERE</code>句にない<code class="literal">f(x)</code>の使用を必ずしもインデックス列とマッチしないという事があります。
上記のような単純な問い合わせの場合は通常は正しく処理できるでしょうが、結合を含む問い合わせでは駄目でしょう。
これらの欠点は<span class="productname">PostgreSQL</span>の将来のバージョンで解決されるかもしれません。
  </p><p>部分インデックスもインデックスオンリースキャンとの間に興味深い関係があります。
<a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="Example 11.3. 一意な部分インデックスの作成">Example 11.3</a>に示す部分インデックスを考えます。
</p><pre class="programlisting">CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</pre><p>
原則として、次のような問い合わせに対して、このインデックスを使ったインデックスオンリースキャンが可能です。
</p><pre class="programlisting">SELECT target FROM tests WHERE subject = 'some-subject' AND success;</pre><p>
しかし、<code class="literal">WHERE</code>句で参照される<code class="literal">success</code>がインデックスの結果列として利用できないという問題があります。
それにも関わらず、インデックスオンリースキャンが可能です。
なぜなら、このプランでは<code class="literal">WHERE</code>句のその部分を実行時に再検査する必要がない、つまりインデックス内にあるすべてのエントリは必ず<code class="literal">success = true</code>なので、プラン内でこれを明示的に検査する必要がないからです。
<span class="productname">PostgreSQL</span>のバージョン9.6およびそれ以降ではこのような場合を認識し、インデックスオンリースキャンを生成可能ですが、それより古いバージョンではできません。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-collations.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-examine.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.10. インデックスと照合順序 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.12. インデックス使用状況の検証</td></tr></table></div></body></html>