<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.7. パターンマッチ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-bitstring.html" title="9.6. ビット文字列関数と演算子" /><link rel="next" href="functions-formatting.html" title="9.8. データ型書式設定関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.7. パターンマッチ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-bitstring.html" title="9.6. ビット文字列関数と演算子">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Chapter 9. 関数と演算子">Up</a></td><th width="60%" align="center">Chapter 9. 関数と演算子</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-formatting.html" title="9.8. データ型書式設定関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="FUNCTIONS-MATCHING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.7. パターンマッチ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-LIKE">9.7.1. <code class="function">LIKE</code></a></span></dt><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-SIMILARTO-REGEXP">9.7.2. <code class="function">SIMILAR TO</code>正規表現</a></span></dt><dt><span class="sect2"><a href="functions-matching.html#FUNCTIONS-POSIX-REGEXP">9.7.3. <acronym class="acronym">POSIX</acronym>正規表現</a></span></dt></dl></div><a id="id-1.5.8.12.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>には、パターンマッチを行うに際して3つの異なった手法があります。伝統的な<acronym class="acronym">SQL</acronym>の<code class="function">LIKE</code>演算子、これより新しい<code class="function">SIMILAR TO</code>演算子（SQL:1999で追加されました）、および<acronym class="acronym">POSIX</acronym>様式の正規表現です。
基本の<span class="quote">“<span class="quote">この文字列はこのパターンに一致するか？</span>”</span>を別としても、一致した部分文字列を取り出したり置換したり、そして一致部分で文字列を分割する関数が用意されています。
   </p><div class="tip"><h3 class="title">Tip</h3><p>上記の手法では検索できないようなパターンマッチが必要な場合は、PerlもしくはTclでユーザ定義関数を作成することを検討してください。
    </p></div><div class="caution"><h3 class="title">Caution</h3><p>ほとんどの正規表現検索はとても速く実行されますが、正規表現は処理するのに任意の時間とメモリを使う可能性があります。
悪意のあるソースから正規表現検索パターンを受け取ることに用心してください。
そうしなければならないのであれば、文のタイムアウトを強制するのが賢明です。
    </p><p><code class="function">SIMILAR TO</code>が<acronym class="acronym">POSIX</acronym>書式の正規表現と同じ多くの機能を提供するので、<code class="function">SIMILAR TO</code>パターンを使う検索は同様のセキュリティ問題を抱えています。
    </p><p><code class="function">LIKE</code>検索は、他の2つの方法よりずっと単純ですので、悪意があるかもしれないパターンのソースで使うのにはより安全です。
    </p></div><div class="sect2" id="FUNCTIONS-LIKE"><div class="titlepage"><div><div><h3 class="title">9.7.1. <code class="function">LIKE</code></h3></div></div></div><a id="id-1.5.8.12.6.2" class="indexterm"></a><pre class="synopsis"><em class="replaceable"><code>string</code></em> LIKE <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
<em class="replaceable"><code>string</code></em> NOT LIKE <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]</pre><p><code class="function">LIKE</code>式は供給された<em class="replaceable"><code>pattern</code></em>に<em class="replaceable"><code>string</code></em>が一致すれば真を返します。
（想像される通り、<code class="function">NOT LIKE</code>式は<code class="function">LIKE</code>式が真を返す場合には偽を返し、その逆もまた同じです。
同等の式として<code class="literal">NOT (<em class="replaceable"><code>string</code></em> LIKE <em class="replaceable"><code>pattern</code></em>)</code>とも表現できます。）
    </p><p><em class="replaceable"><code>pattern</code></em>がパーセント記号もしくはアンダースコアを含んでいない場合patternは自身の文字列そのものです。この場合<code class="function">LIKE</code>式は等号演算子のように振舞います。
<em class="replaceable"><code>pattern</code></em>の中にあるアンダースコア（<code class="literal">_</code>）は任意の一文字との一致を意味し、パーセント記号（<code class="literal">%</code>）は0文字以上の並びとの一致を意味します。
    </p><p>例：
</p><pre class="programlisting">'abc' LIKE 'abc'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'a%'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE '_b_'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' LIKE 'c'      <em class="lineannotation"><span class="lineannotation">false</span></em></pre><p>
   </p><p><code class="function">LIKE</code>によるパターン一致は常に文字列全体に対して行われます。
従って、文字列内の任意位置における並びと一致させたい場合には、パーセント記号を先頭と末尾に付ける必要があります。
   </p><p>他の文字の一致に使用するのではなく、アンダースコアやパーセント記号そのものを一致させたい場合には、<em class="replaceable"><code>pattern</code></em>の中のそれぞれのアンダースコアとパーセント記号の前にエスケープ文字を付けなければなりません。
デフォルトのエスケープ文字はバックスラッシュですが、<code class="literal">ESCAPE</code>句で他の文字を指定することができます。エスケープ文字そのものを一致させるにはエスケープ文字を2つ書きます。
   </p><div class="note"><h3 class="title">Note</h3><p><a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>パラメータをoffにしている場合、リテラル文字列定数に記述するバックスラッシュを二重にする必要があります。
詳細は<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">Section 4.1.2.1</a>を参照してください。
    </p></div><p>同時に<code class="literal">ESCAPE ''</code>と記述することでエスケープ文字を選択しないことも可能です。
これにより、事実上エスケープ機構が働かなくなります。つまり、パターン内のアンダースコアおよびパーセント記号の特別な意味を解除することはできなくなります。
   </p><p>現在のロケールに従って大文字小文字を区別しない一致を行うのであれば、<code class="token">LIKE</code>の代わりに<code class="token">ILIKE</code>キーワードを使うことができます。
これは標準<acronym class="acronym">SQL</acronym>ではなく、<span class="productname">PostgreSQL</span>の拡張です。
   </p><p><code class="literal">~~</code>演算子は<code class="function">LIKE</code>式と等価で、<code class="literal">~~*</code>は<code class="function">ILIKE</code>に対応します。
また<code class="function">NOT LIKE</code>および<code class="function">NOT ILIKE</code>を表す<code class="literal">!~~</code>および<code class="literal">!~~*</code>演算子があります。
これら全ての演算子は<span class="productname">PostgreSQL</span>固有のものです。
   </p></div><div class="sect2" id="FUNCTIONS-SIMILARTO-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.2. <code class="function">SIMILAR TO</code>正規表現</h3></div></div></div><a id="id-1.5.8.12.7.2" class="indexterm"></a><a id="id-1.5.8.12.7.3" class="indexterm"></a><a id="id-1.5.8.12.7.4" class="indexterm"></a><pre class="synopsis"><em class="replaceable"><code>string</code></em> SIMILAR TO <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]
<em class="replaceable"><code>string</code></em> NOT SIMILAR TO <em class="replaceable"><code>pattern</code></em> [<span class="optional">ESCAPE <em class="replaceable"><code>escape-character</code></em></span>]</pre><p><code class="function">SIMILAR TO</code>演算子は、そのパターンが与えられた文字列に一致するかどうかにより、真もしくは偽を返します。
これは、標準SQLの正規表現定義を使用してパターンを解釈するという点以外は、<code class="function">LIKE</code>に類似しています。
SQLの正規表現は、<code class="function">LIKE</code>表記と一般的な正規表現の表記とを混ぜ合わせたようなものになっています。
   </p><p><code class="function">LIKE</code>と同様、<code class="function">SIMILAR TO</code>演算子は、そのパターンが文字列全体に一致した場合のみ真を返します。これは、パターンが文字列の一部分であっても一致する、一般的な正規表現の動作とは異なっています。
また、<code class="function">LIKE</code>と同様、<code class="function">SIMILAR TO</code>では、<code class="literal">%</code>および<code class="literal">_</code>を、それぞれ任意の文字列および任意の単一文字を意味するワイルドカード文字として使用します（これらは、POSIX正規表現での<code class="literal">.*</code>および<code class="literal">.</code>に相当します）。
   </p><p><code class="function">LIKE</code>から取り入れた上記の機能に加え、<code class="function">SIMILAR TO</code>では、以下のようにPOSIX正規表現から取り入れたパターンマッチメタ文字もサポートしています。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">|</code>は、二者択一（2つの選択肢のうちいずれか）を意味します。
     </p></li><li class="listitem"><p><code class="literal">*</code>は、直前の項目の0回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p><code class="literal">+</code>は、直前の項目の1回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p><code class="literal">?</code>は、直前の項目の0回もしくは1回の繰り返しを意味します。
     </p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>は、直前の項目の正確な<em class="replaceable"><code>m</code></em>回の繰り返しを意味します。
     </p></li><li class="listitem"><p>      <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code>は、直前の項目の<em class="replaceable"><code>m</code></em>回以上の繰り返しを意味します。
     </p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>は、直前の項目の<em class="replaceable"><code>m</code></em>回以上かつ<em class="replaceable"><code>n</code></em>回以下の繰り返しを意味します。
     </p></li><li class="listitem"><p>丸括弧<code class="literal">()</code>は、項目を1つの論理項目にグループ化することができます。
     </p></li><li class="listitem"><p>大括弧式<code class="literal">[...]</code>は、POSIX正規表現と同様に文字クラスを指定します。
     </p></li></ul></div><p>

<code class="function">SIMILAR TO</code>ではピリオド（<code class="literal">.</code>）はメタ文字ではないことに注意してください。
   </p><p><code class="function">LIKE</code>と同様、バックスラッシュは全てのメタ文字の特殊な意味を無効にします。
また、異なるエスケープ文字を<code class="literal">ESCAPE</code>で指定することが可能です。
   </p><p>例：
</p><pre class="programlisting">'abc' SIMILAR TO 'abc'      <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO 'a'        <em class="lineannotation"><span class="lineannotation">false</span></em>
'abc' SIMILAR TO '%(b|d)%'  <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' SIMILAR TO '(b|c)%'   <em class="lineannotation"><span class="lineannotation">false</span></em></pre><p>
   </p><p>3つのパラメータを持つ<code class="function">substring</code>関数、<code class="function">substring(<em class="parameter"><code>string</code></em> from <em class="replaceable"><code>pattern</code></em> for <em class="replaceable"><code>escape-character</code></em>)</code>を使用して、SQL正規表現パターンに一致する部分文字列を取り出すことができます。
<code class="literal">SIMILAR TO</code>と同様、指定したパターンがデータ文字列全体に一致する必要があります。一致しない場合、関数は終了し、NULLを返します。一致した場合に返されるべきパターンの一部を示すために、エスケープ文字の後に二重引用符（<code class="literal">"</code>）を繋げたものを2つパターンに含める必要があります。
これらの印で括られたパターンの一部に一致するテキストが返されます。
   </p><p>例：<code class="literal">#"</code>を使用して返される文字列を区切ります。
</p><pre class="programlisting">substring('foobar' from '%#"o_b#"%' for '#')   <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' from '#"o_b#"%' for '#')    <em class="lineannotation"><span class="lineannotation">NULL</span></em></pre><p>
   </p></div><div class="sect2" id="FUNCTIONS-POSIX-REGEXP"><div class="titlepage"><div><div><h3 class="title">9.7.3. <acronym class="acronym">POSIX</acronym>正規表現</h3></div></div></div><a id="id-1.5.8.12.8.2" class="indexterm"></a><a id="id-1.5.8.12.8.3" class="indexterm"></a><a id="id-1.5.8.12.8.4" class="indexterm"></a><a id="id-1.5.8.12.8.5" class="indexterm"></a><a id="id-1.5.8.12.8.6" class="indexterm"></a><a id="id-1.5.8.12.8.7" class="indexterm"></a><a id="id-1.5.8.12.8.8" class="indexterm"></a><p><a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-TABLE" title="Table 9.14. 正規表現マッチ演算子">Table 9.14</a>に、POSIX正規表現を使ったパターンマッチに使用可能な演算子を列挙します。
   </p><div class="table" id="FUNCTIONS-POSIX-TABLE"><p class="title"><strong>Table 9.14. 正規表現マッチ演算子</strong></p><div class="table-contents"><table class="table" summary="正規表現マッチ演算子" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>演算子</th><th>説明</th><th>例</th></tr></thead><tbody><tr><td> <code class="literal">~</code> </td><td>正規表現にマッチ、大文字小文字の区別あり</td><td><code class="literal">'thomas' ~ '.*thomas.*'</code></td></tr><tr><td> <code class="literal">~*</code> </td><td>正規表現にマッチ、大文字小文字の区別なし</td><td><code class="literal">'thomas' ~* '.*Thomas.*'</code></td></tr><tr><td> <code class="literal">!~</code> </td><td>正規表現にマッチしない、大文字小文字の区別あり</td><td><code class="literal">'thomas' !~ '.*Thomas.*'</code></td></tr><tr><td> <code class="literal">!~*</code> </td><td>正規表現にマッチしない、大文字小文字の区別なし</td><td><code class="literal">'thomas' !~* '.*vadim.*'</code></td></tr></tbody></table></div></div><br class="table-break" /><p><acronym class="acronym">POSIX</acronym>正規表現は、パターンマッチという意味合いでは、<code class="function">LIKE</code>および<code class="function">SIMILAR TO</code>演算子よりもさらに強力です。
<code class="command">egrep</code>、<code class="command">sed</code>、あるいは<code class="command">awk</code>のような多くのUnixツールはここで解説しているのと類似したパターンマッチ言語を使用しています。
    </p><p>正規表現とは文字列の集合（<em class="firstterm">正規集合</em>）の簡略された定義である文字が連なっているものです。
ある文字列が正規表現で記述された正規集合の要素になっていれば、その文字列は正規表現にマッチしていると呼ばれます。
<code class="function">LIKE</code>と同様、正規表現言語で特殊文字とされているもの以外、パターン文字は文字列と完全にマッチされます。とは言っても、正規表現は<code class="function">LIKE</code>関数が使用するのとは異なる特殊文字を使用します。
<code class="function">LIKE</code>関数のパターンと違って正規表現は、明示的に正規表現が文字列の最初または最後からと位置指定されていない限り文字列内のどの位置でもマッチを行えます。
    </p><p>例：
</p><pre class="programlisting">'abc' ~ 'abc'    <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '^a'     <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '(b|d)'  <em class="lineannotation"><span class="lineannotation">true</span></em>
'abc' ~ '^(b|c)' <em class="lineannotation"><span class="lineannotation">false</span></em></pre><p>
    </p><p><acronym class="acronym">POSIX</acronym>パターン言語について以下により詳しく説明します。
    </p><p>2つのパラメータを持つ<code class="function">substring</code>関数、<code class="function">substring(<em class="parameter"><code>string</code></em> from <em class="replaceable"><code>pattern</code></em>)</code>を使用して、POSIX正規表現パターンにマッチする部分文字列を取り出すことができます。
この関数は、マッチするものがない場合にはNULLを返し、ある場合はパターンにマッチしたテキストの一部を返します。
しかし、丸括弧を持つパターンの場合、最初の丸括弧内部分正規表現（左丸括弧が最初に来るもの）にマッチするテキストの一部が返されます。
この例外を起こさずにパターン中に丸括弧を使用したいのであれば、常に正規表現全体を丸括弧で囲むことができます。
パターン内の抽出対象の部分文字列より前に丸括弧が必要な場合、後述の捕捉されない丸括弧を参照してください。
    </p><p>例：
</p><pre class="programlisting">substring('foobar' from 'o.b')     <em class="lineannotation"><span class="lineannotation">oob</span></em>
substring('foobar' from 'o(.)b')   <em class="lineannotation"><span class="lineannotation">o</span></em></pre><p>
   </p><p><code class="function">regexp_replace</code>関数は、POSIX正規表現パターンにマッチする部分文字列を新規テキストと置換します。
構文は、<code class="function">regexp_replace</code>(<em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>pattern</code></em>, <em class="replaceable"><code>replacement</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])です。
<em class="replaceable"><code>pattern</code></em>にマッチしない場合は、<em class="replaceable"><code>source</code></em>文字列がそのまま返されます。
マッチすると、マッチ部分文字列を<em class="replaceable"><code>replacement</code></em>文字列で置換した<em class="replaceable"><code>source</code></em>文字列が返されます。
<em class="replaceable"><code>replacement</code></em>文字列に<code class="literal">\</code><em class="replaceable"><code>n</code></em>（<em class="replaceable"><code>n</code></em>は1から9までの数字）を入れて、パターン内の<em class="replaceable"><code>n</code></em>番目の丸括弧つき部分表現にマッチする元の部分文字列を挿入することができます。
また、<code class="literal">\&amp;</code>を入れて、パターン全体とマッチする部分文字列を挿入することもできます。
置換テキスト内にバックスラッシュそのものを挿入する必要がある時は<code class="literal">\\</code>と記述します。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくはそれ以上の1文字フラグを含むオプションのテキスト文字列です。フラグ<code class="literal">i</code>は大文字小文字を区別しないマッチを指定する一方、フラグ<code class="literal">g</code>は、最初にマッチしたもののみではなく、それぞれマッチした部分文字列の置換を指定します。
有効なフラグは(<code class="literal">g</code>を除く)<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Table 9.22. ARE埋め込みオプション文字">Table 9.22</a>に記述されています。
    </p><p>    例：
</p><pre class="programlisting">regexp_replace('foobarbaz', 'b..', 'X')
                                   <em class="lineannotation"><span class="lineannotation">fooXbaz</span></em>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXX</span></em>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <em class="lineannotation"><span class="lineannotation">fooXarYXazY</span></em></pre><p>
   </p><p><code class="function">regexp_match</code>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された最初の部分文字列のテキスト配列を返します。
<code class="function">regexp_match</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
マッチするものがなければ、結果は<code class="literal">NULL</code>となります。
マッチする部分があり、かつ<em class="replaceable"><code>pattern</code></em>が丸括弧で括られた部分文字列を含まない場合、結果はパターン全体にマッチする部分文字列を含む単一要素のテキスト配列となります。
マッチする部分があり、かつ<em class="replaceable"><code>pattern</code></em>が丸括弧で括られた部分文字列を含む場合、結果はテキスト配列で、その<em class="replaceable"><code>n</code></em>番目の要素は<em class="replaceable"><code>pattern</code></em>の<em class="replaceable"><code>n</code></em>番目に丸括弧で括られた部分文字列にマッチする部分文字列となります（<span class="quote">“<span class="quote">捕捉されない</span>”</span>丸括弧は数えません。詳細は以下を参照してください）。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
有効なフラグは<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Table 9.22. ARE埋め込みオプション文字">Table 9.22</a>に記載されています。
    </p><p>例を示します。
</p><pre class="programlisting">SELECT regexp_match('foobarbequebaz', 'bar.*que');
 regexp_match
--------------
 {barbeque}
(1 row)

SELECT regexp_match('foobarbequebaz', '(bar)(beque)');
 regexp_match
--------------
 {bar,beque}
(1 row)</pre><p>
マッチするときはマッチする部分文字列全体、マッチしないときは<code class="literal">NULL</code>を返したいというよくあるケースは、以下のように書くことができます。
</p><pre class="programlisting">SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];
 regexp_match
--------------
 barbeque
(1 row)</pre><p>
   </p><p><code class="function">regexp_matches</code>関数はPOSIX正規表現パターンを文字列にマッチさせた結果、捕捉された部分文字列のテキスト配列の集合を返します。
構文は<code class="function">regexp_match</code>と同じです。
この関数は、マッチするものがないときは行を返しませんが、マッチするものがあり、<code class="literal">g</code>フラグが指定されていないときは1行だけ、マッチするものが<em class="replaceable"><code>N</code></em>個あり、<code class="literal">g</code>フラグが指定されているときは<em class="replaceable"><code>N</code></em>行を返します。
返される各行は上で<code class="function">regexp_match</code>について説明したのと全く同じで、マッチする部分文字列全体、または丸括弧で括られた部分文字列にマッチする部分文字列を含むテキスト配列です。
<code class="function">regexp_matches</code>は<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Table 9.22. ARE埋め込みオプション文字">Table 9.22</a>に示すすべてのフラグに加え、最初のマッチだけでなくすべてのマッチを返す<code class="literal">g</code>を受け付けます。
    </p><p>例を示します。
</p><pre class="programlisting">SELECT regexp_matches('foo', 'not there');
 regexp_matches
----------------
(0 rows)

SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');
 regexp_matches
----------------
 {bar,beque}
 {bazil,barf}
(2 rows)</pre><p>
   </p><div class="tip"><h3 class="title">Tip</h3><p>最初にマッチするものだけが必要なときは<code class="function">regexp_match()</code>を使う方がより簡単で効率的ですから、<code class="function">regexp_matches()</code>はほとんどの場合<code class="literal">g</code>フラグを指定して使われるでしょう。
しかし、<code class="function">regexp_match()</code>は<span class="productname">PostgreSQL</span>のバージョン10以上でのみ利用できます。
古いバージョンを使う時によくある手法は、以下の例のように、副SELECTの中に<code class="function">regexp_matches()</code>の呼び出しを入れることです。
</p><pre class="programlisting">SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;</pre><p>
これは<code class="function">regexp_match()</code>と同じく、マッチするものがあればテキスト配列を生成し、マッチしなければ<code class="literal">NULL</code>となります。
副SELECTを使わなければ、マッチするものがないテーブル行については問い合わせの出力が生成されず、多くの場合に期待される動作と異なります。
    </p></div><p><code class="function">regexp_split_to_table</code>関数はPOSIX正規表現パターンを区切り文字として使用し、文字列を分割します。<code class="function">regexp_split_to_table</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
<em class="replaceable"><code>pattern</code></em>にマッチしない場合、関数は<em class="replaceable"><code>string</code></em>を返します。
少なくともひとつのマッチがあれば、それぞれのマッチに対して関数は最後のマッチの終わり（あるいは文字列の始め）から最初のマッチまでのテキストを返します。
もはやマッチしなくなると最後のマッチの終わりから文字列の最後までテキストを返します。
<em class="replaceable"><code>flags</code></em>パラメータは、関数の動作を変更するゼロもしくは複数の単一文字フラグを含むオプションのテキスト文字列です。
<code class="function">regexp_split_to_table</code>は<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Table 9.22. ARE埋め込みオプション文字">Table 9.22</a>で記載されているフラグをサポートします。
    </p><p><code class="function">regexp_split_to_array</code>関数は、<code class="function">regexp_split_to_array</code>がその結果を<code class="type">text</code>配列で返すことを除いて、<code class="function">regexp_split_to_table</code>と同じ動作をします。
<code class="function">regexp_split_to_array</code>(<em class="replaceable"><code>string</code></em>, <em class="replaceable"><code>pattern</code></em> [<span class="optional">, <em class="replaceable"><code>flags</code></em> </span>])の構文になります。
パラメータは<code class="function">regexp_split_to_table</code>のものと同じです。
    </p><p>例：
</p><pre class="programlisting">
SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\s+') AS foo;
  foo   
-------
 the    
 quick  
 brown  
 fox    
 jumps 
 over   
 the    
 lazy   
 dog    
(9 rows)

SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\s+');
              regexp_split_to_array             
-----------------------------------------------
 {the,quick,brown,fox,jumps,over,the,lazy,dog}
(1 row)

SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\s*') AS foo;
 foo 
-----
 t         
 h         
 e         
 q         
 u         
 i         
 c         
 k         
 b         
 r         
 o         
 w         
 n         
 f         
 o         
 x         
(16 rows)</pre><p>
   </p><p>最後の例が明らかにしているように、regexp分割関数は文字列の最初あるいは終わり、もしくは前のマッチの直後に発生する長さを持たないマッチを無視します。
<code class="function">regexp_match</code>および<code class="function">regexp_matches</code>で実装されたregexpマッチの厳格な定義にこれは相容れませんが、実務上は最も使い勝手の良い動作です。
Perlのような他のソフトウェアシステムも似たような定義を使用します。
   </p><div class="sect3" id="POSIX-SYNTAX-DETAILS"><div class="titlepage"><div><div><h4 class="title">9.7.3.1. 正規表現の詳細</h4></div></div></div><p><span class="productname">PostgreSQL</span>の正規表現はHenry Spencerにより書かれたソフトウェアパッケージを使用して実装されています。
以下に説明する正規表現の多くの部分は同氏のマニュアルから一字一句複製したものです。
   </p><p><acronym class="acronym">POSIX</acronym> 1003.2の定義によると、正規表現（<acronym class="acronym">RE</acronym>）には2つの形式があるとされます。<em class="firstterm">拡張</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">ERE</acronym>（大まかにいって<code class="command">egrep</code>に代表されるもの）、および<em class="firstterm">基本</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">BRE</acronym>（大まかにいって<code class="command">ed</code>に代表されるもの）です。
<span class="productname">PostgreSQL</span>は両方の形式をサポートし、さらに、POSIX標準にはないけれどもPerlやTclなどのプログラミング言語で利用できることから広く使用されるようになった、いくつかの拡張もサポートしています。
本書では、非POSIX拡張を使用した<acronym class="acronym">RE</acronym>を<em class="firstterm">高度な</em><acronym class="acronym">RE</acronym>もしくは<acronym class="acronym">ARE</acronym>と呼びます。AREはEREの正確な上位セットですが、BREとは複数の記法上の非互換な点があります（さらに非常に多くの制限が課されています）。
まず、AREとERE形式について説明し、そして、AREにのみ適用される機能の注意を、さらにBREとの違いについて説明します。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>は常に、まず正規表現はARE規則に従うと推測します。
しかし、REパターンの前に、<a class="xref" href="functions-matching.html#POSIX-METASYNTAX" title="9.7.3.4. 正規表現メタ構文">Section 9.7.3.4</a>に記載されているような<em class="firstterm">埋め込みオプション</em>を追加することにより、より限られたERE、あるいはBRE規則を選択することができます。
これは、<acronym class="acronym">POSIX</acronym>1003.2の規則を正確に期待しているアプリケーションとの互換性に関して有用です。
    </p></div><p>正規表現は<code class="literal">|</code>で区切られた、1つまたは複数の<em class="firstterm">ブランチ</em>として定義されます。
ブランチのいずれか1つにマッチすればマッチしたことになります。
   </p><p>ブランチはゼロ個以上の<em class="firstterm">量化アトム</em>もしくは<em class="firstterm">制約</em>の連結です。
最初のものにマッチに、次に第２番目のものにマッチを、というふうにマッチします。なお、空のブランチは空文字列にマッチします。
   </p><p>量化アトムとは、単一の<em class="firstterm">量指定子</em>が後ろに付く<em class="firstterm">アトム</em>のことです。
量指定子がないと、アトムにマッチするものがマッチしたことになります。
量指定子がある場合、アトムとのマッチが何回あるかでマッチしたことになります。
<em class="firstterm">アトム</em>は、<a class="xref" href="functions-matching.html#POSIX-ATOMS-TABLE" title="Table 9.15. 正規表現のアトム">Table 9.15</a>に示したもののいずれかを取ることができます。
  <a class="xref" href="functions-matching.html#POSIX-QUANTIFIERS-TABLE" title="Table 9.16. 正規表現量指定子">Table 9.16</a>に設定可能な量指定子とその意味を示します。
   </p><p><em class="firstterm">制約</em>は空文字に、特定の条件に合う場合のみにマッチします。
アトムを使用できるところには制約を使用することができます。ただしその後に量指定子を付けることはできません。
単純な制約を<a class="xref" href="functions-matching.html#POSIX-CONSTRAINTS-TABLE" title="Table 9.17. 正規表現制約">Table 9.17</a>に示します。後で他のいくつかの制約を説明します。
   </p><div class="table" id="POSIX-ATOMS-TABLE"><p class="title"><strong>Table 9.15. 正規表現のアトム</strong></p><div class="table-contents"><table class="table" summary="正規表現のアトム" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>アトム</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">(</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>（ここで<em class="replaceable"><code>re</code></em> は任意の正規表現で、）<em class="replaceable"><code>re</code></em>とのマッチに適合するもです。 マッチは可能である報告用と意味づけられます。</td></tr><tr><td> <code class="literal">(?:</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td>上と同じ。ただし、マッチは報告用と意味づけられません。（<span class="quote">“<span class="quote">捕捉されない</span>”</span>括弧の集合）（AREのみ）</td></tr><tr><td> <code class="literal">.</code> </td><td>任意の1文字にマッチします。</td></tr><tr><td> <code class="literal">[</code><em class="replaceable"><code>chars</code></em><code class="literal">]</code> </td><td>        <em class="firstterm">ブラケット式</em>。
        <em class="replaceable"><code>chars</code></em>のいずれか1つにマッチします
       （詳細は<a class="xref" href="functions-matching.html#POSIX-BRACKET-EXPRESSIONS" title="9.7.3.2. ブラケット式">Section 9.7.3.2</a>を参照してください）。
       </td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>k</code></em> </td><td>（ここで<em class="replaceable"><code>k</code></em>は英数字以外です。）普通の文字として指定した文字にマッチします。例えば、<code class="literal">\\</code>はバックスラッシュ文字です。</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>c</code></em> </td><td>ここで<em class="replaceable"><code>c</code></em>は英数字です
       （おそらく他の文字が後に続きます）。
       <em class="firstterm">エスケープ</em>です。
       <a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. 正規表現エスケープ">Section 9.7.3.3</a>を参照してください
       （AREのみ、EREとBREではこれは<em class="replaceable"><code>c</code></em>にマッチします）。
       </td></tr><tr><td> <code class="literal">{</code> </td><td>直後に数字以外がある場合、左中括弧<code class="literal">{</code>にマッチします。
直後に数字が続く場合、<em class="replaceable"><code>bound</code></em>（後述）の始まりです。</td></tr><tr><td> <em class="replaceable"><code>x</code></em> </td><td>ここで<em class="replaceable"><code>x</code></em>は他に意味を持たない1文字です。
<em class="replaceable"><code>x</code></em>にマッチします。</td></tr></tbody></table></div></div><br class="table-break" /><p>REはバックスラッシュ<code class="literal">\</code>を終端とすることはできません。
   </p><div class="note"><h3 class="title">Note</h3><p>もし<a class="xref" href="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS">standard_conforming_strings</a>パラメータをoffにしていた場合、リテラル文字列定数に記述するバックスラッシュは2倍必要となります。
  詳細は<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">Section 4.1.2.1</a>を参照してください。
    </p></div><div class="table" id="POSIX-QUANTIFIERS-TABLE"><p class="title"><strong>Table 9.16. 正規表現量指定子</strong></p><div class="table-contents"><table class="table" summary="正規表現量指定子" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>量指定子</th><th>マッチ</th></tr></thead><tbody><tr><td> <code class="literal">*</code> </td><td>アトムの0個以上複数の並びにマッチ</td></tr><tr><td> <code class="literal">+</code> </td><td>アトムの1個以上複数の並びにマッチ</td></tr><tr><td> <code class="literal">?</code> </td><td>アトムの0個または1個の並びにマッチ</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code> </td><td>アトムの正確に<em class="replaceable"><code>m</code></em>個の並びにマッチ</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code> </td><td>アトムの<em class="replaceable"><code>m</code></em>個以上の並びにマッチ</td></tr><tr><td>       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code> </td><td> アトムの<em class="replaceable"><code>m</code></em>個以上<em class="replaceable"><code>n</code></em>以下の並びにマッチ。
<em class="replaceable"><code>m</code></em>は<em class="replaceable"><code>n</code></em>を超えることはできません。</td></tr><tr><td> <code class="literal">*?</code> </td><td><code class="literal">*</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">+?</code> </td><td><code class="literal">+</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">??</code> </td><td><code class="literal">?</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>の最短マッチを行うバージョン</td></tr><tr><td> <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,}</code>の最短マッチを行うバージョン</td></tr><tr><td>       <code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code> </td><td><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>の最短マッチを行うバージョン</td></tr></tbody></table></div></div><br class="table-break" /><p><code class="literal">{</code><em class="replaceable"><code>...</code></em><code class="literal">}</code>を使用する形式は<em class="firstterm">バウンド</em>として知られています。
バウンド内の<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>という数は符号なし10進整数であり、0以上255以下の値を取ることができます。
   </p><p><em class="firstterm">最短マッチを行う</em>量指定子（AREのみで使用可能）は、対応する通常の（<em class="firstterm">欲張りの</em>）ものと同じものにマッチしますが、最大のマッチではなく最小のマッチを取ります。
詳細は<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照してください。
   </p><div class="note"><h3 class="title">Note</h3><p>量指定子の直後に量指定子を続けることはできません。例えば<code class="literal">**</code>は無効です。
量指定子から式や副式を始めることはできず、また、<code class="literal">^</code>や<code class="literal">|</code>の直後に付けることもできません。
    </p></div><div class="table" id="POSIX-CONSTRAINTS-TABLE"><p class="title"><strong>Table 9.17. 正規表現制約</strong></p><div class="table-contents"><table class="table" summary="正規表現制約" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>制約</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">^</code> </td><td>文字列の先頭にマッチ</td></tr><tr><td> <code class="literal">$</code> </td><td>文字列の末尾にマッチ</td></tr><tr><td> <code class="literal">(?=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">先行肯定検索</em>は、<em class="replaceable"><code>re</code></em>にマッチする部分文字列が始まる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td><em class="firstterm">先行否定検索</em>は、<em class="replaceable"><code>re</code></em>にマッチしない部分文字列が始まる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?&lt;=</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td> <em class="firstterm">後方肯定検索</em>は<em class="replaceable"><code>re</code></em>にマッチする部分文字列が終わる任意の場所にマッチします（AREのみ）。</td></tr><tr><td> <code class="literal">(?&lt;!</code><em class="replaceable"><code>re</code></em><code class="literal">)</code> </td><td> <em class="firstterm">後方否定検索</em><em class="replaceable"><code>re</code></em>にマッチしない部分文字列が終わる任意の場所にマッチします（AREのみ）。</td></tr></tbody></table></div></div><br class="table-break" /><p>先行検索制約および後方検索制約には<em class="firstterm">後方参照</em>（<a class="xref" href="functions-matching.html#POSIX-ESCAPE-SEQUENCES" title="9.7.3.3. 正規表現エスケープ">Section 9.7.3.3</a>を参照）を含めることはできません。また、その中の括弧は全て取り込むものではないとみなされます。
   </p></div><div class="sect3" id="POSIX-BRACKET-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.7.3.2. ブラケット式</h4></div></div></div><p><em class="firstterm">ブラケット式</em>とは、<code class="literal">[]</code>内の文字のリストです。
通常これはそのリスト内の任意の1文字にマッチします（しかし、以降を参照してください）。
リストが<code class="literal">^</code>から始まる場合、そのリストの残りには<span class="emphasis"><em>ない</em></span>任意の1文字にマッチします。
リスト内の2文字が<code class="literal">-</code>で区切られていた場合、これは2つ（を含む）の間にある文字範囲全体を表す省略形となります。例えば、<acronym class="acronym">ASCII</acronym>における<code class="literal">[0-9]</code>は全ての数字にマッチします。
例えば<code class="literal">a-c-e</code>といった、終端を共有する2つの範囲は不正です。
範囲は並びの照合順に非常に依存しています。ですので、移植予定のプログラムではこれに依存してはなりません。
   </p><p>このリストに<code class="literal">]</code>そのものを含めるには、それを先頭文字（もしそれが使用されれば<code class="literal">^</code>の後）にしてください。
<code class="literal">-</code>そのものを含めるには、それを先頭もしくは末尾の文字とするか、範囲の2番目の終端としてください。
<code class="literal">-</code>を範囲の最初の終端で使用するには、<code class="literal">[.</code>と<code class="literal">.]</code>でそれを囲み、照合要素（後述）にしてください。
これら文字と、<code class="literal">[</code>（次段落を参照）のなんらかの組み合わせ、およびエスケープ（AREのみ）を例外として、他の全ての特殊文字はブラケット式内では特殊な意味を持ちません。
特に、<code class="literal">\</code>はEREとBRE規則に従う場合は特別でなくなります。しかし、AREでは（エスケープの始まりとして）特別な意味を持ちます。
   </p><p>ブラケット式内に、照合要素（文字、単一文字であるかのように照合する複数文字の並び、もしくはそれぞれの照合並びの名前）が<code class="literal">[.</code>と<code class="literal">.]</code>の間にあると、その照合要素の文字の並びを意味します。
この並びはブラケット式のリストの一要素として取り扱われます。
このことにより、ブラケット式は要素を照合する複数文字を含むブラケット式を1文字以上にマッチさせることができます。例えば、照合並びが<code class="literal">ch</code>照合要素を含む場合、正規表現<code class="literal">[[.ch.]]*c</code>は<code class="literal">chchcc</code>という文字の最初の5文字にマッチします。
   </p><div class="note"><h3 class="title">Note</h3><p>今のところ、<span class="productname">PostgreSQL</span>は複数文字照合要素をサポートしません。
この情報は将来の振舞いの可能性を説明したものです。
    </p></div><p>ブラケット式内の<code class="literal">[=</code>と<code class="literal">=]</code>の間に照合要素は<em class="firstterm">同値クラス</em>です。全ての照合要素の文字の並びが自身を含むものと等価であることを示します。
（他に等価な照合要素がある場合、<code class="literal">[.</code>と<code class="literal">.]</code>で囲まれたかのように扱われます。）
例えば、<code class="literal">[[=o=]]</code>、<code class="literal">[[=^=]]</code>および<code class="literal">[o^]</code>が全て同意語であれば、<code class="literal">o</code>と<code class="literal">^</code>は同値クラスのメンバです。
同値クラスは範囲の終端にはなりません。
   </p><p>ブラケット式内では、<code class="literal">[:</code>と<code class="literal">:]</code>の間にある文字クラスの名称は、そのクラスに属する全ての文字のリストを意味します。
標準文字クラス名は、<code class="literal">alnum</code>、<code class="literal">alpha</code>、<code class="literal">blank</code>、<code class="literal">cntrl</code>、<code class="literal">digit</code>、<code class="literal">graph</code>、<code class="literal">lower</code>、<code class="literal">print</code>、<code class="literal">punct</code>、<code class="literal">space</code>、<code class="literal">upper</code>、<code class="literal">xdigit</code>です。
これらは<span class="citerefentry"><span class="refentrytitle">ctype</span></span>で定義された文字クラスを意味します。
ロケールは別のものを提供可能です。
文字クラスは範囲の終端では使用することができません。
   </p><p>ブラケット式には2つの特殊な場合があります。<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>というブラケット式は、先頭と終端の単語がそれぞれ空文字であることにマッチする制約です。
単語は、単語文字が前後に付かない単語文字の並びとして定義されます。
単語文字とは（<span class="citerefentry"><span class="refentrytitle">ctype</span></span>で定義されている）1つの<code class="literal">alnum</code>文字またはアンダースコアです。
これは、<acronym class="acronym">POSIX</acronym> 1003.2との互換性はありますが、そこでは定義されていない式です。ですので、他システムへ移植予定のソフトウェアでの使用には注意が必要です。
通常後述の制約エスケープの方がよく使われます。これはもはや標準ではありませんが、入力しやすいものです。
   </p></div><div class="sect3" id="POSIX-ESCAPE-SEQUENCES"><div class="titlepage"><div><div><h4 class="title">9.7.3.3. 正規表現エスケープ</h4></div></div></div><p><em class="firstterm">エスケープ</em>とは、<code class="literal">\</code>から始まり英数字がその後に続く特殊な並びです。
エスケープには、文字エントリ、クラス省略、制約エスケープ、後方参照といった様々な変種があります。
<code class="literal">\</code>の後に英数字が続くけれども、有効なエスケープを構成しない並びはAREでは不正です。
EREにはエスケープはありません。ブラケット式の外側では、<code class="literal">\</code>の後に英数字が続く並びは単に普通の文字としてその文字を意味します。ブラケット式の内側では、<code class="literal">\</code>は普通の文字です。
（後者はEREとARE間の非互換性の1つです。）
   </p><p><em class="firstterm">文字エントリエスケープ</em>は非印字文字やRE内でその他の不便な文字の指定を簡略化するために存在します。
これらを<a class="xref" href="functions-matching.html#POSIX-CHARACTER-ENTRY-ESCAPES-TABLE" title="Table 9.18. 正規表現文字エントリエスケープ">Table 9.18</a>に示します。
   </p><p><em class="firstterm">クラス省略エスケープ</em>は、あるよく使用される文字クラスの省略形を提供します。
これらを<a class="xref" href="functions-matching.html#POSIX-CLASS-SHORTHAND-ESCAPES-TABLE" title="Table 9.19. 正規表現クラス省略エスケープ">Table 9.19</a>に示します。
   </p><p><em class="firstterm">制約エスケープ</em>は、指定した条件に合う場合に空文字にマッチする制約をエスケープとして表したものです。
これらを<a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-ESCAPES-TABLE" title="Table 9.20. 正規表現制約エスケープ">Table 9.20</a>に示します。
   </p><p><em class="firstterm">後方参照</em>（<code class="literal">\</code><em class="replaceable"><code>n</code></em>）は、直前に括弧で囲まれた副式によってマッチされた、<em class="replaceable"><code>n</code></em>番目の同一文字列にマッチします（<a class="xref" href="functions-matching.html#POSIX-CONSTRAINT-BACKREF-TABLE" title="Table 9.21. 正規表現後方参照">Table 9.21</a>を参照してください）。
  例えば、<code class="literal">([bc])\1</code>は<code class="literal">bb</code>もしくは<code class="literal">cc</code>にマッチしますが、<code class="literal">bc</code>や<code class="literal">cb</code>にはマッチしません。REでは副式全体は後方参照の前になければなりません。
副式は開括弧の順番で番号付けされます。
取り込まない括弧は副式を定義しません。
   </p><div class="table" id="POSIX-CHARACTER-ENTRY-ESCAPES-TABLE"><p class="title"><strong>Table 9.18. 正規表現文字エントリエスケープ</strong></p><div class="table-contents"><table class="table" summary="正規表現文字エントリエスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\a</code> </td><td>C言語と同じ警報（ベル）文字</td></tr><tr><td> <code class="literal">\b</code> </td><td>C言語と同じバックスペース</td></tr><tr><td> <code class="literal">\B</code> </td><td> バックスラッシュの必要な二重化回数を減らすためのバックスラッシュ（<code class="literal">\</code>）の同義語</td></tr><tr><td> <code class="literal">\c</code><em class="replaceable"><code>X</code></em> </td><td>（ここで<em class="replaceable"><code>X</code></em>は任意の文字で）その下位5ビットが<em class="replaceable"><code>X</code></em>と同一、その他のビットが0となる文字 </td></tr><tr><td> <code class="literal">\e</code> </td><td>照合順名が<code class="literal">ESC</code>となる文字、それに失敗したら、<code class="literal">033</code>という8進数値を持つ文字。</td></tr><tr><td> <code class="literal">\f</code> </td><td>C言語と同じ改ページ</td></tr><tr><td> <code class="literal">\n</code> </td><td>C言語と同じ改行</td></tr><tr><td> <code class="literal">\r</code> </td><td>C言語と同じ復帰</td></tr><tr><td> <code class="literal">\t</code> </td><td>C言語と同じ水平タブ</td></tr><tr><td> <code class="literal">\u</code><em class="replaceable"><code>wxyz</code></em> </td><td>（ここで<em class="replaceable"><code>wxyz</code></em>は正確に4桁の16進数で）その16進数での値が<code class="literal">0x</code><em class="replaceable"><code>wxyz</code></em>という文字
       </td></tr><tr><td> <code class="literal">\U</code><em class="replaceable"><code>stuvwxyz</code></em> </td><td>（ここで<em class="replaceable"><code>stuvwxyz</code></em>は正確に8桁の16進数で）その16進数での値が<code class="literal">0x</code><em class="replaceable"><code>stuvwxyz</code></em>という文字
       </td></tr><tr><td> <code class="literal">\v</code> </td><td>C言語と同じ垂直タブ</td></tr><tr><td> <code class="literal">\x</code><em class="replaceable"><code>hhh</code></em> </td><td>（ここで<em class="replaceable"><code>hhh</code></em>は任意の16進数の並びで）その文字の16進数値が<code class="literal">0x</code><em class="replaceable"><code>hhh</code></em>となる文字（使用される16進数の桁数にかかわらず単一の文字）
       </td></tr><tr><td> <code class="literal">\0</code> </td><td>その値が<code class="literal">0</code>（NULLバイト）となる文字</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xy</code></em> </td><td>（ここで<em class="replaceable"><code>xy</code></em>は正確に2桁の8進数で、<em class="firstterm">後方参照</em>ではない）その値が<code class="literal">0</code><em class="replaceable"><code>xy</code></em>となる文字</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>xyz</code></em> </td><td>（ここで<em class="replaceable"><code>xyz</code></em>は正確に3桁の8進数で、<em class="firstterm">後方参照</em>ではない）その値が<code class="literal">0</code><em class="replaceable"><code>xyz</code></em>となる文字</td></tr></tbody></table></div></div><br class="table-break" /><p>16進数の桁とは<code class="literal">0</code>-<code class="literal">9</code>、<code class="literal">a</code>-<code class="literal">f</code>、<code class="literal">A</code>-<code class="literal">F</code>です。
8進数の桁とは<code class="literal">0</code>-<code class="literal">7</code>です。
   </p><p>ASCIIの範囲(0-127)外の値を指定した数字のエントリエスケープは、その意味がデータベースエンコーディングに依存します。
エンコーディングがUTF-8の場合、エスケープ値はユニコード符号位置に相当します。例えば、<code class="literal">\u1234</code>は文字<code class="literal">U+1234</code>を意味します。
その他のマルチバイトエンコーディングでは、文字エントリエスケープはたいてい文字のバイト値の連結を指定します。
エスケープ値がデータベースエンコーディングでのいかなる正当な文字にも対応しない場合、エラーは起こりませんが、いかなるデータにもマッチしません。
   </p><p>この文字エントリエスケープは常に普通の文字と解釈されます。
例えば、<code class="literal">\135</code>はASCIIの<code class="literal">]</code>となり、<code class="literal">\135</code>はブラケット式の終端にはなりません。
   </p><div class="table" id="POSIX-CLASS-SHORTHAND-ESCAPES-TABLE"><p class="title"><strong>Table 9.19. 正規表現クラス省略エスケープ</strong></p><div class="table-contents"><table class="table" summary="正規表現クラス省略エスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\d</code> </td><td> <code class="literal">[[:digit:]]</code> </td></tr><tr><td> <code class="literal">\s</code> </td><td> <code class="literal">[[:space:]]</code> </td></tr><tr><td> <code class="literal">\w</code> </td><td> <code class="literal">[[:alnum:]_]</code>
       （アンダースコアが含まれることに注意）</td></tr><tr><td> <code class="literal">\D</code> </td><td> <code class="literal">[^[:digit:]]</code> </td></tr><tr><td> <code class="literal">\S</code> </td><td> <code class="literal">[^[:space:]]</code> </td></tr><tr><td> <code class="literal">\W</code> </td><td> <code class="literal">[^[:alnum:]_]</code>
       （アンダースコアが含まれることに注意）</td></tr></tbody></table></div></div><br class="table-break" /><p>ブラケット式内では、<code class="literal">\d</code>、<code class="literal">\s</code>、および<code class="literal">\w</code>はその外側の大括弧を失い、<code class="literal">\D</code>、<code class="literal">\S</code>および<code class="literal">\W</code>は不正です。
（ですから、例えば<code class="literal">[a-c\d]</code>は<code class="literal">[a-c[:digit:]]</code>と同じになります。また、<code class="literal">[a-c\D]</code>は<code class="literal">[a-c^[:digit:]]</code>と同じになり、不正です。）
   </p><div class="table" id="POSIX-CONSTRAINT-ESCAPES-TABLE"><p class="title"><strong>Table 9.20. 正規表現制約エスケープ</strong></p><div class="table-contents"><table class="table" summary="正規表現制約エスケープ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\A</code> </td><td>文字列の先頭にのみマッチします（<code class="literal">^</code>との違いについては<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照してください）。</td></tr><tr><td> <code class="literal">\m</code> </td><td> 単語の先頭にのみマッチします。 </td></tr><tr><td> <code class="literal">\M</code> </td><td> 単語の末尾にのみマッチします。 </td></tr><tr><td> <code class="literal">\y</code> </td><td> 単語の先頭もしくは末尾にのみマッチします。</td></tr><tr><td> <code class="literal">\Y</code> </td><td>単語の先頭もしくは末尾以外の場所にのみマッチします。</td></tr><tr><td> <code class="literal">\Z</code> </td><td>文字列の末尾にのみマッチします（<code class="literal">$</code>との違いについては<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照してください）。</td></tr></tbody></table></div></div><br class="table-break" /><p>    単語は前述の<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>の規定通りに定義されます。ブラケット式内では制約エスケープは不正です。
   </p><div class="table" id="POSIX-CONSTRAINT-BACKREF-TABLE"><p class="title"><strong>Table 9.21. 正規表現後方参照</strong></p><div class="table-contents"><table class="table" summary="正規表現後方参照" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>エスケープ</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">\</code><em class="replaceable"><code>m</code></em> </td><td>（ここで<em class="replaceable"><code>m</code></em>は非ゼロの数です。）副式の<em class="replaceable"><code>m</code></em>番目への後方参照</td></tr><tr><td> <code class="literal">\</code><em class="replaceable"><code>mnn</code></em> </td><td>（ここで<em class="replaceable"><code>m</code></em>は非ゼロの数です。<em class="replaceable"><code>nn</code></em>でさらに桁を指定します。<em class="replaceable"><code>mnn</code></em>10進数値は取り込み括弧の数よりも多くてはなりません。）副式の<em class="replaceable"><code>mnn</code></em>番目への後方参照</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Note</h3><p>8進数の文字エントリエスケープと後方参照の間には曖昧性があります。上でヒントとして示したようにこれは以下の発見的手法で解決されます。
先頭の0は常に8進数エスケープを示します。
その後に数字が続かない単一の非ゼロ数字は常に後方参照として解釈されます。
ゼロから始まらない複数数字の並びは、適切な副式の後にあれば（つまり、その番号が後方参照用の範囲内にあれば）後方参照として解釈されます。さもなくば、8進数として解釈されます。
    </p></div></div><div class="sect3" id="POSIX-METASYNTAX"><div class="titlepage"><div><div><h4 class="title">9.7.3.4. 正規表現メタ構文</h4></div></div></div><p>上述の主構文の他に、特殊な形式や雑多な構文的な機能が使用可能です。
   </p><p>REは、2つの特殊な<em class="firstterm">決定子</em>前置詞のどちらかから始まります。
REが<code class="literal">***:</code>から始まるものであれば、REの残りはAREと解釈されます。
(<span class="productname">PostgreSQL</span>はREをAREとして推測するため、通常は影響を受けません。ただし、正規表現関数に対して<em class="replaceable"><code>flags</code></em>パラメータを指定されたEREやBREモードでは影響を受けます。)
REが<code class="literal">***=</code>から始まるものであれば、REの残りは、全ての文字を普通の文字とみなしたリテラル文字列と解釈されます。
   </p><p>AREは<em class="firstterm">埋め込みオプション</em>から始められます。<code class="literal">(?</code><em class="replaceable"><code>xyz</code></em><code class="literal">)</code>という並びで残りのREに影響するオプションを指定します（ここで<em class="replaceable"><code>xyz</code></em>は1つ以上の英字です）。
このオプションは、事前に決定されたオプションを上書きします。— 特に、正規表現演算子、もしくは正規表現関数に与えられた<em class="replaceable"><code>flags</code></em>パラメータにより示される大文字小文字の区別を上書きします。
使用可能なオプション文字を<a class="xref" href="functions-matching.html#POSIX-EMBEDDED-OPTIONS-TABLE" title="Table 9.22. ARE埋め込みオプション文字">Table 9.22</a>に示します。
これらの同じオプション文字が、正規表現関数の<em class="replaceable"><code>flags</code></em>パラメータで使用されることに注意して下さい。
   </p><div class="table" id="POSIX-EMBEDDED-OPTIONS-TABLE"><p class="title"><strong>Table 9.22. ARE埋め込みオプション文字</strong></p><div class="table-contents"><table class="table" summary="ARE埋め込みオプション文字" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>オプション</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">b</code> </td><td> 残りのREはBRE </td></tr><tr><td> <code class="literal">c</code> </td><td> 大文字小文字を区別するマッチ（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </td></tr><tr><td> <code class="literal">e</code> </td><td> 残りのREはERE </td></tr><tr><td> <code class="literal">i</code> </td><td> 大文字小文字を区別しないマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照）（演算子で規定される大文字小文字の区別よりこの指定が優先されます）。 </td></tr><tr><td> <code class="literal">m</code> </td><td> <code class="literal">n</code>の歴史的な同義語 </td></tr><tr><td> <code class="literal">n</code> </td><td> 改行を区別するマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">p</code> </td><td> 部分的な改行を区別するマッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">q</code> </td><td> 残りのREはリテラル（<span class="quote">“<span class="quote">引用符付けされた</span>”</span>）文字列、全て普通の文字</td></tr><tr><td> <code class="literal">s</code> </td><td> 改行を区別しないマッチ（デフォルト）</td></tr><tr><td> <code class="literal">t</code> </td><td> 厳しめの構文（デフォルト、後述） </td></tr><tr><td> <code class="literal">w</code> </td><td> 部分的な改行区別の逆（<span class="quote">“<span class="quote">ワイアード</span>”</span>）マッチ（<a class="xref" href="functions-matching.html#POSIX-MATCHING-RULES" title="9.7.3.5. 正規表現マッチ規則">Section 9.7.3.5</a>を参照）</td></tr><tr><td> <code class="literal">x</code> </td><td> 拡張構文（後述） </td></tr></tbody></table></div></div><br class="table-break" /><p>埋め込みオプションはその並びの終端<code class="literal">)</code>で有効になります。
AREの先頭（もし<code class="literal">***:</code>決定子があればその後）でのみ利用可能です。
   </p><p>全ての文字が意味を持つ、通常の（<em class="firstterm">厳しめの</em>）RE構文に加え、<code class="literal">x</code>埋め込みオプションを指定することで利用できる<em class="firstterm">拡張</em>構文があります。
拡張構文では、RE内の空白文字は無視され、<code class="literal">#</code>とその後の改行（もしくはREの終端）の間の全ての文字も同様です。
これにより、段落付けや複雑なREのコメント付けが可能になります。
基本規則に対して3つの例外があります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>直前に<code class="literal">\</code>が付いた空白文字もしくは<code class="literal">#</code>は保持されます。
      </p></li><li class="listitem"><p>ブラケット式内の空白文字もしくは<code class="literal">#</code>は保持されます。
      </p></li><li class="listitem"><p><code class="literal">(?:</code>などの複数文字シンボルでは、空白文字とコメントは不正です。
      </p></li></ul></div><p>

ここでの空白文字とは、空白、タブ、改行、<em class="replaceable"><code>スペース</code></em>文字クラスに属する文字です。
   </p><p>最後に、AREのブラケット式の外側では、<code class="literal">(?#</code><em class="replaceable"><code>ttt</code></em><code class="literal">)</code>という並びはコメントになります（ここで<em class="replaceable"><code>ttt</code></em>は<code class="literal">)</code>を含まない任意のテキストです）。
繰り返しになりますが、これは<code class="literal">(?:</code>などの複数文字シンボルの文字間では使用できません。
こうしたコメントは実用性というより歴史的所産です。そのため、この使用は勧めません。代わりに拡張構文を使用してください。
   </p><p>初めに<code class="literal">***=</code>決定子が指定され、ユーザの入力がREではなくリテラルとして扱われる場合、これらのメタ構文拡張は使用<span class="emphasis"><em>できません</em></span>。
   </p></div><div class="sect3" id="POSIX-MATCHING-RULES"><div class="titlepage"><div><div><h4 class="title">9.7.3.5. 正規表現マッチ規則</h4></div></div></div><p>REが文字列の中の1つ以上の部分文字列とマッチする場合において、REは最初にマッチが始まった部分文字列とマッチします。
その位置からまた1つ以上の部分文字列とマッチした際は、正規表現は<em class="firstterm">最短マッチを行わない（欲張り型）</em>か<em class="firstterm">最短マッチを行う（非欲張り型）</em>かによって、最長マッチもしくは最短マッチの文字列のどちらかにマッチします
   </p><p>REが最長マッチかどうかは以下の規則によって決まります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>ほとんどのアトムおよび全ての式は欲張り属性を持ちません（これらは変動する量のテキストにまったくマッチしないからです）。
      </p></li><li class="listitem"><p>REを括弧で括ることは欲張りかどうかを変更しません。
      </p></li><li class="listitem"><p><code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}</code>もしくは<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">}?</code>といった固定繰り返し数の量指定子を持つ量指定付きアトムは、アトム自身と同一の欲張りさを持ちます（まったく持たない可能性もあります）。
      </p></li><li class="listitem"><p>他の通常の量指定子（<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}</code>、<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>が等しい場合も含みます）を持つ量指定付きアトムは欲張り型です（最長マッチを使用します）。
      </p></li><li class="listitem"><p>他の非欲張り型量指定子（<code class="literal">{</code><em class="replaceable"><code>m</code></em><code class="literal">,</code><em class="replaceable"><code>n</code></em><code class="literal">}?</code>、<em class="replaceable"><code>m</code></em>と<em class="replaceable"><code>n</code></em>が等しい場合も含みます）を持つ量指定付きアトムは非欲張り型です（最短マッチを使用します）。
      </p></li><li class="listitem"><p>最上位レベルの<code class="literal">|</code>演算子を持たないREであるブランチは、最初の欲張り属性を持つ量指定付きアトムと同一の欲張り属性を持ちます。
      </p></li><li class="listitem"><p><code class="literal">|</code>演算子で接続された2つ以上のブランチからなるREは常に欲張り型です。
      </p></li></ul></div><p>
   </p><p>上の規則は、個々の量指定付きアトムだけではなく、量指定付きアトムを複数含むブランチやRE全体の欲張り属性に関連します。
つまり、ブランチやRE全体が<span class="emphasis"><em>全体として</em></span>最長または最短の部分文字列にマッチするという方法でマッチ処理が行われます。
全体のマッチの長さが決まると、特定の部分式にマッチする部分がその部分式の欲張り属性によって決まります。この時、RE内でより前にある部分式が後にある部分式よりも高い優先度を持ちます。
   </p><p>この意味の例を示します。
</p><pre class="screen">SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">123</code>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">1</code></pre><p>
最初の例では、<code class="literal">Y*</code>が欲張り型であるため、REは全体として欲張り型です。
マッチは<code class="literal">Y</code>の位置から始まり、そこから可能な限り最長の文字列にマッチします。つまり<code class="literal">Y123</code>となります。
出力は括弧で括られた部分、つまり<code class="literal">123</code>となります。
2番目の例では、<code class="literal">Y*?</code>が非欲張り型のため、REは全体として非欲張り型です。
マッチは<code class="literal">Y</code>の位置から始まり、そこから可能な限り最短の文字列にマッチします。つまり<code class="literal">Y1</code>となります。
部分式<code class="literal">[0-9]{1,3}</code>は欲張り型ですが、決定されたマッチする全体の長さを変更することはできません。したがって、強制的に<code class="literal">1</code>にマッチすることになります。
   </p><p>まとめると、REが欲張り型部分式と非欲張り型部分式の両方を持つ場合、全体のマッチ長はRE全体に割り当てられる属性に応じて、最長マッチ長か最短マッチ長のどちらかになります。
部分式に割り当てられた属性は、部分式の中でどれだけの量をその部分式の中で<span class="quote">“<span class="quote">消費</span>”</span>できるかのみに影響します。
   </p><p><code class="literal">{1,1}</code>および<code class="literal">{1,1}?</code>量指定子を副式もしくはRE全体に使用して、それぞれ、欲張りか欲張りでないかを強制することが可能です。
RE全体に対してはその要素から推論されるものと異なる欲張りさの属性が必要な場合に、これは便利です。
例として、数字をいくつか含む文字列を数字とその前後の部分に分けようとしているとします。
次のようにしてみるかもしれません。
</p><pre class="screen">SELECT regexp_match('abc01234xyz', '(.*)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc0123,4,xyz}</code></pre><p>
上手くいきませんでした。最初の<code class="literal">.*</code>が欲張りで、可能なだけ<span class="quote">“<span class="quote">消費</span>”</span>してしまい、<code class="literal">\d+</code>は最後の可能な場所で最後の数字にマッチします。
欲張りでなくすることで直そうとするかもしれません。
</p><pre class="screen">SELECT regexp_match('abc01234xyz', '(.*?)(\d+)(.*)');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc,0,""}</code></pre><p>
またもや上手くいきませんでした。今度は、REが全体として欲張りでなくなってしまい、できる限り早く全体に渡るマッチを終わらせてしまうからです。
RE全体として欲張りにすることで欲しいものが得られます。
</p><pre class="screen">SELECT regexp_match('abc01234xyz', '(?:(.*?)(\d+)(.*)){1,1}');
<em class="lineannotation"><span class="lineannotation">Result: </span></em><code class="computeroutput">{abc,01234,xyz}</code></pre><p>
REの全体に渡る欲張りさをその要素の欲張りさと別に制御すれば、可変長のパターンを非常に柔軟に扱えます。
   </p><p>マッチが長いか短いかを判断する時には、マッチの長さは照合要素ではなく文字列で測られます。
空文字列はまったくマッチする要素がない文字列よりも長いと考えられます。
例えば、<code class="literal">bb*</code>は<code class="literal">abbbc</code>の真中の3文字とマッチし、<code class="literal">(week|wee)(night|knights)</code>は<code class="literal">weeknights</code>の全ての10文字とマッチし、<code class="literal">abc</code>に対して<code class="literal">(.*).*</code>がマッチされると、括弧内の部分正規表現は3つの文字全てにマッチし、<code class="literal">bc</code>に対して<code class="literal">(a*)*</code>がマッチされると、全体のREと括弧内の正規表現は空文字列にマッチします。
   </p><p>もし大文字小文字を区別しないマッチが指定されると、アルファベット文字の大文字小文字の区別がまったくなくなったのと同じ効果を与えます。
ブラケット式の外側にアルファベットの大文字小文字が混ざった通常の文字が出てきた場合、例えば、<code class="literal">x</code>が<code class="literal">[xX]</code>となるように大文字小文字ともにブラケット式に実質的に転換されます。
ブラケット式の中に現れた時は、（例えば）<code class="literal">[x]</code>が<code class="literal">[xX]</code>となり、また<code class="literal">[^x]</code>が<code class="literal">[^xX]</code>となるように、全ての大文字小文字それぞれの対がブラケット式に追加されます。
   </p><p>改行を区別するマッチが指定されると、<code class="literal">.</code>と<code class="literal">^</code>を使用するブラケット式は（REが明示的に調整されていたとしてもマッチが改行をまたがらないようにするために）改行文字にマッチしなくなります。また、<code class="literal">^</code>と<code class="literal">$</code>はそれぞれ改行直後と直前の空文字列にマッチし、さらに、それぞれ文字列の先頭と末尾にマッチします。
しかし、AREエスケープの<code class="literal">\A</code>と<code class="literal">\Z</code>は、継続して、文字列の先頭と末尾<span class="emphasis"><em>のみ</em></span>にマッチします。
   </p><p>部分的に改行を区別するマッチが指定されると、<code class="literal">.</code>とブラケット式は改行を区別するマッチを行うようになりますが、<code class="literal">^</code>と<code class="literal">$</code>は変更されません。
   </p><p>部分的に改行を区別する逆マッチが指定されると、<code class="literal">^</code>と<code class="literal">$</code>は改行を区別するマッチを行うようになりますが、<code class="literal">.</code>とブラケット式は変更されません。
これはあまり有用ではありません。対称性のために提供されています。
   </p></div><div class="sect3" id="POSIX-LIMITS-COMPATIBILITY"><div class="titlepage"><div><div><h4 class="title">9.7.3.6. 制限と互換性</h4></div></div></div><p>本実装ではREの長さに関する制限はありません。
しかし、移植性を高めたいプログラムでは、256バイトを超えるREを使用すべきではありません。POSIX互換の実装ではそうしたREでは混乱する可能性があります。
   </p><p>AREの機能のうち、POSIX EREと実質的な非互換性があるのは、<code class="literal">\</code>がブラケット式の内側で特殊な意味を失わないという点のみです。
他の全てのARE機能は、POSIX EREでは不正、未定義、未指定な効果となる構文を使用しています。決定子の<code class="literal">***</code>構文などはBREおよびEREのPOSIX構文にはありません。
   </p><p>多くのARE拡張はPerlから拝借したものです。
しかし、いくつかは整理され、Perlの拡張のいくつかは存在しません。
注意すべき非互換性には、<code class="literal">\b</code>、<code class="literal">\B</code>、改行の取り扱いに関する特殊な措置の欠落、改行を区別するマッチに影響する点について補足したブラケット式の追加、括弧と先行・後方検索制約内の後方参照についての制限、最長/最短（最初にマッチするではなく）マッチのセマンティックがあります。
   </p><p><span class="productname">PostgreSQL</span>リリース7.4より前で認知された、AREとERE構文間で大きな非互換が2つあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>AREでは、<code class="literal">\</code>の後に英数字が続くものはエスケープもしくはエラーとなります。以前のリリースでは、これは単に、英数字を記述する他の方法でした。
これは、大きな問題にはならないはずです。以前のリリースではこうした並びを記述する理由がないからです。
      </p></li><li class="listitem"><p>AREでは、<code class="literal">\</code>は<code class="literal">[]</code>内でも特別な文字です。したがって、ブラケット式では<code class="literal">\</code>を<code class="literal">\\</code>と記述しなければなりません。
      </p></li></ul></div><p>
   </p></div><div class="sect3" id="POSIX-BASIC-REGEXES"><div class="titlepage"><div><div><h4 class="title">9.7.3.7. 基本正規表現</h4></div></div></div><p>BREはEREといくつかの面において異なります。
BREにおいては、<code class="literal">|</code>、<code class="literal">+</code>、<code class="literal">?</code>は普通の文字であり、それらの機能と等価なものはありません。
バウンドの区切りは<code class="literal">\{</code>と<code class="literal">\}</code>であり、<code class="literal">{</code>と<code class="literal">}</code>自身は普通の文字です。
副式を入れ子にするための括弧は<code class="literal">\(</code>と<code class="literal">\)</code>であり、<code class="literal">(</code>と<code class="literal">)</code>自身は普通の文字です。
<code class="literal">^</code>は、REの先頭にある場合や括弧内の副式の先頭の場合を除き、普通の文字です。
<code class="literal">$</code>は、REの末尾にある場合や括弧内の副式の末尾の場合を除き、普通の文字です。
また、<code class="literal">*</code>はREの先頭にある場合や括弧内の副式の先頭にある場合には普通の文字になります（その前に<code class="literal">^</code>が付いている可能性もあります）。
最後に、1桁の後方参照を使用することができ、また、BREにおいては、<code class="literal">\&lt;</code>と<code class="literal">\&gt;</code>はそれぞれ<code class="literal">[[:&lt;:]]</code>と<code class="literal">[[:&gt;:]]</code>と同義です。
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-bitstring.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-formatting.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.6. ビット文字列関数と演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 9.8. データ型書式設定関数</td></tr></table></div></body></html>