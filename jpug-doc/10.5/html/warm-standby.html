<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>26.2. ログシッピングスタンバイサーバ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="different-replication-solutions.html" title="26.1. 様々な解法の比較" /><link rel="next" href="warm-standby-failover.html" title="26.3. フェールオーバ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">26.2. ログシッピングスタンバイサーバ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="different-replication-solutions.html" title="26.1. 様々な解法の比較">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="Chapter 26. 高可用性、負荷分散およびレプリケーション">Up</a></td><th width="60%" align="center">Chapter 26. 高可用性、負荷分散およびレプリケーション</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="warm-standby-failover.html" title="26.3. フェールオーバ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="WARM-STANDBY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">26.2. ログシッピングスタンバイサーバ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="warm-standby.html#STANDBY-PLANNING">26.2.1. 計画</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#STANDBY-SERVER-OPERATION">26.2.2. スタンバイサーバの動作</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#PREPARING-MASTER-FOR-STANDBY">26.2.3. スタンバイサーバのためのマスタの準備</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#STANDBY-SERVER-SETUP">26.2.4. スタンバイサーバの設定</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#STREAMING-REPLICATION">26.2.5. ストリーミングレプリケーション</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#STREAMING-REPLICATION-SLOTS">26.2.6. レプリケーションスロット</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#CASCADING-REPLICATION">26.2.7. カスケードレプリケーション</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#SYNCHRONOUS-REPLICATION">26.2.8. 同期レプリケーション</a></span></dt><dt><span class="sect2"><a href="warm-standby.html#CONTINUOUS-ARCHIVING-IN-STANDBY">26.2.9. スタンバイにおける継続的アーカイビング</a></span></dt></dl></div><p>継続的なアーカイブ処理を使用して、プライマリサーバが失敗した場合に操作を引き継ぐ準備がなされた、1つ以上の<em class="firstterm">スタンバイサーバ</em>を持つ<em class="firstterm">高可用性</em>(HA)クラスタ構成を作成することができます。
この機能は<em class="firstterm">ウォームスタンバイ</em>または<em class="firstterm">ログシッピング</em>として広く知られています。
  </p><p>プライマリサーバとスタンバイサーバは、この機能を提供するために共同して稼動しますが、サーバとサーバはゆるく結合しています。
プライマリサーバは継続的アーカイブモードで動作し、各スタンバイサーバはプライマリからWALファイルを読み取る、継続的リカバリモードで動作します。
この機能を可能にするために、データベースのテーブル変更は不要です。
したがって、他のレプリケーションの解法に比べて、管理にかかるオーバーヘッドが減少します。
この構成はプライマリサーバの性能への影響も相対的に減少させます。
  </p><p>あるデータベースサーバから他へ直接WALレコードを移動することは通常、ログシッピングと説明されます。
<span class="productname">PostgreSQL</span>はファイルベースのログシッピングを実装します。
つまりWALレコードはある時点で1つのファイル(WALセグメント)として送信されることを意味します。
WALファイル(16MB)は隣り合うシステム、同じサイトの別システム、地球の裏側のシステムなど距離に関わらず、簡単かつ安価に送付することができます。
この技法に必要な帯域幅はプライマリサーバのトランザクションの頻度に応じて変動します。
レコードベースのログシッピングはより粒度を細かくしたもので、ネットワーク接続を介してWALの変更を増分的に流します（<a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. ストリーミングレプリケーション">Section 26.2.5</a>参照）。
  </p><p>ログシッピングが非同期であることに注意しなければなりません。
つまり、WALレコードはトランザクションがコミットした後に転送されます。
結果として、プライマリサーバが災害などの致命的な失敗をうけた場合、送信されていないトランザクションが失われますので、データを損失する空白期間があります。
ファイルベースのログシッピングにおけるデータ損失の空白期間量を<code class="varname">archive_timeout</code>パラメータを用いて制限することができます。
これは数秒程度まで小さく設定することができます。
しかし、低く設定するとファイル転送に必要な帯域幅が増大します。
ストリーミングレプリケーション（<a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. ストリーミングレプリケーション">Section 26.2.5</a>参照）により、データを損失する期間を非常に小さくすることができます。
  </p><p>リカバリ処理の性能は十分よく、一度実施されれば、スタンバイサーバが完全な状態から逸脱するのは一時的にしかすぎません。
結果としてこれは、高可用性を提供するウォームスタンバイ構成と呼ばれます。
保管されたベースバックアップからサーバをリストアし、ロールフォワードを行うことはおそらく長時間かかりますので、これは高可用性のための解法とはいえず、災害からのリカバリのための解法です。
スタンバイサーバは読み取り専用の問い合わせに使用することもできます。
この場合ホットスタンバイサーバと呼ばれます。
詳細については<a class="xref" href="hot-standby.html" title="26.5. ホットスタンバイ">Section 26.5</a>を参照してください。
  </p><a id="id-1.6.13.16.7" class="indexterm"></a><a id="id-1.6.13.16.8" class="indexterm"></a><a id="id-1.6.13.16.9" class="indexterm"></a><a id="id-1.6.13.16.10" class="indexterm"></a><a id="id-1.6.13.16.11" class="indexterm"></a><a id="id-1.6.13.16.12" class="indexterm"></a><div class="sect2" id="STANDBY-PLANNING"><div class="titlepage"><div><div><h3 class="title">26.2.1. 計画</h3></div></div></div><p>プライマリサーバとスタンバイサーバを、少なくともデータベースサーバという見地でできる限り同じになるように作成することを通常勧めます。
具体的には、テーブル空間に関連するパス名はそのまま渡されますので、テーブル空間機能を使用する場合には、プライマリとスタンバイサーバの両方でテーブル空間用のマウントパスを同じにしておかなければなりません。
<a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>をプライマリで実行する場合、そのコマンドを実行する前に必要な新しいマウントポイントをプライマリとすべてのスタンバイサーバで作成しなければならないことに注意してください。
ハードウェアをまったく同じにする必要はありませんが、経験上アプリケーションとシステムの運用期間に渡って2つの同じシステムを管理する方が、異なる2つのシステムを管理するよりも簡単です。
いずれにしてもハードウェアアーキテクチャは必ず同じでなければなりません。
例えば32ビットシステムから64ビットシステムへのシッピングは動作しません。
   </p><p>マイナーリリースの更新ではディスク書式を変更しないというのがPostgreSQLグローバル開発グループの方針ですので、プライマリサーバとスタンバイサーバとの間でマイナーリリースレベルの違いがあってもうまく動作するはずです。
しかし、この場合、公的なサポートは提供されません。
できる限りプライマリサーバとスタンバイサーバとで同じリリースレベルを使用してください。
新しいマイナーリリースに更新する場合、もっとも安全な方針はスタンバイサーバを先に更新することです。
新しいマイナーリリースは以前のマイナーリリースのWALファイルを読み込むことはできますが、逆はできないかもしれません。
   </p></div><div class="sect2" id="STANDBY-SERVER-OPERATION"><div class="titlepage"><div><div><h3 class="title">26.2.2. スタンバイサーバの動作</h3></div></div></div><p>スタンバイモードでは、サーバは継続的にマスタサーバから受け取ったWALを適用します。
スタンバイサーバはWALアーカイブ(<a class="xref" href="archive-recovery-settings.html#RESTORE-COMMAND">restore_command</a>参照)から、または直接TCP接続(ストリーミングレプリケーション)を介してマスタサーバから、WALを読み取ることができます。
またスタンバイサーバはスタンバイクラスタの<code class="filename">pg_wal</code>ディレクトリにあるすべてのWALをリストアしようと試みます。
これはよくサーバの再起動後、スタンバイが再起動前にマスタから流れ込んだWALを再生する時に発生します。
しかしまたファイルを再生する任意の時点で、手作業で<code class="filename">pg_wal</code>にコピーすることもできます。
   </p><p>起動時、スタンバイサーバは<code class="varname">restore_command</code>を呼び出して、アーカイブ場所にある利用可能なすべてのWALをリストアすることから始めます。
そこで利用可能なWALの終端に達し、<code class="varname">restore_command</code>が失敗すると、<code class="filename">pg_wal</code>ディレクトリにある利用可能な任意のWALのリストアを試みます。
ストリーミングレプリケーションが設定されている場合、これに失敗すると、スタンバイはプライマリサーバへの接続を試み、アーカイブまたは<code class="filename">pg_wal</code>内に存在した最終の有効レコードからWALのストリーミングを開始します。
ストリーミングレプリケーションが未設定時にこれに失敗する場合、または、接続が後で切断される場合、スタンバイは最初に戻り、アーカイブからのファイルのリストアを繰り返し行います。
このアーカイブ、<code class="filename">pg_wal</code>、ストリーミングレプリケーションからという再試行の繰り返しはサーバが停止する、あるいはトリガファイルによるフェールオーバが発行されるまで続きます。
   </p><p><code class="command">pg_ctl promote</code>が実行された時またはトリガファイル(<code class="varname">trigger_file</code>)が存在する時、スタンバイモードは終了し、サーバは通常の動作に切り替わります。
フェールオーバの前に、アーカイブまたは<code class="filename">pg_wal</code>内の即座に利用可能なWALをすべてリストアします。
しかし、マスタへの接続を行おうとはしません。
   </p></div><div class="sect2" id="PREPARING-MASTER-FOR-STANDBY"><div class="titlepage"><div><div><h3 class="title">26.2.3. スタンバイサーバのためのマスタの準備</h3></div></div></div><p><a class="xref" href="continuous-archiving.html" title="25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）">Section 25.3</a>で説明したように、スタンバイからアクセス可能なアーカイブディレクトリに対してプライマリで継続的なアーカイブを設定してください。
このアーカイブ場所はマスタが停止した時であってもスタンバイからアクセス可能でなければなりません。
つまり、マスタサーバ上ではなく、スタンバイサーバ自身上に存在するか、または他の高信頼性サーバ上に存在しなければなりません。
   </p><p>ストリーミングレプリケーションを使用したい場合、スタンバイサーバ(複数可)からのレプリケーション接続を受け付けるようにプライマリサーバで認証を設定してください。
つまり、ロールを作成し適切な項目を提供、あるいは、そのデータベースフィールドとして<code class="literal">replication</code>を持つ項目を<code class="filename">pg_hba.conf</code>内に設定してください。
また、プライマリサーバの設定ファイルにおいて<code class="varname">max_wal_senders</code>が十分大きな値に設定されていることを確認してください。
レプリケーションスロットを使用している場合は、<code class="varname">max_replication_slots</code>も十分に設定されているか確認してください。
   </p><p><a class="xref" href="continuous-archiving.html#BACKUP-BASE-BACKUP" title="25.3.2. ベースバックアップの作成">Section 25.3.2</a>に記述したように、スタンバイサーバの再起動のために、ベースバックアップを取得してください。
   </p></div><div class="sect2" id="STANDBY-SERVER-SETUP"><div class="titlepage"><div><div><h3 class="title">26.2.4. スタンバイサーバの設定</h3></div></div></div><p>スタンバイサーバを設定するためには、プライマリサーバから取得したベースバックアップをリストアしてください(<a class="xref" href="continuous-archiving.html#BACKUP-PITR-RECOVERY" title="25.3.4. 継続的アーカイブによるバックアップを使用した復旧">Section 25.3.4</a>参照)。
スタンバイのクラスタデータディレクトリ内に<code class="filename">recovery.conf</code>リカバリコマンドファイルを作成し、<code class="varname">standby_mode</code>を有効にしてください。
WALアーカイブからファイルをコピーする簡単なコマンドを<code class="varname">restore_command</code>に設定してください。
高可用性のために複数のスタンバイサーバを持たせようとしている場合、<code class="varname">recovery_target_timeline</code>を<code class="literal">latest</code>に設定し、スタンバイサーバが他のスタンバイにフェールオーバする時に発生するタイムラインの変更に従うようにします。
   </p><div class="note"><h3 class="title">Note</h3><p>ここで説明した組み込みのスタンバイモードといっしょにpg_standbyや類似ツールを使用しないでください。
<code class="varname">restore_command</code>はファイルが存在しない場合に即座に終了しなければなりません。
サーバが必要に応じてそのコマンドを再度実行します。
pg_standbyのようなツールを使用するためには<a class="xref" href="log-shipping-alternative.html" title="26.4. この他のログシッピングの方法">Section 26.4</a>を参照してください。
    </p></div><p>ストリーミングレプリケーションを使用したい場合には、ホスト名(またはIPアドレス)とプライマリサーバとの接続に必要な追加情報を含む、libpq接続文字列で<code class="varname">primary_conninfo</code>を記述してください。
プライマリで認証用のパスワードが必要な場合は<code class="varname">primary_conninfo</code>にそのパスワードも指定する必要があります。
   </p><p>スタンバイサーバを高可用性を目的に設定しているのであれば、スタンバイサーバはフェールオーバの後プライマリサーバとして動作しますので、プライマリサーバと同様にWALアーカイブ処理、接続、認証を設定してください。
   </p><p>WALアーカイブを使用している場合、<a class="xref" href="archive-recovery-settings.html#ARCHIVE-CLEANUP-COMMAND">archive_cleanup_command</a>パラメータを使用してスタンバイサーバで不要となったファイルを削除することで、その容量を最小化することができます。
特に<span class="application">pg_archivecleanup</span>ユーティリティは、典型的な単一スタンバイ構成（<a class="xref" href="pgarchivecleanup.html" title="pg_archivecleanup"><span class="refentrytitle"><span class="application">pg_archivecleanup</span></span></a>参照）における<code class="varname">archive_cleanup_command</code>と共に使用されるように設計されています。
しかし、バックアップを目的にアーカイブを使用している場合には、スタンバイから必要とされなくなったファイルであっても、最新のベースバックアップの時点からリカバリするために必要なファイルを保持しなければならないことに注意してください。
   </p><p><code class="filename">recovery.conf</code>の簡単な例を以下に示します。
</p><pre class="programlisting">standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'</pre><p>
   </p><p>スタンバイサーバの台数に制限はありませんが、ストリーミングレプリケーションを使用するなら、プライマリサーバに同時に接続できるように<code class="varname">max_wal_senders</code>を十分な数に設定してください。
   </p></div><div class="sect2" id="STREAMING-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.5. ストリーミングレプリケーション</h3></div></div></div><a id="id-1.6.13.16.17.2" class="indexterm"></a><p>ストリーミングレプリケーションによりスタンバイサーバはファイルベースのログシッピングよりもより最近の状態を維持できるようになります。
スタンバイは、WALレコードが生成された時にWALファイルがいっぱいになるまで待機せずにWALレコードをスタンバイに流し出すプライマリと接続します。
   </p><p>ストリーミングレプリケーションはデフォルトで非同期で、(<a class="xref" href="warm-standby.html#SYNCHRONOUS-REPLICATION" title="26.2.8. 同期レプリケーション">Section 26.2.8</a>参照)
この場合、プライマリでトランザクションがコミットされてから、その変更がスタンバイ側で参照可能になるまでの間にわずかな遅延がまだあります。
しかし、この遅延はファイルベースのログシッピングよりも非常に小さなもので、負荷に追随できる程度の能力があるスタンバイであれば通常は1秒以下です。
ストリーミングレプリケーションでは、データ損失期間を減らすための<code class="varname">archive_timeout</code>を必要としません。
   </p><p>ファイルベースの継続的アーカイブのないストリーミングレプリケーションを使用している場合、スタンバイが受け取る前に古いWALセグメントを再利用するかもしれません。
もし、そうなった場合はスタンバイは新しいベースバックアップから再作成しなければならなくなります。
<code class="varname">wal_keep_segments</code>を十分に大きくしたり、レプリケーションスロットにスタンバイを設定することでWALセグメントがすぐに再利用されることを防ぎ、これを防ぐことができます。WALアーカイブをスタンバイからアクセスできる位置に設定する場合は、スタンバイが常にWALセグメントを追随することができるため、これらの解決策は要求されません。
   </p><p>ストリーミングレプリケーションを使用するためには、<a class="xref" href="warm-standby.html" title="26.2. ログシッピングスタンバイサーバ">Section 26.2</a>の説明のようにファイルベースのログシッピングを行うスタンバイサーバを設定してください。
ファイルベースのログシッピングを行うスタンバイをストリーミングレプリケーションを行うスタンバイに切り替える手順は、<code class="filename">recovery.conf</code>内の<code class="varname">primary_conninfo</code>設定をプライマリサーバを指し示すように設定することです。
スタンバイサーバがプライマリサーバ上の<code class="literal">replication</code>疑似データベースに接続できる(<a class="xref" href="warm-standby.html#STREAMING-REPLICATION-AUTHENTICATION" title="26.2.5.1. 認証">Section 26.2.5.1</a>参照)ように、プライマリで<a class="xref" href="runtime-config-connection.html#GUC-LISTEN-ADDRESSES">listen_addresses</a>と認証オプション(<code class="filename">pg_hba.conf</code>参照)を設定してください。
   </p><p>キープアライブソケットオプションをサポートするシステムでは、<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-IDLE">tcp_keepalives_idle</a>、<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-INTERVAL">tcp_keepalives_interval</a>および<a class="xref" href="runtime-config-connection.html#GUC-TCP-KEEPALIVES-COUNT">tcp_keepalives_count</a>を設定することで、プライマリの接続切断の即時検知に有用です。
   </p><p>スタンバイサーバからの同時接続数の最大値を設定してください（詳細は<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>を参照）。
   </p><p>スタンバイが起動し、<code class="varname">primary_conninfo</code>が正しく設定されると、スタンバイはアーカイブ内で利用可能なWALファイルをすべて再生した後にプライマリと接続します。
接続の確立に成功すると、スタンバイでWAL受信プロセスが存在し、プライマリで対応するWAL送信プロセスが存在します。
   </p><div class="sect3" id="STREAMING-REPLICATION-AUTHENTICATION"><div class="titlepage"><div><div><h4 class="title">26.2.5.1. 認証</h4></div></div></div><p>信頼できるユーザのみがWALストリームを読み取ることができるように、レプリケーション用のアクセス権限を設定することは非常に重要です。
WALから機密情報を取り出すことは簡単だからです。
スタンバイサーバはプライマリに対してプライマリのスーパーユーザか<code class="literal">REPLICATION</code>権限を持つアカウントとして認証されなければなりません。
レプリケーションのための<code class="literal">REPLICATION</code>権限 と <code class="literal">LOGIN</code>権限を持つ専用のユーザを作成することをお勧めします。
<code class="literal">REPLICATION</code>権限は非常に強力な権限なので、<code class="literal">SUPERUSER</code>のようにプライマリのデータを変更することを許可されていません。
    </p><p>レプリケーション用のクライアント認証は<code class="filename">pg_hba.conf</code>内でその<em class="replaceable"><code>database</code></em>フィールドに<code class="literal">replication</code>を指定したレコードで制御されます。
例えば、スタンバイがIPアドレス<code class="literal">192.168.1.100</code>のホストで稼動し、レプリケーション用のアカウントの名前が<code class="literal">foo</code>である場合、管理者はプライマリ上の<code class="filename">pg_hba.conf</code>に以下の行を追加することができます。

</p><pre class="programlisting"># 利用者 foo のホスト 192.168.1.100 からプライマリサーバへのレプリケーションスタンバイとしての接続を
# 利用者のパスワードが正しく入力されたならば許可する
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5</pre><p>
    </p><p>プライマリサーバのホスト名とポート番号、接続する利用者名およびパスワードは、<code class="filename">recovery.conf</code>ファイルで指定します。
パスワードはスタンバイサーバの<code class="filename">~/.pgpass</code>ファイルでも設定できます（<em class="replaceable"><code>database</code></em>フィールドの<code class="literal">replication</code>を指定します）。
例えば、プライマリサーバが稼動するホストの IP アドレスが<code class="literal">192.168.1.50</code>でポート番号が<code class="literal">5432</code>であり、レプリケーションのアカウント名が<code class="literal">foo</code>であり、パスワードが<code class="literal">foopass</code>である場合、管理者はスタンバイサーバの<code class="filename">recovery.conf</code>ファイルに次行を追加できます。

</p><pre class="programlisting"># プライマリサーバが 192.168.1.50 のホストの 5432ポートで稼動し
# 利用者名が foo でパスワードが foopass とする
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'</pre><p>
    </p></div><div class="sect3" id="STREAMING-REPLICATION-MONITORING"><div class="titlepage"><div><div><h4 class="title">26.2.5.2. 監視</h4></div></div></div><p>ストリーミングレプリケーションの重要な健全性尺度は、プライマリサーバで生成されたがスタンバイサーバではまだ適用されていないWALレコードの量です。
プライマリサーバの現在のWAL書き込み位置とスタンバイサーバの受理したWALの最終位置を比較すれば、この遅延を計算できます。
これらの位置は、プライマリサーバでは<code class="function">pg_current_wal_lsn</code>を、スタンバイサーバでは<code class="function">pg_last_wal_receive_lsn</code>を使用すれば検索できます（詳細は<a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="Table 9.79. バックアップ制御関数">Table 9.79</a>および<a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="Table 9.80. リカバリ情報関数">Table 9.80</a>を参照）。
スタンバイサーバの最終位置は、<code class="command">ps</code>コマンドを使用して WAL受信プロセスの状態としても表示できます（詳細は<a class="xref" href="monitoring-ps.html" title="28.1. 標準的なUnixツール">Section 28.1</a>を参照）。
    </p><p><a class="link" href="monitoring-stats.html#PG-STAT-REPLICATION-VIEW" title="Table 28.5. pg_stat_replicationビュー"><code class="literal">pg_stat_replication</code></a>ビューを介してWAL送信処理プロセスのリストを入手することができます。
<code class="function">pg_current_wal_lsn</code>と<code class="literal">sent_lsn</code>フィールドとの違いが大きい場合、マスタサーバが高負荷状態であることを示している可能性があります。
一方でスタンバイサーバ上の<code class="literal">sent_lsn</code>と<code class="function">pg_last_wal_receive_lsn</code>の値の差異は、ネットワーク遅延、またはスタンバイが高負荷状態であることを示す可能性があります。
    </p></div></div><div class="sect2" id="STREAMING-REPLICATION-SLOTS"><div class="titlepage"><div><div><h3 class="title">26.2.6. レプリケーションスロット</h3></div></div></div><a id="id-1.6.13.16.18.2" class="indexterm"></a><p>レプリケーションスロットは、以下のことを保証する自動的な方法を提供します。
全てのスタンバイがWALセグメントを受け取るまでは、マスターがWALセグメントを削除しないこと、また、スタンバイが接続していない際にも、<a class="link" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="26.5.2. 問い合わせコンフリクトの処理">リカバリの競合</a>が発生する可能性がある行をマスターが削除しないこと、です。
   </p><p>レプリケーションスロットを使う代わりに、<a class="xref" href="runtime-config-replication.html#GUC-WAL-KEEP-SEGMENTS">wal_keep_segments</a>を使う、あるいは<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>を使用してセグメントをアーカイブに保存することによっても、古いWALセグメントの削除を防ぐことができます。
しかし、これらの方法はしばしば要求される以上のWALセグメントを残すことになってしまうのに対し、レプリケーションスロットは必要と判断されたセグメントのみを残します。
これらの方法のメリットの一つは<code class="literal">pg_wal</code>が要求する領域を制限できることです。現時点でレプリケーションスロットを使って同じことをする方法はありません。
   </p><p>同様に、<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY-FEEDBACK">hot_standby_feedback</a>と<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>は必要な行をvacuumが削除するのを防ぐ機能を提供しますが、前者はスタンバイが接続されていない間は行の保護を提供しませんし、後者は適切な保護を提供するために高い値を設定せざるを得ないことがしばしばあります。
レプリケーションスロットはこのような短所を克服しています。
   </p><div class="sect3" id="STREAMING-REPLICATION-SLOTS-MANIPULATION"><div class="titlepage"><div><div><h4 class="title">26.2.6.1. レプリケーションスロットへの問い合わせと操作</h4></div></div></div><p>いずれのレプリケーションスロットにも小文字、数字、アンダースコアを含む名前があります。
    </p><p>レプリケーションスロットとその状態は<a class="link" href="view-pg-replication-slots.html" title="51.80. pg_replication_slots"><code class="structname">pg_replication_slots</code></a>
ビューより確認できます。
    </p><p>レプリケーションスロットはストリーミングレプリケーションプロトコル( <a class="xref" href="protocol-replication.html" title="52.4. ストリーミングレプリケーションプロトコル">Section 52.4</a>参照)もしくはSQL関数(<a class="xref" href="functions-admin.html#FUNCTIONS-REPLICATION" title="9.26.6. レプリケーション関数">Section 9.26.6</a>参照)を使用し、作成や削除ができます。
    </p></div><div class="sect3" id="STREAMING-REPLICATION-SLOTS-CONFIG"><div class="titlepage"><div><div><h4 class="title">26.2.6.2. 設定の例</h4></div></div></div><p>以下のような方法でレプリケーションスロットを作成できます。
</p><pre class="programlisting">postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | lsn
-------------+-----
 node_a_slot |

postgres=# SELECT slot_name, slot_type, active FROM pg_replication_slots;
  slot_name  | slot_type | active 
-------------+-----------+--------
 node_a_slot | physical  | f
(1 row)</pre><p>
スタンバイのレプリケーションスロットを使用できるように設定するためには、<code class="varname">primary_slot_name</code>をスタンバイ側の<code class="filename">recovery.conf</code>に設定します。
以下は設定例です。：
</p><pre class="programlisting">standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'</pre><p>
    </p></div></div><div class="sect2" id="CASCADING-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.7. カスケードレプリケーション</h3></div></div></div><a id="id-1.6.13.16.19.2" class="indexterm"></a><p>カスケードレプリケーションは、リレーのような振る舞い、つまり、スタンバイサーバから他のスタンバイにレプリケーション接続し、WALレコードを送信することができます。
マスターサーバへ直接の接続を減らしたり、サイト相互の帯域オーバヘッドを最小化するために使用することができます。
   </p><p>カスケードスタンバイとして知られているとおり、スタンバイは受け取り手としても送り手としても振る舞うことができます。
よりマスターサーバに近いスタンバイサーバは上流サーバと呼ばれるのに対し、より遠いスタンバイサーバは下流サーバと呼ばれます。
カスケードレプリケーションには下流サーバの数に制限は設定されていません。しかし、どのスタンバイサーバも最終的には1つのマスター/プライマリサーバに繋がる1つの上流サーバに接続します。
   </p><p>カスケードスタンバイはマスターから受け取ったWALレコードだけでなく、アーカイブからリストアしたWALレコードも送信します。
このため、レプリケーション接続が上流サーバで切断しても、ストリーミングレプリケーションは下流サーバへ新しいWAL
レコードがある限り継続します。
   </p><p>カスケードレプリケーションは現時点では非同期です。同期レプリケーション（参照<a class="xref" href="warm-standby.html#SYNCHRONOUS-REPLICATION" title="26.2.8. 同期レプリケーション">Section 26.2.8</a>）の設定は現時点でカスケードレプリケーションへは影響を与えません。
   </p><p>ホットスタンバイがどの様に配置されていても、ホットスタンバイフィードバックは上流に伝播します。
   </p><p>上流スタンバイサーバが昇格し、新しいマスターサーバになった場合、<code class="varname">recovery_target_timeline</code>が<code class="literal">'latest'</code>に設定されていれば、下流サーバは新マスターサーバからのストリーミングレプリケーションを継続します。
   </p><p>カスケードレプリケーションを使うためには、カスケードスタンバイをセットアップ、つまり、レプリケーション接続を許可してください。(<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>と<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>および、 <a class="link" href="auth-pg-hba-conf.html" title="20.1. pg_hba.confファイル">クライアント認証</a>を設定してください)
また、下流スタンバイがカスケードスタンバイに接続できるために、下流スタンバイでは<code class="varname">primary_conninfo</code>を設定する必要があります。
   </p></div><div class="sect2" id="SYNCHRONOUS-REPLICATION"><div class="titlepage"><div><div><h3 class="title">26.2.8. 同期レプリケーション</h3></div></div></div><a id="id-1.6.13.16.20.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>のストリーミングレプリケーションはデフォルトで非同期です。
プライマリサーバがクラッシュした場合、コミットされた一部のトランザクションがスタンバイサーバに複製されず、データ損失を引き起こす可能性があります。
データ損失量はフェールオーバ時点のレプリケーション遅延に比例します。
   </p><p>同期レプリケーションは、あるトランザクションでなされた変更はすべて、１つ以上の同期スタンバイサーバに転送されていることを確実にする機能を提供します。
これはトランザクションコミットで提供される永続性の標準レベルを拡張します。
この保護レベルはコンピュータ科学理論では、2-safeレプリケーション、そして<code class="varname">synchronous_commit</code>が<code class="literal">remote_write</code>に設定されている場合にはgroup-1-safe (group-safeと1-safe) と呼ばれます。
   </p><p>同期レプリケーションを要求する時、書き込みトランザクションのコミットはそれぞれ、そのコミットがプライマリサーバおよびスタンバイサーバの両方で、ディスク上の書き込み先行ログに書き込まれたという確認を受けとるまで待機します。
データ損失が起こる可能性は、プライマリサーバとスタンバイサーバが同時にクラッシュしてしまった場合のみです。
これは非常に高い永続性を提供することができますが、それはシステム管理者が２つのサーバの設置と管理に関して注意を払っている場合のみです。
確認のための待機は、サーバがクラッシュした場合でも変更が失われないということでユーザからの信頼性が大きくなりますが、同時に要求するトランザクションの応答時間も必ず大きくなります。
最小待機時間はプライマリとスタンバイの間の往復遅延時間です。
   </p><p>読み取り専用のトランザクションおよびトランザクションのロールバックはスタンバイサーバからの応答を待つ必要はありません。
副トランザクションのコミットもスタンバイサーバからの応答を待つことはなく、最上位レベルのコミットのみ待機します。
データロード処理やインデックス構築など長時間実行される操作は、最終コミットメッセージまで待機しません。
準備およびコミットの両方を含め、二相コミット動作はすべてコミット待機を必要とします。
   </p><p>同期スタンバイは、物理レプリケーションのスタンバイでも、論理レプリケーションのサブスクライバーのどちらでも構いません。
また同期スタンバイは、適切なフィードバックメッセージを送信する方法を知っている、物理あるいは論理WALレプリケーションストリームの消費者であっても構いません。
組み込みの物理あるいは論理レプリケーションシステムを別にすると、<code class="command">pg_receivewal</code>と<code class="command">pg_recvlogical</code>、それにサードパーティーのレプリケーションシステムとカスタムプログラムが該当します。
対応する同期レプリケーションのサポートの詳細に関するドキュメントを参照してください。
   </p><div class="sect3" id="SYNCHRONOUS-REPLICATION-CONFIG"><div class="titlepage"><div><div><h4 class="title">26.2.8.1. 基本設定</h4></div></div></div><p>一度、ストリーミングレプリケーションが設定されている場合、同期レプリケーションの設定には必要な追加設定は１つだけ：<a class="xref" href="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES">synchronous_standby_names</a>を空でない値に設定することです。
また<code class="varname">synchronous_commit</code>は<code class="literal">on</code>に設定されていなければなりませんが、これはデフォルト値ですので、通常は変更する必要はありません。(<a class="xref" href="runtime-config-wal.html#RUNTIME-CONFIG-WAL-SETTINGS" title="19.5.1. 諸設定">Section 19.5.1</a> および<a class="xref" href="runtime-config-replication.html#RUNTIME-CONFIG-REPLICATION-MASTER" title="19.6.2. マスターサーバ">Section 19.6.2</a>を参照してください)
この設定によりスタンバイがそのコミットレコードを信頼できるストレージに書き込んだことが確認できるまで、各コミットが待たされるようになります。
<code class="varname">synchronous_commit</code>は個々のユーザによって設定することができます。
このため、トランザクション単位を基準とした永続性の保証を制御するために、設定ファイルの中で特定のユーザまたはデータベースについて設定することも、アプリケーションによって動的に設定することもできます。
   </p><p>コミットレコードがプライマリ上のディスクに書き出された後、WALレコードがスタンバイに送信されます。
スタンバイにて<code class="varname">wal_receiver_status_interval</code>がゼロに設定されていない限り、スタンバイは新しいWALデータの塊がディスクに書き出される度に応答メッセージを返します。
<code class="varname">synchronous_commit</code>が<code class="literal">remote_apply</code>に設定されている場合には、コミットレコードが再生され、そのトランザクションが可視化されたときに応答メッセージを返します。
スタンバイが、プライマリ上の<code class="varname">synchronous_standby_names</code>にしたがって、同期スタンバイとして選ばれた時は、コミットレコードの受領の確認のために待機しているトランザクションをいつ解放すべきかを決めるために、他の同期スタンバイとともにそれらスタンバイからの応答メッセージが考慮されます。
これらのパラメータにより、管理者はどのスタンバイサーバを同期スタンバイとすべきかを指定することができます。
同期レプリケーションの設定は主にマスタでなされることに注意してください。
指名されたスタンバイは直接マスターサーバに接続される必要があります。
つまり、カスケードレプリケーションを使用している下流スタンバイサーバについて、マスターサーバは何も知りません。
   </p><p><code class="varname">synchronous_commit</code>を<code class="literal">remote_write</code>に設定することで、個々のコミットは、スタンバイサーバがコミットされたレコードを受け取り、オペレーティングシステムに書きだしたことが確認できるまで待ちますが、スタンバイ上のディスクに吐き出すまでは待ちません。
これは、<code class="literal">on</code>と設定するより、提供される永続性は弱くなります。
具体的には、スタンバイサーバはオペレーティングシステムがクラッシュした場合にデータを失う可能性がありますが、<span class="productname">PostgreSQL</span>がクラッシュした場合にはデータを失いません。
しかし、実用的にはこの設定はトランザクションの応答時間を短くすることができるので有用です。
データの損失は、プライマリサーバとスタンバイサーバが同時にクラッシュし、かつ、プライマリのデータベースが同時に壊れた場合にのみ発生します。
   </p><p><code class="varname">synchronous_commit</code>を<code class="literal">remote_apply</code>に設定することで、現在の同期スタンバイがトランザクションを再生し、ユーザから見えるようにしたと報告するまでは各々のコミットは待たされます。
単純なケースでは、因果一貫性を保つ負荷分散を可能にします。
   </p><p>高速シャットダウンが要求された場合、ユーザは待ち状態ではなくなります。
しかし非同期レプリケーションを使用している時と同じく、送信中のWALレコードが現在接続しているスタンバイサーバに転送されるまで、サーバは完全に停止しません。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-MULTIPLE-STANDBYS"><div class="titlepage"><div><div><h4 class="title">26.2.8.2. 複数の同期スタンバイ</h4></div></div></div><p>同期レプリケーションは、一つ以上の同期スタンバイサーバをサポートします。
同期と見なされるすべてのスタンバイサーバがデータの受領を確認するまで、トランザクションは待機します。
トランザクションが応答を待たなければならない同期スタンバイの数は、<code class="varname">synchronous_standby_names</code>で指定されます。
また、このパラメータには、スタンバイの名前のリストと、リストされたものから同期スタンバイを選ぶ方法（<code class="literal">FIRST</code>と<code class="literal">ANY</code>）を指定します。
   </p><p>方法<code class="literal">FIRST</code>は優先度に基づく同期レプリケーションを指定し、優先度に応じて選択された同期スタンバイにWALレコードがレプリケーションされるまで、トランザクションのコミットは待機します。
リストの前の方に名前が書いてあるスタンバイにはより高い優先度が与えられ、同期とみなされます。
リストの後ろの方に書いてあるスタンバイは、潜在的な同期スタンバイであることを示します。
どんな理由であれ、現在のスタンバイのどれかの接続が切断されると、次に優先度が高いスタンバイがとって代わります。
   </p><p>優先度に基づく複数同期スタンバイのための<code class="varname">synchronous_standby_names</code>の例を示します。
   </p><pre class="programlisting">synchronous_standby_names = 'FIRST 2 (s1, s2, s3)'</pre><p>この例では、もし4つのスタンバイサーバ<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>、<code class="literal">s4</code>が稼働中なら、<code class="literal">s1</code>と<code class="literal">s2</code>が同期スタンバイに選ばれます。
それらの名前がスタンバイ名のリストの最初の方にあるからです。
<code class="literal">s3</code>は潜在的な同期スタンバイで、<code class="literal">s1</code>あるいは<code class="literal">s2</code>が故障した時に同期スタンバイの役割を取って代わります。
このリストに名前が載っていないので、<code class="literal">s4</code>は非同期スタンバイです。
   </p><p>方法<code class="literal">ANY</code>はクォーラムに基づく同期レプリケーションを指定し、<span class="emphasis"><em>少なくとも</em></span>リスト中で指定された数の同期スタンバイにWALレコードがレプリケーションされるまで、トランザクションのコミットを待たせます
   </p><p>クォーラムに基づく同期スタンバイのための<code class="varname">synchronous_standby_names</code>の例を示します。
</p><pre class="programlisting">synchronous_standby_names = 'ANY 2 (s1, s2, s3)'</pre><p>
この例では、もし4つのスタンバイサーバ<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>、<code class="literal">s4</code>が稼働中なら、トランザクションのコミットは、<code class="literal">s1</code>、<code class="literal">s2</code>、<code class="literal">s3</code>のどれか二つのスタンバイから応答があるまで待たされます。
このリストに名前が載っていないので、<code class="literal">s4</code>は非同期スタンバイです。
   </p><p><code class="structname">pg_stat_replication</code>ビューを使って、スタンバイサーバの同期状態を見ることができます。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-PERFORMANCE"><div class="titlepage"><div><div><h4 class="title">26.2.8.3. 性能に関する考慮</h4></div></div></div><p>通常、同期レプリケーションは、アプリケーションが満足できる程度に実行されることを確実にするために、注意深くスタンバイサーバを計画し設置しなければなりません。
待機のためにシステムリソースを使用することはありませんが、トランザクションロックは転送が確認されるまで継続して保持されます。
結果として同期レプリケーションを注意せずに使用すると、応答時間が増加する、および競合がより高くなるため、データベースアプリケーションの性能は低下します。
   </p><p><span class="productname">PostgreSQL</span>ではアプリケーション開発者がレプリケーション経由で必要とする永続性レベルを指定することができます。
これをシステム全体に対して指定することができますし、特定のユーザ、接続、個々のトランザクションに対してさえ指定することもできます。
   </p><p>例えばアプリケーションの作業量が、重要な顧客詳細の変更が10%、ユーザ間のチャットメッセージなど、あまり重要ではなく、失ったとしても業務をより簡単に戻すことができるようなデータの変更が90% という構成を考えてみます。
   </p><p>（プライマリ上で）アプリケーションレベルで指定する同期レプリケーションオプションを使用して、作業全体を低速化させることなく、最も重要な変更に対して同期レプリケーションを企てることができます。
アプリケーションレベルのオプションは、高い性能が求められるアプリケーションで同期レプリケーションの利点が得られる、重要かつ現実的な手段です。
   </p><p>生成されるWALデータの割合よりネットワーク帯域幅が大きくなければならないことを考慮しなければなりません。
   </p></div><div class="sect3" id="SYNCHRONOUS-REPLICATION-HA"><div class="titlepage"><div><div><h4 class="title">26.2.8.4. 高可用性に関する検討</h4></div></div></div><p><code class="varname">synchronous_commit</code>が、<code class="literal">on</code>、<code class="literal">remote_apply</code>、<code class="literal">remote_write</code>のいずれかに設定されている場合、<code class="varname">synchronous_standby_names</code>には、コミットされたトランザクションが応答を待つ同期スタンバイの数と名前を指定します。
そのようなトランザクションのコミットは、同期スタンバイのどれかがクラッシュすると決して完了しないかもしれません。
   </p><p>高可用性のもっとも良い解決方法は、想定したのと同じ数の同期スタンバイを確実に確保することです。
これは、<code class="varname">synchronous_standby_names</code>を使って同期スタンバイ候補を複数指定することによって実現できます。
そのリストの最初の方に名前が上がっているスタンバイは、同期スタンバイとして使用されます。
その後の方に名前が上がっているスタンバイは、同期スタンバイのどれかが故障した時に、その役割を取って代わります。
   </p><p>優先度に基づく同期レプリケーションでは、リストの前の方に名前が現れるスタンバイが同期スタンバイになります。
現在の同期スタンバイのどれかが故障した際には、リストの後の方にあるスタンバイが同期スタンバイの役割を引き継ぎます。
   </p><p>クォーラムに基づく同期レプリケーションでは、リストに現れたすべてのスタンバイが同期スタンバイの候補となります。
そのどれかが故障した場合でも、他のスタンバイは引き続き同期スタンバイの候補としての役割を担い続けます。
   </p><p>スタンバイが最初にプライマリに接続された時、それはまだ適切に同期されていません。
これは<code class="literal">catchup</code>モードと呼ばれます。
一旦スタンバイとプライマリ間の遅延がゼロになると、実時間<code class="literal">streaming</code>状態に移ります。
追従（catchup）期間はスタンバイが作成された直後は長くなるかもしれません。
スタンバイが停止している場合、追従期間はスタンバイの停止期間にしたがって長くなります。
スタンバイは、<code class="literal">streaming</code>状態に達した後でのみ、同期スタンバイになることができます。
この状態は、<code class="structname">pg_stat_replication</code>ビューで見ることができます。
   </p><p>コミットが受領通知を待機している間にプライマリが再起動した場合、プライマリデータベースが復旧した後、待機中のトランザクションは完全にコミットされたものと記録されます。
すべてのスタンバイがプライマリのクラッシュ時点で送信中のWALデータのすべてを受信したかどうかを確認する方法はありません。
トランザクションの一部は、プライマリではコミットされたものと表示されていたとしても、スタンバイではコミットされていないと表示されるかもしれません。
PostgreSQLは、WALデータをすべてのスタンバイが安全に受信したことが分かるまで、アプリケーションは明示的なトランザクションコミットの成功に関する受領通知を受けとらないことを保証しています。
   </p><p>要求していた数の同期スタンバイを本当に確保できないときは、トランザクションが応答を待たなければならない同期スタンバイの数を、<code class="varname">synchronous_standby_names</code>から減らしてください（もしくは無効にします）。
そして、プライマリサーバの設定ファイルを再読み込みしてください。
   </p><p>プライマリが既存のスタンバイサーバから切り離された場合は、スタンバイサーバの中から最善と思われる候補にフェールオーバしてください。
   </p><p>トランザクションの待機中にスタンバイサーバを再作成する必要がある場合、pg_start_backup()およびpg_stop_backup()を実行するコマンドを<code class="varname">synchronous_commit</code> = <code class="literal">off</code>であるセッション内で確実に実行してください。
さもないとこれらの要求はスタンバイに現れるまで永遠に待機します。
   </p></div></div><div class="sect2" id="CONTINUOUS-ARCHIVING-IN-STANDBY"><div class="titlepage"><div><div><h3 class="title">26.2.9. スタンバイにおける継続的アーカイビング</h3></div></div></div><a id="id-1.6.13.16.21.2" class="indexterm"></a><p>スタンバイにおいてWALの継続的アーカイビングが行われる場合、2つのシナリオが考えられます。
WALアーカイブがプライマリとスタンバイで共有されるケースと、スタンバイが自分のWALアーカイブを持つケースです。
スタンバイが自分のWALアーカイブを持つケースでは、<code class="varname">archive_mode</code>を<code class="literal">always</code>に設定しておくことにより、アーカイブからリストアされたWALセグメントであろうと、ストリーミングレプリケーション由来のWALセグメントであろうと、WALセグメントを受信する度にスタンバイはアーカイブコマンドを呼び出します。
共有アーカイブのケースも同じように扱えますが、<code class="varname">archive_command</code>はアーカイブしようとしているファイルがすでに存在していて、それが同一内容かどうかのチェックを行う必要があります。
このため、<code class="varname">archive_command</code>はより工夫が必要です。
というのも、<code class="varname">archive_command</code>は既存のファイルを異なる内容で置き換えてはいけませんし、またまったく同じ内容のファイルを置き換えた場合には成功したと報告しなければならないからです。
更に、2つのサーバが同時に同じファイルをアーカイブしようとした時に、競合状態が起きないようにしなければなりません。
   </p><p><code class="varname">archive_mode</code>が<code class="literal">on</code>の場合には、リカバリモードあるいはスタンバイモードではアーカイブは有効になりません。
スタンバイサーバが昇格すると、昇格後にスタンバイサーバはアーカイブを開始します。
しかし、自分が生成しなかったWALは一切アーカイブしません。
完全な一連のWALファイルをアーカイブから取り出すためには、WALがスタンバイに到着する前に、すべてのWALがアーカイブされていることを保証しなければなりません。
ファイルベースのログシッピングにおいても本質的にはこの通りです。
というのも、スタンバイはアーカイブにあるファイルだけをリストアできるからです。
ストリーミングレプリケーションが有効ならば、この限りではありません。
サーバがリカバリモードでない場合には、<code class="literal">on</code>と<code class="literal">always</code>のモードの間には違いはありません。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="different-replication-solutions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="warm-standby-failover.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">26.1. 様々な解法の比較 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 26.3. フェールオーバ</td></tr></table></div></body></html>