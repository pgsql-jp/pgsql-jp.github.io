<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>60.1. インデックスの基本的API構造</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義" /><link rel="next" href="index-functions.html" title="60.2. インデックスアクセスメソッド関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">60.1. インデックスの基本的API構造</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Up</a></td><th width="60%" align="center">Chapter 60. インデックスアクセスメソッドのインタフェース定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="index-functions.html" title="60.2. インデックスアクセスメソッド関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEX-API"><div class="titlepage"><div><div><h2 class="title" style="clear: both">60.1. インデックスの基本的API構造</h2></div></div></div><p>各インデックスメソッドは<a class="link" href="catalog-pg-am.html" title="51.3. pg_am"><code class="structname">pg_am</code></a>システムカタログの行で説明されます。
<code class="structname">pg_am</code>エントリはアクセスメソッドの名前と<em class="firstterm">ハンドラ関数</em>を指定します。
これらのエントリはSQLコマンド<a class="xref" href="sql-create-access-method.html" title="CREATE ACCESS METHOD"><span class="refentrytitle">CREATE ACCESS METHOD</span></a>と<a class="xref" href="sql-drop-access-method.html" title="DROP ACCESS METHOD"><span class="refentrytitle">DROP ACCESS METHOD</span></a>を使って、作成および削除することができます。
  </p><p>インデックスメソッドのハンドラ関数は、<code class="type">internal</code>型の引数を1つ取り、疑似型<code class="type">index_am_handler</code>を返すものとして宣言しなければなりません。
引数は単にハンドラ関数がSQLコマンドから直接呼び出されるのを防ぐためのダミーの値です。
関数の結果は型<code class="structname">IndexAmRoutine</code>のpallocされた構造体でなければならず、そこにはインデックスアクセスメソッドを使用するためにコアコードが知っている必要のあるすべてのことが含まれています。
<code class="structname">IndexAmRoutine</code>構造体は、アクセスメソッドの<em class="firstterm">API構造体</em>とも呼ばれ、複数列のインデックスをサポートするかどうかなどといった、アクセスメソッドに関する様々な既定の属性を指定するフィールドが含まれます。
さらに重要なことに、この構造体にはアクセスメソッドのサポート関数へのポインタが含まれ、これによってインデックスにアクセスするためのすべての実際の処理が行われます。
これらのサポート関数は単なるCの関数で、SQLレベルでは見ることも呼び出すこともできません。
サポート関数は<a class="xref" href="index-functions.html" title="60.2. インデックスアクセスメソッド関数">Section 60.2</a>で説明されています。
  </p><p>構造体<code class="structname">IndexAmRoutine</code>は以下のように定義されています。
</p><pre class="programlisting">typedef struct IndexAmRoutine
{
    NodeTag     type;

    /*
     * Total number of strategies (operators) by which we can traverse/search
     * this AM.  Zero if AM does not have a fixed set of strategy assignments.
     */
    uint16      amstrategies;
    /* total number of support functions that this AM uses */
    uint16      amsupport;
    /* does AM support ORDER BY indexed column's value? */
    bool        amcanorder;
    /* does AM support ORDER BY result of an operator on indexed column? */
    bool        amcanorderbyop;
    /* does AM support backward scanning? */
    bool        amcanbackward;
    /* does AM support UNIQUE indexes? */
    bool        amcanunique;
    /* does AM support multi-column indexes? */
    bool        amcanmulticol;
    /* does AM require scans to have a constraint on the first index column? */
    bool        amoptionalkey;
    /* does AM handle ScalarArrayOpExpr quals? */
    bool        amsearcharray;
    /* does AM handle IS NULL/IS NOT NULL quals? */
    bool        amsearchnulls;
    /* can index storage data type differ from column data type? */
    bool        amstorage;
    /* can an index of this type be clustered on? */
    bool        amclusterable;
    /* does AM handle predicate locks? */
    bool        ampredlocks;
    /* does AM support parallel scan? */
    bool        amcanparallel;
    /* type of data stored in index, or InvalidOid if variable */
    Oid         amkeytype;

    /* interface functions */
    ambuild_function ambuild;
    ambuildempty_function ambuildempty;
    aminsert_function aminsert;
    ambulkdelete_function ambulkdelete;
    amvacuumcleanup_function amvacuumcleanup;
    amcanreturn_function amcanreturn;   /* can be NULL */
    amcostestimate_function amcostestimate;
    amoptions_function amoptions;
    amproperty_function amproperty;     /* can be NULL */
    amvalidate_function amvalidate;
    ambeginscan_function ambeginscan;
    amrescan_function amrescan;
    amgettuple_function amgettuple;     /* can be NULL */
    amgetbitmap_function amgetbitmap;   /* can be NULL */
    amendscan_function amendscan;
    ammarkpos_function ammarkpos;       /* can be NULL */
    amrestrpos_function amrestrpos;     /* can be NULL */

    /* interface functions to support parallel index scans */
    amestimateparallelscan_function amestimateparallelscan;    /* can be NULL */
    aminitparallelscan_function aminitparallelscan;    /* can be NULL */
    amparallelrescan_function amparallelrescan;    /* can be NULL */
} IndexAmRoutine;</pre><p>
  </p><p>使い易くするために、インデックスアクセスメソッドはまた、<a class="link" href="catalog-pg-opfamily.html" title="51.35. pg_opfamily"><code class="structname">pg_opfamily</code></a>、<a class="link" href="catalog-pg-opclass.html" title="51.33. pg_opclass"><code class="structname">pg_opclass</code></a>、<a class="link" href="catalog-pg-amop.html" title="51.4. pg_amop"><code class="structname">pg_amop</code></a>および<a class="link" href="catalog-pg-amproc.html" title="51.5. pg_amproc"><code class="structname">pg_amproc</code></a>内で定義される、複数の<em class="firstterm">演算子族</em>と<em class="firstterm">演算子クラス</em>を持ちます。
これらの項目により、プランナは、このアクセスメソッドのインデックスがどのような問い合わせ条件に対して使用できるかを決定することができます。
演算子族と演算子クラスについては、<a class="xref" href="xindex.html" title="37.14. インデックス拡張機能へのインタフェース">Section 37.14</a>で説明します。
これは本章を読む上で必要となる資料です。
  </p><p>個々のインデックスは、インデックスを物理的なリレーションとして記述する<a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>項目と、インデックスの論理的な内容、つまり、インデックスが持つインデックス列の集合とその列の意味を、関連する演算子クラスで再現されたものとして表す<a class="link" href="catalog-pg-index.html" title="51.26. pg_index"><code class="structname">pg_index</code></a>項目とで定義されます。
インデックス列（キー値）は、背後のテーブルの単純な列、あるいは、テーブル行に対する式とすることができます。
通常、インデックスアクセスメソッドはインデックスキー値が何を表すかについて考慮しません。
（常に計算済みのキー値として扱われます。）
しかし、<code class="structname">pg_index</code>内の演算子クラスの情報を深く考慮します。
この両方のカタログ項目は、インデックスに対するすべての操作に渡される<code class="structname">Relation</code>データ構造の一部としてアクセスすることができます。
  </p><p><code class="structname">IndexAmRoutine</code>のフラグフィールドの中には、意味がわかりにくいものがあります。
<code class="structfield">amcanunique</code>の必要条件は<a class="xref" href="index-unique-checks.html" title="60.5. インデックス一意性検査">Section 60.5</a>で説明されています。
<code class="structfield">amcanmulticol</code>フラグはアクセスメソッドが複数列に対するインデックスをサポートすることを表し、<code class="structfield">amoptionalkey</code>は、インデックス可能な制限句が最初のインデックス列に指定されていないスキャンを許可することを表します。
<code class="structfield">amcanmulticol</code>が偽の場合、<code class="structfield">amoptionalkey</code>は基本的に、アクセスメソッドが制限句なしで完全なインデックススキャンをサポートするかどうかを表します。
複数列に対するインデックスをサポートするアクセスメソッドは、最初の列以降のすべてまたは一部の列に関する制限がなくてもスキャンをサポート<span class="emphasis"><em>しなければなりません</em></span>。
しかし、最初のインデックス列にいくつかの制限を要求することは認められています。
これは、<code class="structfield">amoptionalkey</code>を偽に設定することで通知されます。
インデックスアクセスメソッドが<code class="structfield">amoptionalkey</code>を偽にする１つの理由は、NULLをインデックス付けしない場合です。
ほとんどのインデックス可能な演算子は厳密で、NULL値の入力に対して真を返すことができませんので、NULLに対してインデックス項目を格納しないことは一見魅力的です。
これはインデックススキャンによって何も返しません。
しかし、最初のインデックス列に対する制限がないインデックススキャンでは、この引数は失敗します。
プランナがこうしたスキャンキーをまったく持たないインデックスを使用することを決定する可能性がありますので、実際これは、<code class="structfield">amoptionalkey</code>が真のインデックスはNULLインデックスを持たなければならないことを意味します。
関連する制限として、プランナはこれらの列を制限しない問い合わせでインデックスを使用できることを前提とするため、複数のインデックス列をサポートするインデックスアクセスメソッドは1番目の後の列でNULL値のインデックスをサポート<span class="emphasis"><em></em></span>しなければならないということがあります。
例えば、(a,b)に対するインデックスに、<code class="literal">WHERE a = 4</code>という条件で問い合わせを行うことを考えてみます。
システムは、このインデックスを<code class="literal">a = 4</code>を持つ行をスキャンすることに使用できるものと仮定します。
これはもし、<code class="literal">b</code>がNULLの場合の行をインデックスが省略する場合は間違っています。
しかし、最初のインデックス列がNULLの場合に行を省略することは問題ありません
また、NULLをインデックス付けするインデックスアクセスメソッドは<code class="structfield">amsearchnulls</code>を設定する可能性があります。
これは検索条件として<code class="literal">IS NULL</code>および<code class="literal">IS NOT NULL</code>句をサポートすることを示します。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexam.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="index-functions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 60. インデックスアクセスメソッドのインタフェース定義 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 60.2. インデックスアクセスメソッド関数</td></tr></table></div></body></html>