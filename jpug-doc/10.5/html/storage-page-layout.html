<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>66.6. データベースページのレイアウト</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="storage-init.html" title="66.5. 初期化フォーク" /><link rel="next" href="bki.html" title="Chapter 67. BKIバックエンドインタフェース" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">66.6. データベースページのレイアウト</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="storage-init.html" title="66.5. 初期化フォーク">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="storage.html" title="Chapter 66. データベースの物理的な格納">Up</a></td><th width="60%" align="center">Chapter 66. データベースの物理的な格納</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="bki.html" title="Chapter 67. BKIバックエンドインタフェース">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="STORAGE-PAGE-LAYOUT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">66.6. データベースページのレイアウト</h2></div></div></div><p>本節では<span class="productname">PostgreSQL</span>のテーブルおよびインデックスで使われるページ書式の概略について説明します。
<a href="#ftn.id-1.10.19.8.2.2" class="footnote"><sup class="footnote" id="id-1.10.19.8.2.2">[14]</sup></a>
<acronym class="acronym">TOAST</acronym>のテーブルとシーケンスは、通常のテーブルと同様に整形されています。</p><p>以下の説明では1<em class="firstterm">バイト</em>は8ビットからなることを前提としています。
さらに、<em class="firstterm">アイテム</em>という単語は、ページに格納される個別のデータ値のことを指しています。
テーブル内ではアイテムは行であり、インデックス内ではアイテムはインデックスのエントリです。</p><p>テーブルとインデックスはすべて、固定サイズ（通常8キロバイト。サーバのコンパイル時に異なるサイズを設定可能）の<em class="firstterm">ページ</em>の集まりとして格納されます。
テーブルでは、すべてのページは論理上等価です。
したがって、あるアイテム（行）はどのページにでも格納することができます。
インデックスでは、初めのページは通常、制御用の情報を保持する<em class="firstterm">メタページ</em>として予約されます。
また、インデックスではインデックスアクセスメソッドに依存した様々なページ種類があります。</p><p><a class="xref" href="storage-page-layout.html#PAGE-TABLE" title="Table 66.2. ページレイアウト全体">Table 66.2</a>はページの全体的なレイアウトを示しています。
各ページには5つの部分があります。</p><div class="table" id="PAGE-TABLE"><p class="title"><strong>Table 66.2. ページレイアウト全体</strong></p><div class="table-contents"><table class="table" summary="ページレイアウト全体" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>アイテム</th><th>説明</th></tr></thead><tbody><tr><td>PageHeaderData</td><td>長さは24バイト。空き領域ポインタを含む、ページについての一般情報です。</td></tr><tr><td>ItemIdData</td><td>実際のアイテムを指す（オフセットと長さの）ペアの配列です。
1アイテムにつき4バイトです。</td></tr><tr><td>空き領域</td><td>割り当てられていない空間です。
新規のアイテムポインタはこの領域の先頭から、新規のアイテムは最後から割り当てられます。</td></tr><tr><td>アイテム</td><td>実際のアイテムそのものです。</td></tr><tr><td>特別な空間</td><td>インデックスアクセスメソッド特有のデータです。異なるメソッドは異なるデータを格納します。通常のテーブルでは空です。</td></tr></tbody></table></div></div><br class="table-break" /><p>
それぞれのページの最初の24バイトはページヘッダ(<code class="structname">PageHeaderData</code>)から構成されています。
その書式を<a class="xref" href="storage-page-layout.html#PAGEHEADERDATA-TABLE" title="Table 66.3. PageHeaderDataのレイアウト">Table 66.3</a>にて説明します。
最初のフィールドは、このページに関連する最も最近のWAL項目を表しています。
2番目のフィールドには<a class="xref" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS">data checksums</a>が有効な場合にページチェックサムが格納されています。
次にフラグビットを含む2バイトのフィールドがあります。
その後に2バイトの整数フィールドが3つ続きます（<code class="structfield">pd_lower</code>、<code class="structfield">pd_upper</code>、<code class="structfield">pd_special</code>）。
これらには、割り当てられていない空間の始まり、割り当てられていない空間の終わり、そして特別な空間の始まりのバイトオフセットが格納されています。
ページヘッダの次の2バイトである<code class="structfield">pd_pagesize_version</code>は、ページサイズとバージョン指示子の両方を格納します。
<span class="productname">PostgreSQL</span> 8.3以降のバージョン番号は4、<span class="productname">PostgreSQL</span> 8.1と8.2のバージョン番号は3、<span class="productname">PostgreSQL</span> 8.0のバージョン番号は2、<span class="productname">PostgreSQL</span> 7.3と7.4のバージョン番号は1です。
それより前のリリースのバージョン番号は0です
（ほとんどのバージョン間で基本的なページレイアウトやヘッダの書式は変更されていませんが、ヒープ行ヘッダのレイアウトが変更されました）。
ページサイズは基本的に照合用としてのみ存在しています。
同一インストレーションでの複数のページサイズはサポートされていません。
最後のフィールドはそのページの切り詰めが有益かどうかを示すヒントです。
これはページ上で切り詰められていないもっとも古いXMAXが追跡するものです。

 </p><div class="table" id="PAGEHEADERDATA-TABLE"><p class="title"><strong>Table 66.3. PageHeaderDataのレイアウト</strong></p><div class="table-contents"><table class="table" summary="PageHeaderDataのレイアウト" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>フィールド</th><th>型</th><th>長さ</th><th>説明</th></tr></thead><tbody><tr><td>pd_lsn</td><td>PageXLogRecPtr</td><td>8バイト</td><td>LSN: このページへの最終変更に対応するWALレコードの最後のバイトの次のバイト</td></tr><tr><td>pd_checksum</td><td>uint16</td><td>2バイト</td><td>ページチェックサム</td></tr><tr><td>pd_flags</td><td>uint16</td><td>2バイト</td><td>フラグビット</td></tr><tr><td>pd_lower</td><td>LocationIndex</td><td>2 バイト</td><td>空き領域の始まりに対するオフセット</td></tr><tr><td>pd_upper</td><td>LocationIndex</td><td>2バイト</td><td>空き領域の終わりに対するオフセット</td></tr><tr><td>pd_special</td><td>LocationIndex</td><td>2バイト</td><td>特別な空間の始まりに対するオフセット</td></tr><tr><td>pd_pagesize_version</td><td>uint16</td><td>2バイト</td><td>ページサイズおよびレイアウトのバージョン番号の情報</td></tr><tr><td>pd_prune_xid</td><td>TransactionId</td><td>4バイト</td><td>ページ上でもっとも古い切り詰められていないXMAX。存在しなければゼロ。</td></tr></tbody></table></div></div><br class="table-break" /><p>詳細情報については<code class="filename">src/include/storage/bufpage.h</code>を参照してください。
 </p><p>
ページヘッダに続くのはアイテム識別子（<code class="type">ItemIdData</code>）です。
識別子ごとに4バイトを必要とします。
アイテム識別子は、アイテムが開始されるバイトオフセット、バイト単位の長さ、そしてその解釈に影響する属性ビット群を持っています。
新しいアイテム識別子は必要に応じて、未割当て空間の最初から割り当てられます。
アイテム識別子の数は、新しい識別子を割り当てるために増加される<code class="structfield">pd_lower</code>を見ることで決定できます。
アイテム識別子は解放されるまで動かされることがないので、アイテム自体が空き領域をまとめるためにページ上で移動される場合でも、そのインデックスはアイテムを参照するために長期にわたって使うことができます。
実際、<span class="productname">PostgreSQL</span>が作る、アイテムへのポインタ（<code class="type">ItemPointer</code>、<code class="type">CTID</code>とも言います）はページ番号とアイテム識別子のインデックスによって構成されています。

 </p><p>
アイテム自体は、未割り当て空間の最後から順番に割り当てられた空間に格納されます。
正確な構造は、テーブルに何を含めるかによって異なります。
テーブルとシーケンスの両方が、以下で説明する<code class="type">HeapTupleHeaderData</code>という構造を使用します。

 </p><p>
最後のセクションは、アクセスメソッドが格納しようとするものを何でも含めることのできる<span class="quote">“<span class="quote">特別なセクション</span>”</span>です。
例えば、B-treeインデックスは、そのページの両隣のページへのリンク、ならびに、インデックス構造体に関連したその他の何らかのデータを持ちます。
通常のテーブルではこれはまったく使用されません（ページサイズを同じにするために<code class="structfield">pd_special</code>を設定することで示されます）。

 </p><p>
テーブル行はすべて同じ方法で構成されています。
固定サイズのヘッダ（ほとんどのマシンで23バイトを占有します）があり、その後にオプションのNULLビットマップ、オプションのオブジェクトIDフィールド、およびユーザデータが続きます。
ヘッダについては<a class="xref" href="storage-page-layout.html#HEAPTUPLEHEADERDATA-TABLE" title="Table 66.4. HeapTupleHeaderDataのレイアウト">Table 66.4</a>で説明します。
実際のユーザデータ（行内の列）は、常にプラットフォームのMAXALIGN距離の倍数である<code class="structfield">t_hoff</code>で示されるオフセットから始まります。
NULLビットマップは<em class="firstterm">HEAP_HASNULL</em>ビットが<code class="structfield">t_infomask</code>で設定されている場合にのみ存在します。
存在する場合は、固定ヘッダのすぐ後ろから始まり、データ列ごとに1ビットとするのに十分なバイト数を占有します（合計すると、<code class="structfield">t_natts</code>のビット数となります）。
このビットのリスト内では、1ビットは非NULLを、0ビットはNULLを示します。
このビットマップが存在しない場合、すべての列が非NULLとみなされます。
オブジェクトIDは<em class="firstterm">HEAP_HASOID</em>ビットが<code class="structfield">t_infomask</code>で設定されている場合にのみ存在します。
存在する場合、これは<code class="structfield">t_hoff</code>境界の直前に現れます。
<code class="structfield">t_hoff</code>をMAXALIGNの倍数とするために必要なパッドは全て、NULLビットマップとオブジェクトIDの間に現れます
（このことにより、オブジェクトIDの位置揃えが確実に適切になります）。

 </p><div class="table" id="HEAPTUPLEHEADERDATA-TABLE"><p class="title"><strong>Table 66.4. HeapTupleHeaderDataのレイアウト</strong></p><div class="table-contents"><table class="table" summary="HeapTupleHeaderDataのレイアウト" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>フィールド</th><th>型</th><th>長さ</th><th>説明</th></tr></thead><tbody><tr><td>t_xmin</td><td>TransactionId</td><td>4バイト</td><td>挿入XIDスタンプ</td></tr><tr><td>t_xmax</td><td>TransactionId</td><td>4バイト</td><td>削除XIDスタンプ</td></tr><tr><td>t_cid</td><td>CommandId</td><td>4バイト</td><td>挿入、削除の両方または片方のCIDスタンプ（t_xvacと共有）</td></tr><tr><td>t_xvac</td><td>TransactionId</td><td>4バイト</td><td>行バージョンを移すVACUUM操作用XID</td></tr><tr><td>t_ctid</td><td>ItemPointerData</td><td>6バイト</td><td>この行または最新バージョンの行の現在のTID</td></tr><tr><td>t_infomask2</td><td>uint16</td><td>2バイト</td><td>属性の数と各種フラグビット</td></tr><tr><td>t_infomask</td><td>uint16</td><td>2バイト</td><td>様々なフラグビット</td></tr><tr><td>t_hoff</td><td>uint8</td><td>1バイト</td><td>ユーザデータに対するオフセット</td></tr></tbody></table></div></div><br class="table-break" /><p>詳細情報については<code class="filename">src/include/access/htup_details.h</code>を参照してください。
 </p><p>
実際のデータの解釈は、他のテーブル、ほとんどの場合、<code class="structname">pg_attribute</code>から取得された情報でのみ行うことができます。
フィールド位置を識別するために必要なキー値は、<code class="structfield">attlen</code>および<code class="structfield">attalign</code>です。
フィールドの幅が固定されていてNULL値が存在しない場合を除き、特定の属性を直接取得する方法はありません。
この仕組みはすべて、<em class="firstterm">heap_getattr</em>、<em class="firstterm">fastgetattr</em>および<em class="firstterm">heap_getsysattr</em>関数にラップされています。

 </p><p>
データを読むためには、それぞれの属性を順番に検査する必要があります。
まず、NULLビットマップに従ってフィールドがNULLかどうかを検査します。
もしNULLであれば、次に進みます。
次に、位置揃えが正しいことを確認してください。
フィールドの幅が固定されていれば、すべてのバイトが単純に配置されます。
可変長のフィールド（attlen == -1）の場合はもう少し複雑です。
可変長のデータ型はすべて、格納する値の長さといくつかのフラグビットを持つ<code class="type">struct varlena</code>という共通ヘッダ構造体を共有します。
フラグによって、データは行内、または別のテーブル（TOAST）のいずれかとなったり、圧縮済みとなったりします
（<a class="xref" href="storage-toast.html" title="66.2. TOAST">Section 66.2</a>を参照してください）。

 </p><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.10.19.8.2.2" class="footnote"><p><a href="#id-1.10.19.8.2.2" class="para"><sup class="para">[14] </sup></a>実際にはインデックスアクセスメソッドはこのページ書式を使用する必要はありません。
既存のすべてのインデックスメソッドがこの基本書式を使用しています。
しかし、インデックスメタページに保持されるデータは通常、アイテムレイアウト規則に正確には従っていません。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-init.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="storage.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bki.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">66.5. 初期化フォーク </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 67. <acronym class="acronym">BKI</acronym>バックエンドインタフェース</td></tr></table></div></body></html>