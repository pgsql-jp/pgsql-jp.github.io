<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE CAST</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createaggregate.html" title="CREATE AGGREGATE" /><link rel="next" href="sql-createcollation.html" title="CREATE COLLATION" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE CAST</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createaggregate.html" title="CREATE AGGREGATE">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createcollation.html" title="CREATE COLLATION">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATECAST"><div class="titlepage"></div><a id="id-1.9.3.55.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE CAST</span></h2><p>CREATE CAST — 新しいキャストを定義する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE CAST (<em class="replaceable"><code>source_type</code></em> AS <em class="replaceable"><code>target_type</code></em>)
    WITH FUNCTION <em class="replaceable"><code>function_name</code></em> [ (<em class="replaceable"><code>argument_type</code></em> [, ...]) ]
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<em class="replaceable"><code>source_type</code></em> AS <em class="replaceable"><code>target_type</code></em>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<em class="replaceable"><code>source_type</code></em> AS <em class="replaceable"><code>target_type</code></em>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]</pre></div><div class="refsect1" id="SQL-CREATECAST-DESCRIPTION"><h2>説明</h2><p><code class="command">CREATE CAST</code>を使用すると、新しいキャストを定義できます。
キャストは、2つのデータ型間の変換処理方法を指定するものです。
以下に例を示します。
</p><pre class="programlisting">SELECT CAST(42 AS float8);</pre><p>
この文を実行すると、事前に指定された関数（この場合<code class="literal">float8(int4)</code>）が呼び出され、整数定数42が<code class="type">float8</code>型に変換されます
（適切なキャストが定義されていない場合、変換処理は失敗します）。
  </p><p>2つのデータ型を<em class="firstterm">バイナリ強制互換</em>とすることができます。
これは、関数をまったく呼び出さなくても、<span class="quote">“<span class="quote">自由に</span>”</span>変換を行うことができることを意味します。
これには、対応する値は、同じ内部表現を使用している必要があります。
例えば、データ型<code class="type">text</code>と<code class="type">varchar</code>には、両方向でバイナリ互換性があります。
バイナリ強制互換性は必ずしも対称関係ではありません。
例えば、現在の実装では<code class="type">xml</code>から<code class="type">text</code>へのキャストは自由に行うことができますが、逆方向では少なくとも構文検査を行う関数が必要です。
（2つの型が両方向でバイナリ強制互換であることは、バイナリ互換性と呼ばれます。）
  </p><p><code class="literal">WITH INOUT</code>構文を使用して<em class="firstterm">I/O変換キャスト</em>としてキャスト定義を行うことができます。
I/O変換キャストは、元データ型の出力関数を呼び出し、その結果文字列を対象データ型の入力関数に渡すことで行われます。
多くの一般的な場合では、この機能により変換用に別個のキャスト関数を作成する必要性がなくなります。
I/O変換キャストは通常の関数を基にしたキャストと同様に動作します。ただ実装が異なるだけです。
  </p><p>デフォルトでは、キャストは明示的なキャスト要求があった場合のみ発生します。
明示的なキャスト要求の構文は、<code class="literal">CAST(<em class="replaceable"><code>x</code></em> AS <em class="replaceable"><code>typename</code></em>)</code>、もしくは、<em class="replaceable"><code>x</code></em><code class="literal">::</code><em class="replaceable"><code>typename</code></em>式です。
  </p><p>キャストに<code class="literal">AS ASSIGNMENT</code>オプションを付けると、対象データ型の列に代入する際、暗黙的にそのキャストを発生させることができます。
例えば、<code class="literal">foo.f1</code>が<code class="type">text</code>型の列であるとします。
</p><pre class="programlisting">INSERT INTO foo (f1) VALUES (42);</pre><p>
<code class="type">integer</code>型を<code class="type">text</code>型に変換するキャストに<code class="literal">AS ASSIGNMENT</code>オプションが付けられていれば、上記のSQL文が実行できます。
しかし、<code class="literal">AS ASSIGNMENT</code>オプションが付いていなければ、実行できません
（一般的に、この種のキャストを<em class="firstterm">代入キャスト</em>と呼びます）。
  </p><p>キャストに<code class="literal">AS IMPLICIT</code>オプションを付けると、代入の場合だけでなく、式の中にある場合でも、全てのコンテキストで暗黙的にそのキャストを呼び出すことができます。
（一般的に、この種のキャストを<em class="firstterm">暗黙キャスト</em>と呼びます。）
例えば次のような問い合わせを考えてみます。
</p><pre class="programlisting">SELECT 2 + 4.0;</pre><p>
パーサはまず定数にそれぞれ<code class="type">integer</code>と<code class="type">numeric</code>であると印を付けます。
システムカタログには、<code class="type">integer</code> <code class="literal">+</code> <code class="type">numeric</code>という演算子はありませんが、<code class="type">numeric</code> <code class="literal">+</code> <code class="type">numeric</code>という演算子は存在します。
したがって、<code class="type">integer</code>から<code class="type">numeric</code>へのキャストが利用可能であり、そのキャストに<code class="literal">AS IMPLICIT</code>が付いていればこの問い合わせは成功します（実際このようになっています）。
パーサは暗黙的なキャストを行い、問い合わせをあたかも次のように記載されたものとして解決します。
</p><pre class="programlisting">SELECT CAST ( 2 AS numeric ) + 4.0;</pre><p>
  </p><p>ここで、カタログはまた<code class="type">numeric</code>から<code class="type">integer</code>へのキャストも提供しています。
もしこのキャストに<code class="literal">AS IMPLICIT</code>が付いていたら（実際は付いていません）、パーサは上のように解釈するか、それとも、<code class="type">numeric</code>定数を<code class="type">integer</code>にキャストし、<code class="type">integer</code> <code class="literal">+</code> <code class="type">integer</code>という演算子を適用するかを選択しなければなりません。
どちらがより良いかという知見がなければ、選択をあきらめ、問い合わせがあいまいであると宣告します。
2つのキャストの内1つのみが暗黙的であるという事実が、パーサに、<code class="type">numeric</code>と<code class="type">integer</code>が混在する式を<code class="type">numeric</code>として扱うという適切な解決方法を知らせる方法です。
これに関する組み込まれた知見は存在しません。
  </p><p>暗黙キャストは、多用しない方が賢明です。
暗黙的キャストを使用し過ぎると、<span class="productname">PostgreSQL</span>がコマンドを思わぬ意味に解釈してしまう原因になります。
また、複数の解釈が可能なため、コマンドをまったく解読できなくなってしまう可能性もあります。
経験的には、2つのデータ型が同一の一般的なデータ型のカテゴリに属しており、変換によって情報が保持される場合のみ、暗黙キャストを呼び出し可能にするのが良い方法と思われます。
例えば、<code class="type">int2</code>型から<code class="type">int4</code>型へのキャストは、暗黙キャストにするのが妥当ですが、<code class="type">float8</code>型から<code class="type">int4</code>型へのキャストは、おそらく代入キャストのみにすべきでしょう。
<code class="type">text</code>型から<code class="type">int4</code>型への変換のような、カテゴリを越えるデータ型のキャストは、明示的にのみ使用するのが適切です。
  </p><div class="note"><h3 class="title">Note</h3><p>型の集合の中で複数の暗黙的なキャストを提供することが、有用性や標準との互換性上の理由により必要となることがあり、これにより、上で説明した通り防ぐことができないあいまいさが引き起こされます。
パーサは、こうした状況でも望ましい動作の提供を補助できる<em class="firstterm">型カテゴリ</em>と<em class="firstterm">優先される型</em>に基づいた発見的手法を用意しています。
詳細は<a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>を参照してください。
   </p></div><p>キャストを作成するためには、変換元または変換先（の内の一方）のデータ型を所有し、もう一方の型に対する<code class="literal">USAGE</code>権限を持つ必要があります。
また、バイナリ強制互換性を持つキャストを作成できるのは、スーパーユーザでなければなりません。
（バイナリ強制互換性があるキャスト変換を誤って使用するとサーバがクラッシュしてしまう可能性が高いことから、この制限が付けられました）。
  </p></div><div class="refsect1" id="id-1.9.3.55.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>source_type</code></em></span></dt><dd><p>キャストする変換元のデータ型の名前です。
      </p></dd><dt><span class="term"><em class="replaceable"><code>target_type</code></em></span></dt><dd><p>キャストする変換先のデータ型の名前です。
      </p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>function_name</code></em>[(<em class="replaceable"><code>argument_type</code></em> [, ...])]</code></span></dt><dd><p>キャストを実行するために使用される関数です。
関数名はスキーマ修飾することができます。
スキーマ修飾されていない場合、関数はスキーマ検索パスから検索されます。
関数の結果のデータ型は、キャストの変換先のデータ型と一致する必要があります。
引数については後で説明します。
引数リストが指定されない場合、関数名はスキーマ内で一意でなければなりません。
      </p></dd><dt><span class="term"><code class="literal">WITHOUT FUNCTION</code></span></dt><dd><p>変換元データ型から変換先データ型への間に、バイナリ強制互換性があることを示します。
この場合、キャストを実行するのに関数は必要ありません。
      </p></dd><dt><span class="term"><code class="literal">WITH INOUT</code></span></dt><dd><p>キャストが、変換元データ型の出力関数を呼び出し、その結果の文字列を変換先データ型の入力関数に渡すことで行われる、I/O変換キャストであることを示します。
      </p></dd><dt><span class="term"><code class="literal">AS ASSIGNMENT</code></span></dt><dd><p>代入コンテキストで、暗黙的にキャストを呼び出せることを示します。
      </p></dd><dt><span class="term"><code class="literal">AS IMPLICIT</code></span></dt><dd><p>任意のコンテキストで、暗黙的にキャストを呼び出せることを示します。
      </p></dd></dl></div><p>キャストを実装する関数は1〜3個の引数を取ることができます。
1番目の引数型はキャストの変換元データ型と同一、または、変換元データ型からのバイナリ強制互換を持つ型でなければなりません。
2番目の引数（もしあれば）は、<code class="type">integer</code>型でなければなりません。変換先の型に関連付けられた型修飾子を指定します。
型修飾子がない場合は<code class="literal">-1</code>を指定します。
3番目の引数（もしあれば）は、<code class="type">boolean</code>型でなければなりません。キャストが明示的なキャストであれば<code class="literal">true</code>を、それ以外であれば<code class="literal">false</code>を指定します
（奇妙な話ですが、標準SQLでは、明示的キャストと暗黙的キャストとの間で異なる振舞いを要求する場合があります。
この引数はそのようなキャストを実装しなければならない関数用に提供されています。
独自のデータ型をこの流儀に従うように設計することは勧められません）。
  </p><p>キャスト関数の戻り値は、キャストの対象型と同一またはバイナリ強制互換性を持たなければなりません。
  </p><p>通常、キャストにおける変換元データ型と変換先データ型は異なる必要があります。
しかし、2つ以上の引数を持つ関数でキャストを実装した場合は、変換元と変換先とで同一のデータ型を持つキャストを宣言することができます。
これは、システムカタログにおいて型固有の長さ強制関数を表現するために使用されています。
指定された関数は、型の値を強制的に2番目の引数で与えられた型修飾子の値にするために使用されます
  </p><p>キャストが変換元と変換先のデータ型が異なり、複数の引数を取る関数を持つ場合、あるデータ型から他のデータ型への変換と長さの強制を1つの操作にまとめたものをサポートします。
引数を1つしか取らない場合は、型修飾子を使用して型を強制するために、データ型間の変換と修飾子の適用という2つのキャスト操作が必要となります。
  </p><p>ドメイン型へのキャスト、ドメイン型からのキャストは現在は効果がありません。
ドメインへのキャスト、ドメインからのキャストは、基となる型と関連したキャストを使用します。
  </p></div><div class="refsect1" id="SQL-CREATECAST-NOTES"><h2>注釈</h2><p>ユーザ定義のキャストを削除するには<a class="xref" href="sql-dropcast.html" title="DROP CAST"><span class="refentrytitle">DROP CAST</span></a>を使用してください。
  </p><p>データ型を双方向に変更可能にするには、双方向のキャストを明示的に宣言する必要があることに注意してください。
  </p><a id="id-1.9.3.55.7.4" class="indexterm"></a><p>ユーザ定義型と標準文字列型（<code class="type">text</code>、<code class="type">varchar</code>、<code class="type">char(<em class="replaceable"><code>n</code></em>)</code>）、および文字列カテゴリとして定義されたユーザ定義型との間のキャストを作成することは、通常必要ありません。
<span class="productname">PostgreSQL</span>はこのために自動的なI/O変換キャストを提供します。
この文字列への自動キャストは代入キャストとして扱われますが、文字列型からの入出力変換キャストは明示的なキャストのみです。
この振舞いは独自のキャストを宣言して自動キャストを置き換えることで変更することができます。
しかし、通常このようにするのは、この変換を標準の代入のみまたは明示的のみの設定よりもより呼び出しやすくしたい場合に限られます。
他にも、型の入出力関数と異なる動作で変換したいという理由もあるかもしれません。
しかし、これは非常に驚かされるものであり、そうすべきかどうか熟考すべきです。
（組み込み型のごく一部は実際変換用に異なった振舞いをしますが、ほとんどは標準SQLの仕様のためのものです。）
  </p><p>必須ではありませんが、キャストを実装する関数には変換先のデータ型の名前を付けるという以前からの慣習に従っておくことを推奨します。
多くのユーザは<em class="replaceable"><code>typename</code></em>(<em class="replaceable"><code>x</code></em>)という関数スタイルの記法でデータ型のキャストを行っています。
この記法は、キャストを実装している関数の呼び出しに他なりません。
キャストとして特別に扱われるわけではないのです。
ユーザが作成した変換関数の名前がこの慣習に従っていないと、他のユーザがとまどうことになります。
<span class="productname">PostgreSQL</span>は引数として異なる型を取る同じ名前の関数をオーバーロードすることができるので、様々な型から特定の変換先型への変換関数の名前を全て変換先の型名にしても特に問題は発生しません。
  </p><div class="note"><h3 class="title">Note</h3><p>実際のところ、前の段落は単純化しすぎたものです。
関数呼び出し式が実際の関数と一致しない状態でキャスト要求として扱われる状況が2つ存在します。
関数呼び出し<em class="replaceable"><code>name</code></em>(<em class="replaceable"><code>x</code></em>)が実際の関数に正確に一致せず、<em class="replaceable"><code>name</code></em>がデータ型の名前であり、<code class="structname">pg_cast</code>が<em class="replaceable"><code>x</code></em>の型からその型へのバイナリ強制互換のキャストを提供する場合、この呼び出しはバイナリ強制互換キャストとして処理されます。
この例外は、実際の関数が存在しなくても、関数のような構文でバイナリ強制互換キャストを呼び出すことができるように作成されました。
同様に、<code class="structname">pg_cast</code>に項目がないが、文字列型との間のキャストが存在する場合、この呼び出しは入出力変換キャストとして処理されます。
この例外により関数のような構文で入出力変換キャストができるようになります。
   </p></div><div class="note"><h3 class="title">Note</h3><p>この例外にも例外があります。
複合型から文字列型へのI/O変換キャストでは関数構文を使用して呼び出すことができず、明示的なキャスト構文（<code class="literal">CAST</code>記法または<code class="literal">::</code>記法のいずれか）で記述しなければなりません
この例外は、自動提供I/O変換キャストを導入した後、関数または列参照を意図した時に非常に簡単に間違って呼び出されることが判明したため追加されました。
   </p></div></div><div class="refsect1" id="SQL-CREATECAST-EXAMPLES"><h2>例</h2><p>関数<code class="literal">int4(bigint)</code>を使用した<code class="type">bigint</code>型から<code class="type">int4</code>型への代入キャストを作成します。
</p><pre class="programlisting">CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;</pre><p>
（このキャストは、システムに既に定義されています。）
  </p></div><div class="refsect1" id="SQL-CREATECAST-COMPAT"><h2>互換性</h2><p>SQLではバイナリ強制互換性があるデータ型や実装関数の追加の引数について規定されていません。さらに、<code class="literal">AS IMPLICIT</code>は、<span class="productname">PostgreSQL</span>の拡張です。
これらの点以外では、<code class="command">CREATE CAST</code>は標準<acronym class="acronym">SQL</acronym>に準拠しています。

  </p></div><div class="refsect1" id="SQL-CREATECAST-SEEALSO"><h2>関連項目</h2><p>   <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>,
   <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>,
   <a class="xref" href="sql-dropcast.html" title="DROP CAST"><span class="refentrytitle">DROP CAST</span></a>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createaggregate.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createcollation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE AGGREGATE </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE COLLATION</td></tr></table></div></body></html>