<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.7. 記述子領域の使用</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ecpg-pgtypes.html" title="35.6. pgtypes ライブラリ" /><link rel="next" href="ecpg-errors.html" title="35.8. エラー処理" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.7. 記述子領域の使用</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-pgtypes.html" title="35.6. pgtypes ライブラリ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Chapter 35. ECPG - C言語による埋め込みSQL">Up</a></td><th width="60%" align="center">Chapter 35. <span xmlns="http://www.w3.org/1999/xhtml" class="application">ECPG</span> - C言語による埋め込み<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-errors.html" title="35.8. エラー処理">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ECPG-DESCRIPTORS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.7. 記述子領域の使用</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-descriptors.html#ECPG-NAMED-DESCRIPTORS">35.7.1. 名前付きSQL記述子領域</a></span></dt><dt><span class="sect2"><a href="ecpg-descriptors.html#ECPG-SQLDA-DESCRIPTORS">35.7.2. SQLDA記述子領域</a></span></dt></dl></div><p>SQL記述子領域は<code class="command">SELECT</code>、<code class="command">FETCH</code>、<code class="command">DESCRIBE</code>文の結果を処理する、より洗練された手法です。
SQL記述子領域は1行のデータをメタデータ項目と一緒に1つのデータ構造体としてグループ化します。
特に動的SQL文を実行する場合は結果列の性質が前もってわかりませんので、メタデータが有用です。
PostgreSQLは記述子領域を使用するための2つの方法、名前付きSQL記述子領域とC構造化SQLDA、を提供します。
  </p><div class="sect2" id="ECPG-NAMED-DESCRIPTORS"><div class="titlepage"><div><div><h3 class="title">35.7.1. 名前付きSQL記述子領域</h3></div></div></div><p>名前付きSQL記述子領域は、記述子全体に関する情報を持つヘッダと、基本的に結果行内の1つの列を記述する、1つ以上の項目記述子領域から構成されます。
   </p><p>SQL記述子領域を使用可能にするためには、それを以下のように割り当てなければなりません。
</p><pre class="programlisting">EXEC SQL ALLOCATE DESCRIPTOR <em class="replaceable"><code>identifier</code></em>;</pre><p>
この識別子は記述子領域の<span class="quote">“<span class="quote">変数名</span>”</span>として使用されます。
記述子が不要になったら、以下のように解放してください。
</p><pre class="programlisting">EXEC SQL DEALLOCATE DESCRIPTOR <em class="replaceable"><code>identifier</code></em>;</pre><p>
   </p><p>記述子領域を使用するには、<code class="literal">INTO</code>句内の格納対象として、ホスト変数を列挙するのではなく、記述子領域を指定してください。
</p><pre class="programlisting">EXEC SQL FETCH NEXT FROM mycursor INTO SQL DESCRIPTOR mydesc;</pre><p>
結果セットが空の場合であっても、記述子領域には問い合わせのメタデータ、つまりフィールド名、が含まれます。
   </p><p>まだ実行されていないプリペアド問い合わせでは、結果セットのメタデータを入手するために<code class="command">DESCRIBE</code>を使用することができます。
</p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
char *sql_stmt = "SELECT * FROM table1";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :sql_stmt;
EXEC SQL DESCRIBE stmt1 INTO SQL DESCRIPTOR mydesc;</pre><p>
   </p><p>PostgreSQL 9.0より前では、<code class="literal">SQL</code>キーワードは省略可能でした。
このため<code class="literal">DESCRIPTOR</code>および<code class="literal">SQL DESCRIPTOR</code>は名前付きSQL記述子領域を生成しました。
これは強制事項になり、<code class="literal">SQL</code>キーワードを省略すると、SQLDA記述子領域を生成します。
<a class="xref" href="ecpg-descriptors.html#ECPG-SQLDA-DESCRIPTORS" title="35.7.2. SQLDA記述子領域">Section 35.7.2</a>を参照してください。
   </p><p><code class="command">DESCRIBE</code>および<code class="command">FETCH</code>文では、<code class="literal">INTO</code>および<code class="literal">USING</code>キーワードを同じように使用することができます。
これらは結果セットと記述子領域内のメタデータを生成します。
   </p><p>さて、どうやって記述子領域からデータを取り出すのでしょうか。
この記述子領域を名前付きフィールドを持つ構造体とみなすことができます。
ヘッダからフィールド値を取り出し、それをホスト変数に格納するには、以下のコマンドを使用します。
</p><pre class="programlisting">EXEC SQL GET DESCRIPTOR <em class="replaceable"><code>name</code></em> :<em class="replaceable"><code>hostvar</code></em> = <em class="replaceable"><code>field</code></em>;</pre><p>
今のところ、<em class="replaceable"><code>COUNT</code></em>というヘッダフィールドが1つだけ定義されています。
これは、記述子領域に存在する項目数を表すものです
（つまり、結果内に含まれる列数です）。
このホスト変数は整数型でなければなりません。
項目記述子領域からフィールドを取り出すには、以下のコマンドを使用します。
</p><pre class="programlisting">EXEC SQL GET DESCRIPTOR <em class="replaceable"><code>name</code></em> VALUE <em class="replaceable"><code>num</code></em> :<em class="replaceable"><code>hostvar</code></em> = <em class="replaceable"><code>field</code></em>;</pre><p>
<em class="replaceable"><code>num</code></em>はリテラル整数、もしくは整数を持つホスト変数を取ることができます。
取り得るフィールドは以下の通りです。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">CARDINALITY</code> (整数)</span></dt><dd><p>結果セット内の行数です。
       </p></dd><dt><span class="term"><code class="literal">DATA</code></span></dt><dd><p>実際のデータ項目です
（したがってこのフィールドのデータ型は問い合わせに依存します）。
       </p></dd><dt><span class="term"><code class="literal">DATETIME_INTERVAL_CODE</code> (整数)</span></dt><dd><p><code class="literal">TYPE</code>が<code class="literal">9</code>の場合、<code class="literal">DATETIME_INTERVAL_CODE</code>は、<code class="literal">DATE</code>では<code class="literal">1</code>、<code class="literal">TIME</code>では<code class="literal">2</code>、<code class="literal">TIMESTAMP</code>では<code class="literal">3</code>、<code class="literal">TIME WITH TIME ZONE</code>では<code class="literal">4</code>、<code class="literal">TIMESTAMP WITH TIME ZONE</code>では<code class="literal">5</code>という値を取ります。
       </p></dd><dt><span class="term"><code class="literal">DATETIME_INTERVAL_PRECISION</code> (整数)</span></dt><dd><p>未実装です。
       </p></dd><dt><span class="term"><code class="literal">INDICATOR</code> (整数)</span></dt><dd><p>（NULL値や値の切り詰めを示す）指示子です。
       </p></dd><dt><span class="term"><code class="literal">KEY_MEMBER</code> (整数)</span></dt><dd><p>実装されていません。
       </p></dd><dt><span class="term"><code class="literal">LENGTH</code> (整数)</span></dt><dd><p>データの文字列の長さです。
       </p></dd><dt><span class="term"><code class="literal">NAME</code> (文字列)</span></dt><dd><p>列名です。
       </p></dd><dt><span class="term"><code class="literal">NULLABLE</code> (整数)</span></dt><dd><p>実装されていません。
       </p></dd><dt><span class="term"><code class="literal">OCTET_LENGTH</code> (整数)</span></dt><dd><p>データの文字表現のバイト長です。
       </p></dd><dt><span class="term"><code class="literal">PRECISION</code> (整数)</span></dt><dd><p>（<code class="type">numeric</code>型用の）精度です。
       </p></dd><dt><span class="term"><code class="literal">RETURNED_LENGTH</code> (整数)</span></dt><dd><p>データの文字数です。
       </p></dd><dt><span class="term"><code class="literal">RETURNED_OCTET_LENGTH</code> (整数)</span></dt><dd><p>データの文字表現のバイト長です。
       </p></dd><dt><span class="term"><code class="literal">SCALE</code> (整数)</span></dt><dd><p>（<code class="type">numeric</code>型用の）桁です。
       </p></dd><dt><span class="term"><code class="literal">TYPE</code> (整数)</span></dt><dd><p>列のデータ型の数値コードです。
       </p></dd></dl></div><p>
   </p><p><code class="command">EXECUTE</code>、<code class="command">DECLARE</code>および<code class="command">OPEN</code>文では、<code class="literal">INTO</code>および<code class="literal">USING</code>の効果は異なります。
また、問い合わせやカーソル用の入力パラメータを提供するために記述子領域は手作業で構築することができます。
<code class="literal">USING SQL DESCRIPTOR <em class="replaceable"><code>name</code></em></code>は入力パラメータとパラメータ付きの問い合わせに渡す方法です。
名前付きSQL記述子領域を構築するSQL文は以下の通りです。
</p><pre class="programlisting">EXEC SQL SET DESCRIPTOR <em class="replaceable"><code>name</code></em> VALUE <em class="replaceable"><code>num</code></em> <em class="replaceable"><code>field</code></em> = :<em class="replaceable"><code>hostvar</code></em>;</pre><p>
   </p><p>PostgreSQLは、1つの<code class="command">FETCH</code>文内の1レコードを複数取り出し、ホスト変数に格納することをサポートします。
この場合ホスト変数は配列であると仮定されます。
</p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
int id[5];
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH 5 FROM mycursor INTO SQL DESCRIPTOR mydesc;

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :id = DATA;</pre><p>

   </p></div><div class="sect2" id="ECPG-SQLDA-DESCRIPTORS"><div class="titlepage"><div><div><h3 class="title">35.7.2. SQLDA記述子領域</h3></div></div></div><p>SQLDA記述子領域は、問い合わせの結果セットとメタデータを取り出すために使用可能なC言語の構造体です。
1つの構造体には結果セットの1レコードが格納されます。
</p><pre class="programlisting">EXEC SQL include sqlda.h;
sqlda_t         *mysqlda;

EXEC SQL FETCH 3 FROM mycursor INTO DESCRIPTOR mysqlda;</pre><p>
<code class="literal">SQL</code>キーワードが省略されていることに注意してください。
<a class="xref" href="ecpg-descriptors.html#ECPG-NAMED-DESCRIPTORS" title="35.7.1. 名前付きSQL記述子領域">Section 35.7.1</a>の<code class="literal">INTO</code>および<code class="literal">USING</code>の使用状況に関する段落はここで多少追加して適用します。
<code class="command">DESCRIBE</code>文では、<code class="literal">INTO</code>が使用されている場合<code class="literal">DESCRIPTOR</code>キーワードは完全に省略可能です。
</p><pre class="programlisting">EXEC SQL DESCRIBE prepared_statement INTO mysqlda;</pre><p>
   </p><div class="procedure"><p>SQLDAを使用するプログラムの一般的な流れは以下の通りです。
     </p><ol class="procedure" type="1"><li class="step"><p>問い合わせをプリペアし、そのカーソルを宣言します。</p></li><li class="step"><p>結果セット用のSQLDAを宣言します。</p></li><li class="step"><p>入力パラメータ用のSQLDAを宣言し、初期化（メモリ割り当て、パラメータの設定）します。</p></li><li class="step"><p>入力用SQLDAでカーソルを開きます。</p></li><li class="step"><p>カーソルから行を取り出し、出力用SQLDAに格納します。</p></li><li class="step"><p>出力用SQLDAから値をホスト変数に（必要に応じて変換を行い）読み取ります。</p></li><li class="step"><p>カーソルを閉じます。</p></li><li class="step"><p>入力用SQLDAに割り当てられたメモリ領域を解放します。</p></li></ol></div><div class="sect3" id="id-1.7.5.13.4.4"><div class="titlepage"><div><div><h4 class="title">35.7.2.1. SQLDAのデータ構造</h4></div></div></div><p>SQLDAは<code class="type">sqlda_t</code>、<code class="type">sqlvar_t</code>、<code class="type">struct sqlname</code>という３つの種類のデータ構造を使用します。
    </p><div class="tip"><h3 class="title">Tip</h3><p>PostgreSQLのSQLDAはIBM DB2ユニバーサルデータベースのものと似たデータ構造を持ちます。
このため、DB2のSQLDAに関する技術情報の一部はPostgreSQLのSQLDAの理解のより良い助けになるでしょう。
     </p></div><div class="sect4" id="ECPG-SQLDA-SQLDA"><div class="titlepage"><div><div><h5 class="title">35.7.2.1.1. sqlda_t構造体</h5></div></div></div><p><code class="type">sqlda_t</code>構造体は実際のSQLDAの型です。
これは１つのレコードを保持します。
そして２つ以上の<code class="type">sqlda_t</code>構造体を<code class="structfield">desc_next</code>フィールド内においてポインタを使ってリンクリスト内でつなげることができます。
こうして行の順序付き集合を表現します。
このため、２つ以上の行を取り出す時、アプリケーションは各<code class="type">sqlda_t</code>ノードの<code class="structfield">desc_next</code>ポインタを追うことでそれらを読み取ることができます。
     </p><p><code class="type">sqlda_t</code>の定義は以下の通りです。
</p><pre class="programlisting">struct sqlda_struct
{
    char            sqldaid[8];
    long            sqldabc;
    short           sqln;
    short           sqld;
    struct sqlda_struct *desc_next;
    struct sqlvar_struct sqlvar[1];
};

typedef struct sqlda_struct sqlda_t;</pre><p>

フィールドの意味は以下の通りです。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sqldaid</code></span></dt><dd><p>ここには<code class="literal">"SQLDA  "</code>文字列リテラルが含まれます。
       </p></dd><dt><span class="term"><code class="literal">sqldabc</code></span></dt><dd><p>ここにはバイト単位の割り当てられた領域のサイズが含まれます。
       </p></dd><dt><span class="term"><code class="literal">sqln</code></span></dt><dd><p><code class="literal">USING</code>キーワードを使用して<code class="command">OPEN</code>、<code class="command">DECLARE</code>、<code class="command">EXECUTE</code>文に渡される場合、ここにはパラメータ付き問い合わせの入力パラメータ数が含まれます。
<code class="command">SELECT</code>、<code class="command">EXECUTE</code>、<code class="command">FETCH</code>文の出力として使用される場合、この値は<code class="literal">sqld</code>文と同じです。
       </p></dd><dt><span class="term"><code class="literal">sqld</code></span></dt><dd><p>ここには結果セットのフィールド数が含まれます。
       </p></dd><dt><span class="term"><code class="literal">desc_next</code></span></dt><dd><p>問い合わせが複数のレコードを返す場合、複数結び付いたSQLDA構造体が返されます。
<code class="literal">desc_next</code>にリスト内の次の項目を指し示すポインタが保持されます。
       </p></dd><dt><span class="term"><code class="literal">sqlvar</code></span></dt><dd><p>これは結果セット内の列の配列です。
       </p></dd></dl></div><p>
     </p></div><div class="sect4" id="ECPG-SQLDA-SQLVAR"><div class="titlepage"><div><div><h5 class="title">35.7.2.1.2. sqlvar_t構造体</h5></div></div></div><p><code class="type">sqlvar_t</code>構造体は列の値と型や長さなどのメタデータを保持します。
この型の定義は以下の通りです。

</p><pre class="programlisting">struct sqlvar_struct
{
    short          sqltype;
    short          sqllen;
    char          *sqldata;
    short         *sqlind;
    struct sqlname sqlname;
};

typedef struct sqlvar_struct sqlvar_t;</pre><p>

フィールドの意味は以下の通りです。

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sqltype</code></span></dt><dd><p>ここにはフィールドの型識別子が含まれます。
値については<code class="literal">ecpgtype.h</code>の<code class="literal">enum ECPGttype</code>を参照してください。
           </p></dd><dt><span class="term"><code class="literal">sqllen</code></span></dt><dd><p>フィールドのバイナリ長が含まれます。
例えば<code class="type">ECPGt_int</code>では4バイトです。
           </p></dd><dt><span class="term"><code class="literal">sqldata</code></span></dt><dd><p>データそのものを指し示します。
データ書式は<a class="xref" href="ecpg-variables.html#ECPG-VARIABLES-TYPE-MAPPING" title="35.4.4. データ型の対応">Section 35.4.4</a>で説明します。
           </p></dd><dt><span class="term"><code class="literal">sqlind</code></span></dt><dd><p>データのNULL指示子を指し示します。
0は非NULLを、-1はNULLを意味します。
           </p></dd><dt><span class="term"><code class="literal">sqlname</code></span></dt><dd><p>フィールドの名前です。
           </p></dd></dl></div><p>
     </p></div><div class="sect4" id="ECPG-SQLDA-SQLNAME"><div class="titlepage"><div><div><h5 class="title">35.7.2.1.3. struct sqlname構造体</h5></div></div></div><p><code class="type">struct sqlname</code>構造体は列名を保持します。
<code class="type">sqlvar_t</code>構造体のメンバとして使用されます。
構造体の定義は以下の通りです。
</p><pre class="programlisting">#define NAMEDATALEN 64

struct sqlname
{
        short           length;
        char            data[NAMEDATALEN];
};</pre><p>
フィールドの意味は以下の通りです。
            </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">length</code></span></dt><dd><p>フィールド名の長さが含まれます。
                </p></dd><dt><span class="term"><code class="literal">data</code></span></dt><dd><p>実際のフィールド名が含まれます。
                </p></dd></dl></div><p>
     </p></div></div><div class="sect3" id="ECPG-SQLDA-OUTPUT"><div class="titlepage"><div><div><h4 class="title">35.7.2.2. SQLDAを使用した結果セットの取り出し</h4></div></div></div><div class="procedure"><p>SQLDAを通して問い合わせの結果を取り出す一般的な手順は以下に示します。
     </p><ol class="procedure" type="1"><li class="step"><p>結果セットを受けとるための<code class="type">sqlda_t</code>構造体を宣言します。</p></li><li class="step"><p>宣言したSQLDAを指定した問い合わせを処理するために<code class="command">FETCH</code>/<code class="command">EXECUTE</code>/<code class="command">DESCRIBE</code>を実行します。</p></li><li class="step"><p><code class="type">sqlda_t</code>構造体のメンバ<code class="structfield">sqln</code>を検索することにより結果セット内のレコード数を検査します。</p></li><li class="step"><p><code class="type">sqlda_t</code>構造体のメンバ<code class="literal">sqlvar[0]</code>、<code class="literal">sqlvar[1]</code>などから各列の値を入手します。</p></li><li class="step"><p><code class="type">sqlda_t</code>構造体のメンバ<code class="structfield">desc_next</code>ポインタを追い、次の行（<code class="type">sqlda_t</code>構造体）に進みます。</p></li><li class="step"><p>必要なだけ上を繰り返します。</p></li></ol></div><p>以下にSQLDAを通して結果セットを取り出す例を示します。
    </p><p>まず、結果セットを受け取る<code class="type">sqlda_t</code>構造体を宣言します。
</p><pre class="programlisting">sqlda_t *sqlda1;</pre><p>
    </p><p>次にコマンド内にSQLDAを指定します。
以下は<code class="command">FETCH</code>コマンドの例です。
</p><pre class="programlisting">EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</pre><p>
    </p><p>行を取り出すためにリンクリストを追うループを実行します。
</p><pre class="programlisting">sqlda_t *cur_sqlda;

for (cur_sqlda = sqlda1;
     cur_sqlda != NULL;
     cur_sqlda = cur_sqlda-&gt;desc_next)
{
    ...
}</pre><p>
    </p><p>ループの内側では、行の列データ（<code class="type">sqlvar_t</code>構造体）それぞれを取り出す別のループを実行します。
</p><pre class="programlisting">for (i = 0; i &lt; cur_sqlda-&gt;sqld; i++)
{
    sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
    char *sqldata = v.sqldata;
    short sqllen  = v.sqllen;
    ...
}</pre><p>
    </p><p>列の値を入手するために、<code class="type">sqlvar_t</code>構造体のメンバ<code class="structfield">sqltype</code>の値を検査します。
そして、列の型に応じて、<code class="structfield">sqlvar</code>フィールドからホスト変数にデータをコピーするための適切な方法に切り替えます。
</p><pre class="programlisting">char var_buf[1024];

switch (v.sqltype)
{
    case ECPGt_char:
        memset(&amp;var_buf, 0, sizeof(var_buf));
        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf) - 1 : sqllen));
        break;

    case ECPGt_int: /* 整数 */
        memcpy(&amp;intval, sqldata, sqllen);
        snprintf(var_buf, sizeof(var_buf), "%d", intval);
        break;

    ...
}</pre><p>
    </p></div><div class="sect3" id="ECPG-SQLDA-INPUT"><div class="titlepage"><div><div><h4 class="title">35.7.2.3. SQLDAを使用した問い合わせパラメータ渡し</h4></div></div></div><div class="procedure"><p>プリペアド問い合わせに入力パラメータを渡すためにSQLDAを使用する、一般的な手順は以下の通りです。
     </p><ol class="procedure" type="1"><li class="step"><p>プリペアド問い合わせ（プリペアド文）を作成します。</p></li><li class="step"><p>入力用SQLDAとしてsqlda_t構造体を宣言します。</p></li><li class="step"><p>入力用SQLDA用にメモリ領域を（sqlda_t構造体として）割り当てます。</p></li><li class="step"><p>割り当てたメモリに入力値を設定（コピー）します。</p></li><li class="step"><p>入力用SQLDAを指定してカーソルを開きます。</p></li></ol></div><p>以下に例を示します。
    </p><p>まずプリペアド文を作成します。
</p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
char query[1024] = "SELECT d.oid, * FROM pg_database d, pg_stat_database s WHERE d.oid = s.datid AND (d.datname = ? OR d.oid = ?)";
EXEC SQL END DECLARE SECTION;

EXEC SQL PREPARE stmt1 FROM :query;</pre><p>
    </p><p>次にSQLDA用にメモリを割り当て、<code class="type">sqlda_t</code>構造体のメンバ変数<code class="structfield">sqln</code>に入力パラメータ数を設定します。
プリペアド問い合わせで２つ以上の入力パラメータが必要な場合、アプリケーションは(パラメータ数 - 1) * sizeof(sqlvar_t)で計算される追加のメモリ空間を割り当てなければなりません。
ここで示す例では２つの入力パラメータ用にメモリ空間を割り当てます。
</p><pre class="programlisting">sqlda_t *sqlda2;

sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));

sqlda2-&gt;sqln = 2; /* 入力変数の個数 */</pre><p>
    </p><p>メモリを割り当てた後、<code class="literal">sqlvar[]</code>配列にパラメータ値を格納します。
（これは、SQLDAが結果セットを受け取る時に列値を取り出すために使用した配列と同じです。）
この例では、入力パラメータは文字列型を持つ<code class="literal">"postgres"</code>と整数型を持つ<code class="literal">1</code>です。
</p><pre class="programlisting">sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
sqlda2-&gt;sqlvar[0].sqldata = "postgres";
sqlda2-&gt;sqlvar[0].sqllen  = 8;

int intval = 1;
sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);</pre><p>
    </p><p>ここまでで設定したSQLDAを指定するカーソルを開くことで、入力パラメータはプリペアド文に渡されます。
</p><pre class="programlisting">EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;</pre><p>
    </p><p>最後に、問い合わせ結果を受け取るために使用するSQLDAとは異なり、入力用SQLDAの使用後、割り当てたメモリ空間を明示的に解放しなければなりません。
</p><pre class="programlisting">free(sqlda2);</pre><p>
    </p></div><div class="sect3" id="ECPG-SQLDA-EXAMPLE"><div class="titlepage"><div><div><h4 class="title">35.7.2.4. SQLDAを使用するサンプルアプリケーション</h4></div></div></div><p>以下に、システムカタログから入力パラメータにより指定されたデータベースの統計情報にアクセスし取り出す方法を示す、プログラム例を示します。
    </p><p>このアプリケーションは、pg_databaseとpg_stat_databaseシステムテーブルをデータベースOIDで結合し、２つの入力パラメータ（データベース<code class="literal">postgres</code>とOID<code class="literal">1</code>）により取り出されるデータベース統計情報を読み取り、表示します。
    </p><p>まず、入力用のSQLDAと出力用のSQLDAを宣言します。
</p><pre class="programlisting">EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 出力記述子 */
sqlda_t *sqlda2; /* 入力記述子 */</pre><p>
    </p><p>次に、データベースに接続し、プリペアド文を作成し、プリペアド文用のカーソルを宣言します。
</p><pre class="programlisting">int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO testdb AS con1 USER testuser;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;</pre><p>
    </p><p>次に、入力パラメータのために入力用SQLDA内にいくつかの値を格納します。
入力用SQLDAのためのメモリを割り当て、入力パラメータの個数を<code class="literal">sqln</code>に設定します。
型、値、値の長さを<code class="literal">sqlvar</code>構造体内の<code class="literal">sqltype</code>、<code class="literal">sqldata</code>、<code class="literal">sqllen</code>に格納します。

</p><pre class="programlisting">    /* 入力パラメータ用のSQLDA構造体を作成する。 */
    sqlda2 = (sqlda_t *) malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2-&gt;sqln = 2; /* 入力変数の数 */

    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&gt;sqlvar[0].sqldata = "postgres";
    sqlda2-&gt;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&gt;sqlvar[1].sqldata = (char *)&amp;intval;
    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);</pre><p>
    </p><p>入力用SQLDAを設定し終えた後、入力用SQLDAを付けたカーソルを開きます。

</p><pre class="programlisting">    /* 入力パラメータ付きでカーソルを開く。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;</pre><p>
    </p><p>開いたカーソルから出力用SQLDA内に行を取り込みます。
（一般的に結果セット内の行をすべて取り込むためには、ループ内で<code class="command">FETCH</code>を繰り返し呼び出さなければなりません。）
</p><pre class="programlisting">    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 記述子をカーソルに割り当てる */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;</pre><p>
    </p><p>次に、<code class="type">sqlda_t</code>構造体のリンクリストを追うことで、SQLDAから取り込んだレコードを取り出します。
</p><pre class="programlisting">    for (cur_sqlda = sqlda1 ;
         cur_sqlda != NULL ;
         cur_sqlda = cur_sqlda-&gt;desc_next)
    {
        ...</pre><p>
    </p><p>最初のレコードから各列を読み取ります。
列数は<code class="structfield">sqld</code>に、最初の列の実データは<code class="literal">sqlvar[0]</code>に格納されています。
どちらも<code class="type">sqlda_t</code>構造体のメンバです。

</p><pre class="programlisting">        /* 1行の列をすべて表示する。 */
        for (i = 0; i &lt; sqlda1-&gt;sqld; i++)
        {
            sqlvar_t v = sqlda1-&gt;sqlvar[i];
            char *sqldata = v.sqldata;
            short sqllen  = v.sqllen;

            strncpy(name_buf, v.sqlname.data, v.sqlname.length);
            name_buf[v.sqlname.length] = '\0';</pre><p>
    </p><p>ここで、列データが<code class="varname">v</code>変数内に格納されました。
列の型について<code class="literal">v.sqltype</code>を検索しながら、すべてのデータをホスト変数にコピーします。
</p><pre class="programlisting">            switch (v.sqltype) {
                int intval;
                double doubleval;
                unsigned long long int longlongval;

                case ECPGt_char:
                    memset(&amp;var_buf, 0, sizeof(var_buf));
                    memcpy(&amp;var_buf, sqldata, (sizeof(var_buf) &lt;= sqllen ? sizeof(var_buf)-1 : sqllen));
                    break;

                case ECPGt_int: /* 整数 */
                    memcpy(&amp;intval, sqldata, sqllen);
                    snprintf(var_buf, sizeof(var_buf), "%d", intval);
                    break;

                ...

                default:
                    ...
            }

            printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
        }</pre><p>
    </p><p>すべてのレコードを処理した後カーソルを閉じ、データベースとの接続を切断します。
</p><pre class="programlisting">    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;</pre><p>
    </p><p>プログラム全体を<a class="xref" href="ecpg-descriptors.html#ECPG-SQLDA-EXAMPLE-EXAMPLE" title="Example 35.1. SQLDAプログラムの例">Example 35.1</a>に示します。
    </p><div class="example" id="ECPG-SQLDA-EXAMPLE-EXAMPLE"><p class="title"><strong>Example 35.1. SQLDAプログラムの例</strong></p><div class="example-contents"><pre class="programlisting">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

EXEC SQL include sqlda.h;

sqlda_t *sqlda1; /* 出力記述子 */
sqlda_t *sqlda2; /* 入力記述子 */

EXEC SQL WHENEVER NOT FOUND DO BREAK;
EXEC SQL WHENEVER SQLERROR STOP;

int
main(void)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char query[1024] = "SELECT d.oid,* FROM pg_database d, pg_stat_database s WHERE d.oid=s.datid AND ( d.datname=? OR d.oid=? )";

    int intval;
    unsigned long long int longlongval;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO uptimedb AS con1 USER uptime;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;

    EXEC SQL PREPARE stmt1 FROM :query;
    EXEC SQL DECLARE cur1 CURSOR FOR stmt1;

    /* 入力パラメータ用のSQLDA構造体を作成する */
    sqlda2 = (sqlda_t *)malloc(sizeof(sqlda_t) + sizeof(sqlvar_t));
    memset(sqlda2, 0, sizeof(sqlda_t) + sizeof(sqlvar_t));
    sqlda2-&gt;sqln = 2; /* 入力変数の数 */

    sqlda2-&gt;sqlvar[0].sqltype = ECPGt_char;
    sqlda2-&gt;sqlvar[0].sqldata = "postgres";
    sqlda2-&gt;sqlvar[0].sqllen  = 8;

    intval = 1;
    sqlda2-&gt;sqlvar[1].sqltype = ECPGt_int;
    sqlda2-&gt;sqlvar[1].sqldata = (char *) &amp;intval;
    sqlda2-&gt;sqlvar[1].sqllen  = sizeof(intval);

    /* 入力パラメータ付きでカーソルを開く。 */
    EXEC SQL OPEN cur1 USING DESCRIPTOR sqlda2;

    while (1)
    {
        sqlda_t *cur_sqlda;

        /* 記述子をカーソルに割り当てる */
        EXEC SQL FETCH NEXT FROM cur1 INTO DESCRIPTOR sqlda1;

        for (cur_sqlda = sqlda1 ;
             cur_sqlda != NULL ;
             cur_sqlda = cur_sqlda-&gt;desc_next)
        {
            int i;
            char name_buf[1024];
            char var_buf[1024];

            /* 1行の列をすべて表示する。 */
            for (i=0 ; i&lt;cur_sqlda-&gt;sqld ; i++)
            {
                sqlvar_t v = cur_sqlda-&gt;sqlvar[i];
                char *sqldata = v.sqldata;
                short sqllen  = v.sqllen;

                strncpy(name_buf, v.sqlname.data, v.sqlname.length);
                name_buf[v.sqlname.length] = '\0';

                switch (v.sqltype)
                {
                    case ECPGt_char:
                        memset(&amp;var_buf, 0, sizeof(var_buf));
                        memcpy(&amp;var_buf, sqldata, (sizeof(var_buf)&lt;=sqllen ? sizeof(var_buf)-1 : sqllen) );
                        break;

                    case ECPGt_int: /* 整数 */
                        memcpy(&amp;intval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%d", intval);
                        break;

                    case ECPGt_long_long: /* bigint */
                        memcpy(&amp;longlongval, sqldata, sqllen);
                        snprintf(var_buf, sizeof(var_buf), "%lld", longlongval);
                        break;

                    default:
                    {
                        int i;
                        memset(var_buf, 0, sizeof(var_buf));
                        for (i = 0; i &lt; sqllen; i++)
                        {
                            char tmpbuf[16];
                            snprintf(tmpbuf, sizeof(tmpbuf), "%02x ", (unsigned char) sqldata[i]);
                            strncat(var_buf, tmpbuf, sizeof(var_buf));
                        }
                    }
                        break;
                }

                printf("%s = %s (type: %d)\n", name_buf, var_buf, v.sqltype);
            }

            printf("\n");
        }
    }

    EXEC SQL CLOSE cur1;
    EXEC SQL COMMIT;

    EXEC SQL DISCONNECT ALL;

    return 0;
}</pre><p>この例の出力は以下のようなものになるはずです（一部の数値は変動します）。
     </p><pre class="screen">oid = 1 (type: 1)
datname = template1 (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = t (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl = {=c/uptime,uptime=CTc/uptime} (type: 1)
datid = 1 (type: 1)
datname = template1 (type: 1)
numbackends = 0 (type: 5)
xact_commit = 113606 (type: 9)
xact_rollback = 0 (type: 9)
blks_read = 130 (type: 9)
blks_hit = 7341714 (type: 9)
tup_returned = 38262679 (type: 9)
tup_fetched = 1836281 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)

oid = 11511 (type: 1)
datname = postgres (type: 1)
datdba = 10 (type: 1)
encoding = 0 (type: 5)
datistemplate = f (type: 1)
datallowconn = t (type: 1)
datconnlimit = -1 (type: 5)
datlastsysoid = 11510 (type: 1)
datfrozenxid = 379 (type: 1)
dattablespace = 1663 (type: 1)
datconfig =  (type: 1)
datacl =  (type: 1)
datid = 11511 (type: 1)
datname = postgres (type: 1)
numbackends = 0 (type: 5)
xact_commit = 221069 (type: 9)
xact_rollback = 18 (type: 9)
blks_read = 1176 (type: 9)
blks_hit = 13943750 (type: 9)
tup_returned = 77410091 (type: 9)
tup_fetched = 3253694 (type: 9)
tup_inserted = 0 (type: 9)
tup_updated = 0 (type: 9)
tup_deleted = 0 (type: 9)</pre></div></div><br class="example-break" /></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-pgtypes.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-errors.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">35.6. pgtypes ライブラリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 35.8. エラー処理</td></tr></table></div></body></html>