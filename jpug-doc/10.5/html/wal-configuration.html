<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>30.4. WALの設定</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="wal-async-commit.html" title="30.3. 非同期コミット" /><link rel="next" href="wal-internals.html" title="30.5. WALの内部" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">30.4. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">WAL</acronym>の設定</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal-async-commit.html" title="30.3. 非同期コミット">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み">Up</a></td><th width="60%" align="center">Chapter 30. 信頼性とログ先行書き込み</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="wal-internals.html" title="30.5. WALの内部">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="WAL-CONFIGURATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">30.4. <acronym class="acronym">WAL</acronym>の設定</h2></div></div></div><p>データベースの性能に影響するような<acronym class="acronym">WAL</acronym>に関連した設定パラメータが複数あります。
本節では、その使い方を説明します。
サーバ設定パラメータの設定方法についての詳細は<a class="xref" href="runtime-config.html" title="Chapter 19. サーバの設定">Chapter 19</a>を参照してください。
  </p><p><em class="firstterm">チェックポイント</em><a id="id-1.6.17.6.3.2" class="indexterm"></a>は、一連のトランザクションにおいて、そのチェックポイント以前に書かれた全ての情報によりヒープとインデックスファイルがすでに更新されていることを保証する場所です。
チェックポイントの時刻において、全てのダーティページデータはディスクにフラッシュされ、特殊なチェックポイントレコードがログファイルに書き込まれます。
(変更されたレコードは以前に<acronym class="acronym">WAL</acronym>フラッシュされています。)
クラッシュした時、クラッシュからの復旧処理は最後のチェックポイントレコードを見つけ、ログの中でどのレコード（これはredoレコードと呼ばれています）から復旧処理がREDOログ操作を開始すべきかを決定します。
このチェックポイント以前になされたデータの変更は、すでにディスク上にあることが保証されています。
従って、チェックポイント後、redoレコード内のそのチェックポイント以前のログセグメントは不要となり、再利用または削除することができます
（<acronym class="acronym">WAL</acronym>アーカイブが行われる場合、このログセグメントは削除もしくは再利用される前に保存されなければなりません）。
  </p><p>チェックポイント処理は、全てのダーティデータページをディスクへ書き出すため、大きなI/O負荷を発生させます。
チェックポイント処理においては、I/Oはチェックポイント開始時に始まり、次のチェックポイントが開始する前に完了するように調節されます。
これは、チェックポイント処理中の性能劣化を極力抑える効果があります。
  </p><p>サーバのチェックポインタプロセスは、自動的にチェックポイントを時々実行します。
<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-TIMEOUT">checkpoint_timeout</a>秒が経過するか、または<a class="xref" href="runtime-config-wal.html#GUC-MAX-WAL-SIZE">max_wal_size</a>に達するか、どちらかの条件が最初に満たされるとチェックポイントが開始されます。
デフォルトの設定では、それぞれ5分と1GBとなっています。
前回のチェックポイント以降書き出すWALがない場合、<code class="varname">checkpoint_timeout</code>が経過したとしても新しいチェックポイントが飛ばされます。
WALアーカイブ処理を使用しており、かつ、データ損失の可能性を限定するためにファイルのアーカイブ頻度に対する下限を設定したい場合、チェックポイント関連のパラメータよりも、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</a>パラメータを調節するべきです。
また、<code class="command">CHECKPOINT</code> SQLコマンドで強制的にチェックポイントを作成することもできます。
  </p><p><code class="varname">checkpoint_timeout</code>または<code class="varname">max_wal_size</code>、あるいはその両者を減少させると、チェックポイントはより頻繁に行われます。
これにより、やり直しに要する処理量が少なくなるので、クラッシュ後の修復は高速になります。
しかし、変更されたデータページの吐き出しがより頻繁に行われることにより増大するコストとバランスを考えなければなりません。
<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>が設定されている（デフォルトです）場合、他に考慮しなければならない点があります。
データページの一貫性を保証するために、各チェックポイント後の最初に変更されるデータページは、そのページ全体の内容がログに保存されることになります。
このような場合、チェックポイントの間隔を少なくすることは、WALログへの出力を増加させ、間隔を短くする目的の一部を無意味にします。
また、確実により多くのディスクI/Oが発生します。
  </p><p>チェックポイントはかなり高価なものです。
1番の理由は、この処理は現時点の全てのダーティバッファを書き出す必要があること、2番目の理由は、上記のようにその後に余計なWALの書き込みが発生することです。
そのため、チェックポイント用のパラメータを高くし、チェックポイントがあまりにも頻発することがないようにすることを勧めます。
簡単なチェックポイント用のパラメータの健全性検査として、<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-WARNING">checkpoint_warning</a>パラメータを設定することができます。
チェックポイントの発生間隔が<code class="varname">checkpoint_warning</code>秒未満の場合、<code class="varname">max_wal_size</code>の増加を勧めるメッセージがサーバのログに出力されます。
このメッセージが稀に現れたとしても問題にはなりませんが、頻出するようであれば、チェックポイントの制御パラメータを増加させるべきです。
<code class="varname">max_wal_size</code>を十分高く設定していないと、大規模な<code class="command">COPY</code>転送などのまとまった操作でこうした警告が多く発生するかもしれません。
  </p><p>ページ書き出しの集中による入出力システムの溢れを防ぐために、チェックポイント期間のダーティバッファの書き出しは一定の期間に分散されます。
この期間は<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a>により制御され、チェックポイント間隔の割合として指定されます。
I/Oの割合は、チェックポイントの起動時から<code class="varname">checkpoint_timeout</code>秒が経過した時、あるいは<code class="varname">max_wal_size</code>を超えた時、このどちらかが発生するとすぐに、チェックポイントが完了するように調整されます。
デフォルトの0.5という値では、<span class="productname">PostgreSQL</span>は、次のチェックポイントが始まるまでのおよそ半分の時間で各チェックポイントが完了するものと想定できることになります。
通常の操作においてほぼ最大のI/Oスループットに近いようなシステムでは、チェックポイントにおけるI/O負荷を減らすために<code class="varname">checkpoint_completion_target</code>を増やすことを勧めます。
この欠点は、延長されたチェックポイントがリカバリ時に影響をあたえることです。
リカバリ時に使用できるように、より多くのWALセグメントを保持する必要があるためです。
<code class="varname">checkpoint_completion_target</code>を最大の1.0に設定することもできますが、より低く抑えること（おそらく最大で0.9）が最善です。
チェックポイントには、ダーティバッファを書き出す以外の活動も含まれているからです。
1.0という設定は、ある時点でチェックポイントが完了しなくなるという結果に陥ります。
これは必要なWALセグメント数が想定以上に変動することになり、性能の劣化が発生することになります。
  </p><p>LinuxおよびPOSIXプラットフォームでは、チェックポイントによって書かれたページを、設定したバイト数の後にディスクに吐き出すように<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-FLUSH-AFTER">checkpoint_flush_after</a>を使ってOSに強制させることができます。
この設定がない場合はこのページはOSのページキャッシュに保持されるかもしれず、チェックポイントの最後に<code class="literal">fsync</code>が発行された際の速度低下を招きます。
この設定は、しばしばトランザクションの遅延を減少させるのに役立ちます。
しかし、とりわけワークロードが<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>よりも大きく、かつOSのページキャッシュよりも小さい場合には性能上不利になることもあります。
  </p><p><code class="filename">pg_wal</code>ディレクトリ内のWALセグメントファイルの数は、<code class="varname">min_wal_size</code>、<code class="varname">max_wal_size</code>、それに前回のチェックポイントで生成されたWALの量に依存します。
古いログセグメントファイルが不要になると、削除または再利用(連番のうち、今後利用される予定の番号に名前が変更されます)されます。
ログの出力レートが短期間にピークを迎えたために<code class="varname">max_wal_size</code>を超えた場合、この制限以下になるまで不要なセグメントファイルが削除されます。
この制限以下になると、次のチェックポイントまでは、システムは見積もりを満たすだけのWALファイルを再利用します。
この見積は、前回のチェックポイントの際に使用されたWALファイルの移動平均に基づいています。
もし実際の使用量が見積もりを上回ると、移動平均は直ちに増加します。
これにより、平均需要というよりは、ピーク時の需要をある程度満たすことができるわけです。
<code class="varname">min_wal_size</code>は、今後のために再利用されるWALファイル数の最小値を設定します。
システムがアイドル状態にあり、WALの使用量を見積った結果、少ないWALしか必要ないとなったとしても、こうした量のWALファイルは必ず再利用されます。
  </p><p><code class="varname">max_wal_size</code>とは無関係に、WALファイルのうち、常に最新の(<a class="xref" href="runtime-config-replication.html#GUC-WAL-KEEP-SEGMENTS">wal_keep_segments</a> + 1)個が維持されます。
また、WALアーカイブを利用している場合は、古いセグメントは、アーカイブされるまでは削除も再利用もされません。
WALが生成されるペースにWALのアーカイブ処理が追いつかなかったり、<code class="varname">archive_command</code>が連続して失敗すると、事態が解決するまでWALファイルは<code class="filename">pg_wal</code>の下に蓄積されていきます。
レプリケーションスロットを使用しているスタンバイサーバが低速だったり、失敗すると、同じ現象が起きます(<a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="26.2.6. レプリケーションスロット">Section 26.2.6</a>を参照のこと)
  </p><p>アーカイブからのリカバリもしくはスタンバイモードにおいて、サーバでは定期的に通常運用でのチェックポイント処理と似た<em class="firstterm">再開始点</em><a id="id-1.6.17.6.12.2" class="indexterm"></a>処理を行います。これは、すでに再生されたWALを再度読み込む必要がないよう、ディスクに現在の状態を強制的に書き込み、<code class="filename">pg_control</code>ファイルを更新します。また<code class="filename">pg_wal</code>ディレクトリの中の古いログセグメントを再利用できるようにします。
再開始点処理はチェックポイントレコードに対してしか実施されないので、マスタ側のチェックポイント処理よりも発生頻度が多いということはありません。
再開始点は、最後の再開始点より少なくとも<code class="varname">checkpoint_timeout</code>秒が経過しているか、あるいは<code class="varname">max_wal_size</code>を超えそうな場合に起動されます。
しかし、再開始点が実施できるための制約事項により、リカバリの際には1回のチェックポイント分のWALを上限に、<code class="varname">max_wal_size</code>を超えてしまいがちです。
(どのみち<code class="varname">max_wal_size</code>はハードリミットではないので、ディスクスペースを使い尽くしてしまわないように、常に十分な余裕を持っておくべきです)
  </p><p>よく使われる2つの内部用<acronym class="acronym">WAL</acronym>関数があります。
<code class="function">XLogInsertRecord</code>と<code class="function">XLogFlush</code>です。
<code class="function">XLogInsertRecord</code>は共有メモリ上の<acronym class="acronym">WAL</acronym>バッファに新しいレコードを挿入します。
新しいレコードを挿入する余地がない時は、<code class="function">XLogInsertRecord</code>は、満杯になった<acronym class="acronym">WAL</acronym>バッファを書き込み（カーネルキャッシュに移動）しなければいけません。
これは望ましいことではありません。
なぜなら、データベースへの低レベルの変更（例えば行の挿入）の度に<code class="function">XLogInsertRecord</code>が呼ばれますが、そのような場合には変更を受けたページに対して排他ロックがかかっており、それゆえこの操作は可能な限り高速に実行されなければなりません。
さらに悪いことには、<acronym class="acronym">WAL</acronym>バッファへの書き込みの際に、さらに時間がかかる、強制的な新しいログセグメントの生成が必要となるかもしれません。
通常、<acronym class="acronym">WAL</acronym>の書き込み、吐き出しは<code class="function">XLogFlush</code>要求で実施されます。
これはたいていの場合、トランザクションコミットの際に永続的な記憶領域にトランザクションレコードが吐き出されることを保証するために行われます。
ログ出力が大量に行われるシステムでは、<code class="function">XLogInsertRecord</code>によって必要となる書き込みを防ぐほどには<code class="function">XLogFlush</code>要求が頻繁に起こらないかもしれません。
そういうシステムでは、<a class="xref" href="runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>パラメータを変更して<acronym class="acronym">WAL</acronym>バッファの数を増やしてください。
<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>が設定され、かつ、システムが高負荷状態である場合、<code class="varname">wal_buffers</code>を高くすることで、各チェックポイントの直後の応答時間を滑らかにすることができます。
  </p><p><a class="xref" href="runtime-config-wal.html#GUC-COMMIT-DELAY">commit_delay</a>パラメータは、<code class="function">XLogFlush</code>内でロックを取得してからグループコミット上位者が何マイクロ秒休止するかを定義します。一方、グループコミット追従者は上位者の後に並びます。
すべてが上位者の結果として生ずる同期操作によりフラッシュされるように、この遅延は他のサーバプロセスがそれらのコミットレコードをWALバッファに追加することを許容します。
<a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a>が有効でないか、または<a class="xref" href="runtime-config-wal.html#GUC-COMMIT-SIBLINGS">commit_siblings</a>より少ない他のセッションがその時点で活動しているトランザクションであれば休止は行われません。
他の何らかのセッションが直ぐにでもコミットするという起こりそうにない時の休止を避けるものです。
いくつかのプラットフォームにおいて、休止要求の分解能は10ミリ秒で、１から10000マイクロ秒の間の<code class="varname">commit_delay</code>の設定は、どの値でも同じ効果となることを覚えておいてください。
いくつかのプラットフォームで、休止操作はパラメータによって要求された時間よりわずかに長くなることも覚えておいてください。
  </p><p><code class="varname">commit_delay</code>の目的は、それぞれのフラッシュ操作のコストを並列にコミット中のトランザクションに（潜在的にはトランザクションの待ち時間と引き換えに）分散させることにあり、うまく設定を行うためには、まずそのコストを測る必要があります。
そのコストが高ければ高いほど、トランザクションのスループットがある程度向上するという意味において、<code class="varname">commit_delay</code>の効果がより増すことが期待できます。
<a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a>プログラムは、一つのWALフラッシュが必要とするマイクロ秒単位の平均時間を計測するために使用可能です。
プログラムが報告する単一の8kB書き込み操作のあとのフラッシュ平均時間の２分の１の値は、しばしば<code class="varname">commit_delay</code>の最も効果的な設定です。
従って、この値は特定の作業負荷のための最適化を行うときに使用するための手始めとして推奨されます。
WALログが高遅延の回転ディスクに格納されているときは、<code class="varname">commit_delay</code>のチューニングは特に有効ですが、半導体ドライブまたはバッテリー・バックアップされている書き込みキャッシュ付きのRAIDアレーのような、特に同期時間が高速な格納メディア上であっても大きなメリットがある場合があります。
しかし、このことは、代表的作業負荷に対してきちんと検証しておくべきです。
<code class="varname">commit_siblings</code>の高い値は、これらの状況で使用すべきで、一方より小さな<code class="varname">commit_siblings</code>の値は高遅延メディア上でしばしば有用です。
余りにも高い値の<code class="varname">commit_delay</code>を設定すると、トランザクション遅延を増加させかねないことになり、トランザクションの総スループットが低下します。
  </p><p><code class="varname">commit_delay</code>が(デフォルトの）ゼロに設定されても、グループコミットが起こることがあります。
しかし、それぞれのグループは前回のフラッシュ操作（あった場合）が発生していた期間中に、それぞれのコミットレコードをフラッシュする必要に至ったセッションのみから成ります。
クライアントが多い状況では、<span class="quote">“<span class="quote">gangway effect</span>”</span>が起こる傾向があり、そのため<code class="varname">commit_delay</code>がゼロであってもグループコミットの効果が著しく、従って、<code class="varname">commit_delay</code>を明示的に設定しても役立ちません。
<code class="varname">commit_delay</code>の設定は（１）複数の同時にコミット中のトランザクションが存在すること、そして（２）コミット頻度によりある程度までスループットが制限されている場合に役立ちます。
しかし、回転待ち時間が長い場合、この設定はわずか二つのクライアントにおいてさえトランザクションスループットを向上させる効果があるかもしれません（言いかえれば、一つの兄弟（sibling）トランザクションを所有する単一のコミット中のクライアントです）。
  </p><p><a class="xref" href="runtime-config-wal.html#GUC-WAL-SYNC-METHOD">wal_sync_method</a>パラメータは<span class="productname">PostgreSQL</span>がカーネルに対して<acronym class="acronym">WAL</acronym>更新のディスクへの書き込みを要求する方法を決定します。
<code class="literal">fsync_writethrough</code>を除き、どういう設定でも信頼性は同じはずです。<code class="literal">fsync_writethrough</code>は他のオプションがそうしないときでも、時々ディスクキャッシュの書き出しを強制することができます。
しかしながら、プラットフォームによってどれが一番速いのかがまったく違います。
<a class="xref" href="pgtestfsync.html" title="pg_test_fsync"><span class="refentrytitle"><span class="application">pg_test_fsync</span></span></a>プログラムを使って異なるオプションの速度テストを行うことができます。
ちなみに、このパラメータは<code class="varname">fsync</code>が無効になっている場合は役に立ちません。

  </p><p><a class="xref" href="runtime-config-developer.html#GUC-WAL-DEBUG">wal_debug</a>設定パラメータを有効にすることで、<code class="function">XLogInsertRecord</code>と<code class="function">XLogFlush</code>という<acronym class="acronym">WAL</acronym>呼び出しは毎回サーバログにログが残ります
（このパラメータをサポートするように<span class="productname">PostgreSQL</span>をコンパイルする必要があります）。
将来このオプションはより一般的な機構に置き換わる可能性があります。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal-async-commit.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="wal-internals.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">30.3. 非同期コミット </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 30.5. WALの内部</td></tr></table></div></body></html>