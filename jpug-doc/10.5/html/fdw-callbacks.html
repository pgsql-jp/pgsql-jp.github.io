<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>56.2. 外部データラッパのコールバックルーチン</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fdw-functions.html" title="56.1. 外部データラッパ関数" /><link rel="next" href="fdw-helpers.html" title="56.3. 外部データラッパヘルパ関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">56.2. 外部データラッパのコールバックルーチン</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-functions.html" title="56.1. 外部データラッパ関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="Chapter 56. 外部データラッパの作成">Up</a></td><th width="60%" align="center">Chapter 56. 外部データラッパの作成</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="fdw-helpers.html" title="56.3. 外部データラッパヘルパ関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="FDW-CALLBACKS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">56.2. 外部データラッパのコールバックルーチン</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-SCAN">56.2.1. 外部テーブルスキャンのためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-JOIN-SCAN">56.2.2. 外部テーブルの結合をスキャンするためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-UPPER-PLANNING">56.2.3. スキャン/結合後の処理をプラン生成するためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-UPDATE">56.2.4. 外部テーブル更新のためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING">56.2.5. 行ロックのためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-EXPLAIN">56.2.6. <code class="command">EXPLAIN</code>のためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-ANALYZE">56.2.7. <code class="command">ANALYZE</code>のためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-IMPORT">56.2.8. <code class="command">IMPORT FOREIGN SCHEMA</code>のためのFDWルーチン</a></span></dt><dt><span class="sect2"><a href="fdw-callbacks.html#FDW-CALLBACKS-PARALLEL">56.2.9. パラレル実行のためのFDWルーチン</a></span></dt></dl></div><p>FDWハンドラ関数は、以下で説明するコールバックの関数ポインタを含む、pallocされた<code class="structname">FdwRoutine</code>構造体を返します。
スキャンに関連した関数は必須で、それ以外は省略可能です。
    </p><p><code class="structname">FdwRoutine</code>構造体は<code class="filename">src/include/foreign/fdwapi.h</code>で宣言されていますので、追加情報はそちらを参照してください。
    </p><div class="sect2" id="FDW-CALLBACKS-SCAN"><div class="titlepage"><div><div><h3 class="title">56.2.1. 外部テーブルスキャンのためのFDWルーチン</h3></div></div></div><pre class="programlisting">void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);</pre><p>

外部テーブルのリレーションサイズ見積もりを取得します。
この関数は、ある外部テーブルをスキャンするクエリのプラン作成の開始時に呼び出されます。
<code class="literal">root</code>はそのクエリに関するプランナのグローバル情報です。
<code class="literal">baserel</code>はそのテーブルに関するプランナの情報です。
そして、<code class="literal">foreigntableid</code>はその外部テーブルの<code class="structname">pg_class</code> OIDです。
(<code class="literal">foreigntableid</code>はプランナデータ構造体からも取得できますが、手間を省くために明示的に渡されます。)
    </p><p>この関数は、検索条件によるフィルタリングも考慮に入れた、そのテーブルスキャンが返すと見込まれる件数に<code class="literal">baserel-&gt;rows</code>を更新するべきです。
<code class="literal">baserel-&gt;rows</code>の初期値は固定のデフォルト見積もりなので、可能な限り置き換えられるべきです。この関数は、行の幅のよりよい見積もりを計算できるのであれば、<code class="literal">baserel-&gt;width</code>を更新することも選択出来ます。
    </p><p>追加情報については<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p><pre class="programlisting">void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);</pre><p>

外部テーブル対するスキャンとして可能なアクセスパスを作成します。
この関数はクエリのプラン作成中に呼び出されます。
引数は、先に呼ばれている<code class="function">GetForeignRelSize</code>と同じです。
    </p><p>この関数は、少なくとも一つのアクセスパス(<code class="structname">ForeignPath</code>ノード)を作成して、それぞれのパスを<code class="literal">baserel-&gt;pathlist</code>に追加するために<code class="function">add_path</code>を呼ばなければなりません。
<code class="structname">ForeignPath</code>ノードを構築するには<code class="function">create_foreignscan_path</code>を使うことが推奨されています。
この関数は、たとえばソート済みの結果を表現する有効な<code class="literal">pathkeys</code>を持つパスのような複数のアクセスパスを作成することが出来ます。
それぞれのアクセスパスはコスト見積もりを含まねばならず、また意図した特定のスキャン方式を識別するのに必要なFDW固有の情報を持つことが出来ます。
    </p><p>追加情報については<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p><pre class="programlisting">ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses,
                Plan *outer_plan);</pre><p>

選択された外部アクセスパスから<code class="structname">ForeignScan</code>プランノードを作成します。
この関数はクエリプラン作成の最後に呼び出されます。
引数は、<code class="function">GetForeignRelSize</code>と同じものに、選択された<code class="structname">ForeignPath</code>(事前に<code class="function">GetForeignPaths</code>、<code class="function">GetForeignJoinPaths</code>または<code class="function">GetForeignUpperPaths</code>によって作成されたもの)、そのプランノードによって出力されるターゲットリスト、そのプランノードで強制される条件句、および<code class="function">RecheckForeignScan</code>が実行する再検査で使用される<code class="structname">ForeignScan</code>の外側のサブプランが追加されます。
（パスがベースリレーションではなく結合のためのものの場合、<code class="literal">foreigntableid</code>は<code class="literal">InvalidOid</code>になります。）
    </p><p>この関数は<code class="structname">ForeignScan</code>プランノードを作成して返さなければなりません。<code class="structname">ForeignScan</code>ノードを構築するには<code class="function">make_foreignscan</code>を使うことが推奨されています。
    </p><p>追加情報については<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p><pre class="programlisting">void
BeginForeignScan (ForeignScanState *node,
                  int eflags);</pre><p>

外部テーブルスキャンの実行を開始します。
この関数はエグゼキュータの起動中に呼び出されます。
スキャンを開始できるようになる前に、あらゆる必要な初期化を実行するべきですが、実際のスキャンの実行を始めるべきではありません(それは最初の<code class="function">IterateForeignScan</code>呼び出しにおいて行われるべきです)。
<code class="structname">ForeignScanState</code>ノードは作成されていますが、その<code class="structfield">fdw_state</code>フィールドはNULLのままです。
スキャンするテーブルの情報は、<code class="structname">ForeignScanState</code>ノード(特に、その先にある<code class="function">GetForeignPlan</code>から提供されたFDWプライベート情報を含む、<code class="structname">ForeignScan</code>プランノード)を通じてアクセス可能です。
<code class="literal">eflags</code>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </p><p><code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<code class="function">ExplainForeignScan</code>や<code class="function">EndForeignScan</code>用にノード状態を有効にするのに必要とされる最小限のことだけをすべきです。
    </p><pre class="programlisting">TupleTableSlot *
IterateForeignScan (ForeignScanState *node);</pre><p>

外部ソースから一行を取り出して、それをタプルテーブルスロットに入れて返します(この用途にはノードの<code class="structfield">ScanTupleSlot</code>を使うべきです)。
利用可能な行がない場合は、NULLを返します。
タプルテーブルスロット機構を使うと、物理タプルと仮想タプルのどちらでも返せます。
ほとんどの場合、パフォーマンスの観点から後者を選ぶのが良いでしょう。
この関数は、呼出しごとにリセットされる短命なメモリコンテキスト内で呼び出されることに注意してください。
より長命なストレージが必要な場合は、<code class="function">BeginForeignScan</code>でメモリコンテキストを作成するか、ノードの<code class="structname">EState</code>に含まれる<code class="structfield">es_query_cxt</code>を使用してください。
    </p><p>返される行は、ターゲットリスト<code class="structfield">fdw_scan_tlist</code>が提供されたなら、それとマッチしなければならず、提供されていない場合はスキャンされている外部テーブルの行型とマッチしなければなりません。
不要な列を取り出さないように最適化することを選ぶなら、それらの列の位置にNULLを入れるか、あるいはそれらの列を除いた<code class="structfield">fdw_scan_tlist</code>リストを生成するべきです。
    </p><p><span class="productname">PostgreSQL</span>のエグゼキュータは返された行が外部テーブルに定義された制約に違反しているかどうかは気にしません。
しかし、プランナはそれに着目するので、宣言された制約に反する行が外部テーブル上にあった場合に、不正な最適化をするかもしれません。
ユーザが制約が成り立つと宣言したのに制約に違反した場合は(データ型が一致しなかった場合にする必要があるのと同様に)エラーを発生させるのが適切でしょう。
    </p><pre class="programlisting">void
ReScanForeignScan (ForeignScanState *node);</pre><p>

先頭からスキャンを再開します。
スキャンが依存するいずれかのパラメータが値を変更しているかもしれないので、新しいスキャンが必ずしも厳密に同じ行を返すとは限らないことに注意してください。
    </p><pre class="programlisting">void
EndForeignScan (ForeignScanState *node);</pre><p>

スキャンを終了しリソースを解放します。
通常、pallocされたメモリを解放することは重要ではありませんが、開いたファイルやリモートサーバへの接続などはクリーンアップするべきです。
    </p></div><div class="sect2" id="FDW-CALLBACKS-JOIN-SCAN"><div class="titlepage"><div><div><h3 class="title">56.2.2. 外部テーブルの結合をスキャンするためのFDWルーチン</h3></div></div></div><p>FDWが外部テーブルの結合を（両方のテーブルのデータをフェッチして、ローカルで結合するのでなく）リモートで実行することをサポートする場合、次のコールバック関数を提供します。
    </p><pre class="programlisting">void
GetForeignJoinPaths (PlannerInfo *root,
                     RelOptInfo *joinrel,
                     RelOptInfo *outerrel,
                     RelOptInfo *innerrel,
                     JoinType jointype,
                     JoinPathExtraData *extra);</pre><p>
同じ外部サーバにある2つ（またはそれ以上）の外部テーブルの結合のための可能なアクセスパスを作成します。
このオプション関数は、問い合わせの計画時に呼び出されます。
<code class="function">GetForeignPaths</code>と同じく、この関数は提供された<code class="literal">joinrel</code>のための<code class="structname">ForeignPath</code>パスを生成し、<code class="function">add_path</code>を呼んで、それらのパスを結合のために考慮されるパスの集合に追加します。
しかし、<code class="function">GetForeignPaths</code>とは異なり、この関数が少なくとも1つのパスの作成に成功することは必要ではありません。
なぜなら、ローカルの結合を含んだパスはいつでも可能だからです。
    </p><p>この関数は、同じ結合のリレーションに対して、内側と外側のリレーションの異なる組み合わせで繰り返し呼び出されることに注意して下さい。
同じ作業の繰り返しを最小化することはFDWの責任です。
    </p><p><code class="structname">ForeignPath</code>パスが結合のために選択されると、それは結合プロセス全体を代表することになり、構成テーブルとその関連の結合のために生成されたパスは使われなくなります。
結合パスの以降の処理は、単一の外部テーブルをスキャンするパスとほぼ同様に進みます。
1つの相違点は、結果として作られる<code class="structname">ForeignScan</code>計画ノードの<code class="structfield">scanrelid</code>が0にセットされるべき、ということで、これはそれが表現する単一のリレーションがないためです。
その代わりに、<code class="structname">ForeignScan</code>ノードの<code class="structfield">fs_relids</code>フィールドが結合されるリレーションの集合を表します。
（後者のフィールドはコアのプランナのコードによって自動的にセットされるので、FDWによって設定される必要はありません。）
他の相違点は、リモートの結合についての列リストがシステムカタログにはないため、FDWは<code class="structfield">fdw_scan_tlist</code>に適切な<code class="structfield">TargetEntry</code>ノードのリストを入れて、実行時に返されるタプル内の列の集合を表すようにしなければならないということです。
    </p><p>追加情報については<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p></div><div class="sect2" id="FDW-CALLBACKS-UPPER-PLANNING"><div class="titlepage"><div><div><h3 class="title">56.2.3. スキャン/結合後の処理をプラン生成するためのFDWルーチン</h3></div></div></div><p>FDWがリモート集約など、リモートでのスキャン/結合後の処理をサポートする場合、次のコールバック関数を提供します。
    </p><pre class="programlisting">void
GetForeignUpperPaths (PlannerInfo *root,
                      UpperRelationKind stage,
                      RelOptInfo *input_rel,
                      RelOptInfo *output_rel);</pre><p>
<em class="firstterm">上位リレーション</em>処理のための、ありうるアクセスパスを作成します。上位リレーションはプランナ用語で、ウィンドウ関数、ソート、テーブル更新など、全てのスキャン/結合後の問い合わせのことです。
この省略可能な関数は問い合わせのプラン作成時に呼ばれます。
今のところ、これは問い合わせに含まれる全てのベースリレーションが同じFDWに属する場合だけ呼ばれます。
この関数では、FDWがどのようにリモートで実行するか分かっている全てのスキャン/結合後の処理に<code class="structname">ForeignPath</code>パスを生成し、それらパスを指定された上位リレーションに加えるために<code class="function">add_path</code>を呼び出してください。
<code class="function">GetForeignJoinPaths</code>の時と同様に、この関数が何らかのパス作成に成功する必要はありません。なぜなら、ローカル処理を含んでいるパスはいつでも可能だからです。
    </p><p><code class="literal">stage</code>パラメータはどのスキャン/結合後の処理が現在考慮されているかを定めます。
<code class="literal">output_rel</code>は本処理の計算方法をあらわすパスを受け取るであろう上位リレーションで、<code class="literal">input_rel</code>は本処理への入力をあらわすリレーションです。
（注意：これらの処理は外部で実行されると考えられるため、<code class="literal">output_rel</code>に加えられる<code class="structname">ForeignPath</code>パスは、一般的に<code class="literal">input_rel</code>のパスへの直接の依存を全く持たないでしょう。
しかしながら、手前の処理段階のために以前に生成されたパスを検査することは、冗長なプラン作成活動を回避するのに役立ちます。）
    </p><p>追加情報については<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p></div><div class="sect2" id="FDW-CALLBACKS-UPDATE"><div class="titlepage"><div><div><h3 class="title">56.2.4. 外部テーブル更新のためのFDWルーチン</h3></div></div></div><p>もしFDWが更新可能な外部テーブルをサポートする場合、FDWのニーズと能力に応じて、以下のコールバック関数の一部または全てを提供する必要があります。
    </p><pre class="programlisting">void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);</pre><p>

<code class="command">UPDATE</code>と<code class="command">DELETE</code>の操作は、テーブルスキャン関数によって事前にフェッチされた行に対して実行されます。
FDWは、更新や削除の対象行を厳密に識別できるように行IDや主キー列の値といった追加情報を必要とするかもしれません。
それをサポートするために、この関数は<code class="command">UPDATE</code>や<code class="command">DELETE</code>の間に外部テーブルから取得される列のリストに追加の隠された(または<span class="quote">“<span class="quote">ジャンクの</span>”</span>)ターゲット列を追加することができます。
    </p><p>これを実行するには、フェッチする追加の値の式を含む<code class="structname">TargetEntry</code>エントリを<code class="literal">parsetree-&gt;targetList</code>に追加します。
それぞれのエントリは<code class="structfield">resjunk</code> = <code class="literal">true</code>とマークされなければならず、また実行時にエントリを識別できる異なる<code class="structfield">resname</code>を持つ必要があります。
コアシステムがそのような名前のジャンク列を生成できるように、<code class="literal">ctid<em class="replaceable"><code>N</code></em></code>や<code class="literal">wholerow</code>、<code class="literal">wholerow<em class="replaceable"><code>N</code></em></code>と一致する名前は使用しないでください。
    </p><p>追加の式が単純な（Var型の）変数よりも複雑な場合は、それらをtargetlistに追加する前に<code class="function">eval_const_expressions</code>を実行する必要があります。
    </p><p>この関数はプラン生成中に呼び出されますが、提供される情報は他のプラン生成ルーチンで使用できる情報とは少し異なります。
<code class="literal">parsetree</code>は<code class="command">UPDATE</code>や<code class="command">DELETE</code>コマンドの解析ツリーで、<code class="literal">target_rte</code>と<code class="literal">target_relation</code>は対象の外部テーブルを表します。
    </p><p>もし<code class="function">AddForeignUpdateTargets</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、追加のターゲット式は追加されません。
(FDWが行を識別するのに不変の主キーに依存するのであれば<code class="command">UPDATE</code>は依然として実現可能かもしれませんが、<code class="command">DELETE</code>操作を実装することは不可能になるでしょう。)
    </p><pre class="programlisting">List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);</pre><p>

外部テーブルに対する挿入、更新、削除に必要となる、追加のプラン生成アクションを実行します。
この関数は、更新処理を実行する<code class="structname">ModifyTable</code>プランノードに追加されるFDW固有の情報を生成します。この固有情報は<code class="literal">List</code>形式でなければならず、また実行段階の間に<code class="function">BeginForeignModify</code>に渡されます。
    </p><p><code class="literal">root</code>はそのクエリに関するプランナのグローバル情報です。
<code class="literal">plan</code>は<code class="structfield">fdwPrivLists</code>フィールドを除いて完成している<code class="structname">ModifyTable</code>プランノードです。
<code class="literal">resultRelation</code>は対象の外部テーブルをレンジテーブルの添字で識別します。
<code class="literal">subplan_index</code>は<code class="structname">ModifyTable</code>プランノードの対象がどれであるかを0始まりで識別します。この情報は<code class="literal">plan-&gt;plans</code>などの<code class="literal">plan</code>の下位構造を指定したい場合に使用してください。
    </p><p>追加情報は<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p><p>もし<code class="function">PlanForeignModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、追加のプラン作成時処理は実行されず、<code class="function">BeginForeignModify</code>に渡される<code class="literal">fdw_private</code>リストはNILになります。
    </p><pre class="programlisting">void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);</pre><p>

外部テーブルへの変更操作の実行を開始します。
このルーチンはエグゼキュータの起動中に呼び出されます。
実際のテーブル変更に先立って必要なあらゆる初期化処理を実行する必要があります。
その後、各タプルが挿入、更新、削除されるように<code class="function">ExecForeignInsert</code>、<code class="function">ExecForeignUpdate</code>、<code class="function">ExecForeignDelete</code>のいずれかが呼ばれます。
    </p><p><code class="literal">mtstate</code>は実行されている<code class="structname">ModifyTable</code>プランノード全体の状態です。プランに関する全般的なデータと実行状態はこの構造体経由で利用可能です。
<code class="literal">rinfo</code>は対象の外部テーブルを表す<code class="structname">ResultRelInfo</code>構造体です。
(<code class="structname">ResultRelInfo</code>の<code class="structfield">ri_FdwState</code>フィールドはこの操作で必要となる固有の状態をFDWが格納するのに利用できます。)
<code class="literal">fdw_private</code>は、もしあれば<code class="function">PlanForeignModify</code>で生成された固有データを含みます。
<code class="literal">subplan_index</code>は、これが<code class="structname">ModifyTable</code>プランノードのどのターゲットであるかを識別します。
<code class="literal">eflags</code>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </p><p><code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<code class="function">ExplainForeignModify</code>や<code class="function">EndForeignModify</code>用にノード状態を有効にするのに必要な最小限のことだけを実行するべきです。
    </p><p>もし<code class="function">BeginForeignModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、エグゼキュータ起動時には追加処理は何も実行されません。
    </p><pre class="programlisting">TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</pre><p>

外部テーブルにタプルを一つ挿入します。
<code class="literal">estate</code>はそのクエリのグローバルな実行状態です。
<code class="literal">rinfo</code>は対象の外部テーブルを表す<code class="structname">ResultRelInfo</code>構造体です。
<code class="literal">slot</code>には挿入されるタプルが含まれます。その行型定義は外部テーブルと一致します。
<code class="literal">planSlot</code>には<code class="structname">ModifyTable</code>プランノードのサブプランが生成したタプルが含まれます。追加の<span class="quote">“<span class="quote">ジャンク</span>”</span>列を含みうる点において、<code class="literal">slot</code>とは異なります。(<code class="literal">planSlot</code>は一般的に<code class="command">INSERT</code>のケースにおいてはそれほど意味を持ちませんが、完全性のために提供されます。)
    </p><p>戻り値は実際に挿入されたデータ(例えばトリガー処理の結果などにより、提供されたデータとは異なるかもしれません)を含むスロットか、または(こちらも一般的にトリガーの結果)実際には挿入されなかった場合はNULLです。
渡された<code class="literal">slot</code>はこの用途に再利用可能です。
    </p><p>返却されたスロット内のデータは<code class="command">INSERT</code>クエリが<code class="literal">RETURNING</code>句を持っていた場合もしくは外部テーブルが<code class="literal">AFTER ROW</code>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<code class="literal">RETURNING</code>句の内容に応じて返却する列を一部にするかすべてにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </p><p>もし<code class="function">ExecForeignInsert</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、外部テーブルへの挿入の試みはエラーメッセージとともに失敗します。
    </p><pre class="programlisting">TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</pre><p>

外部テーブル内のタプルを一つ更新します。
<code class="literal">estate</code>はそのクエリのグローバルな実行状態です。
<code class="literal">rinfo</code>は対象の外部テーブルを表す<code class="structname">ResultRelInfo</code>構造体です。
<code class="literal">slot</code>にはタプルの新しいデータが含まれます。その行型定義は外部テーブルと一致します。
<code class="literal">planSlot</code>には<code class="structname">ModifyTable</code>プランノードのサブプランが生成したタプルが含まれます。追加の<span class="quote">“<span class="quote">ジャンク</span>”</span>列を含みうる点において、<code class="literal">slot</code>とは異なります。実際、<code class="function">AddForeignUpdateTargets</code>が要求するジャンク列はこのスロットから利用可能です。
    </p><p>戻り値は実際に更新されたデータ(例えばトリガー処理の結果などにより、提供されたデータとは異なるかもしれません)を含むスロットか、または(こちらも一般的にトリガーの結果)実際には更新されなかった場合はNULLです。
渡された<code class="literal">slot</code>はこの用途に再利用可能です。
    </p><p>返却されたスロット内のデータは<code class="command">UPDATE</code>クエリが<code class="literal">RETURNING</code>句を持っていた場合もしくは外部テーブルが<code class="literal">AFTER ROW</code>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<code class="literal">RETURNING</code>句の内容に応じて返却する列を一部にするか全てにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </p><p>もし<code class="function">ExecForeignUpdate</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、外部テーブルへの更新の試みはエラーメッセージとともに失敗します。
    </p><pre class="programlisting">TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</pre><p>

外部テーブルからタプルを一つ削除します。
<code class="literal">estate</code>はそのクエリのグローバルな実行状態です。
<code class="literal">rinfo</code>は対象の外部テーブルを表す<code class="structname">ResultRelInfo</code>構造体です。
<code class="literal">slot</code>にはタプルの新しいデータが含まれます。その行型定義は外部テーブルと一致します。
<code class="literal">planSlot</code>には<code class="structname">ModifyTable</code>プランノードのサブプランが生成したタプルが含まれます。実際、<code class="function">AddForeignUpdateTargets</code>が要求するジャンク列はこのスロットが運びます。ジャンク列は削除されるタプルを識別するために使用しなければなりません。
    </p><p>戻り値は実際に削除されたデータを含むスロットか、または(一般的にトリガーの結果)実際には削除されなかった場合はNULLです。
渡された<code class="literal">slot</code>は返却するタプルを保持する用途に利用可能です。
    </p><p>返却されたスロット内のデータは<code class="command">DELETE</code>クエリが<code class="literal">RETURNING</code>句を持っていた場合もしくは外部テーブルが<code class="literal">AFTER ROW</code>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<code class="literal">RETURNING</code>句の内容に応じて返却する列を一部にするか全てにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </p><p>もし<code class="function">ExecForeignDelete</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、外部テーブルからの削除の試みはエラーメッセージとともに失敗します。
    </p><pre class="programlisting">void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);</pre><p>

テーブル更新を終えてリソースを解放します。pallocされたメモリの解放は通常重要ではありませんが、開いたファイルやリモートサーバへの接続はクリーンアップするべきです。
    </p><p>もし<code class="function">EndForeignModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、エグゼキュータ終了時には追加処理は何も実行されません。
    </p><pre class="programlisting">int
IsForeignRelUpdatable (Relation rel);</pre><p>

指定された外部テーブルがどの更新処理をサポートしているかを報告します。
戻り値は、その外部テーブルがサポートする操作を表すルールイベント番号のビットマスクである必要があります。
<code class="command">UPDATE</code>用の<code class="literal">(1 &lt;&lt; CMD_UPDATE) = 4</code>、<code class="command">INSERT</code>用の<code class="literal">(1 &lt;&lt; CMD_INSERT) = 8</code>、<code class="command">DELETE</code>用の<code class="literal">(1 &lt;&lt; CMD_DELETE) = 16</code>といった<code class="literal">CmdType</code>列挙値を使います。
    </p><p>もし<code class="function">IsForeignRelUpdatable</code>ポインタが<code class="literal">NULL</code>に設定されていると、外部テーブルは<code class="function">ExecForeignInsert</code>、<code class="function">ExecForeignUpdate</code>、<code class="function">ExecForeignDelete</code>を提供していると、それぞれ挿入、更新、削除をサポートしていると判断します。
この関数は、FDWが一部のテーブルについてのみ更新をサポートする場合にのみ必要です。
(そのような場合でも、この関数でチェックする代わりにクエリ実行関数でエラーにしても構いません。しかしながら、この関数は<code class="literal">information_schema</code>のビューの表示で更新可否を判定するのに使用されます。)
    </p><p>外部テーブルへの挿入、更新、削除は、代替インタフェース一式を実装することで最適化できます。
通常の挿入、更新、削除のインタフェースは行をリモートサーバから取得し、その後、それらの行を一つずつ変更します。
一部の場合にはこの一行ごとのやり方は必要ですが、非効率とも言えます。
外部サーバについて行が本当はそれらを引き出すことなしに変更されるべきと判断できて、操作に影響を与えるローカルトリガーが無いならば、操作全体がリモートサーバで実行されるように計画することができます。
以下に示すインタフェースはこれを可能にします。
    </p><pre class="programlisting">bool
PlanDirectModify (PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);</pre><p>

リモートサーバ上で直接変更を実行することが安全かを判断します。
そうであれば、そのために必要なプラン作成の動作を実行した後に<code class="literal">true</code>を返します。
さもなくば、<code class="literal">false</code>を返します。
この省略可能な関数は問い合わせのプラン作成時に呼ばれます。
この関数が成功すると、<code class="function">BeginDirectModify</code>、<code class="function">IterateDirectModify</code>、<code class="function">EndDirectModify</code>が実行段階で代わりに呼び出されます。
成功しなければ、テーブルの変更は前述のテーブル更新関数を使って実行されます。
パラメータは<code class="function">PlanForeignModify</code>に対するものと同じです。
    </p><p>リモートサーバで直接変更を実行するには、本関数は対象サブプランをリモートサーバ上で直接変更する<code class="structname">ForeignScan</code>プランノードで書き換えしなければなりません。
<code class="structname">ForeignScan</code>の<code class="structfield">operation</code>フィールドには<code class="literal">CmdType</code>列挙値を適切に、すなわち、<code class="command">UPDATE</code>には<code class="literal">CMD_UPDATE</code>、<code class="command">INSERT</code>には<code class="literal">CMD_INSERT</code>、<code class="command">DELETE</code>には<code class="literal">CMD_DELETE</code>を設定しなければいけません。
    </p><p>追加情報は<a class="xref" href="fdw-planning.html" title="56.4. 外部データラッパのクエリプラン作成">Section 56.4</a>を参照してください。
    </p><p><code class="function">PlanDirectModify</code>ポインタに<code class="literal">NULL</code>が設定されている場合、
リモートサーバでの直接変更の実行は試みられません。
    </p><pre class="programlisting">void
BeginDirectModify (ForeignScanState *node,
                   int eflags);</pre><p>

リモートサーバでの直接変更を実行する準備をします。
この関数はエグゼキュータが開始するときに呼び出されます。
この関数は（最初の<code class="function">IterateDirectModify</code>呼び出しで実行されるであろう）直接変更より前に必要とされる全ての初期化を実行するべきです。
<code class="structname">ForeignScanState</code>ノードはすでに作られていますが、<code class="structfield">fdw_state</code>がフィールドはまだNULLです。
変更するテーブルに関する情報は<code class="structname">ForeignScanState</code>ノードを通して（具体的には<code class="function">PlanDirectModify</code>で提供されるFDWプライベート情報を含む、元となる<code class="structname">ForeignScan</code>プランノードから）入手可能です。
<code class="literal">eflags</code>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </p><p><code class="literal">(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</code>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<code class="function">ExplainDirectModify</code>や<code class="function">EndDirectModify</code>用にノード状態を有効にするのに必要な最小限のことだけを実行するべきです。
    </p><p><code class="function">BeginDirectModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </p><pre class="programlisting">TupleTableSlot *
IterateDirectModify (ForeignScanState *node);</pre><p>

<code class="command">INSERT</code>、<code class="command">UPDATE</code>、または、<code class="command">DELETE</code>の問い合わせが<code class="literal">RETURNING</code>句を持たないときには、リモートサーバでの直接変更の後、単にNULLが返ります。
問い合わせが<code class="literal">RETURNING</code>句を持つときには、<code class="literal">RETURNING</code>計算に必要なデータを含む結果を一つ取り出し、タプルテーブルスロットでそれを返します（この用途にはノードの<code class="structfield">ScanTupleSlot</code>を使うべきです）。
実際に挿入、更新、削除されたデータはノードの<code class="structname">EState</code>の<code class="literal">es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</code>に格納されなければなりません。
有効な行がそれ以上なければNULLを返します。
これは呼び出しの間でリセットされる寿命の短いメモリコンテキストで呼び出されることに注意してください。
より長命な格納場所を必要とするなら、<code class="function">BeginDirectModify</code>でメモリコンテキストを作るか、ノードの<code class="structname">EState</code>の<code class="structfield">es_query_cxt</code>を使ってください。
    </p><p>返される行は、ターゲットリスト<code class="structfield">fdw_scan_tlist</code>が提供されたなら、それとマッチしなければならず、提供されていない場合は変更されている外部テーブルの行型とマッチしなければなりません。
<code class="literal">RETURNING</code>計算に不要な列を取り出さないように最適化することを選ぶなら、それらの列の位置にNULLを入れるか、あるいはそれらの列を除いた<code class="structfield">fdw_scan_tlist</code>リストを生成するべきです。
    </p><p>問い合わせが<code class="literal">RETURNING</code>句をもつかどうかによらず、問い合わせが報告する行数はFDW自身によって増加されなければなりません。
問い合わせが<code class="literal">RETURNING</code>句を持たないときも、FDWは<code class="command">EXPLAIN ANALYZE</code>の場合の<code class="structname">ForeignScanState</code> nodeむけに行数を増加させなければなりません。
    </p><p><code class="function">IterateDirectModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </p><pre class="programlisting">void
EndDirectModify (ForeignScanState *node);</pre><p>

リモートサーバでの直接変更の後、クリーンアップします。
pallocされたメモリの解放は通常重要ではありませんが、開いたファイルやリモートサーバへの接続はクリーンアップするべきです。
    </p><p><code class="function">EndDirectModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </p></div><div class="sect2" id="FDW-CALLBACKS-ROW-LOCKING"><div class="titlepage"><div><div><h3 class="title">56.2.5. 行ロックのためのFDWルーチン</h3></div></div></div><p>FDWが（<a class="xref" href="fdw-row-locking.html" title="56.5. 外部データラッパでの行ロック">Section 56.5</a>で説明される）<em class="firstterm">遅延行ロック</em>をサポートする場合は、以下のコールバック関数を提供する必要があります。
    </p><pre class="programlisting">RowMarkType
GetForeignRowMarkType (RangeTblEntry *rte,
                       LockClauseStrength strength);</pre><p>

行の印付けでどのオプションを外部テーブルに使うかを報告します。
<code class="literal">rte</code>はテーブルの<code class="structname">RangeTblEntry</code>ノードで、<code class="literal">strength</code>は関連する<code class="literal">FOR UPDATE/SHARE</code>句があれば、それが要求するロックの強さを表します。
その結果は、<code class="literal">RowMarkType</code>列挙型のメンバーでなければなりません。
    </p><p>この関数は<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">SELECT FOR UPDATE/SHARE</code>の問い合わせに現れ、かつ<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>の対象ではない各外部テーブルについて、問い合わせの計画時に呼び出されます。
    </p><p><code class="function">GetForeignRowMarkType</code>のポインタが<code class="literal">NULL</code>に設定されていると、必ず<code class="literal">ROW_MARK_COPY</code>オプションが使われます。
（これは<code class="function">RefetchForeignRow</code>が決して呼び出されないので、それを提供する必要もない、ということを意味します。）
    </p><p>さらなる情報については<a class="xref" href="fdw-row-locking.html" title="56.5. 外部データラッパでの行ロック">Section 56.5</a>を参照してください。
    </p><pre class="programlisting">HeapTuple
RefetchForeignRow (EState *estate,
                   ExecRowMark *erm,
                   Datum rowid,
                   bool *updated);</pre><p>

必要ならロックした後で、外部テーブルから1つのタプルを再フェッチします。
<code class="literal">estate</code>は問い合わせのグローバルな実行状態です。
<code class="literal">erm</code>は対象の外部テーブルおよび獲得する行ロックの種別（あれば）を記述する<code class="structname">ExecRowMark</code>構造体です。
<code class="literal">rowid</code>はフェッチするタプルを特定するものです。
<code class="literal">updated</code>は出力パラメータです。
    </p><p>この関数は、フェッチしたタプルをpallocして複製したものを返すか、あるいは行ロックが取得できなければ<code class="literal">NULL</code>を返します。
獲得する行ロックの種別は<code class="literal">erm-&gt;markType</code>で指定されますが、この値は事前に<code class="function">GetForeignRowMarkType</code>から返されたものです。
（<code class="literal">ROW_MARK_REFERENCE</code>は行のロックを獲得せずに、単にタプルを再フェッチすることを意味し、また、<code class="literal">ROW_MARK_COPY</code>はこのルーチンで使われることはありません。）
    </p><p>そして、<code class="literal">*updated</code>はフェッチしたタプルが、以前に取得したものと同じではなく、更新されたバージョンであったときに<code class="literal">true</code>にセットされます。
（どちらなのかFDWが判断できない場合は、<code class="literal">true</code>を返すことが推奨されます）。
    </p><p>デフォルトでは、行ロックの獲得に失敗したときはエラーを発生させるべきであることに注意してください。
<code class="literal">NULL</code>を返すのが適切なのは、<code class="literal">erm-&gt;waitPolicy</code>で<code class="literal">SKIP LOCKED</code>オプションが指定されている場合だけです。
    </p><p><code class="literal">rowid</code>は、再フェッチする行を以前読んだ時の<code class="structfield">ctid</code>値です。
<code class="literal">rowid</code>値は<code class="type">Datum</code>として渡されますが、現在は<code class="type">tid</code>にしかなりません。
将来は行ID以外のデータ型が可能になることを期待して、関数APIとすることが選択されました。
    </p><p><code class="function">RefetchForeignRow</code>ポインタが<code class="literal">NULL</code>の場合、行を再フェッチする試みは失敗し、エラーメッセージを発行します。
    </p><p>さらなる情報については<a class="xref" href="fdw-row-locking.html" title="56.5. 外部データラッパでの行ロック">Section 56.5</a>を参照してください。
    </p><pre class="programlisting">bool
RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);</pre><p>
以前に戻されたタプルが、関連するスキャンおよび結合の制約とまだ一致しているか再検査し、更新されたバージョンのタプルを提供する場合もあります。
結合のプッシュダウンを行わない外部データラッパでは、通常は、これを<code class="literal">NULL</code>にセットし、代わりに<code class="structfield">fdw_recheck_quals</code>を適切にセットする方が便利でしょう。
しかし、外部結合をプッシュダウンする場合、すべてのベーステーブルに関する検査を結果のタプルに適用するだけでは、たとえすべての必要な属性がそこにあったとしても十分ではありません。
なぜなら一部の制約が一致しないことで、タプルが戻されない代わりに、一部の属性がNULLになってしまうかもしれないからです。
<code class="literal">RecheckForeignScan</code>制約を再検査し、それが依然として満たされていれば真を、そうでなければ偽を返すことができます。
それだけでなく、置換されたタプルを提供されたスロットに格納することもできます。
    </p><p>結合のプッシュダウンを実装する場合、外部データラッパは通常、再検査のためだけに使用される代替のローカル結合プランを構築します。
これが<code class="literal">ForeignScan</code>の外部サブプランとなります。
再検査が必要な時は、このサブプランを実行して、結果のタプルをスロットに格納することができます。
どのベーステーブルも最大で1行しか返さないので、このプランは効率的である必要はありません。
例えば、すべての結合をネステッドループで実装することもできます。
関数<code class="literal">GetExistingLocalJoinPath</code>は、存在するパスから代替ローカルの結合プランとして使用可能な適当なローカル結合パスを検索するのに使われるかもしれません。
<code class="literal">GetExistingLocalJoinPath</code>は指定された結合リレーションのパスリストのパラメータ化されていないパスを検索します。
（そのようなパスが見つからなかった場合はNULLを返します。この場合、外部データラッパはそれ自身によりローカルパスを構築するかもしれず、あるいは、その結合むけのアクセスパスを作らないことを選択するかもしれません。）
    </p></div><div class="sect2" id="FDW-CALLBACKS-EXPLAIN"><div class="titlepage"><div><div><h3 class="title">56.2.6. <code class="command">EXPLAIN</code>のためのFDWルーチン</h3></div></div></div><pre class="programlisting">void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);</pre><p>

外部テーブルスキャンの追加の<code class="command">EXPLAIN</code>出力を表示します。
<code class="command">EXPLAIN</code>出力にフィールドを追加するために<code class="function">ExplainPropertyText</code>や関連する関数を呼び出すことができます。
<code class="literal">es</code>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<code class="command">EXPLAIN ANALYZE</code>の場合には、実行時統計情報を提供するために<code class="structname">ForeignScanState</code>ノードの状態を調べることができます。
    </p><p>もし<code class="function">ExplainForeignScan</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、<code class="command">EXPLAIN</code>中に追加情報は表示されません。
    </p><pre class="programlisting">void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);</pre><p>

外部テーブル更新の追加の<code class="command">EXPLAIN</code>出力を表示します。
<code class="command">EXPLAIN</code>出力にフィールドを追加するために<code class="function">ExplainPropertyText</code>や関連する関数を呼び出すことができます。
<code class="literal">es</code>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<code class="command">EXPLAIN ANALYZE</code>の場合には、実行時統計情報を提供するために<code class="structname">ForeignScanState</code>ノードの状態を調べることができます。
最初の4つの引数は<code class="function">BeginForeignModify</code>と同じです。
    </p><p>もし<code class="function">ExplainForeignModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、<code class="command">EXPLAIN</code>中に追加情報は表示されません。
    </p><pre class="programlisting">void
ExplainDirectModify (ForeignScanState *node,
                     ExplainState *es);</pre><p>

リモートサーバでの直接変更について追加<code class="command">EXPLAIN</code>出力を表示します。
この関数は<code class="command">EXPLAIN</code>出力にフィールドを加えるために<code class="function">ExplainPropertyText</code>と関連の関数を呼ぶことができます。
<code class="literal">es</code>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<code class="command">EXPLAIN ANALYZE</code>の場合には、実行時統計情報を提供するために<code class="structname">ForeignScanState</code>ノードの状態を調べることができます。
    </p><p><code class="function">ExplainDirectModify</code>ポインタが<code class="literal">NULL</code>に設定されている場合は、<code class="command">EXPLAIN</code>中に追加情報は表示されません。
    </p></div><div class="sect2" id="FDW-CALLBACKS-ANALYZE"><div class="titlepage"><div><div><h3 class="title">56.2.7. <code class="command">ANALYZE</code>のためのFDWルーチン</h3></div></div></div><pre class="programlisting">bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);</pre><p>

この関数は<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>が外部テーブルに対して実行されたときに呼び出されます。
もしFDWがこの外部テーブルの統計情報を収集できる場合は、そのテーブルからサンプル行を集める関数のポインタとページ単位でのテーブルサイズの見積もりをそれぞれ<em class="parameter"><code>func</code></em>と<em class="parameter"><code>totalpages</code></em>に渡し<code class="literal">true</code>を返す必要があります。
そうでない場合は、<code class="literal">false</code>を返します。
    </p><p>もしFDWが統計情報の収集をどのテーブルについてもサポートしない場合は、<code class="function">AnalyzeForeignTable</code>ポインタを<code class="literal">NULL</code>にすることもできます。
    </p><p>もし提供される場合は、サンプル収集関数はこのようなシグネチャを持つ必要があります。
</p><pre class="programlisting">int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);</pre><p>

最大<em class="parameter"><code>targrows</code></em>行のランダムサンプルをテーブルから収集し、呼び出し元が提供する<em class="parameter"><code>rows</code></em>配列に格納する必要があります。
実際に収集された行の数を返す必要があります。
さらに、テーブルに含まれる有効行と不要行の合計数の見積もりを出力パラメータの<em class="parameter"><code>totalrows</code></em>と<em class="parameter"><code>totaldeadrows</code></em>に返す必要があります。(もしFDWが不要行という概念を持たない場合は<em class="parameter"><code>totaldeadrows</code></em>を0に設定してください。)
    </p></div><div class="sect2" id="FDW-CALLBACKS-IMPORT"><div class="titlepage"><div><div><h3 class="title">56.2.8. <code class="command">IMPORT FOREIGN SCHEMA</code>のためのFDWルーチン</h3></div></div></div><pre class="programlisting">List *
ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);</pre><p>

外部テーブル作成コマンドのリストを取得します。
この関数は<a class="xref" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA"><span class="refentrytitle">IMPORT FOREIGN SCHEMA</span></a>を実行する時に呼び出され、その文の解析木と外部サーバが使用するOIDとを渡されます。
C文字列のリストを返し、その各文字列は<a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>コマンドを含んでいる必要があります。
これらの文字列はコアサーバが解析して実行します。
    </p><p><code class="structname">ImportForeignSchemaStmt</code>構造体において、<code class="structfield">remote_schema</code>はリモートスキーマの名前で、そこからテーブルがインポートされます。
<code class="structfield">list_type</code>はテーブル名のフィルタ方法を指定します。
ここで、<code class="literal">FDW_IMPORT_SCHEMA_ALL</code>はリモートスキーマのすべてのテーブルをインポートすること（この場合、<code class="structfield">table_list</code>は空にします）、
<code class="literal">FDW_IMPORT_SCHEMA_LIMIT_TO</code>は<code class="structfield">table_list</code>に列挙されたテーブルだけを含めること、
そして<code class="literal">FDW_IMPORT_SCHEMA_EXCEPT</code>は<code class="structfield">table_list</code>に列挙されたテーブルを除外することを意味します。
<code class="structfield">options</code>はインポートのプロセスで使用されるオプションのリストです。
オプションの意味はFDWに依存します。
例えば、FDWは列の<code class="literal">NOT NULL</code>属性をインポートするかどうかを定めるオプションを使うことができます。
これらのオプションはFDWがデータベースオブジェクトのオプションとしてサポートするものと何ら関係ある必要はありません。
    </p><p>FDWは<code class="structname">ImportForeignSchemaStmt</code>の<code class="structfield">local_schema</code>フィールドを無視しても良いです。
なぜなら、コアサーバは解析された<code class="command">CREATE FOREIGN TABLE</code>コマンドにその名前を自動的に挿入するからです。
    </p><p>FDWは<code class="structfield">list_type</code>および<code class="structfield">table_list</code>で指定されるフィルタの実装にも注意する必要はありません。
なぜなら、コアサーバはそれらのオプションによって除外されるテーブルに対して戻されたコマンドをすべて自動的にスキップするからです。
しかし、除外されるテーブルについてコマンドを作成する作業を回避するのは、そもそも役立つことが多いです。
関数<code class="function">IsImportableForeignTable()</code>は指定の外部テーブル名がフィルタを通るかどうかの検査に役立つかもしれません。
    </p><p>FDWがテーブル定義のインポートをサポートしない場合は、<code class="function">ImportForeignSchema</code>ポインタを<code class="literal">NULL</code>にセットすることができます。
    </p></div><div class="sect2" id="FDW-CALLBACKS-PARALLEL"><div class="titlepage"><div><div><h3 class="title">56.2.9. パラレル実行のためのFDWルーチン</h3></div></div></div><p><code class="structname">ForeignScan</code>ノードは、オプションとして、パラレル実行をサポートします。
並列<code class="structname">ForeignScan</code>は複数プロセスで実行され、全ての協調プロセスにわたって各行が一度だけ返るようにしなければなりません。
これを行うため、プロセスは動的共有メモリの固定サイズチャンクを通して調整をはかることができます。
この共有メモリは全プロセスで同じアドレスに割り当てされることが保証されませんので、ポインタを含まないようにしなければなりません。
以下のコールバックは一般に全て省略可能ですが、パラレル実行をサポートするためには必要です。
    </p><pre class="programlisting">bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);</pre><p>
スキャンがパラレルワーカーで実行できるかテストします。
この関数はプランナが並列プランが可能であろうと考えるときだけ呼ばれます。また、そのスキャンにとってパラレルワーカーで実行するのが安全であるとき真を返すべきです。
リモートデータソースがトランザクションのセマンティクスを持つ場合は、一般にあてはまりません。ただし、ワーカーのデータへの接続を何らかの形でリーダーとして同じトランザクション文脈を共有させることができる場合を除きます。
    </p><p>この関数が定義されていない場合、スキャンはパラレルリーダー内で実行しなければならないと想定されます。
真を返すことは、スキャンがパラレルワーカーで実行可能であるだけで、パラレルに実行可能であることを意味するのでは無いことに注意してください。
そのため、この関数を定義することはパラレル実行がサポートされていないときでも役立つ可能性があります。
    </p><pre class="programlisting">Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);</pre><p>
並列操作に必要とされるであろう動的共有メモリ量を推定します。
これは実際に使われる量よりも大きくてよいですが、小さくてはいけません。
戻り値はバイト単位です。
この関数はオプションであり、必要でない場合は省略することができます。
しかし省略された場合、FDWの使用のために共有メモリが割り当てられないため、次の3つの関数も省略しなければなりません。
    </p><pre class="programlisting">void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);</pre><p>
並列処理で必要とされる動的共有メモリを初期化します。
<code class="literal">coordinate</code>は<code class="function">EstimateDSMForeignScan</code>の戻り値に等しいサイズの共有メモリ領域へのポインタです。
この関数はオプションであり、必要でない場合は省略することができます。
   </p><pre class="programlisting">void
ReInitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                           void *coordinate);</pre><p>
外部スキャンプランノードが再スキャンされようとしているときに、並列操作に必要な動的共有メモリーを再初期化します。
この関数はオプションであり、必要でない場合は省略することができます。
<code class="function">ReScanForeignScan</code>関数はローカル状態のみをリセットし、この関数は共有状態のみをリセットすることをお勧めします。
現在、この関数は<code class="function">ReScanForeignScan</code>より前に呼び出されますが、その順序に依存しないようにする方が良いでしょう。
   </p><pre class="programlisting">void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);</pre><p>
<code class="function">InitializeDSMForeignScan</code>でリーダーがセットアップした共有状態に基づくパラレルワーカーのローカル状態を初期化します。
この関数はオプションであり、必要でない場合は省略することができます。
   </p><pre class="programlisting">void
ShutdownForeignScan(ForeignScanState *node);</pre><p>
ノードが完了するまで実行されないことが予想されるときにリソースを解放します。
これはすべてのケースで呼ばれるわけではありません。
<code class="literal">EndForeignScan</code>は、この関数が最初に呼び出されなくても呼び出されることがあります。
このコールバックが呼び出された直後に、並列クエリで使用されるDSM(動的共有メモリ）セグメントが破棄されるため、DSMセグメントがなくなる前に何らかのアクションを実行する外部データラッパーがこのメソッドを実装する必要があります。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-functions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="fdw-helpers.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">56.1. 外部データラッパ関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 56.3. 外部データラッパヘルパ関数</td></tr></table></div></body></html>