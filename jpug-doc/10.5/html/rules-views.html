<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>40.2. ビューとルールシステム</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="querytree.html" title="40.1. 問い合わせツリーとは" /><link rel="next" href="rules-materializedviews.html" title="40.3. マテリアライズドビュー" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">40.2. ビューとルールシステム</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="querytree.html" title="40.1. 問い合わせツリーとは">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Chapter 40. ルールシステム">Up</a></td><th width="60%" align="center">Chapter 40. ルールシステム</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-materializedviews.html" title="40.3. マテリアライズドビュー">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="RULES-VIEWS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">40.2. ビューとルールシステム</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="rules-views.html#RULES-SELECT">40.2.1. <code class="command">SELECT</code>ルールの動き</a></span></dt><dt><span class="sect2"><a href="rules-views.html#id-1.8.6.7.6">40.2.2. 非<code class="command">SELECT</code>文のビュールール</a></span></dt><dt><span class="sect2"><a href="rules-views.html#id-1.8.6.7.7">40.2.3. <span class="productname">PostgreSQL</span>におけるビューの能力</a></span></dt><dt><span class="sect2"><a href="rules-views.html#RULES-VIEWS-UPDATE">40.2.4. ビューの更新について</a></span></dt></dl></div><a id="id-1.8.6.7.2" class="indexterm"></a><a id="id-1.8.6.7.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>におけるビューはルールシステムを使って実装されています。
実際、

</p><pre class="programlisting">CREATE VIEW myview AS SELECT * FROM mytab;</pre><p>

と

</p><pre class="programlisting">CREATE TABLE myview (<em class="replaceable"><code>same column list as mytab</code></em>);
CREATE RULE "_RETURN" AS ON SELECT TO myview DO INSTEAD
    SELECT * FROM mytab;</pre><p>
の2つのコマンドの間には基本的な違いはありません。

と言うのは、<code class="command">CREATE VIEW</code>コマンドによって内部的にまったく同じコマンドが行われるからです。
これには副作用もあります。
その1つは<span class="productname">PostgreSQL</span>システムカタログのビューについての情報はテーブルの情報とまったく同一であるということです。
そのため、パーサにとってはテーブルとビューの間に違いは一切ありません。
これらは同じもの、つまりリレーションです。</p><div class="sect2" id="RULES-SELECT"><div class="titlepage"><div><div><h3 class="title">40.2.1. <code class="command">SELECT</code>ルールの動き</h3></div></div></div><a id="id-1.8.6.7.5.2" class="indexterm"></a><p>たとえコマンドが<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>などであっても、<code class="literal">ON SELECT</code>ルールは全ての問い合わせに対し最後に適用されます。
そして、このルールは他のコマンド種類のルールと異なるセマンティックを持っていて、問い合わせツリーを新規に生成せずに、そこにあるものを修正します。
したがって<code class="command">SELECT</code>ルールを一番初めに記述します。</p><p>現在のところ、<code class="literal">ON SELECT</code>ルールでは1つのアクションしか許されず、それは<code class="literal">INSTEAD</code>である無条件の<code class="command">SELECT</code>アクションでなければいけません。
この制約は、一般のユーザが何をしても、ルールシステムが堅牢であるために必要であり、<code class="literal">ON SELECT</code>のルールはビュー同様の動作に限定されます。</p><p>本章の例として挙げているのは、ちょっとした演算をする2つの結合のビューと、次にこれらの機能を利用するいくつかのビューです。
初めの2つのビューのうちの1つは、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>操作に対するルールを後で追加することでカスタマイズされ、最終結果は何らかの魔法の機能によりあたかも実テーブルのように振舞うビューになります。
初めて学ぶための例としては決して簡単ではなく先に進むことを躊躇させるかもしれませんが、多くの別々の例を持ち出して頭の混乱を招くよりも、全ての論点をステップごとに追う1つの例を挙げる方が良いでしょう。</p><p>この例では、2つの整数から小さな値を返すちょっとした<code class="literal">min</code>関数を必要とします。
関数の生成は以下のようにします。

</p><pre class="programlisting">CREATE FUNCTION min(integer, integer) RETURNS integer AS $$
    SELECT CASE WHEN $1 &lt; $2 THEN $1 ELSE $2 END
$$ LANGUAGE SQL STRICT;</pre><p>最初の2つのルールシステムの説明で必要とする実テーブルを以下に示します。

</p><pre class="programlisting">CREATE TABLE shoe_data (
    shoename   text,          -- 主キー
    sh_avail   integer,       -- 在庫
    slcolor    text,          -- 望ましい靴紐の色
    slminlen   real,          -- 靴紐の最短サイズ
    slmaxlen   real,          -- 靴紐の最長サイズ
    slunit     text           -- 長さの単位
);

CREATE TABLE shoelace_data (
    sl_name    text,          -- 主キー
    sl_avail   integer,       -- 在庫
    sl_color   text,          -- 靴紐の色
    sl_len     real,          -- 靴紐の長さ
    sl_unit    text           -- 長さの単位
);

CREATE TABLE unit (
    un_name    text,          -- 主キー
    un_fact    real           -- cmに変換するファクタ
);</pre><p>

これでわかるかもしれませんが、これらは靴屋のデータを表しています。</p><p>ビューを以下のように作成します。

</p><pre class="programlisting">CREATE VIEW shoe AS
    SELECT sh.shoename,
           sh.sh_avail,
           sh.slcolor,
           sh.slminlen,
           sh.slminlen * un.un_fact AS slminlen_cm,
           sh.slmaxlen,
           sh.slmaxlen * un.un_fact AS slmaxlen_cm,
           sh.slunit
      FROM shoe_data sh, unit un
     WHERE sh.slunit = un.un_name;

CREATE VIEW shoelace AS
    SELECT s.sl_name,
           s.sl_avail,
           s.sl_color,
           s.sl_len,
           s.sl_unit,
           s.sl_len * u.un_fact AS sl_len_cm
      FROM shoelace_data s, unit u
     WHERE s.sl_unit = u.un_name;

CREATE VIEW shoe_ready AS
    SELECT rsh.shoename,
           rsh.sh_avail,
           rsl.sl_name,
           rsl.sl_avail,
           min(rsh.sh_avail, rsl.sl_avail) AS total_avail
      FROM shoe rsh, shoelace rsl
     WHERE rsl.sl_color = rsh.slcolor
       AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
       AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm;</pre><p>

<code class="literal">shoelace</code>ビュー（今ある一番簡単なビュー）用の<code class="command">CREATE VIEW</code>コマンドは、<code class="literal">shoelace</code>リレーションと、問い合わせ範囲テーブルの中で<code class="literal">shoelace</code>リレーションが参照される時はいつでも、適用されるべき書き換えルールの存在を示す項目を<code class="structname">pg_rewrite</code>に作ります。
ルールはルール条件（<code class="command">SELECT</code>ルールは現在持つことができませんので、非<code class="command">SELECT</code>ルールのところで取り上げます）を持たない<code class="literal">INSTEAD</code>です。
ルール条件は問い合わせ条件とは異なることに注意してください！
ルールアクションは問い合わせ条件を持っています。
このルールアクションは、ビュー作成コマンド内の<code class="command">SELECT</code>のコピーである、1つの問い合わせツリーです。</p><div class="note"><h3 class="title">Note</h3><p><code class="structname">pg_rewrite</code>項目の<code class="literal">NEW</code>と<code class="literal">OLD</code>に対する2つの特別な範囲テーブル項目は<code class="command">SELECT</code>ルールには関係ありません。
    </p></div><p>ではここで<code class="literal">unit</code>、<code class="literal">shoe_data</code>、<code class="literal">shoelace_data</code>にデータを入れ、ビューに簡単な問い合わせを行います。

</p><pre class="programlisting">INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);

INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');

INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');

SELECT * FROM shoelace;

 sl_name   | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
-----------+----------+----------+--------+---------+-----------
 sl1       |        5 | black    |     80 | cm      |        80
 sl2       |        6 | black    |    100 | cm      |       100
 sl7       |        7 | brown    |     60 | cm      |        60
 sl3       |        0 | black    |     35 | inch    |      88.9
 sl4       |        8 | black    |     40 | inch    |     101.6
 sl8       |        1 | brown    |     40 | inch    |     101.6
 sl5       |        4 | brown    |      1 | m       |       100
 sl6       |        0 | brown    |    0.9 | m       |        90
(8 rows)</pre><p>
   </p><p>これは、ビューに対する最も簡単な<code class="command">SELECT</code>ですので、この機会にビュールールの基本を説明します。
<code class="literal">SELECT * FROM shoelace</code>はパーサによって処理され、次の問い合わせツリーが生成されます。

</p><pre class="programlisting">SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM shoelace shoelace;</pre><p>

このツリーがルールシステムに伝えられます。
ルールシステムは範囲テーブルを参照し、何らかのリレーションに対してルールが存在するか調べます。
<code class="literal">shoelace</code>（現時点では唯一のビュー）についての範囲テーブル項目を処理する際、問い合わせツリーで<code class="literal">_RETURN</code>ルールを検出します。

</p><pre class="programlisting">SELECT s.sl_name, s.sl_avail,
       s.sl_color, s.sl_len, s.sl_unit,
       s.sl_len * u.un_fact AS sl_len_cm
  FROM shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_unit = u.un_name;</pre><p>ビューを展開するために、リライタは単純にルールのアクション問い合わせツリーを持つ副問い合わせ範囲テーブルの項目を作り、ビューを参照していた元の範囲テーブルを置き換えます。
書き換えられた結果の問い合わせツリーは、以下のように入力した場合とほぼ同じです。

</p><pre class="programlisting">SELECT shoelace.sl_name, shoelace.sl_avail,
       shoelace.sl_color, shoelace.sl_len,
       shoelace.sl_unit, shoelace.sl_len_cm
  FROM (SELECT s.sl_name,
               s.sl_avail,
               s.sl_color,
               s.sl_len,
               s.sl_unit,
               s.sl_len * u.un_fact AS sl_len_cm
          FROM shoelace_data s, unit u
         WHERE s.sl_unit = u.un_name) shoelace;</pre><p>

しかし1つだけ違いがあります。
副問い合わせの範囲テーブルが2つの余分な項目<code class="literal">shoelace old</code>と<code class="literal">shoelace new</code>を持っていることです。
これらの項目は副問い合わせの結合ツリーや目的リストで参照されませんので、直接問い合わせでは使われません。
リライタはそれらを使用して、ビューを参照した範囲テーブルの項目に元々存在したアクセス権限確認情報を格納します。
この方法で、書き換えられた問い合わせで直接ビューを使用していなくても、エクゼキュータはユーザがそのビューにアクセスするための正しい権限を持っているか確認します。</p><p>これが最初に適用されるルールです。
ルールシステムは最上位の問い合わせの残り（この例ではこれ以上ありません）の範囲テーブルの項目をチェックし続けます。
そしてルールシステムは、追加された副問い合わせの範囲テーブルの項目がビューを参照するかを再帰的に確認します
（しかし<code class="literal">old</code>や<code class="literal">new</code>は展開しません。
そうでなければ無限再帰になってしまいます！）。
この例では<code class="literal">shoelace_data</code>や<code class="literal">unit</code>用の書き換えルールはありません。
ですから書き換えは完結し、上記がプランナに渡される最終的な結果となります。</p><p>さて、店に置いてある靴紐（の色とサイズ）に一致する靴が店にあるか、完全に一致する靴紐の在庫数が2以上あるかどうかを把握する問い合わせを書いてみましょう。

</p><pre class="programlisting">SELECT * FROM shoe_ready WHERE total_avail &gt;= 2;

 shoename | sh_avail | sl_name | sl_avail | total_avail
----------+----------+---------+----------+-------------
 sh1      |        2 | sl1     |        5 |           2
 sh3      |        4 | sl7     |        7 |           4
(2 rows)</pre><p>今回のパーサの出力は以下の問い合わせツリーです。

</p><pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM shoe_ready shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;</pre><p>

最初に適用されるルールは<code class="literal">shoe_ready</code>ビュー用のもので、問い合わせツリーにおける結果は以下のようになります。

</p><pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM shoe rsh, shoelace rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt;= 2;</pre><p>

同じように、<code class="literal">shoe</code>と<code class="literal">shoelace</code>用のルールは副問い合わせの範囲テーブルとして代用され、3レベルの最終問い合わせツリーへと導きます。

</p><pre class="programlisting">SELECT shoe_ready.shoename, shoe_ready.sh_avail,
       shoe_ready.sl_name, shoe_ready.sl_avail,
       shoe_ready.total_avail
  FROM (SELECT rsh.shoename,
               rsh.sh_avail,
               rsl.sl_name,
               rsl.sl_avail,
               min(rsh.sh_avail, rsl.sl_avail) AS total_avail
          FROM (SELECT sh.shoename,
                       sh.sh_avail,
                       sh.slcolor,
                       sh.slminlen,
                       sh.slminlen * un.un_fact AS slminlen_cm,
                       sh.slmaxlen,
                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,
                       sh.slunit
                  FROM shoe_data sh, unit un
                 WHERE sh.slunit = un.un_name) rsh,
               (SELECT s.sl_name,
                       s.sl_avail,
                       s.sl_color,
                       s.sl_len,
                       s.sl_unit,
                       s.sl_len * u.un_fact AS sl_len_cm
                  FROM shoelace_data s, unit u
                 WHERE s.sl_unit = u.un_name) rsl
         WHERE rsl.sl_color = rsh.slcolor
           AND rsl.sl_len_cm &gt;= rsh.slminlen_cm
           AND rsl.sl_len_cm &lt;= rsh.slmaxlen_cm) shoe_ready
 WHERE shoe_ready.total_avail &gt; 2;</pre><p>
   </p><p>次にプランナはこのツリーを2レベルの問い合わせツリーに縮めます。
一番下の<code class="command">SELECT</code>コマンドは別々に処理する必要がありませんので2つ目の<code class="command">SELECT</code>に<span class="quote">“<span class="quote">引っ張り上げ</span>”</span>られます。
しかし2つ目の<code class="command">SELECT</code>は集約関数を持つため、頂点からは区別されます。
もしそれらを引っ張り上げてしまうと一番上の<code class="command">SELECT</code>の動作を変えてしまうことになり、それはしたくありません。
しかし、問い合わせツリーを縮めるという最適化を、書き換えシステム自身で意識する必要はありません。
   </p></div><div class="sect2" id="id-1.8.6.7.6"><div class="titlepage"><div><div><h3 class="title">40.2.2. 非<code class="command">SELECT</code>文のビュールール</h3></div></div></div><p>これまでのビュールールの説明では問い合わせツリーの2つの詳細について触れませんでした。
それらは、コマンドタイプと結果リレーションです。
実際、コマンドタイプはビュールールでは必要とされませんが、結果リレーションがビューの場合には特別な考慮が必要ですので、結果リレーションは問い合わせリライタの動作に影響するかもしれません。</p><p><code class="command">SELECT</code>と他のコマンドに対する問い合わせツリーの間には大きな違いはありません。
明らかに、それらは違うコマンドタイプを持っていて、<code class="command">SELECT</code>以外のコマンドでは、結果リレーションは結果の格納先となる範囲テーブルの項目を指し示します。
それ以外ではまったく同じです。
ですから、<code class="literal">a</code>と<code class="literal">b</code>の列を持つテーブル<code class="literal">t1</code>、<code class="literal">t2</code>に対する以下の2つの文の問い合わせツリーは、ほとんど同じです。

</p><pre class="programlisting">SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;

UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;</pre><p>

以下に、具体的に示します。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>範囲テーブルには、テーブル<code class="literal">t1</code>と<code class="literal">t2</code>に対する項目があります。
        </p></li><li class="listitem"><p>目的リストにはテーブル<code class="literal">t2</code>に対する範囲テーブル項目の<code class="literal">b</code>列を指し示す1つの変数があります。
        </p></li><li class="listitem"><p>条件式は、範囲テーブルの両項目の<code class="literal">a</code>列の等価性を比較します。
        </p></li><li class="listitem"><p>結合ツリーは<code class="literal">t1</code>と<code class="literal">t2</code>の単純な結合を表しています。
        </p></li></ul></div><p>
   </p><p>結果として、両方の問い合わせツリーは似たような実行計画になります。
それらはともに2つのテーブルの結合です。
<code class="command">UPDATE</code>では<code class="literal">t1</code>から抜けている列はプランナによって目的リストに追加され、最終の問い合わせツリーは、以下のようになります。

</p><pre class="programlisting">UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;</pre><p>

そして、結合を実行したエクゼキュータは、

</p><pre class="programlisting">SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;</pre><p>

の結果集合とまったく同じ結果集合を作成します。
とは言っても<code class="command">UPDATE</code>にはちょっとした問題があります。
結合を行うエクゼキュータの計画の部分は、結合の結果が何に向けられているかに関与しません。
エクゼキュータは単に結果となる行の集合を作成するだけです。
1つは<code class="command">SELECT</code>コマンドでもう1つは<code class="command">UPDATE</code>コマンドであるという事実は、エクゼキュータの中のより上位で扱われます。
そこでは、これが<code class="command">UPDATE</code>であるとわかっていて、この結果がテーブル<code class="literal">t1</code>に入らなければいけないことを知っています。
しかし、そこにあるどの行が新しい行によって置換されなければならないのでしょうか。</p><p>この問題を解決するため、<code class="command">UPDATE</code>文（<code class="command">DELETE</code>文の場合も同様）の目的リストに別の項目が付け加えられます。
それは、現在のタプルID（<acronym class="acronym">CTID</acronym>）です。
<a id="id-1.8.6.7.6.5.4" class="indexterm"></a>
これはその行のファイルブロック番号とブロック中の位置を持つシステム列です。
テーブルがわかっている場合、<acronym class="acronym">CTID</acronym>を使用して、元の<code class="literal">t1</code>行を抽出して更新することができます。
<acronym class="acronym">CTID</acronym>を目的リストに追加すると、問い合わせは以下のようになります。

</p><pre class="programlisting">SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;</pre><p>

では、<span class="productname">PostgreSQL</span>の別の詳細説明に入りましょう。
テーブルの行は上書きされませんので、<code class="command">ROLLBACK</code>処理は速いのです。
<code class="command">UPDATE</code>では、（<acronym class="acronym">CTID</acronym>を取り除いた後）テーブルに新しい結果行が挿入され、<acronym class="acronym">CTID</acronym>が指し示す古い行の行ヘッダ内の<code class="literal">cmax</code>と<code class="literal">xmax</code>項目は現在のコマンドカウンタと現在のトランザクションIDに設定されます。
このようにして、古い行は隠され、トランザクションがコミットされた後、vacuum掃除機が不必要になった行をそのうちに削除できます。</p><p>これらの詳細が全部理解できれば、どんなコマンドに対してもまったく同じようにしてビューのルールを簡単に適用することができます。
そこには差異がありません。</p></div><div class="sect2" id="id-1.8.6.7.7"><div class="titlepage"><div><div><h3 class="title">40.2.3. <span class="productname">PostgreSQL</span>におけるビューの能力</h3></div></div></div><p>ここまでで、ルールシステムがどのようにビューの諸定義を元の問い合わせツリーに組み入れるかを解説しました。
第2の例では、1つのビューからの単純な<code class="command">SELECT</code>によって、最終的に4つのテーブルを結合する問い合わせツリーが生成されました（<code class="literal">unit</code>は違った名前で2回使われました）。</p><p>ビューをルールシステムで実装する利点は、どのテーブルをスキャンすべきか、それらのテーブル間の関連性、ビューからの制約条件、元の問い合わせ条件に関する情報を全て、プランナが1つの問い合わせツリーの中に持っていることです。
元の問い合わせが既にビューに対する結合である時も同様です。
プランナはここでどれが問い合わせ処理の最適経路かを決定しなければなりません。
プランナは保持する情報が多ければ多いほど、より良い決定を下すことができます。
そして<span class="productname">PostgreSQL</span>に実装されているルールシステムはこれが現時点で、提供されている全ての情報であることを保証します。</p></div><div class="sect2" id="RULES-VIEWS-UPDATE"><div class="titlepage"><div><div><h3 class="title">40.2.4. ビューの更新について</h3></div></div></div><p>ビューが<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>などの目的リレーションとして名付けられた場合はどうなるのでしょうか？
上で説明したような置換をすると、結果リレーションが副問い合わせの範囲テーブル項目を指す問い合わせツリーができてしまい、それは上手く機能しません。しかし、いくつかのケースでは<span class="productname">PostgreSQL</span>はビューの更新をサポートする事ができます。</p><p>副問い合わせが単一のテーブルを参照しかつ十分に単純である時、リライタは副問い合わせを被参照テーブルに自動的に置き換え、したがって、<code class="command">INSERT</code>、<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>を適切な方法で被参照テーブルに適用する事ができます。
この場合の<span class="quote">“<span class="quote">十分に単純</span>”</span>であるとは<em class="firstterm">自動的に更新可能</em>ある事です。より詳細な自動的に更新可能なビューの情報については、<a class="xref" href="sql-createview.html" title="CREATE VIEW"><span class="refentrytitle">CREATE VIEW</span></a>を参照してください。</p><p>もう一つの方法として、ビューに対するユーザ定義の<code class="literal">INSTEAD OF</code>トリガによってこれらのコマンドを処理する事ができます。この場合、書き換えは少々違う形で行われます。
<code class="command">INSERT</code>に対しては、リライタはビューに全く何もせず、問い合わせの結果リレーションをそのままにします。
<code class="command">UPDATE</code>と<code class="command">DELETE</code>に対しては、コマンドが更新もしくは削除しようとする<span class="quote">“<span class="quote">古い</span>”</span>行を生成するためにビュー問い合わせを展開する必要がまだあります。
そのため、ビューは通常通り展開されますが、もう一つの展開されない範囲テーブル項目が結果リレーションとしてビューを表す問い合わせに追加されます。</p><p>ここで起こる問題はビューで更新される行をどのように特定するかということです。
結果リレーションがテーブルの場合、更新する行の物理的な位置を特定するために特別な<acronym class="acronym">CTID</acronym>項目が目的リストに追加されることを思い出して下さい。
ビューの行には実際の物理的な位置がないため、ビューには<acronym class="acronym">CTID</acronym>がありませんので、これは結果リレーションがビューの場合には上手くいきません。
その代わり、<code class="command">UPDATE</code>や<code class="command">DELETE</code>操作では、特別な<code class="literal">行全体</code>の項目が目的リストに追加されていて、それはビューからすべての列を含むように展開されています。
エクゼキュータはこの値を使って<span class="quote">“<span class="quote">古い</span>”</span>行を<code class="literal">INSTEAD OF</code>トリガに提供します。
新旧の行の値に基づいて更新するものを計算するのはトリガの責任です。</p><p>別の方法としては、ビューに対する<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>コマンドに代替の動作を指定する<code class="literal">INSTEAD</code>ルールを定義する事です。
これらのルールは、ビューではなくコマンドを、通常は1つもしくは複数のテーブルを更新するコマンドに書き換えます。
それが<a class="xref" href="rules-update.html" title="40.4. INSERT、UPDATE、DELETEについてのルール">Section 40.4</a>の論題になります。</p><p>ルールが最初に評価され、元の問い合わせが計画され実行される前にそれを書き換えることに注意して下さい。
そのためビューに<code class="literal">INSTEAD OF</code>トリガと<code class="command">INSERT</code>や<code class="command">UPDATE</code>や<code class="command">DELETE</code>に関するルールがあった場合、ルールが最初に評価され、その結果よってはトリガが全く使われないかもしれません。</p><p>単純なビューに対する<code class="command">INSERT</code>、<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>コマンドの自動書き換えは常に最後に試みられます。したがって、ビューがルールもしくはトリガを持っていた場合、これらは更新可能ビューのデフォルト動作を上書きします。</p><p>ビューに<code class="literal">INSTEAD</code>ルールも<code class="literal">INSTEAD OF</code>トリガも定義されておらず、かつ、リライタが問い合わせを自動的に被参照テーブルへの更新に書き換える事ができなかった場合、エグゼキュータはビューを更新できませんのでエラーが発生します。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="querytree.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-materializedviews.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">40.1. 問い合わせツリーとは </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 40.3. マテリアライズドビュー</td></tr></table></div></body></html>