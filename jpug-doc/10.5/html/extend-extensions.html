<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.15. 関連するオブジェクトを拡張としてパッケージ化</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xindex.html" title="37.14. インデックス拡張機能へのインタフェース" /><link rel="next" href="extend-pgxs.html" title="37.16. 拡張構築基盤" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.15. 関連するオブジェクトを拡張としてパッケージ化</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xindex.html" title="37.14. インデックス拡張機能へのインタフェース">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="extend-pgxs.html" title="37.16. 拡張構築基盤">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="EXTEND-EXTENSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.15. 関連するオブジェクトを拡張としてパッケージ化</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-STYLE">37.15.1. 拡張オブジェクトの定義</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#id-1.8.3.18.12">37.15.2. 拡張のファイル</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION">37.15.3. 拡張の再配置性</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES">37.15.4. 拡張設定テーブル</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#id-1.8.3.18.15">37.15.5. 拡張の更新</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#id-1.8.3.18.16">37.15.6. 更新スクリプトを利用した拡張のインストール</a></span></dt><dt><span class="sect2"><a href="extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE">37.15.7. 拡張の例</a></span></dt></dl></div><a id="id-1.8.3.18.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>への有用な拡張は通常、複数のSQLオブジェクトを含んでいます。
例えば、新しいデータ型は新しい関数、新しい演算子、おそらく新しいインデックス演算子クラスを必要とします。
これらのオブジェクトをすべて単一のパッケージとしてまとめることは、データベース管理を単純化するために役に立ちます。
<span class="productname">PostgreSQL</span>ではこうしたパッケージを<em class="firstterm">拡張</em>とよびます。
拡張を定義するためには、少なくとも、拡張のオブジェクトを作成するための<acronym class="acronym">SQL</acronym>コマンドを含む<em class="firstterm">スクリプトファイル</em>、拡張自身の数個の基本属性を指定する<em class="firstterm">制御ファイル</em>が必要です。
また拡張がCコードを含む場合、通常Cコードで構築された共有ライブラリが存在します。
これらのファイルがあれば、単純な<a class="xref" href="sql-createextension.html" title="CREATE EXTENSION"><span class="refentrytitle">CREATE EXTENSION</span></a>コマンドがそのオブジェクトをデータベース内に読み込みます。
   </p><p>拡張を使用する主な利点は、<acronym class="acronym">SQL</acronym>スクリプトを実行するだけでデータベースに<span class="quote">“<span class="quote">粗な</span>”</span>なオブジェクトの群をロードできることではなく、<span class="productname">PostgreSQL</span>が拡張のオブジェクトをまとまったものと理解できることです。
単一の<a class="xref" href="sql-dropextension.html" title="DROP EXTENSION"><span class="refentrytitle">DROP EXTENSION</span></a>コマンドでオブジェクトすべてを削除することができます（個々の<span class="quote">“<span class="quote">アンインストール</span>”</span>スクリプトを保守する必要はありません）。
もっと有用なことは、<span class="application">pg_dump</span>が拡張の個々のメンバオブジェクトを削除してはならないことを把握していることです。
代わりにダンプ内には<code class="command">CREATE EXTENSION</code>コマンドだけが含まれます。
これは、古いバージョンよりも多くのまたは異なるオブジェクトを含む可能性がある、拡張の新しいバージョンへの移行を大きく単純化します。
しかし、こうしたダンプを新しいデータベースにロードする際には、拡張の制御ファイル、スクリプトファイル、その他のファイルが利用できるようにしておく必要があります。
   </p><p><span class="productname">PostgreSQL</span>はユーザに、拡張全体を削除させる以外に、拡張内に含まれる個々のオブジェクトを削除させません。
また、拡張のメンバオブジェクトの定義を変更する（例えば関数では<code class="command">CREATE OR REPLACE FUNCTION</code>を介して変更する）ことはできますが、変更した定義は<span class="application">pg_dump</span>によりダンプされないことに留意してください。
こうした変更は通常、同時に拡張のスクリプトファイルにも同じ変更を行った場合のみ認識することができます。
（しかし設定データを持つテーブルに対しては特殊な準備があります。<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-CONFIG-TABLES" title="37.15.4. 拡張設定テーブル">Section 37.15.4</a>を参照してください。）
本番環境では、拡張メンバオブジェクトへの変更を処理するために拡張更新スクリプトを作成するのが一般により良い方法です。
   </p><p>拡張スクリプトは、<code class="command">GRANT</code>文と<code class="command">REVOKE</code>文を使って拡張の一部のオブジェクトに権限を設定するかもしれません。
それぞれのオブジェクト（どれかが設定される場合）の最終的な権限のセットは、<a class="link" href="catalog-pg-init-privs.html" title="51.28. pg_init_privs"><code class="structname">pg_init_privs</code></a>システムカタログに格納されます。
<span class="application">pg_dump</span>が使用されると、<code class="command">CREATE EXTENSION</code>コマンドがダンプ内に含まれ、オブジェクトの権限をダンプが取られた時点のものに設定するために必要となる<code class="command">GRANT</code>文と<code class="command">REVOKE</code>文が後に続きます。
   </p><p><span class="productname">PostgreSQL</span>は、現在拡張スクリプトにて<code class="command">CREATE POLICY</code>文や<code class="command">SECURITY LABEL</code>文の発行をサポートしていません。
これらは拡張が作成された後に設定されるべきです。
拡張オブジェクトのすべての行セキュリティポリシーとセキュリティラベルは<span class="application">pg_dump</span>によって作成されたダンプに含まれます。
   </p><p>また拡張機構は、拡張に含まれるSQLオブジェクトの定義を調整するパッケージ調整スクリプトを準備しています。
例えば、拡張のバージョン1.1でバージョン1.0と比べて１つの関数を追加し、他の関数本体を変更する場合、拡張の作成者はこれらの２つの変更のみを行う<em class="firstterm">更新スクリプト</em>を提供することができます。
そして<code class="command">ALTER EXTENSION UPDATE</code>コマンドを使用して、これらの変更を適用し、指定されたデータベース内に実際にインストールされた拡張のバージョンが何かを記録します。
   </p><p>拡張のメンバとなり得るSQLオブジェクトの種類を<a class="xref" href="sql-alterextension.html" title="ALTER EXTENSION"><span class="refentrytitle">ALTER EXTENSION</span></a>で説明します。
拡張は１つのデータベースの中でのみ認識されますので、データベース、ロール、テーブル空間などデータベースクラスタ全体のオブジェクトは拡張のメンバにすることができないことに注意してください。
（拡張のスクリプトでこうしたオブジェクトを生成することは禁止されていませんが、作成したとしても、拡張の一部として記録されません。）
また、テーブルは拡張のメンバになることができますが、インデックスなどそれに付随するオブジェクトは拡張の直接的なメンバとはみなされません。
もう一つの重要な点は、スキーマは拡張に属すことがありますがその逆はないということです。
拡張は非修飾名でいかなるスキーマ<span class="quote">“<span class="quote">の中に</span>”</span>も存在しません。
しかし、拡張のメンバオブジェクトはオブジェクトの型が適切であればスキーマに属します。
拡張が自身のメンバオブジェクトが属するスキーマを所有することは適切かも知れませんし、そうでないかも知れません。
   </p><p>ある拡張のスクリプトが（一時テーブルのような）一時オブジェクトを作成する場合、現在のセッションで、以降そのオブジェクトは拡張のメンバーとして扱われます。
しかしすべての一時オブジェクト同様、セッションの終わりに削除されます。
これは、拡張全体を削除することなしに、拡張のメンバーオブジェクトは削除できない、という規則の例外です。
   </p><div class="sect2" id="EXTEND-EXTENSIONS-STYLE"><div class="titlepage"><div><div><h3 class="title">37.15.1. 拡張オブジェクトの定義</h3></div></div></div><p>広く配布される拡張では、インストールされるデータベースについて前提とすることは最小限にすべきです。
とりわけ、<code class="literal">SET search_path = pg_temp</code>を実行しない限り、修飾されない名前は、悪意のあるユーザが定義したオブジェクトになる可能性があることを前提としてください。
暗黙的に<code class="varname">search_path</code>に依存するような構文要素に注意してください。
<code class="token">IN</code>と<code class="literal">CASE <em class="replaceable"><code>式</code></em> WHEN</code>は、サーチパスを使って演算子を選択します。
代わりに、<code class="literal">OPERATOR(<em class="replaceable"><code>schema</code></em>.=) ANY</code>と<code class="literal">CASE WHEN <em class="replaceable"><code>式</code></em></code>を使ってください。
    </p></div><div class="sect2" id="id-1.8.3.18.12"><div class="titlepage"><div><div><h3 class="title">37.15.2. 拡張のファイル</h3></div></div></div><a id="id-1.8.3.18.12.2" class="indexterm"></a><p><a class="xref" href="sql-createextension.html" title="CREATE EXTENSION"><span class="refentrytitle">CREATE EXTENSION</span></a>コマンドは各拡張に関して、拡張と同じ名前に<code class="literal">.control</code>という拡張子を持つファイル名である必要がある、制御ファイルに依存します。
また、このファイルはインストレーションの<code class="literal">SHAREDIR/extension</code>ディレクトリ内に存在しなければなりません。
また少なくとも１つの、<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>version</code></em>.sql</code>という命名規約（例えば<code class="literal">foo</code>拡張のバージョン<code class="literal">1.0</code>では<code class="literal">foo--1.0.sql</code>）に従った<acronym class="acronym">SQL</acronym>スクリプトファイルが存在しなければなりません。
デフォルトでは、このスクリプトファイルも<code class="literal">SHAREDIR/extension</code>ディレクトリに格納されますが、制御ファイルでスクリプトファイルを別のディレクトリに指定することができます。
    </p><p>拡張の制御ファイルのファイル書式は<code class="filename">postgresql.conf</code>ファイルと同じです。
すなわち、<em class="replaceable"><code>parameter_name</code></em> <code class="literal">=</code> <em class="replaceable"><code>value</code></em>という代入を１行当たり１つ記述します。
空行および<code class="literal">#</code>から始まるコメントが許されます。
単一の単語または数字ではない値にはすべて引用符で確実にくくってください。
    </p><p>制御ファイルは以下のパラメータを設定することができます。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">directory</code> (<code class="type">string</code>)</span></dt><dd><p>拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルを含むディレクトリです。
絶対パスで指定されていない限り、この名前はインストレーションの<code class="literal">SHAREDIR</code>ディレクトリからの相対パスになります。
デフォルトの動作は<code class="literal">directory = 'extension'</code>と指定した場合と同じです。
       </p></dd><dt><span class="term"><code class="varname">default_version</code> (<code class="type">string</code>)</span></dt><dd><p>拡張のデフォルトのバージョン（<code class="command">CREATE EXTENSION</code>でバージョン指定がない場合にインストールされるバージョン）です。
これは省略することができますが、その場合<code class="literal">VERSION</code>オプションがない<code class="command">CREATE EXTENSION</code>は失敗します。
ですので通常省略しようとは思わないでしょう。
       </p></dd><dt><span class="term"><code class="varname">comment</code> (<code class="type">string</code>)</span></dt><dd><p>拡張に関するコメント（任意の文字列）です。
最初に拡張が作成されるときにコメントは適用されますが、拡張が更新される間はされません（ユーザが追加したコメントを上書いてしまうため）。
この他の方法として、スクリプトファイル内で<a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a>コマンドを使用してコメントを設定することができます。
       </p></dd><dt><span class="term"><code class="varname">encoding</code> (<code class="type">string</code>)</span></dt><dd><p>スクリプトファイルで使用される文字セット符号化方式です。
スクリプトファイルに何らかの非ASCII文字が含まれる場合に指定しなければなりません。
指定がなければ、ファイルはデータベース符号化方式であると仮定されます。
       </p></dd><dt><span class="term"><code class="varname">module_pathname</code> (<code class="type">string</code>)</span></dt><dd><p>このパラメータの値でスクリプトファイル内の<code class="literal">MODULE_PATHNAME</code>の出現箇所が置換されます。
設定されていない場合は置換は行われません。
通常これは、スクリプトファイル内で共有ライブラリの名前を直接書き込む必要がなくなるように<code class="literal">$libdir/<em class="replaceable"><code>shared_library_name</code></em></code>に設定され、C言語関数では<code class="command">CREATE FUNCTION</code>コマンド中で<code class="literal">MODULE_PATHNAME</code>を使用します。
       </p></dd><dt><span class="term"><code class="varname">requires</code> (<code class="type">string</code>)</span></dt><dd><p>拡張が依存する拡張の名前のリストです。
例えば<code class="literal">requires = 'foo, bar'</code>です。
対象の拡張がインストールできるようになる前に、これらの拡張がインストールされていなければなりません。
       </p></dd><dt><span class="term"><code class="varname">superuser</code> (<code class="type">boolean</code>)</span></dt><dd><p>このパラメータが<code class="literal">true</code>（デフォルト）の場合、スーパーユーザのみが拡張を作成または新しいバージョンに更新することができます。
<code class="literal">false</code>に設定されている場合は、インストレーション内でコマンドを実行するまたはスクリプトを更新するために必要な権限のみが必要とされます。
       </p></dd><dt><span class="term"><code class="varname">relocatable</code> (<code class="type">boolean</code>)</span></dt><dd><p>拡張を最初に作成した後に拡張により含まれるオブジェクトを別のスキーマに移動することができる場合、拡張は<em class="firstterm">再配置可能</em>です。
デフォルトは<code class="literal">false</code>、つまり、拡張は再配置可能ではありません。
詳しくは<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="37.15.3. 拡張の再配置性">Section 37.15.3</a>を参照してください。
       </p></dd><dt><span class="term"><code class="varname">schema</code> (<code class="type">string</code>)</span></dt><dd><p>このパラメータは再配置可能ではない拡張に対してのみ設定することができます。
拡張が指名したスキーマのみにロードされ、他にはロードされないことを強制します。
<code class="varname">schema</code>パラメータは、拡張を最初に作成するときにのみ参照され、拡張が更新される間はされません。
詳しくは<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-RELOCATION" title="37.15.3. 拡張の再配置性">Section 37.15.3</a>を参照してください。
       </p></dd></dl></div><p>主制御ファイル<code class="literal"><em class="replaceable"><code>extension</code></em>.control</code>に加え、拡張は<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>version</code></em>.control</code>という形の名前の副制御ファイルを持つことができます。
これらを提供する場合は、スクリプトファイルディレクトリに格納しなければなりません。
副制御ファイルは主制御ファイルと同じ書式に従います。
拡張の対応するバージョンをインストールまたは更新する時、副制御ファイル内で設定されるパラメータはいずれも、主制御ファイルを上書きします。
しかし<code class="varname">directory</code>および<code class="varname">default_version</code>パラメータは副制御ファイルで設定することはできません。
    </p><p>拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルにはトランザクション制御コマンド（<code class="command">BEGIN</code>、<code class="command">COMMIT</code>など）およびトランザクションブロックの内側で実行することができないコマンド（<code class="command">VACUUM</code>など）を除く任意のSQLコマンドを含めることができます。
スクリプトファイルが暗黙的にトランザクションブロック内で実行されるためです。
    </p><p>拡張の<acronym class="acronym">SQL</acronym>スクリプトファイルには、<code class="literal">\echo</code>から始まる行を含めることができます。
この行は拡張の機構では無視されます（コメントとして扱われます）。
これは、このスクリプトが<code class="command">CREATE EXTENSION</code>（<a class="xref" href="extend-extensions.html#EXTEND-EXTENSIONS-EXAMPLE" title="37.15.7. 拡張の例">Section 37.15.7</a>のスクリプト例を参照）ではなく<span class="application">psql</span>に渡された場合にエラーを発生するために一般的に使用するために用意されたものです。
これがないと、ユーザは間違って拡張としてではなく、<span class="quote">“<span class="quote">まとまっていない</span>”</span>オブジェクトとして拡張の内容をロードしてしまい、復旧が多少困難な状態になる可能性があります。
    </p><p>スクリプトファイルは指定した符号化方式で認められる任意の文字を含めることができますが、<span class="productname">PostgreSQL</span>が制御ファイルの符号化方式が何かを把握する方法がありませんので、制御ファイルにはASCII文字のみを含めなければなりません。
実際には、拡張のコメントに非ASCII文字を含めたい場合にのみ、これが問題になります。
このような場合には、制御ファイルの<code class="varname">comment</code>を使用せず、代わりにコメントを設定するためにスクリプトファイル内で<code class="command">COMMENT ON EXTENSION</code>を使用することを勧めます。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-RELOCATION"><div class="titlepage"><div><div><h3 class="title">37.15.3. 拡張の再配置性</h3></div></div></div><p>ユーザは拡張に含まれるオブジェクトを拡張の作成者が考えていたスキーマとは別のスキーマにロードしたいとよく考えます。
再配置性に関して３つのレベルがサポートされます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>完全な再配置可能な拡張は、いつでも、データベースにロードされた後であっても、他のスキーマに移動させることができます。
これは、自動的にすべてのメンバオブジェクトを新しいスキーマに名前を変更する、<code class="command">ALTER EXTENSION SET SCHEMA</code>を用いて行います。
通常これは、拡張がオブジェクトが含まれるスキーマが何かに関して内部的な仮定を持たない場合のみ可能です。
また、拡張のオブジェクト（手続き言語など何らかのスキーマに属さないオブジェクトは無視して）はすべて最初に１つのスキーマ内に存在しなければなりません。
制御ファイル内で<code class="literal">relocatable = true</code>と設定することで、完全な再配置可能と印付けます。
      </p></li><li class="listitem"><p>拡張はインストール処理の間再配置可能ですが、その後再配置することはできません。
通常これは、拡張のスクリプトファイルが、SQL関数用の<code class="literal">search_path</code>属性の設定など、対象のスキーマを明示的に参照する必要がある場合です。
こうした拡張では、制御ファイルで<code class="literal">relocatable = false</code>と設定し、スクリプトファイル内で対象のスキーマを参照するために<code class="literal">@extschema@</code>を設定してください。
この文字列の出現箇所はすべて、スクリプトが実行される前に、実際の対象のスキーマ名に置換されます。
ユーザは<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>オプションを使用して対象のスキーマを設定することができます。
      </p></li><li class="listitem"><p>拡張が再配置をまったくサポートしない場合、制御ファイルで<code class="literal">relocatable = false</code>を設定し、かつ、<code class="literal">schema</code>を意図している対象スキーマの名前に設定してください。
これは、制御ファイル内で指定されたスキーマと同じ名前が指定されていない限り、<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>オプションの指定を阻止します。
この選択は通常、拡張が<code class="literal">@extschema@</code>を使用して置き換えることができないスキーマ名について内部的な仮定を持つ場合に必要です。
<code class="literal">@extschema@</code>置換機構はこの場合でも使用することができますが、スキーマ名が制御ファイルによって決定されますので、用途は限定されます。
      </p></li></ul></div><p>すべての場合において、スクリプトファイルは対象のスキーマを指し示すようにあらかじめ設定した<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>を用いて実行されます。
つまり<code class="command">CREATE EXTENSION</code>は以下と同じことを行います。
</p><pre class="programlisting">SET LOCAL search_path TO @extschema@;</pre><p>
これによりスクリプトファイルで作成されるオブジェクトを対象のスキーマ内に格納することができます。
スクリプトファイルは要望に応じて<code class="varname">search_path</code>を変更することができますが、一般的には望まれません。
<code class="command">CREATE EXTENSION</code>の実行後、<code class="varname">search_path</code>は以前の設定に戻されます。
    </p><p>対象のスキーマは制御ファイル内の<code class="varname">schema</code>パラメータがあればこのパラメータにより決定されます。
このパラメータがなければ、<code class="command">CREATE EXTENSION</code>の<code class="literal">SCHEMA</code>があればこの値で決まり、これ以外の場合は現在のデフォルトのオブジェクト生成用スキーマ（呼び出し元の<code class="varname">search_path</code>の最初のもの）になります。
制御ファイルの<code class="varname">schema</code>パラメータが使用される時、対象のスキーマが存在しない場合は作成されますが、これ以外の２つの場合ではすでに存在しなければなりません。
    </p><p>何らかの事前に必要な拡張が制御ファイル内の<code class="varname">requires</code>に列挙されていた場合、それらの対象スキーマが<code class="varname">search_path</code>の初期設定に追加されます。
これにより新しい拡張のスクリプトファイルからそれらのオブジェクトが可視になります。
    </p><p>再配置不可能な拡張は複数スキーマにまたがるオブジェクトを含めることができますが、通常、外部使用を意図したオブジェクトはすべて単一スキーマに格納することが望まれます。
この単一スキーマが拡張の対象のスキーマとみなされます。
こうした調整は依存する拡張を作成する間、デフォルトの<code class="varname">search_path</code>設定を都合に合わせて扱います。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-CONFIG-TABLES"><div class="titlepage"><div><div><h3 class="title">37.15.4. 拡張設定テーブル</h3></div></div></div><p>一部の拡張は、拡張をインストールした後でユーザにより追加または変更される可能性があるデータを持つ設定テーブルを含みます。
通常、テーブルが拡張の一部である場合、テーブル定義もその内容も<span class="application">pg_dump</span>によりダンプされません。
しかしこの振舞いは設定テーブルの場合望まれません。
ユーザによってなされたデータ変更はダンプ内に含まれなければなりません。
さもないとダンプしリストアした後で拡張の動作が変わってしまいます。
    </p><a id="id-1.8.3.18.14.3" class="indexterm"></a><p>この問題を解消するために、拡張のスクリプトファイルでは設定リレーションとして作成されるテーブル、またはシーケンスに印を付け、<span class="application">pg_dump</span>にテーブルの、またはシーケンスの内容をダンプに含める（定義は含まれません）ようにさせることができます。
このためには、以下の例のようにテーブル、またはシーケンスを作成した後に<code class="function">pg_extension_config_dump(regclass, text)</code>関数を呼び出してください。
</p><pre class="programlisting">CREATE TABLE my_config (key text, value text);
CREATE SEQUENCE my_config_seq;

SELECT pg_catalog.pg_extension_config_dump('my_config', '');
SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');</pre><p>
任意数のテーブル、またはシーケンスをこの方法で印付けることができます。
<code class="type">serial</code>列または<code class="type">bigserial</code>列に関連したシーケンスが、同様に印付けることができます。
    </p><p><code class="function">pg_extension_config_dump</code>の第２引数が空文字列である場合、テーブルのすべての内容が<span class="application">pg_dump</span>によりダンプされます。
これは、拡張のスクリプトによって作成された初期段階においてテーブルが空である場合のみ正しいものです。
テーブルの中で初期データとユーザが提供したデータが混在する場合、<code class="function">pg_extension_config_dump</code>の第２引数においてダンプすべきデータを選択する<code class="literal">WHERE</code>条件を提供します。
以下に例を示します。
</p><pre class="programlisting">CREATE TABLE my_config (key text, value text, standard_entry boolean);

SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');</pre><p>
このようにした後、拡張のスクリプトで作成される行のみで<code class="structfield">standard_entry</code>が確実に真になるようにします。
    </p><p>シーケンスにおいて、<code class="function">pg_extension_config_dump</code>の第２引数は何も影響を及ぼしません。
    </p><p>初期状態で提供される行がユーザによって変更されるようなもっと複雑な状況では、設定テーブルに対するトリガを作成して、変更された行が正しく印付けられることを確実にするように取り扱うことができます。
    </p><p><code class="function">pg_extension_config_dump</code>を再度呼び出すことにより、設定テーブルに関連付いたフィルタ条件を変更することができます。
（通常これは拡張の更新スクリプト内で役に立つでしょう。）
設定ファイルからテーブルを取り除くように印付ける方法は、<code class="command">ALTER EXTENSION ... DROP TABLE</code>を用いてテーブルを拡張から分離するしかありません。
    </p><p>このテーブルとの外部キーの関係は、テーブルがpg_dumpによってダンプされる順序に影響します。
特に、pg_dumpは参照しているテーブルの前に参照されているテーブルをダンプしようとします。
外部キーの関係はCREATE EXTENSION時(データがテーブルにロードされる前)に設定されますので、循環依存はサポートされません。
循環依存が存在すれば、データはダンプされますが、そのダンプを直接はリストアできず、ユーザの介入が必要になります。
    </p><p><code class="type">serial</code>列または<code class="type">bigserial</code>列に関連したシーケンスは、それらの状態をダンプするために直接印付けする必要があります。
親リレーションを印付けすることは、この目的に十分ではありません。
    </p></div><div class="sect2" id="id-1.8.3.18.15"><div class="titlepage"><div><div><h3 class="title">37.15.5. 拡張の更新</h3></div></div></div><p>拡張機構の１つの利点は、拡張のオブジェクトを定義するSQLコマンドの更新を簡便に管理する方法を提供していることです。
これは、拡張のインストール用スクリプトのリリース版それぞれにバージョン名称またはバージョン番号を関連付けることで行われます。
さらに、ユーザにあるバージョンから次のバージョンへ動的にデータベースを更新させることができるようにしたい場合、あるバージョンから次のバージョンまでの間に行われる必要な変更を行う<em class="firstterm">更新スクリプト</em>を提供しなければなりません。
更新スクリプトは<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>oldversion</code></em>--<em class="replaceable"><code>newversion</code></em>.sql</code>というパターンに従った名前（例えば、<code class="literal">foo--1.0--1.1.sql</code>は<code class="literal">foo</code>拡張のバージョン<code class="literal">1.0</code>からバージョン<code class="literal">1.1</code>に変更するコマンドを含みます。）を持たなければなりません。
    </p><p>適切な更新スクリプトが利用可能である場合、<code class="command">ALTER EXTENSION UPDATE</code>コマンドはインストール済みの拡張を指定した新しいバージョンへ更新します。
更新スクリプトは、<code class="command">CREATE EXTENSION</code>がインストール用スクリプト向けに提供する環境と同じ環境で実行されます。
具体的には<code class="varname">search_path</code>は同じ方法で設定され、スクリプトにより作成される新しいオブジェクトはすべて自動的に拡張に追加されます。
また、スクリプトが拡張のメンバーオブジェクトを削除する場合には、それらのメンバーオブジェクトは拡張から自動的に分離されます。
    </p><p>拡張が副制御ファイルを持つ場合、更新スクリプトで使用される制御パラメータは、スクリプトの対象の（新しい）バージョンに関連付けされたものになります。
    </p><p>更新機構を使用して、オブジェクトの<span class="quote">“<span class="quote">粗</span>”</span>集合から拡張に変換するという、特別かつ重大な状況を解消することができます。
拡張機構が<span class="productname">PostgreSQL</span>に（9.1で）追加されるようになる前では、パッケージ化されずに単に詰めあわされたオブジェクトを作成する拡張モジュールを多くのユーザが作成していました。
こうしたオブジェクトを持つデータベースが存在する場合、どのようにすればこれらのオブジェクトを適切にパッケージ化された拡張に変換できるでしょうか？
削除した後で普通に<code class="command">CREATE EXTENSION</code>を行うことも１つの方法ですが、オブジェクトに依存関係がある（例えば拡張により作成されたデータ型のテーブル列が存在する場合など）場合は好まれません。
こうした状況を解消する方法は、空の拡張を作成し、<code class="command">ALTER EXTENSION ADD</code>を使用して、既存のオブジェクトそれぞれを拡張に関連づけ、最後にパッケージ化されていないリリースに存在しないが現在のバージョンの拡張には存在する新しいオブジェクトを作成するという方法です。
<code class="command">CREATE EXTENSION</code>は<code class="literal">FROM</code> <em class="replaceable"><code>old_version</code></em>オプションでこの状況をサポートします。
この場合、通常のインストール用スクリプトは実行されず、代わりに<code class="literal"><em class="replaceable"><code>extension</code></em>--<em class="replaceable"><code>old_version</code></em>--<em class="replaceable"><code>target_version</code></em>.sql</code>という名前の更新スクリプトが実行されるようになります。
<em class="replaceable"><code>old_version</code></em>として使用するダミーのバージョン名の選択は拡張の作成者に任せられていますが、<code class="literal">unpackaged</code>がよく使われる規約です。
拡張形式に更新できるようにしたい過去のバージョンが複数存在する場合、それらを識別できるように複数のダミーバージョン番号を使用していください。
    </p><p><code class="command">ALTER EXTENSION</code>は、要求される更新を実現するために更新スクリプトを連続して実行することができます。
例えば<code class="literal">foo--1.0--1.1.sql</code>と<code class="literal">foo--1.1--2.0.sql</code>のみが利用可能であるとすると、現在<code class="literal">1.0</code>がインストールされている時にバージョン<code class="literal">2.0</code>への更新が要求された場合、<code class="command">ALTER EXTENSION</code>はこれらを順番に適用します。
    </p><p><span class="productname">PostgreSQL</span>はバージョン名称の特性についてまったく仮定を行いません。
例えば<code class="literal">1.0</code>の次が<code class="literal">1.1</code>であるかどうかを把握しません。
これは利用可能なバージョン名をかみ合わせ、もっとも少ない数の更新スクリプトを適用するために必要な経路を続けるだけです。
（バージョン名には、<code class="literal">--</code>を含まず先頭または最後に<code class="literal">-</code>が付かなければ、任意の文字を取ることができます。）
    </p><p><span class="quote">“<span class="quote">ダウングレード</span>”</span>スクリプトを提供することが便利な場合があります。
例えば<code class="literal">foo--1.1--1.0.sql</code>は、バージョン<code class="literal">1.1</code>に関連した変更を元に戻すことができます。
この場合、ダウングレードスクリプトがより短いパスを生成するために、予期せず適用されてしまう可能性に注意してください。
複数のバージョンをまたがって更新する<span class="quote">“<span class="quote">近道</span>”</span>更新スクリプトと近道の開始バージョンへのダウングレードスクリプトが存在する場合に危険性があります。
ダウングレードしてから近道となる更新スクリプトを実行する方が、バージョンを１つずつ進めるよりも少ない処理で済んでしまうかもしれません。
ダウングレードスクリプトが取り返しがつかないオブジェクトを何か削除してしまう場合、望まない結果になってしまいます。
    </p><p>想定外の更新経路かどうかを検査するためには、以下のコマンドを使用してください。
</p><pre class="programlisting">SELECT * FROM pg_extension_update_paths('<em class="replaceable"><code>extension_name</code></em>');</pre><p>
これは指定した拡張の個々の既知のバージョン名の組み合わせをそれぞれ、元のバージョンから対象のバージョンへ進む時に取られる更新経路順、またはもし利用できる更新経路がなければ<code class="literal">NULL</code>を付けて、表示します。
経路は<code class="literal">--</code>を区切り文字として使用したテキスト形式で表示されます。
配列形式の方が良ければ<code class="literal">regexp_split_to_array(path,'--')</code>を使用することができます。
    </p></div><div class="sect2" id="id-1.8.3.18.16"><div class="titlepage"><div><div><h3 class="title">37.15.6. 更新スクリプトを利用した拡張のインストール</h3></div></div></div><p>以前から存在している拡張は、おそらく複数のバージョンに渡って存在しているので、拡張の作者は更新スクリプトを開発する必要性が出てきます。
たとえば、拡張<code class="literal">foo</code>がバージョン<code class="literal">1.0</code>、<code class="literal">1.1</code>、<code class="literal">1.2</code>をリリースしていたとすると、更新スクリプト<code class="filename">foo--1.0--1.1.sql</code>と<code class="filename">foo--1.1--1.2.sql</code>が存在しなければなりません。
<span class="productname">PostgreSQL</span> 10より前では、新しい拡張のバージョンを直接作成するスクリプトファイル<code class="filename">foo--1.1.sql</code>と<code class="filename">foo--1.2.sql</code>も新規に作る必要がありました。
これらがないと、新しいバージョンの拡張を直接インストールすることはできず、<code class="literal">1.0</code>をインストールしてから更新するしかありませんでした。
それにはうんざりしますし、また冗長です。
しかし、今では<code class="command">CREATE EXTENSION</code>が自動的に更新連鎖を追跡してくるので、それは不要になりました。
たとえば、<code class="filename">foo--1.0.sql</code>、<code class="filename">foo--1.0--1.1.sql</code>、<code class="filename">foo--1.1--1.2.sql</code>だけしかない場合、バージョン<code class="literal">1.2</code>のインストールのリクエストは、これらのスクリプトを順に実行することによって達成されます。
この手順は、最初に<code class="literal">1.0</code>をインストールして、<code class="literal">1.2</code>にアップデートする場合でも同じです。
（<code class="command">ALTER EXTENSION UPDATE</code>は、複数の手順がある場合には、最短の手順を選びます。）
この方法で拡張のスクリプトを調整することにより、小さな更新を複数作成するための保守の手間を減らすことができます。
    </p><p>この方法で保守している拡張に二次的な（バージョン固有の）制御ファイルがある場合は、スタンドアローンのインストールスクリプトがない場合でも、各バージョンで制御ファイルが必要になることに注意してください。
そのバージョンへと更新する暗黙的な方法を、制御ファイルが決定するからです。
たとえば、<code class="filename">foo--1.0.control</code>が<code class="literal">requires = 'bar'</code>を指定しているのに、<code class="literal">foo</code>の他の制御ファイルが指定していないとすると、<code class="literal">1.0</code>から他のバージョンに更新した際に<code class="literal">bar</code>への依存性が削除されてしまうでしょう。
    </p></div><div class="sect2" id="EXTEND-EXTENSIONS-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">37.15.7. 拡張の例</h3></div></div></div><p>ここでは、<acronym class="acronym">SQL</acronym>のみの拡張の完全な例を示します。
<span class="quote">“<span class="quote">k</span>”</span>と<span class="quote">“<span class="quote">v</span>”</span>という名称の２つの要素からなる複合型であり、そのスロットには任意の型の値を格納することができるものです。
格納の際テキスト以外の値は自動的にテキストに変換されます。
    </p><p><code class="filename">pair--1.0.sql</code>スクリプトファイルは以下のようになります。

</p><pre class="programlisting">-- スクリプトが、CREATE EXTENSION経由ではなく、psqlのソースとして使われた場合には文句を言う
\echo Use "CREATE EXTENSION pair" to load this file. \quit

CREATE TYPE pair AS ( k text, v text );

CREATE OR REPLACE FUNCTION pair(text, text)
RETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';

CREATE OPERATOR ~&gt; (LEFTARG = text, RIGHTARG = text, PROCEDURE = pair);

-- "SET search_path" is easy to get right, but qualified names perform better.
CREATE OR REPLACE FUNCTION lower(pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'
SET search_path = pg_temp;

CREATE OR REPLACE FUNCTION pair_concat(pair, pair)
RETURNS pair LANGUAGE SQL
AS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,
               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';</pre><p>
    </p><p><code class="filename">pair.control</code>制御ファイルは以下のようになります。

</p><pre class="programlisting"># pair extension
comment = 'A key/value pair data type'
default_version = '1.0'
relocatable = false</pre><p>
    </p><p>これらの２つのファイルを正しいディレクトリにインストールするためにメークファイルを作成する必要はほとんどありませんが、以下を含む<code class="filename">Makefile</code>を使用することができます。

</p><pre class="programlisting">EXTENSION = pair
DATA = pair--1.0.sql

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</pre><p>

このメークファイルは<a class="xref" href="extend-pgxs.html" title="37.16. 拡張構築基盤">Section 37.16</a>で説明する<acronym class="acronym">PGXS</acronym>に依存します。
<code class="literal">make install</code>コマンドは制御ファイルとスクリプトファイルを<span class="application">pg_config</span>で報告される正しいディレクトリにインストールします。
    </p><p>ファイルがインストールされた後、<a class="xref" href="sql-createextension.html" title="CREATE EXTENSION"><span class="refentrytitle">CREATE EXTENSION</span></a>コマンドを使用してオブジェクトを任意の特定のデータベースにロードしてください。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xindex.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-pgxs.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.14. インデックス拡張機能へのインタフェース </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.16. 拡張構築基盤</td></tr></table></div></body></html>