<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>20.3. 認証方式</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="auth-username-maps.html" title="20.2. ユーザ名マップ" /><link rel="next" href="client-authentication-problems.html" title="20.4. 認証における問題点" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">20.3. 認証方式</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="client-authentication.html" title="Chapter 20. クライアント認証">Up</a></td><th width="60%" align="center">Chapter 20. クライアント認証</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="client-authentication-problems.html" title="20.4. 認証における問題点">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="AUTH-METHODS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">20.3. 認証方式</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="auth-methods.html#AUTH-TRUST">20.3.1. trust認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-PASSWORD">20.3.2. パスワード認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#GSSAPI-AUTH">20.3.3. GSSAPI認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#SSPI-AUTH">20.3.4. SSPI認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-IDENT">20.3.5. Ident認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-PEER">20.3.6. Peer認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-LDAP">20.3.7. LDAP認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-RADIUS">20.3.8. RADIUS認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-CERT">20.3.9. 証明書認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-PAM">20.3.10. PAM認証</a></span></dt><dt><span class="sect2"><a href="auth-methods.html#AUTH-BSD">20.3.11. BSD認証</a></span></dt></dl></div><p>   以下の小節では、認証方式について詳細に説明します。
  </p><div class="sect2" id="AUTH-TRUST"><div class="titlepage"><div><div><h3 class="title">20.3.1. trust認証</h3></div></div></div><p><code class="literal">trust</code>認証が指定されると<span class="productname">PostgreSQL</span>は、サーバに接続できる全ての人に対して
（データベーススーパーユーザさえも）その人が指定する任意のデータベースユーザ名としてのアクセス権限が付与されていると想定します。
当然ながら<code class="literal">database</code>と<code class="literal">user</code>列にある制限は適用されます。
この方式はサーバに接続する際に適切なオペレーティングシステムレベルの保護が掛けられている場合にのみ使用すべきです。
   </p><p><code class="literal">trust</code>認証はユーザが1人のみのワークステーション上でローカル接続を行う場合は適切であると同時に非常に便利です。
複数ユーザが存在するマシン上では一般的に適切では<span class="emphasis"><em>ありません</em></span>。
とは言っても、ファイルシステムの許可属性を使ってサーバのUnixドメインソケットファイルへのアクセスを制限すれば<code class="literal">trust</code>認証を複数ユーザのマシン上で使用することも可能です。
その方法は、<a class="xref" href="runtime-config-connection.html" title="19.3. 接続と認証">Section 19.3</a>に記載されているように<code class="varname">unix_socket_permissions</code>（および<code class="varname">unix_socket_group</code>パラメータの可能性もあります）パラメータを設定します。
もしくは、<code class="varname">unix_socket_directories</code>設定パラメータでソケットファイルをそれに相応しく制限されているディレクトリにします。
   </p><p>Unixソケット接続を行うただ1つの方法は、ファイルシステムの許可を設定することです。
ローカルのTCP/IP接続は、ファイルシステムにより制限はされていません。
よってローカルでファイルシステムの許可を使用したい場合は<code class="filename">pg_hba.conf</code>から
<code class="literal">host ... 127.0.0.1 ...</code>の行を削除するか、<code class="literal">trust</code>認証とは異なる方法に変更する必要があります。
   </p><p>TCP/IP接続における<code class="literal">trust</code>認証は、<code class="literal">trust</code>を指定する<code class="filename">pg_hba.conf</code>の行によってサーバに接続を許可される全てのマシン上の全てのユーザを信用（trust）できる場合にのみ相応しいものです。
<span class="systemitem">ローカルホスト</span>（127.0.0.1）以外からのTCP/IP接続に<code class="literal">trust</code>認証を用いる理由はほとんど見当たりません。
   </p></div><div class="sect2" id="AUTH-PASSWORD"><div class="titlepage"><div><div><h3 class="title">20.3.2. パスワード認証</h3></div></div></div><a id="id-1.6.7.10.4.2" class="indexterm"></a><a id="id-1.6.7.10.4.3" class="indexterm"></a><a id="id-1.6.7.10.4.4" class="indexterm"></a><p>複数のパスワードに基づく認証方式があります。
これらは似たような方法で使用されますが、ユーザのパスワードをサーバに格納する方法と、クライアントによって提供されたパスワードが接続を通じて送信される方法が異なります。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">scram-sha-256</code></span></dt><dd><p><code class="literal">scram-sha-256</code>方式は、<a class="ulink" href="https://tools.ietf.org/html/rfc7677" target="_top">RFC 7677</a>に記述された方法でSCRAM-SHA-256認証を実行します。
これはチャレンジ／レスポンス方式のひとつであり、信頼できない接続におけるパスワードの漏洩を防ぎ、安全だと見なされる暗号学的ハッシュ形式でパスワードをサーバに格納するのを支援します。
      </p><p>これは、現在実装されている認証方式の中では最も安全ですが、古いクライアントライブラリではサポートされていません。
      </p></dd><dt><span class="term"><code class="literal">md5</code></span></dt><dd><p><code class="literal">md5</code>方式は、独自のより安全性の低いチャレンジ／レスポンス機構を使います。
パスワードの漏洩を防ぎ、平文でパスワードをサーバに格納するのを避けることができますが、攻撃者がサーバからパスワードハッシュを盗むことを防ぐのを防ぐことはできません。
また、MD5ハッシュアルゴリズムは、昨今では強い意志をもった攻撃に対しては安全ではないと考えられています。
      </p><p><code class="literal">md5</code>は、<a class="xref" href="runtime-config-connection.html#GUC-DB-USER-NAMESPACE">db_user_namespace</a>機能と一緒に使用することはできません。
      </p><p><code class="literal">md5</code>方式からより新しいSCRAM方式への移行を容易にするため、<code class="filename">pg_hba.conf</code>で<code class="literal">md5</code>が指定されているにもかかわらず、パスワードがSCRAM（下記参照）で暗号化されている場合には、自動的にSCRAMに基づく認証が代わりに使用されます。
      </p></dd><dt><span class="term"><code class="literal">password</code></span></dt><dd><p><code class="literal">password</code>方式は、パスワードを平文で送信するので、パスワード<span class="quote">“<span class="quote">盗聴</span>”</span>攻撃に対して脆弱です。
可能ならば、常に避けるようにしてください。
しかしながら、接続がSSL暗号で保護されていれば、<code class="literal">password</code>は安全に使用できます。
（もっとも、SSLの利用に依存するのであれば、SSL証明書認証がより良い選択かもしれません。）
      </p></dd></dl></div><p><span class="productname">PostgreSQL</span>データベースパスワードはオペレーティングシステムのユーザパスワードとも別のものです。
各データベースユーザのパスワードは<code class="literal">pg_authid</code>システムカタログテーブルの中に格納されます。
<strong class="userinput"><code>CREATE USER foo WITH PASSWORD 'secret';</code></strong>のように、パスワードはSQLコマンド<a class="xref" href="sql-createuser.html" title="CREATE USER"><span class="refentrytitle">CREATE USER</span></a>と<a class="xref" href="sql-alterrole.html" title="ALTER ROLE"><span class="refentrytitle">ALTER ROLE</span></a>を使って管理できます。
あるいは、<span class="application">psql</span>の<code class="literal">\password</code>コマンドでも管理できます。
もしユーザに対してパスワードが設定されない場合、格納されるパスワードはNULLとなり、そのユーザのパスワード認証は常に失敗します。
   </p><p>パスワードにもとづく異なる認証方式が利用可能かどうかは、サーバ上でユーザのパスワードがどのように暗号化（正確には、ハッシュ化）されるのかに依存します。
これは、パスワードが設定されたときに、設定パラメータの<a class="xref" href="runtime-config-connection.html#GUC-PASSWORD-ENCRYPTION">password_encryption</a>によって制御されます。
パスワードが<code class="literal">scram-sha-256</code>によって暗号化されていれば、認証方式の<code class="literal">scram-sha-256</code>と<code class="literal">password</code>で利用できます。
（ただし、後者の場合にはパスワードの転送は平文になります。）
前述のように、ここで認証方式の<code class="literal">md5</code>を指定すると、<code class="literal">scram-sha-256</code>方式に自動的に切り替わります。
パスワードが<code class="literal">md5</code>で暗号化されていると、<code class="literal">md5</code>と<code class="literal">password</code>でのみ使用されます。
（ここでも、後者の場合にはパスワードは平文で転送されます。）
  （以前のPostgreSQLのリリースでは、パスワードを平文で格納することをサポートしていました。
  これはもはや不可能です。）
現在格納されているパスワードのハッシュを確認するには、システムカタログ<code class="literal">pg_authid</code>を参照してください。
   </p><p>既存のインストールにおいて、<code class="literal">md5</code>から<code class="literal">scram-sha-256</code>にアップグレードするには、すべてのクライアントライブラリが十分新しく、SCRAMをサポートをできることを確認してから、<code class="filename">postgresql.conf</code>で<code class="literal">password_encryption = 'scram-sha-256'</code>を設定し、すべてのユーザに新しいパスワードを設定してもらい、<code class="filename">pg_hba.conf</code>の認証方式を<code class="literal">scram-sha-256</code>に変更してください。
   </p></div><div class="sect2" id="GSSAPI-AUTH"><div class="titlepage"><div><div><h3 class="title">20.3.3. GSSAPI認証</h3></div></div></div><a id="id-1.6.7.10.5.2" class="indexterm"></a><p><span class="productname">GSSAPI</span>は、RFC 2743で定義されている安全な認証のための業界標準のプロトコルです。
<span class="productname">PostgreSQL</span>は、RFC 1964により<span class="productname">Kerberos</span>認証での<span class="productname">GSSAPI</span>をサポートします。
<span class="productname">GSSAPI</span>は、<span class="productname">GSSAPI</span>をサポートしているシステムに対して自動認証（シングルサインオン）を提供します。
認証自体は安全ですが、データベース接続を通じて送信されるデータは、<acronym class="acronym">SSL</acronym>が使用されていない場合は平文となります。
   </p><p>GSSAPIサポートは、<span class="productname">PostgreSQL</span>を構築する時に有効にしなければなりません。詳細は、<a class="xref" href="installation.html" title="Chapter 16.  ソースコードからインストール">Chapter 16</a>を参照してください。
   </p><p><span class="productname">GSSAPI</span>が<span class="productname">Kerberos</span>を使用しているとき、<span class="productname">GSSAPI</span>は、<code class="literal"><em class="replaceable"><code>servicename</code></em>/<em class="replaceable"><code>hostname</code></em>@<em class="replaceable"><code>realm</code></em></code>という書式の標準のプリンシパルを使用します。
[訳注：プリンシパルとは大雑把に2つのものを指します。1つはサービスを受けるクライアントで、もう1つはサービスを提供するサーバアプリケーションです。どちらも、認証に関してはKerberosのKDCから見るとクライアントになります]
PostgreSQLサーバはサーバにより使われるkeytabに含まれるいかなるプリンシパルも受け付けますが、<code class="literal">krbsrvname</code>接続パラメータを使ってクライアントから接続する場合には、プリンシパルの詳細を正確に指定することに注意を払う必要があります。
(<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. パラメータキーワード">Section 33.1.2</a>も参照してください。)
ビルド時に<code class="literal">./configure --with-krb-srvnam=whatever</code>を使用することで、インストール時のデフォルトはデフォルトの<code class="literal">postgres</code>から変更が可能です。
多くの環境では、このパラメータは変更する必要はないでしょう。
いくつかのKerberosの実装では、異なるサービス名が必要になります。Microsoftアクティブディレクトリではサービス名は（<code class="literal">POSTGRES</code>）のように大文字にする必要があります。
   </p><p><em class="replaceable"><code>hostname</code></em>はサーバマシンの完全修飾されたホスト名です。
サービスプリンシパルのrealmはサーバマシンが提起したrealmです。
   </p><p>クライアントのプリンシパルは<code class="filename">pg_ident.conf</code>で異なる<span class="productname">PostgreSQL</span>のデータベースユーザ名にマップできます。
例えば、<code class="literal">pgusername@realm</code>を単なる<code class="literal">pgusername</code>にマップできます。
もう1つの方法として、プリンシパル名全体<code class="literal">username@realm</code>を<span class="productname">PostgreSQL</span>のロール名としてマッピングなしに使うこともできます。
   </p><p><span class="productname">PostgreSQL</span>はプリンシパルからrealmを外すパラメータもサポートしています。
この方法は後方互換のためにサポートされているものであり、異なるrealmから来た同じユーザ名の異なるユーザを区別することができませんので、使用しないことを強く薦めます。
この方法を有効にするには<code class="literal">include_realm</code>を0に設定してください。
単純な単一realmの設定では、(プリンシパルのrealmが<code class="literal">krb_realm</code>パラメータ内のものと正確に一致するか確認する)<code class="literal">krb_realm</code>パラメータと組み合わせることが安全です。
しかし、これは<code class="filename">pg_ident.conf</code>で明示的なマッピングを指定するのに比べてあまり適切でない選択でしょう。
   </p><p>サーバ鍵ファイルが<span class="productname">PostgreSQL</span>サーバアカウントによって読み込み可能（そしてできれば読み込み専用で書き込み不可）であることを確認してください。
（<a class="xref" href="postgres-user.html" title="18.1. PostgreSQLユーザアカウント">Section 18.1</a>を参照してください。）
鍵ファイルの保存場所は<a class="xref" href="runtime-config-connection.html#GUC-KRB-SERVER-KEYFILE">krb_server_keyfile</a>設定パラメータで指定されます
デフォルトは、<code class="filename">/usr/local/pgsql/etc/krb5.keytab</code>（もしくはビルド時に<code class="varname">sysconfdir</code>で指定されたディレクトリ）です。
セキュリティ上の理由から、システムkeytabファイルで許可するよりも、<span class="productname">PostgreSQL</span>サーバ用に別のkeytabファイルを使うことをお薦めします。
   </p><p>keytabファイルはKerberosのソフトウェアによって作成されます。詳細はKerberosのドキュメントを参照してください。
MIT互換のKerberos5実装の例を以下に示します。
</p><pre class="screen"><code class="prompt">kadmin% </code><strong class="userinput"><code>ank -randkey postgres/server.my.domain.org</code></strong>
<code class="prompt">kadmin% </code><strong class="userinput"><code>ktadd -k krb5.keytab postgres/server.my.domain.org</code></strong></pre><p>
   </p><p>データベースに接続しようとしている時要求されるデータベースユーザ名に一致するプリンシパルのチケットを所有しているか確認してください。
例えば、データベースユーザ名<code class="literal">fred</code>に対し、<code class="literal">fred@EXAMPLE.COM</code>のプリンシパルは接続できるでしょう。
<code class="literal">fred/users.example.com@EXAMPLE.COM</code>のプリンシパルも許可するためには<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>内に記述されているユーザ名マップを使用して下さい。
   </p><p>次の設定オプションは<span class="productname">GSSAPI</span>のためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">include_realm</code></span></dt><dd><p>0に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、ユーザ名マッピング（<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>）で渡されるシステムユーザ名から外されています。
<code class="literal">krb_realm</code>も一緒に使われていない限り、これは複数realm環境で安全ではありませんので、非推奨であり、主に後方互換性のために利用できます。
<code class="literal">include_realm</code>をデフォルト(1)にしたまま、プリンシパル名を<span class="productname">PostgreSQL</span>ユーザ名に変換するために<code class="filename">pg_ident.conf</code>で明示的なマッピングを指定することをお薦めします。
       </p></dd><dt><span class="term"><code class="literal">map</code></span></dt><dd><p>システムとデータベースの間のマッピングを許可します。
詳細は<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>を参照してください。
GSSAPI/Kerberosプリンシパル<code class="literal">username@EXAMPLE.COM</code>(もしくは、あまり一般的ではありませんが<code class="literal">username/hostbased@EXAMPLE.COM</code>)に対しては、もし<code class="literal">include_realm</code>が0に設定されていない限り、マッピングに使われるユーザ名は<code class="literal">username@EXAMPLE.COM</code>(もしくは<code class="literal">username/hostbased@EXAMPLE.COM</code>)です。
0に設定されている場合には、<code class="literal">username</code>(もしくは<code class="literal">username/hostbased</code>)がマッピング時のシステムユーザ名です。
       </p></dd><dt><span class="term"><code class="literal">krb_realm</code></span></dt><dd><p>realmをユーザプリンシパル名に一致するように設定します。
もしこのパラメータが設定されている場合はそのrealmのユーザのみが受け付けられます。
もしこれが設定されていない場合は、どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="SSPI-AUTH"><div class="titlepage"><div><div><h3 class="title">20.3.4. SSPI認証</h3></div></div></div><a id="id-1.6.7.10.6.2" class="indexterm"></a><p><span class="productname">SSPI</span>は、シングルサインオンで安全な認証を行うための<span class="productname">Windows</span>の技術です。
<span class="productname">PostgreSQL</span>は、<code class="literal">negotiate</code>モードにおいてSSPIを使用します。
これは、可能な場合は<span class="productname">Kerberos</span>を使用し、他の場合については自動的に<span class="productname">NTLM</span>を使用することを意味しています。
<span class="productname">SSPI</span>認証は、サーバ、クライアントが共に<span class="productname">Windows</span>上もしくは<span class="productname">GSSAPI</span>が利用可能な場合はWindowsではないプラットフォームで稼動しているときにのみ動作します。
   </p><p><span class="productname">Kerberos</span>認証を使用しているとき、
<span class="productname">SSPI</span>は、<span class="productname">GSSAPI</span>と同じように動作します。
詳細は<a class="xref" href="auth-methods.html#GSSAPI-AUTH" title="20.3.3. GSSAPI認証">Section 20.3.3</a>を参照してください。
   </p><p>次の設定オプションは<span class="productname">SSPI</span>のためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">include_realm</code></span></dt><dd><p>0に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、ユーザ名マッピング（<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>）で渡されるシステムユーザ名から外されています。
<code class="literal">krb_realm</code>も一緒に使われていない限り、これは複数realm環境で安全ではありませんので、非推奨であり、主に後方互換性のために利用できます。
<code class="literal">include_realm</code>をデフォルト(1)にしたまま、プリンシパル名を<span class="productname">PostgreSQL</span>ユーザ名に変換するために<code class="filename">pg_ident.conf</code>で明示的なマッピングを指定することをお薦めします。
       </p></dd><dt><span class="term"><code class="literal">compat_realm</code></span></dt><dd><p>1に設定されている場合は、（NetBIOS名としても知られている）ドメインのSAM互換名が<code class="literal">include_realm</code>オプションのために使用されます。
これはデフォルトの動作です。
0に設定されている場合は、ケルベロスユーザプリンシパル名からの真のrealm名が使用されます。
       </p><p>ドメインアカウント（これはドメインメンバーシステムの仮想サービスアカウントを含みます）にて実行されているサーバで、SSPIで認証されているすべてのクライアントがドメインアカウントを使用してる場合を除き、このオプションを無効にしないでください。
さもなくば認証は失敗します。
       </p></dd><dt><span class="term"><code class="literal">upn_username</code></span></dt><dd><p><code class="literal">compat_realm</code>と共にこのオプションが有効の場合、認証にはケルベロスUPNからユーザ名が使用されます。
無効（デフォルト）である場合は、SAM互換ユーザ名が使用されます。
デフォルトでは、これらの2つのユーザ名は新しいユーザアカウントでは同じものとなります。
       </p><p>明示的なユーザ名が指定されない場合、<span class="application">libpq</span>はSAM互換名を使用することに注意してください。
<span class="application">libpq</span>もしくは<span class="application">libpq</span>を基礎としたドライバを使用する場合は、このオプションを無効のままにするか、明示的なユーザ名を接続文字列にて指定してください。
       </p></dd><dt><span class="term"><code class="literal">map</code></span></dt><dd><p>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>を参照してください。
SSAPI/Kerberosプリンシパル<code class="literal">username@EXAMPLE.COM</code>(もしくは、あまり一般的ではありませんが<code class="literal">username/hostbased@EXAMPLE.COM</code>)に対しては、もし<code class="literal">include_realm</code>が0に設定されていない限り、マッピングに使われるユーザ名は<code class="literal">username@EXAMPLE.COM</code>(もしくは<code class="literal">username/hostbased@EXAMPLE.COM</code>)です。
0に設定されている場合には、<code class="literal">username</code>(もしくは<code class="literal">username/hostbased</code>)がマッピング時のシステムユーザ名です。
       </p></dd><dt><span class="term"><code class="literal">krb_realm</code></span></dt><dd><p>realmをユーザプリンシパル名に一致するように設定します。もしこのパラメータが設定されている場合は
realmのユーザのみが受け付けられます。もしこれが設定されていない場合は、
どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="AUTH-IDENT"><div class="titlepage"><div><div><h3 class="title">20.3.5. Ident認証</h3></div></div></div><a id="id-1.6.7.10.7.2" class="indexterm"></a><p>ident認証方式は、クライアントのオペレーティングシステムのユーザ名をidentサーバから入手し、それを（オプションのユーザ名マップとともに）許可されているデータベースのユーザ名として使用します。
これはTCP/IP接続のみサポートされます。
   </p><div class="note"><h3 class="title">Note</h3><p>identが（TCP/IPではない）ローカル接続で指定されている場合、
ピア認証（<a class="xref" href="auth-methods.html#AUTH-PEER" title="20.3.6. Peer認証">Section 20.3.6</a>を参照してください）が代わりに使用されます。
    </p></div><p>次の設定オプションは<span class="productname">ident</span>のためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">map</code></span></dt><dd><p>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>を参照してください。
       </p></dd></dl></div><p>
   </p><p><span class="quote">“<span class="quote">身元特定（Identification）プロトコル</span>”</span>についてはRFC 1413で説明されています。
事実上全てのUnix系のオペレーティングシステムの配布には、デフォルトでTCPポート113を監視するidentサーバが付属しています。
identサーバの基本的な機能は<span class="quote">“<span class="quote">どのユーザがポート<em class="replaceable"><code>X</code></em>からの接続を開始し、自分のポート<em class="replaceable"><code>Y</code></em>への接続を初期化したのか？</span>”</span>というような質問に答えることです。
<span class="productname">PostgreSQL</span>は物理的な接続が確立された時に<em class="replaceable"><code>X</code></em>と<em class="replaceable"><code>Y</code></em>の両方を認識するので、接続するクライアントのホスト上のidentサーバに応答指令信号を送ることができ、理論的には与えられたどの接続にもオペレーティングシステムユーザを決定できます。
   </p><p>この手続きの欠点は、クライアントの正直さに頼るところが大きいということです。
もしクライアントマシンが信用されない、もしくは危険に晒されている場合、攻撃者はポート113上でほぼどんなプログラムでも実行することができ、どのユーザ名でも好きに選んで返すことができます。
したがってこの認証方式は、各々のクライアントマシンが厳格な管理下にあり、データベースとシステム管理者が密接に連絡を取り合って動作している、外界から閉ざされたネットワークにのみ適していると言えます。
言い換えると、identサーバが稼働しているマシンを信用しなければなりません。
次の警告に注意してください。
    </p><div class="blockquote"><table border="0" class="blockquote" style="width: 100%; cellspacing: 0; cellpadding: 0;" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>      身元特定プロトコルは、認証、あるいはアクセス管理プロトコルには意図されていません。
     </p></td><td width="10%" valign="top"> </td></tr><tr><td width="10%" valign="top"> </td><td colspan="2" align="right" valign="top">--<span class="attribution">RFC 1413</span></td></tr></table></div><p>
   </p><p>いくつかの身元特定サーバは、ユーザ名を（マシンの管理者のみが知っているキーで）暗号化して返すような非標準のオプションを持っています。
このオプションは、身元特定サーバと<span class="productname">PostgreSQL</span>とを一緒に使用する場合には、使用しては<span class="emphasis"><em>いけません</em></span>。
理由は<span class="productname">PostgreSQL</span>は、返された文字列を復号化して本当のユーザを決定するための手段を持っていないためです。
   </p></div><div class="sect2" id="AUTH-PEER"><div class="titlepage"><div><div><h3 class="title">20.3.6. Peer認証</h3></div></div></div><a id="id-1.6.7.10.8.2" class="indexterm"></a><p>peer認証方式はカーネルからクライアント上のオペレーティングシステムのユーザ名を取得し、
それをデータベースユーザ名（オプションのユーザ名マップとともに）として使用することにより動作します。この方法はローカル接続でのみ使用可能です。
   </p><p>次の設定オプションは<span class="productname">peer</span>のためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">map</code></span></dt><dd><p>システムとデータベースのユーザ名のマッピングを許可します。詳細は<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>を参照してください。
       </p></dd></dl></div><p>
   </p><p>Peer認証はオペレーティングシステムが、<code class="function">getpeereid()</code>関数、<code class="symbol">SO_PEERCRED</code>のソケットパラメータ、もしくは同じような仕組みを提供しているときにのみ使用可能です。現状では、<span class="systemitem">Linux</span>、<span class="systemitem">OS X</span>を含む<span class="systemitem">BSD</span>系、そして<span class="systemitem">Solaris</span>に含まれています。
   </p></div><div class="sect2" id="AUTH-LDAP"><div class="titlepage"><div><div><h3 class="title">20.3.7. LDAP認証</h3></div></div></div><a id="id-1.6.7.10.9.2" class="indexterm"></a><p>この認証方式は<code class="literal">password</code>と似ていますが、パスワード確認にLDAPを使用する点が異なります。
LDAPはユーザの名前とパスワードの組み合わせの検証のみに使用されます。
そのため、LDAPを使用して認証を行うようにする前に、ユーザはデータベースに存在しなければなりません。
   </p><p>LDAP認証は2つのモードで動作します。1つ目のモードでは、それは単なるバインド・モードを呼び出すものですが、
サーバは<em class="replaceable"><code>prefix</code></em> <em class="replaceable"><code>username</code></em> <em class="replaceable"><code>suffix</code></em>として区別された名前にバインドします。
一般的に、<em class="replaceable"><code>prefix</code></em>パラメータはActive Directory環境での<code class="literal">cn=</code>や<em class="replaceable"><code>DOMAIN</code></em><code class="literal">\</code>を特定するために使用されます。
<em class="replaceable"><code>suffix</code></em>は、Active Directory環境ではない場合でのDNの残りの部分を特定するために使用されます。
   </p><p>2つ目のモードでは、それはsearch/bindモードを呼び出すもので、サーバは最初に<em class="replaceable"><code>ldapbinddn</code></em>と<em class="replaceable"><code>ldapbindpasswd</code></em>で指定された、
固定されたユーザ名とパスワードを使用してLDAPディレクトリにバインドします。
それからデータベースにログインしようとしているユーザを検索します。
もしユーザとパスワードが指定されていなかった場合は、ディレクトリに対して匿名でバインドします。
検索は<em class="replaceable"><code>ldapbasedn</code></em>のサブツリーまで行われ、<em class="replaceable"><code>ldapsearchattribute</code></em>で指定された属性に正確に一致するかどうかまで行われます。
この検索において、一度ユーザが見つかるとサーバは切断して、クライアントで指定されたパスワードを使用してこのユーザとして再度ディレクトリにバインドします。これはそのログインが正しいかどうかを検証するためです。
このモードはApache <code class="literal">mod_authnz_ldap</code>および<code class="literal">pam_ldap</code>のように他のソフトウェアと同じように、LDAP認証の仕組みで使用されるものと同じです。
この方法は、ユーザオブジェクトがディレクトリに配置されている場合に、かなりの柔軟性があります。
しかし、LDAPサーバへの2つの分離した接続が作成されます。
   </p><p>次の設定オプションは両方のモードで使用されます。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ldapserver</code></span></dt><dd><p>接続するLDAPサーバの名称もしくはIPアドレスの名称。空白で区切ることで複数のサーバを指定できます。
       </p></dd><dt><span class="term"><code class="literal">ldapport</code></span></dt><dd><p>LDAPサーバに接続するためのポート番号。もしポートが指定されていない場合は
LDAPライブラリ内のデフォルトポート設定が使用されます。
       </p></dd><dt><span class="term"><code class="literal">ldaptls</code></span></dt><dd><p>1に設定すると、PostgreSQLとLDAPサーバ間の接続にTLSによる暗号化を使用します。
これはLDAPサーバへのトラフィックのみを暗号化することに注意してください。—
クライアントへの接続はSSLを使用しない限り暗号化されません。
       </p></dd></dl></div><p>

以下のオプションは単純バインド・モードのみで使用されます。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ldapprefix</code></span></dt><dd><p>単純なバインド認証を行う場合のDNを生成する際にユーザ名の前に追加する文字列
       </p></dd><dt><span class="term"><code class="literal">ldapsuffix</code></span></dt><dd><p>単純なバインド認証を行う場合のDNを生成する際にユーザ名の後に追加する文字列
       </p></dd></dl></div><p>

以下のオプションはsearch/bindモードのみで使用されます。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ldapbasedn</code></span></dt><dd><p>検索とバインドの認証を行う場合のユーザ名がログインするための検索を始めるためのルートDN
       </p></dd><dt><span class="term"><code class="literal">ldapbinddn</code></span></dt><dd><p>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのDN
       </p></dd><dt><span class="term"><code class="literal">ldapbindpasswd</code></span></dt><dd><p>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのパスワード
       </p></dd><dt><span class="term"><code class="literal">ldapsearchattribute</code></span></dt><dd><p>検索とバインドの認証を行う場合の検索時のユーザ名に対して一致させる属性。
属性が指定されない場合、属性<code class="literal">uid</code>が使用されます。
        </p></dd><dt><span class="term"><code class="literal">ldapurl</code></span></dt><dd><p>RFC 4516 LDAP URL。これはその他いくつかのLDAPオプションをより簡潔、かつ一般的な形式で記述する別の方法です。
フォーマットは以下のようになっています。
</p><pre class="synopsis">ldap://<em class="replaceable"><code>host</code></em>[:<em class="replaceable"><code>port</code></em>]/<em class="replaceable"><code>basedn</code></em>[?[<em class="replaceable"><code>attribute</code></em>][?[<em class="replaceable"><code>scope</code></em>]]]</pre><p>
<em class="replaceable"><code>scope</code></em>は<code class="literal">base</code>、<code class="literal">one</code>,、<code class="literal">sub</code>のいずれかでなくてはならず、一般的には最後のものです。
        </p><p>非匿名バインド（non-anonymous bind）に対し、<code class="literal">ldapbinddn</code>および<code class="literal">ldapbindpasswd</code>は個別のオプションとして指定されなければなりません。
        </p><p>暗号化されたLDAP接続を使用するには、<code class="literal">ldapurl</code>に加え<code class="literal">ldaptls</code>オプションを使用しなければなりません。<code class="literal">ldaps</code> URLの仕組み（直接SSL接続）はサポートされていません。
        </p><p>現在の所、LDAP URLはWindows上ではなく、OpenLDAPのみでサポートされています。
        </p></dd></dl></div><p>
   </p><p>seartch/bindオプションと単純バインドに対するオプションの設定を混在させるのはエラーです。
   </p><p>以下に単純バインドLDAP設定の例を示します。
</p><pre class="programlisting">host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"</pre><p>
データベースのユーザ、<code class="literal">someuser</code>からデータベースサーバに接続を要求された場合、PostgreSQLはDN <code class="literal">cn=someuser, dc=example, dc=net</code>およびクライアントから提供されたパスワードを用いてLDAPサーバにバインドを試みます。
その接続が成功すればデータベースへのアクセスが認められます。
   </p><p>以下はsearch/bind設定の例です。
</p><pre class="programlisting">host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid</pre><p>
データベースユーザ<code class="literal">someuser</code>としてデータベースに接続するとき、PostgreSQLは（<code class="literal">ldapbinddn</code>が指定されていないので）匿名的にバインドを試み、指定されたベースDNの基で<code class="literal">(uid=someuser)</code>の検索を行います。あるエントリが見つかると、見つかった情報とクライアントから与えられたパスワードを用いて、その結果バインドを試みます。その二番目の接続が成功するとデータベースアクセスが認められます。
   </p><p>URLとして記述した同じsearch/bind設定の例です。
</p><pre class="programlisting">host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"</pre><p>
LDAPに対し認証をサポートする幾つかの他のソフトウェアは同じURLフォーマットを使用します。
従って、設定をより簡易に共有することができます。
   </p><div class="tip"><h3 class="title">Tip</h3><p>LDAPはDNの異なる構成要素を区別するため往々にしてコンマとスペースを使用します。
例で示されたように、LDAPオプションを設定する場合、二重引用符で括られたパラメータ値を使用することが必須となることがしばしば必須となります。
    </p></div></div><div class="sect2" id="AUTH-RADIUS"><div class="titlepage"><div><div><h3 class="title">20.3.8. RADIUS認証</h3></div></div></div><a id="id-1.6.7.10.10.2" class="indexterm"></a><p>この認証方法は、RADIUSをパスワード検証として使用するという点を除いて<code class="literal">password</code>と似た動作をします。
RADIUSはユーザ名/パスワードの組のみを検証するために使用されます。
よってユーザはRADIUSが認証に使用される以前にデータベースにすでに存在していなければいけません。
   </p><p>RADIUS認証を使用する場合に、設定されたRADIUSサーバにアクセスリクエストメッセージが送信されます。
このリクエストは<code class="literal">Authenticate Only</code>の形式になり、<code class="literal">ユーザ名</code>, （暗号化された）<code class="literal">パスワード</code>、<code class="literal">NAS識別子</code>を含んでいます。
リクエストはサーバと共有している秘密を用いて暗号化されます。
RADIUSサーバは、このサーバに対して<code class="literal">Access Accept</code>もしくは<code class="literal">Access Reject</code>を返します。
RADIUSアカウントのサポートはありません。
   </p><p>複数のRADIUSサーバを指定することができ、その場合には各々が順に試行されます。
サーバから負の応答があると、認証は失敗します。
サーバから応答がない場合は、リスト内の次のサーバが試されます。
複数のサーバを指定するには、サーバ名を引用符の中に入れ、各々をカンマで区切ってください。
複数のサーバが指定されると、他のすべてのRADIUSオプションもカンマで区切って指定することが可能で、それぞれ各々のサーバに対して適用されます。
オプションは単一の値としても指定でき、その場合にはこの値がすべてのサーバに対して適用されます。
   </p><p>RADIUSのために次の設定オプションがサポートされています。
     </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">radiusservers</code></span></dt><dd><p>接続するRADIUSサーバの名称もしくはIPアドレス。
このパラメータは必須です。
        </p></dd><dt><span class="term"><code class="literal">radiussecrets</code></span></dt><dd><p>RADIUSサーバと安全なやり取りに使用される共有の秘密データ。
これはPostgreSQLとRADIUSサーバにおいて厳密に同じ値にする必要があります。
少なくとも16文字以上の文字列が推奨されます。
このパラメータは必須です。
         </p><div class="note"><h3 class="title">Note</h3><p>使用されている暗号化ベクターは<span class="productname">PostgreSQL</span>が<span class="productname">OpenSSL</span>をサポートするよう構築している場合にのみ暗号論的に強力です。
他の場合にはRADIUSサーバへの伝送は難読化されているだけで安全ではなく、必要ならば外部のセキュリティ方法を適用すべきです。
         </p></div><p>
        </p></dd><dt><span class="term"><code class="literal">radiusports</code></span></dt><dd><p>接続するRADIUSサーバのポート番号。
もしポート番号が指定されていない場合は、デフォルトポートである<code class="literal">1812</code>が使用されます。
        </p></dd><dt><span class="term"><code class="literal">radiusidentifiers</code></span></dt><dd><p>RADIUSリクエスト内で<code class="literal">NAS Identifier</code>として使用されている文字列。
ユーザがどのデータベースユーザに対して認証しようとしているか、RADIUSサーバにおいてポリシーを一致させるために何が使用されるか、
を識別するために、このパラメータは2番目のパラメータとして使用されます。
もし識別子が指定されていない場合は、デフォルトの<code class="literal">postgresql</code>が使用されます。
        </p></dd></dl></div><p>
   </p></div><div class="sect2" id="AUTH-CERT"><div class="titlepage"><div><div><h3 class="title">20.3.9. 証明書認証</h3></div></div></div><a id="id-1.6.7.10.11.2" class="indexterm"></a><p>この認証方法は、認証のためにSSLクライアント証明書を使用します。
よってこの方法は、SSL接続を使用します。
この認証方法を使用する際は、サーバはクライアントが有効かつ信頼された証明書を提供することを要求します。
パスワードのプロンプトはクライアントに送信されません。
証明書の<code class="literal">cn</code>（Common Name）属性は、要求されたデータベースユーザ名と比較されます。
もしそれらが一致した場合はログインが許可されます。
ユーザ名マッピングは、<code class="literal">cn</code>がデータベースユーザ名と異なるものであることを許可するために使用されます。
   </p><p>次の設定オプションはSSL証明書認証のためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">map</code></span></dt><dd><p>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<a class="xref" href="auth-username-maps.html" title="20.2. ユーザ名マップ">Section 20.2</a>を参照してください。
       </p></dd></dl></div><p>
   </p><p>証明書認証を指定する<code class="filename">pg_hba.conf</code>のレコードにおいて、認証オプションである<code class="literal">clientcert</code>は<code class="literal">1</code>であるとみなされ、クライアント証明書がこの方式のために必要であるゆえに無効にできません。
<code class="literal">cert</code>方式が基本的な<code class="literal">clientcert</code>証明書の妥当性確認に追加するのは、<code class="literal">cn</code>属性がデータベースユーザ名と合致することの確認となります。
   </p></div><div class="sect2" id="AUTH-PAM"><div class="titlepage"><div><div><h3 class="title">20.3.10. PAM認証</h3></div></div></div><a id="id-1.6.7.10.12.2" class="indexterm"></a><p>この認証方式は認証機構としてPAM（Pluggable Authentication Modules）を使用することを除いて<code class="literal">password</code>のように動作します。
デフォルトのPAMサービス名は<code class="literal">postgresql</code>です。
PAMはユーザ名/パスワードの組の確認と接続されたリモートホスト名またはIPアドレスを任意に確認するためだけに使用されます。
PAMについての詳細は<a class="ulink" href="http://www.kernel.org/pub/linux/libs/pam/" target="_top"><span class="productname">Linux-PAM</span>ページ</a>を読んでください。
   </p><p>次の設定オプションはPAMのためにサポートされています。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">pamservice</code></span></dt><dd><p>PAMサービス名。
       </p></dd><dt><span class="term"><code class="literal">pam_use_hostname</code></span></dt><dd><p><code class="symbol">PAM_RHOST</code>アイテムを通じてPAMモジュールに提供されるものがリモートのIPアドレスかホスト名かを決定します。
デフォルトではIPアドレスが使用されます。
ホスト名にて使用するためにはこのオプションを1にセットしてください。
ホスト名の解決はログインの遅延をもたらします。（ほとんどのPAM設定はこの情報を利用せず、PAM設定がホスト名を使用するために明確に作成された場合のみ、この設定値を考慮する必要があります。）
       </p></dd></dl></div><p>
   </p><div class="note"><h3 class="title">Note</h3><p>PAMが<code class="filename">/etc/shadow</code>を読み取るように設定されている場合は、PostgreSQLがルートユーザで起動されていないため、認証は失敗するでしょう。
しかしPAMがLDAPや他の認証方法を使用するように設定されている場合は、これは問題ではありません。
    </p></div></div><div class="sect2" id="AUTH-BSD"><div class="titlepage"><div><div><h3 class="title">20.3.11. BSD認証</h3></div></div></div><a id="id-1.6.7.10.13.2" class="indexterm"></a><p>この認証方式は、パスワードを照合するためにBSD認証を使用すること以外は<code class="literal">password</code>と同じように動作します。
BSD認証は、ユーザ名/パスワードの組の確認のみに使用されます。
それゆえ、ユーザのロールはBSD認証が認証に使用可能となる前にデータベースに存在していなければいけません。
BSD認証フレームワークは現在OpenBSDでのみ利用可能です。
   </p><p><span class="productname">PostgreSQL</span>でのBSD認証は、<code class="literal">auth-postgresql</code>ログイン型を使用し、<code class="literal">postgresql</code>ログインクラスが<code class="filename">login.conf</code>にて定義されている場合はそれを使った認証を使用します。
デフォルトでは、そのログインクラスは存在せず、<span class="productname">PostgreSQL</span>はデフォルトログインクラスを使用します。
   </p><div class="note"><h3 class="title">Note</h3><p>BSD認証を使用するために、PostgreSQLユーザアカウント（サーバを起動しているオペレーティングシステムユーザ）が、まずは<code class="literal">auth</code>グループに追加されていなければいけません。
<code class="literal">auth</code>グループはOpenBSDシステムではデフォルトで存在しています。
    </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="auth-username-maps.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="client-authentication.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="client-authentication-problems.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">20.2. ユーザ名マップ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 20.4. 認証における問題点</td></tr></table></div></body></html>