<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>REINDEX</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-refreshmaterializedview.html" title="REFRESH MATERIALIZED VIEW" /><link rel="next" href="sql-release-savepoint.html" title="RELEASE SAVEPOINT" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">REINDEX</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-refreshmaterializedview.html" title="REFRESH MATERIALIZED VIEW">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-release-savepoint.html" title="RELEASE SAVEPOINT">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-REINDEX"><div class="titlepage"></div><a id="id-1.9.3.156.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">REINDEX</span></h2><p>REINDEX — インデックスを再構築する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">REINDEX [ ( VERBOSE ) ] { INDEX | TABLE | SCHEMA | DATABASE | SYSTEM } <em class="replaceable"><code>name</code></em></pre></div><div class="refsect1" id="id-1.9.3.156.5"><h2>説明</h2><p><code class="command">REINDEX</code>は、インデックスのテーブルに保存されたデータを使用してインデックスを再構築し、古いインデックスのコピーと置き換えます。
以下に<code class="command">REINDEX</code>が使用される状況を示します。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>インデックスが破損してしまい、有効なデータがなくなった場合です。
理論的には決して起こらないはずですが、実際には、ソフトウェアのバグやハードウェアの障害によりインデックスが破損することがあります。
<code class="command">REINDEX</code>はこの修復手段を提供します。
     </p></li><li class="listitem"><p>インデックスが<span class="quote">“<span class="quote">膨張状態</span>”</span>、つまり、多くの空、もしくは、ほとんど空のページを持つ状態になっている場合です。
この状況は、<span class="productname">PostgreSQL</span>のB-treeインデックスが特定の普通でないパターンでアクセスされた場合に起こり得ます。
<code class="command">REINDEX</code>を使って、使用されないページを取り除いた新しいインデックス作成すると、インデックスの領域消費量を減少することができます。
詳細は<a class="xref" href="routine-reindex.html" title="24.2. 定常的なインデックスの再作成">Section 24.2</a>を参照してください。
     </p></li><li class="listitem"><p>インデックスの格納パラメータ（フィルファクタなど）を変更し、この変更を確実に有効にしたい場合です。
     </p></li><li class="listitem"><p><code class="literal">CONCURRENTLY</code>オプションをつけたインデックス作成が失敗し、<span class="quote">“<span class="quote">無効な</span>”</span>インデックスが残った場合です。
こうしたインデックスは使用されませんが、<code class="command">REINDEX</code>を使用して再作成するのが便利かもしれません。
<code class="command">REINDEX</code>では同時構築ができないことに注意してください。
運用に影響を与えずにインデックスを作成するためには、インデックスを削除してから<code class="command">CREATE INDEX CONCURRENTLY</code>コマンドを再発行しなければなりません。
     </p></li></ul></div></div><div class="refsect1" id="id-1.9.3.156.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">INDEX</code></span></dt><dd><p>指定したインデックスを再作成します。
     </p></dd><dt><span class="term"><code class="literal">TABLE</code></span></dt><dd><p>指定したテーブルの全インデックスを再作成します。
テーブルに2次的な<span class="quote">“<span class="quote">TOAST</span>”</span>テーブルがある場合、それについてもインデックスを再作成します。
     </p></dd><dt><span class="term"><code class="literal">SCHEMA</code></span></dt><dd><p>指定したスキーマのすべてのインデックスを再作成します。
このスキーマのテーブルが二次的な<span class="quote">“<span class="quote">TOAST</span>”</span>テーブルを持っている場合は、そのインデックスも再作成されます。
共有システムカタログのインデックスも処理されます。
この構文の<code class="command">REINDEX</code>はトランザクションブロックの内側で実行することはできません。
     </p></dd><dt><span class="term"><code class="literal">DATABASE</code></span></dt><dd><p>現在のデータベースのすべてのインデックスを再作成します。
共有システムカタログのインデックスも処理されます。
この構文の<code class="command">REINDEX</code>をトランザクションブロック内で実行することはできません。
     </p></dd><dt><span class="term"><code class="literal">SYSTEM</code></span></dt><dd><p>現在のデータベースのシステムカタログに対するすべてのインデックスを再作成します。
共有システムカタログのインデックスも含みます。
ユーザテーブルのインデックスは処理されません。
この構文の<code class="command">REINDEX</code>をトランザクションブロック内で実行することはできません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>インデックスを再作成するインデックス、テーブル、データベースの名前です。
インデックスとテーブルはスキーマ修飾可能です。
現状では、<code class="command">REINDEX DATABASE</code>と<code class="command">REINDEX SYSTEM</code>は現在のデータベースのインデックスのみを再作成することができます。
そのため、このパラメータは現在のデータベース名と一致する必要があります。
     </p></dd><dt><span class="term"><code class="literal">VERBOSE</code></span></dt><dd><p>各インデックスが再作成されるときに、進捗レポートを表示します。
     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.156.7"><h2>注釈</h2><p>ユーザテーブル上の特定のインデックスに破損の疑いがある場合、<code class="command">REINDEX INDEX</code>を使ってそのインデックスを再構築することもできますし、<code class="command">REINDEX TABLE</code>を使ってそのテーブルのすべてのインデックスを再構築することもできます。
  </p><p>システムテーブルのインデックスの破損を復旧する場合の手順はより複雑になります。
この場合、システムによって破損の可能性があるインデックス自体が使用されないようにすることが重要です
（実際は、このようなケースでは、破損したインデックスに依存していたため、サーバプロセスが起動時に強制終了してしまう可能性があります）。
安全に復旧させるには、システムカタログ検索時のインデックスの使用を禁止する<code class="option">-P</code>オプションを使用してサーバを起動しなければなりません。
  </p><p>考えられる方法の1つは次の方法です。まず、サーバを停止して、コマンドラインから<code class="option">-P</code>オプションを指定してシングルユーザ状態の<span class="productname">PostgreSQL</span>サーバを起動します。
そして、再構成する範囲に応じて、<code class="command">REINDEX DATABASE</code>、<code class="command">REINDEX SYSTEM</code>、<code class="command">REINDEX TABLE</code>、または、<code class="command">REINDEX INDEX</code>コマンドを発行します。
範囲が不明な場合は、<code class="command">REINDEX SYSTEM</code>を使用して、そのデータベースの全てのシステムインデックスを再構成してください。
その後、シングルユーザ状態のサーバセッションを停止して、通常のサーバを再起動します。
シングルユーザ状態のサーバインタフェースの操作方法についての詳細は、<a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a>マニュアルページを参照してください。
  </p><p>その他、コマンドラインで<code class="option">-P</code>を指定して通常のサーバセッションを起動することもできます。
具体的な方法は、クライアントによって異なります。
しかし、<span class="application">libpq</span>ベースのクライアントであれば、クライアントを起動する前に環境変数<code class="envar">PGOPTIONS</code>を<code class="literal">-P</code>に設定すれば実現できます。
この方法では他のクライアントを締め出す必要はありませんが、修復が終わるまで破損したデータベースへの他のユーザの接続を防止する方が良いことに注意してください。
  </p><p><code class="command">REINDEX</code>は、インデックスの中身を1から作り直すという点では、インデックスを削除してから再作成する処理と似ています。
しかし、ロックに関しては異なります。
<code class="command">REINDEX</code>はインデックスの元となるテーブルの書き込みをロックしますが、読み込みはロックしません。
また、処理中のインデックスに対する排他ロックを取得するので、そのインデックスを使用する読み込みはブロックされます。
一方、<code class="command">DROP INDEX</code>は瞬間的に元となるテーブルの排他ロックを取得するので、書き込みも読み込みもブロックされます。
その後に行う<code class="command">CREATE INDEX</code>では書き込みのみをロックし、読み込みはロックしません。
インデックスは存在しないので、インデックスを使用する読み込みは発生しません。
したがって、読み込みがブロックされることはありませんが、コストが高いシーケンシャルスキャンの使用を強制されることになります。
  </p><p>単一インデックスまたは単一テーブルのインデックス再作成を行うには、そのインデックスまたはテーブルの所有者でなければなりません。
データベースに対するインデックス再作成を行うには、データベースの所有者でなければなりません（したがって、この所有者は他のユーザが所有するテーブルのインデックスを再作成することができます）。
もちろん、スーパーユーザは常にすべてのインデックス再作成を行うことができます。
  </p></div><div class="refsect1" id="id-1.9.3.156.8"><h2>例</h2><p>単一のインデックスを再構築します。

</p><pre class="programlisting">REINDEX INDEX my_index;</pre><p>
  </p><p>テーブル<code class="literal">my_table</code>上のすべてのインデックスを再構築します。

</p><pre class="programlisting">REINDEX TABLE my_table;</pre><p>
  </p><p>システムインデックスが有効かどうかを確認することなく、あるデータベース内の全てのインデックスを再構築します。

</p><pre class="programlisting">$ <strong class="userinput"><code>export PGOPTIONS="-P"</code></strong>
$ <strong class="userinput"><code>psql broken_db</code></strong>
...
broken_db=&gt; REINDEX DATABASE broken_db;
broken_db=&gt; \q</pre></div><div class="refsect1" id="id-1.9.3.156.9"><h2>互換性</h2><p>標準SQLには<code class="command">REINDEX</code>はありません。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-refreshmaterializedview.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-release-savepoint.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">REFRESH MATERIALIZED VIEW </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> RELEASE SAVEPOINT</td></tr></table></div></body></html>