<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>INSERT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA" /><link rel="next" href="sql-listen.html" title="LISTEN" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">INSERT</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-listen.html" title="LISTEN">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-INSERT"><div class="titlepage"></div><a id="id-1.9.3.146.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">INSERT</span></h2><p>INSERT — テーブルに新しい行を作成する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">[ WITH [ RECURSIVE ] <em class="replaceable"><code>with_query</code></em> [, ...] ]
INSERT INTO <em class="replaceable"><code>table_name</code></em> [ AS <em class="replaceable"><code>alias</code></em> ] [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]
    [ OVERRIDING { SYSTEM | USER} VALUE ]
    { DEFAULT VALUES | VALUES ( { <em class="replaceable"><code>expression</code></em> | DEFAULT } [, ...] ) [, ...] | <em class="replaceable"><code>query</code></em> }
    [ ON CONFLICT [ <em class="replaceable"><code>conflict_target</code></em> ] <em class="replaceable"><code>conflict_action</code></em> ]
    [ RETURNING * | <em class="replaceable"><code>output_expression</code></em> [ [ AS ] <em class="replaceable"><code>output_name</code></em> ] [, ...] ]

<span class="phrase">ここで<em class="replaceable"><code>conflict_target</code></em>は以下のいずれかです。</span>

    ( { <em class="replaceable"><code>index_column_name</code></em> | ( <em class="replaceable"><code>index_expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ...] ) [ WHERE <em class="replaceable"><code>index_predicate</code></em> ]
    ON CONSTRAINT <em class="replaceable"><code>constraint_name</code></em>

<span class="phrase">また<em class="replaceable"><code>conflict_action</code></em>は以下のいずれかです。</span>

    DO NOTHING
    DO UPDATE SET { <em class="replaceable"><code>column_name</code></em> = { <em class="replaceable"><code>expression</code></em> | DEFAULT } |
                    ( <em class="replaceable"><code>column_name</code></em> [, ...] ) = [ ROW ] ( { <em class="replaceable"><code>expression</code></em> | DEFAULT } [, ...] ) |
                    ( <em class="replaceable"><code>column_name</code></em> [, ...] ) = ( <em class="replaceable"><code>sub-SELECT</code></em> )
                  } [, ...]
              [ WHERE <em class="replaceable"><code>condition</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.146.5"><h2>説明</h2><p><code class="command">INSERT</code>はテーブルに新しい行を挿入します。
値式を使用して行（複数可）を挿入すること、および、問い合わせの結果を使って0行以上の行を挿入することができます。
  </p><p>対象の列名はどのような順番でも指定できます。
列名リストが指定されなかった場合は、テーブル内の全ての列を宣言時の順番に並べたものがデフォルトとして使われます。
また、<code class="literal">VALUES</code>句や<em class="replaceable"><code>query</code></em>で<em class="replaceable"><code>N</code></em>列のみが与えられた場合は、先頭の<em class="replaceable"><code>N</code></em>列の名前が指定されたものとみなされます。
<code class="literal">VALUES</code>句や<em class="replaceable"><code>query</code></em>で提供される値は、明示的または暗黙的な列リストと左から右への順で関連付けられます
  </p><p>明示的または暗黙的な列リストにない各列にはデフォルト値（デフォルト値が宣言されていればその値、未宣言ならばNULL）が挿入されます。
  </p><p>各列の式が正しいデータ型でない場合は、自動的に型の変換が行われます。
  </p><p><code class="literal">ON CONFLICT</code>は一意制約または排他制約について、違反のエラーを発生させるのに代わる動作を指定するのに使うことができます。
（以下の<a class="xref" href="sql-insert.html#SQL-ON-CONFLICT" title="ON CONFLICT句"><code class="literal">ON CONFLICT</code>句</a>を参照してください。）
  </p><p><code class="literal">RETURNING</code>句を指定すると、<code class="command">INSERT</code>は実際に挿入された（あるいは<code class="literal">ON CONFLICT DO UPDATE</code>句によって更新された）各行に基づいて計算された値を返すようになります。
これは、通番のシーケンス番号など、デフォルトで与えられた値を取り出す時に主に便利です。
しかし、そのテーブルの列を使用した任意の式を指定することができます。
<code class="literal">RETURNING</code>リストの構文は<code class="command">SELECT</code>の出力リストと同一です。
挿入または更新に成功した行だけが返されます。
例えば、行がロックされていて、<code class="literal">ON CONFLICT DO UPDATE ... WHERE</code>句の <em class="replaceable"><code>condition</code></em>が満たされなかったために更新されなかった行は返されません。
  </p><p>テーブルに行を追加するには、そのテーブルに対して<code class="literal">INSERT</code>権限を持っている必要があります。
<code class="literal">ON CONFLICT DO UPDATE</code>がある場合は、テーブルの<code class="literal">UPDATE</code>権限も必要です。
  </p><p>列リストを指定する場合は、列挙された列に対する<code class="literal">INSERT</code>権限のみが必要です。
同様に、<code class="literal">ON CONFLICT DO UPDATE</code>が指定されている場合、更新対象として列挙されている列についてのみ、<code class="literal">UPDATE</code>権限が必要です。
しかし、<code class="literal">ON CONFLICT DO UPDATE</code>はまた、その式あるいは<em class="replaceable"><code>condition</code></em>で読み取られるすべての列についての<code class="literal">SELECT</code>権限も必要です。
  </p><p><code class="literal">RETURNING</code>句を使用するには、<code class="literal">RETURNING</code>で使用するすべての列に対する<code class="literal">SELECT</code>権限が必要です。
<em class="replaceable"><code>query</code></em>を使用して問い合わせ結果を元に行を挿入する場合は当然ながら、その問い合わせ内で使われる全てのテーブルまたは列に対して<code class="literal">SELECT</code>権限を持っている必要があります。
  </p></div><div class="refsect1" id="id-1.9.3.146.6"><h2>パラメータ</h2><div class="refsect2" id="SQL-INSERTING-PARAMS"><h3>挿入</h3><p>この節では新しい行を挿入するときにのみ使われるパラメータについて説明します。
<code class="literal">ON CONFLICT</code>句において<span class="emphasis"><em>のみ</em></span>使われるパラメータについては、別に説明します。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>with_query</code></em></span></dt><dd><p><code class="literal">WITH</code>句により、<code class="command">INSERT</code>問い合わせ内で名前により参照することができる１つ以上の副問い合わせを指定することができます。
詳しくは<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">Section 7.8</a>と<a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>を参照してください。
       </p><p><em class="replaceable"><code>query</code></em>（<code class="command">SELECT</code>文）でもまた、<code class="literal">WITH</code>句を含めることができます。
こうした場合、<em class="replaceable"><code>with_query</code></em>の集合との両方を<em class="replaceable"><code>query</code></em>内で参照することができます。
しかし、第二の問い合わせがより近くにネストされているため優先します。
       </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>既存のテーブルの名前です（スキーマ修飾名も可）。
       </p></dd><dt><span class="term"><em class="replaceable"><code>alias</code></em></span></dt><dd><p><em class="replaceable"><code>table_name</code></em>の代替名です。
aliasを指定すると、テーブルの実際の名前が完全に隠されます。
これは、<code class="varname">excluded</code>という名前のテーブルを<code class="literal">ON CONFLICT DO UPDATE</code>が対象にしている場合、これを指定しなければ、それが挿入で処理される行を表現する特別なテーブルの名前とみなされるため、特に有用となります。
       </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p><em class="replaceable"><code>table_name</code></em>で指名されたテーブル内の列名です。
必要なら列名を副フィールドの名前や配列の添え字で修飾することができます。
（複合型の列の一部のフィールドのみを挿入すると他のフィールドはNULLになります。）
<code class="literal">ON CONFLICT DO UPDATE</code>で列を参照する場合、対象列の指定にテーブル名を含めてはいけません。
例えば、<code class="literal">INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1</code>は無効です（これは<code class="command">UPDATE</code>の一般的な動作に従います）。
       </p></dd><dt><span class="term"><code class="literal">OVERRIDING SYSTEM VALUE</code></span></dt><dd><p>この句がない場合、<code class="literal">GENERATED ALWAYS</code>として定義されたIDENTITY列に（<code class="literal">DEFAULT</code>以外の）明示的な値を指定するとエラーになります。
この句はその制限よりも優先します。
       </p></dd><dt><span class="term"><code class="literal">OVERRIDING USER VALUE</code></span></dt><dd><p>この句が指定されると、<code class="literal">GENERATED BY DEFAULT</code>として定義されたIDENTITY列について指定された値はすべて無視されて、シーケンスが生成したデフォルト値が適用されます。
       </p><p>この句は例えばテーブル間で値をコピーする時に有用です。
<code class="literal">INSERT INTO tbl2 OVERRIDING USER VALUE SELECT * FROM tbl1</code>とすると、<code class="literal">tbl1</code>の列で<code class="literal">tbl2</code>のIDENTITY列でないものがすべてコピーされる一方、<code class="literal">tbl2</code>のIDENTITY列の値は、<code class="literal">tbl2</code>に紐付けられたシーケンスによって生成されます。
       </p></dd><dt><span class="term"><code class="literal">DEFAULT VALUES</code></span></dt><dd><p>全ての列に、それぞれのデフォルト値が設定されます。
（<code class="literal">OVERRIDING</code>はこの構文では使用できません。）
       </p></dd><dt><span class="term"><em class="replaceable"><code>expression</code></em></span></dt><dd><p>対応する列に代入する式または値を指定します。
       </p></dd><dt><span class="term"><code class="literal">DEFAULT</code></span></dt><dd><p>対応する列にデフォルト値を設定します。
       </p></dd><dt><span class="term"><em class="replaceable"><code>query</code></em></span></dt><dd><p>挿入する行を提供する問い合わせ（<code class="command">SELECT</code>文）を指定します。
構文の説明については<a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>文を参照してください。
       </p></dd><dt><span class="term"><em class="replaceable"><code>output_expression</code></em></span></dt><dd><p>各行が挿入または更新された後、<code class="command">INSERT</code>により計算され、返される式です。
この式には<em class="replaceable"><code>table_name</code></em>で指名されたテーブルの任意の列名を使用することができます。
挿入または更新された行のすべての列を返す場合は<code class="literal">*</code>と記載してください。
       </p></dd><dt><span class="term"><em class="replaceable"><code>output_name</code></em></span></dt><dd><p>返される列で使用される名前です。
       </p></dd></dl></div></div><div class="refsect2" id="SQL-ON-CONFLICT"><h3><code class="literal">ON CONFLICT</code>句</h3><a id="id-1.9.3.146.6.3.2" class="indexterm"></a><a id="id-1.9.3.146.6.3.3" class="indexterm"></a><p>オプションの<code class="literal">ON CONFLICT</code>句では、一意制約や排他制約の違反について、エラーを発生させる代替となる動作を指定します。
挿入しようとされた各行について、挿入の処理が進められるか、あるいは、<em class="parameter"><code>conflict_target</code></em>により指定された<span class="emphasis"><em>競合</em></span>制約またはインデックスに違反した場合の代替の<em class="parameter"><code>conflict_action</code></em>が実行されるか、のいずれかです。
<code class="literal">ON CONFLICT DO NOTHING</code>は代替の動作として、単に行の挿入をしなくなるだけです。
<code class="literal">ON CONFLICT DO UPDATE</code>は代替の動作として、挿入されようとしていた行と競合する既存の行を更新します。
   </p><p><em class="parameter"><code>conflict_target</code></em>は<span class="emphasis"><em>一意インデックスの推定</em></span>を実行することができます。
推定を実行するとき、それは1つ以上の<em class="replaceable"><code>index_column_name</code></em>列、または<em class="replaceable"><code>index_expression</code></em>式、あるいはその両方、およびオプションで<em class="replaceable"><code>index_predicate</code></em>から構成されます。
<em class="replaceable"><code>table_name</code></em>の一意インデックスで<em class="parameter"><code>conflict_target</code></em>で指定された列と式を（順序は関係なく）正確に含むものは、すべて競合解決インデックスとして推定されます（選ばれます）。
<em class="replaceable"><code>index_predicate</code></em>が指定されている場合は、推定のさらなる条件として、それは競合解決インデックスを満たさなければなりません。
これは、部分インデックスでない一意インデックス（述語のない一意インデックス）は、それが他のすべての条件を満たすのであれば推定される（従って<code class="literal">ON CONFLICT</code>で使用される）ことを意味することに注意して下さい。
推定に失敗した時は、エラーが発生します。
   </p><p><code class="literal">ON CONFLICT DO UPDATE</code>は<code class="command">INSERT</code>または<code class="command">UPDATE</code>の原子的な結果を保証します。
無関係のエラーが発生しなければ、多数の同時実行がある状況においてさえも、それら2つの結果のうちの1つになります。
これは<em class="firstterm">UPSERT</em>、つまり<span class="quote">“<span class="quote">UPDATE or INSERT</span>”</span>としても知られています。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>conflict_target</code></em></span></dt><dd><p><code class="literal">ON CONFLICT</code>が<em class="firstterm">競合解決インデックス</em>を選ぶことで代替の動作をするときの競合を指定します。
<span class="emphasis"><em>一意インデックスの推定</em></span>を実行するか、あるいは制約を明示的に指定するかのいずれかです。
<code class="literal">ON CONFLICT DO NOTHING</code>では<em class="parameter"><code>conflict_target</code></em>を指定するのはオプションです。
省略すると、利用可能なすべての制約（および一意インデックス）との競合が処理されます。
<code class="literal">ON CONFLICT DO UPDATE</code>では<em class="parameter"><code>conflict_target</code></em>を指定<span class="emphasis"><em>しなければなりません</em></span>。
       </p></dd><dt><span class="term"><em class="replaceable"><code>conflict_action</code></em></span></dt><dd><p><em class="parameter"><code>conflict_action</code></em>では<code class="literal">ON CONFLICT</code>の代替の動作を指定します。
これは<code class="literal">DO NOTHING</code>あるいは<code class="literal">DO UPDATE</code>句のいずれかをとることができ、後者では競合が発生した場合に実行される<code class="literal">UPDATE</code>の動作の正確な詳細を記述します。
<code class="literal">ON CONFLICT DO UPDATE</code>の<code class="literal">SET</code>句と<code class="literal">WHERE</code>は既存の行にテーブルの名前（または別名）を使ってアクセスでき、また挿入されようとしていた行には、特別な<code class="varname">excluded</code>テーブルを使ってアクセスできます。
<code class="varname">excluded</code>の列を読み取るときには、対象テーブルの対応する列の<code class="literal">SELECT</code>権限が必要です。
       </p><p>すべての行レベルの<code class="literal">BEFORE INSERT</code>トリガーの結果が<code class="varname">excluded</code>の値に反映されることに注意して下さい。
これらの結果として、行が挿入から除外されることになったかもしれないからです。
       </p></dd><dt><span class="term"><em class="replaceable"><code>index_column_name</code></em></span></dt><dd><p><em class="replaceable"><code>table_name</code></em>の列の名前です。
競合解決インデックスを推定するのに使われます。
<code class="command">CREATE INDEX</code>の形式に従います。
<em class="replaceable"><code>index_column_name</code></em>の<code class="literal">SELECT</code>が必要です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>index_expression</code></em></span></dt><dd><p><em class="replaceable"><code>index_column_name</code></em>と似ていますが、インデックスの定義に現れる<em class="replaceable"><code>table_name</code></em>の列の式（単純な列ではない）の推定に使われます。
<code class="command">CREATE INDEX</code>の形式に従います。
<em class="replaceable"><code>index_expression</code></em>に現れるすべての列の<code class="literal">SELECT</code>権限が必要です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>collation</code></em></span></dt><dd><p>これを指定すると、推定時に、対応する<em class="replaceable"><code>index_column_name</code></em>あるいは<em class="replaceable"><code>index_expression</code></em>をマッチさせるときに、特定の照合順序を指定することになります。
普通は照合順序は制約違反が発生するかどうかに関係しないので、通常は省略されます。
<code class="command">CREATE INDEX</code>の形式に従います。
       </p></dd><dt><span class="term"><em class="replaceable"><code>opclass</code></em></span></dt><dd><p>これを指定すると、推定時に、対応する<em class="replaceable"><code>index_column_name</code></em>あるいは<em class="replaceable"><code>index_expression</code></em>をマッチさせるときに、特定の演算子クラスを指定することになります。
<span class="emphasis"><em>等価</em></span>の意味は、いずれにせよ、型の演算子クラスをまたがって同等であることが多いですし、また定義された一意インデックスは等価を適切に定義していると信頼すれば十分なので、通常はこれは省略されます。
<code class="command">CREATE INDEX</code>の形式に従います。
       </p></dd><dt><span class="term"><em class="replaceable"><code>index_predicate</code></em></span></dt><dd><p>部分一意インデックスの推定を可能にします。
述語を満たすすべてのインデックス（実際に部分インデックスである必要はありません）は推定可能になります。
<code class="command">CREATE INDEX</code>の形式に従います。
<em class="replaceable"><code>index_predicate</code></em>に現れるすべての列について<code class="literal">SELECT</code>権限が必要です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>constraint_name</code></em></span></dt><dd><p>競合解決の<span class="emphasis"><em>制約</em></span>を制約やインデックスの推定によるのではなく、明示的に名前で指定します。
       </p></dd><dt><span class="term"><em class="replaceable"><code>condition</code></em></span></dt><dd><p><code class="type">boolean</code>型の値を返す式です。
この式が<code class="literal">true</code>を返す行のみが更新されます。
ただし、<code class="literal">ON CONFLICT DO UPDATE</code>の動作が行われるときは、すべての行がロックされます。
<em class="replaceable"><code>condition</code></em>は最後に評価される、競合が更新対象候補として特定された後であることに注意して下さい。
       </p></dd></dl></div><p>排他制約は<code class="literal">ON CONFLICT DO UPDATE</code>の競合解決としてはサポートされないことに注意して下さい。
すべての場合について、<code class="literal">NOT DEFERRABLE</code>である制約と一意インデックスのみが競合解決としてサポートされます。
   </p><p><code class="literal">ON CONFLICT DO UPDATE</code>句のある<code class="command">INSERT</code>は<span class="quote">“<span class="quote">決定論的な</span>”</span>文です。
これは、そのコマンドが既存のどの行に対しても、2回以上影響を与えることが許されない、ということを意味します。
これに反する状況が発生した時は、カーディナリティ違反のエラーが発生します。
挿入されようとする行は、競合解決インデックスあるいは制約により制限される属性の観点で、複製されてはなりません。
   </p><div class="tip"><h3 class="title">Tip</h3><p><code class="literal">ON CONFLICT ON CONSTRAINT</code> <em class="replaceable"><code> constraint_name</code></em>を使って制約を直接指定するより、一意インデックスの推定を使う方が望ましいことが多いです。
背景にあるインデックスが、他のほぼ同等のインデックスと重なり合う形で置換されるとき、推定は正しく動作し続けます。
例えば、置換されるインデックスを削除する前に<code class="literal">CREATE UNIQUE INDEX ...  CONCURRENTLY</code>を使う場合です。
    </p></div></div></div><div class="refsect1" id="id-1.9.3.146.7"><h2>出力</h2><p>正常に終了すると、<code class="command">INSERT</code>は以下のようなコマンドタグを返します。
</p><pre class="screen">INSERT <em class="replaceable"><code>oid</code></em> <em class="replaceable"><code>count</code></em></pre><p>
<em class="replaceable"><code>count</code></em>は挿入または更新された行数です。
<em class="replaceable"><code>count</code></em>が正確に1であり、対象のテーブルがOIDを持つ場合、<em class="replaceable"><code>oid</code></em>は挿入された行に割り当てられた<acronym class="acronym">OID</acronym>です。
その1行は、更新ではなく挿入された行です。
その他の場合、<em class="replaceable"><code>oid</code></em>は0となります。
  </p><p><code class="command">INSERT</code>コマンドが<code class="literal">RETURNING</code>句を持つ場合、その結果は、<code class="literal">RETURNING</code>リストで定義した列と値を持ち、そのコマンドで挿入または更新された行全体に対して計算を行う<code class="command">SELECT</code>文の結果と似たものになるでしょう。
  </p></div><div class="refsect1" id="id-1.9.3.146.8"><h2>注釈</h2><p>指定したテーブルがパーティションテーブルの場合、各行は適切なパーティションに回され、そちらに挿入されます。
指定したテーブルがパーティションの場合、挿入行にパーティションの制約に違反するものがあれば、エラーが発生します。
  </p></div><div class="refsect1" id="id-1.9.3.146.9"><h2>例</h2><p><code class="literal">films</code>テーブルに1行を挿入します。

</p><pre class="programlisting">INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');</pre><p>
  </p><p>次の例では、<code class="literal">len</code>列を省略しています。
したがって、ここにはデフォルト値が入ります。

</p><pre class="programlisting">INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');</pre><p>
  </p><p>次の例では、日付列に対して値を指定する代わりに<code class="literal">DEFAULT</code>を使用します。

</p><pre class="programlisting">INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');</pre><p>
  </p><p>全てデフォルト値からなる行を挿入します。

</p><pre class="programlisting">INSERT INTO films DEFAULT VALUES;</pre><p>
  </p><p>複数行の<code class="command">VALUES</code>構文を使用して複数行を挿入します。

</p><pre class="programlisting">INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');</pre><p>
  </p><p>次の例では、<code class="literal">films</code>テーブルと同じ列レイアウトを持つ<code class="literal">tmp_films</code>テーブルから<code class="literal">films</code>テーブルへいくつか行を挿入します。

</p><pre class="programlisting">INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';</pre><p>
  </p><p>次の例では、配列型の列に挿入します。

</p><pre class="programlisting">-- 三目並べ用の3×3マスのゲーム盤を作成します。
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
--上の例の添え字は本当は必要ありません。
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');</pre><p>
  </p><p><code class="literal">distributors</code>テーブルに一行を挿入し、その<code class="literal">DEFAULT</code>句により生成されたシーケンス番号を返します。

</p><pre class="programlisting">INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;</pre><p>
  </p><p>Acme社の顧客を担当する営業担当者の売り上げ数を増やし、ログテーブルに更新行全体と更新時刻を記録します。
</p><pre class="programlisting">WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;</pre><p>
  </p><p>新しい販売店(distributors)を適切に挿入または更新します。
<code class="literal">did</code>列に現れる値を制限する一意インデックスが定義されているものとします。
元々挿入されようとしていた値を参照するために、特別な<code class="varname">excluded</code>テーブルが使用されていることに注意して下さい。
</p><pre class="programlisting">INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;</pre><p>
  </p><p>販売店を挿入するか、あるいは挿入しようとした行について既存の除外行（before insertの行トリガを実行した後で制約列にマッチした行）がある場合は何もしません。
例では<code class="literal">did</code>列に現れる値を制限する一意インデックスがあるものとしています。
</p><pre class="programlisting">INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;</pre><p>
  </p><p>新しい販売店を適切に挿入または更新します。
例では<code class="literal">did</code>列に現れる値を制限する一意インデックスがあるものとしています。
実際に更新される行を制限するために<code class="literal">WHERE</code>句が使われています（ただし、更新されない既存の行もすべてロックされます）。
</p><pre class="programlisting">-- 特定の郵便番号については既存の販売店を更新しません
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- 文中で制約を直接指定します（DO NOTHINGの動作をする競合解決のため
-- 関連するインデックスを指定します）
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;</pre><p>
  </p><p>可能であれば新しい販売店を挿入しますが、できないときは<code class="literal">DO NOTHING</code>とします。
この例では、<code class="literal">is_active</code>というブーリアン列が<code class="literal">true</code>である行という条件で、<code class="literal">did</code>列に一意インデックスが定義されているものとしています。
</p><pre class="programlisting">-- この文は"WHERE is_active"という述語を使って、部分インデックスを
-- 推定できますが、単に"did"上の通常の一意制約を使うこともできます
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;</pre></div><div class="refsect1" id="id-1.9.3.146.10"><h2>互換性
  </h2><p><code class="command">INSERT</code>は標準SQLに準拠します。
ただし、<code class="literal">RETURNING</code>句、<code class="command">INSERT</code>で<code class="literal">WITH</code>が可能であること、<code class="literal">ON CONFLICT</code>で代替の動作を指定できることは<span class="productname">PostgreSQL</span>の拡張です。
また、標準SQLでは、列名リストが省略された時に、<code class="literal">VALUES</code>句または<em class="replaceable"><code>query</code></em>で一部の列のみを指定することはできません。
  </p><p>標準SQLでは、必ず値を生成するIDENTITY列が存在する場合にのみ<code class="literal">OVERRIDING SYSTEM VALUE</code>を指定できるとしています。
PostgreSQLではこの句はどのような場合でも指定でき、それが適用できないときには無視します。
  </p><p><em class="replaceable"><code>query</code></em>句の制限については、<a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>にて記述されています。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-importforeignschema.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-listen.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">IMPORT FOREIGN SCHEMA </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> LISTEN</td></tr></table></div></body></html>