<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>63.3. 拡張性</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="spgist-builtin-opclasses.html" title="63.2. 組み込み演算子クラス" /><link rel="next" href="spgist-implementation.html" title="63.4. 実装" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">63.3. 拡張性</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html" title="63.2. 組み込み演算子クラス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="spgist.html" title="Chapter 63. SP-GiSTインデックス">Up</a></td><th width="60%" align="center">Chapter 63. SP-GiSTインデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="spgist-implementation.html" title="63.4. 実装">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SPGIST-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">63.3. 拡張性</h2></div></div></div><p><acronym class="acronym">SP-GiST</acronym>は高度に抽象化されたインタフェースを提供します。アクセスメソッドの開発者は特定のデータ型専用のメソッドだけを開発する必要があります。
<acronym class="acronym">SP-GiST</acronym>のコアは効率的なディスクマッピングと木構造の探索を担当します。
また、同時実行制御とログ出力も担当します。
 </p><p><acronym class="acronym">SP-GiST</acronym>のツリーのリーフタプルは、インデックスの付けられた列と同じデータ型の値を含んでいます。
ルートレベルにあるリーフタプルは、必ずインデックスが付けられた元のデータの値を含んでいますが、より下のレベルのリーフタプルは、接尾辞など、圧縮された表現しか含んでいないかも知れません。
この場合、演算子クラスのサポート関数が、内部タプルをリーフレベルまでたどりながら集める情報を使って元の値を再構築できる必要があります。
 </p><p>内部タプルは、探索木の分岐点となるため、もっと複雑です。
それぞれの内部タプルは1つ以上の<em class="firstterm">ノード</em>の集合を含んでおり、ノードは類似のリーフ値のグループを表現します。
ノードは下向きのリンクを含んでおり、これは下のレベルの別の内部タプルを指すか、あるいはすべて同じインデックスページ上に載っているリーフタプルの短いリストを指しています。
それぞれのノードは、通常、それを記述する<em class="firstterm">ラベル</em>を持っています。
例えば、基数木では、ノードのラベルは文字列の値の次の文字にすることができます。
（あるいは、すべての内部タプルについて、決まったノードの集合しか扱わないのであれば、演算子クラスはノードのラベルを省略することができます。
<a class="xref" href="spgist-implementation.html#SPGIST-NULL-LABELS" title="63.4.2. ノードラベルのないSP-GiST">Section 63.4.2</a>を参照してください。）
省略可能ですが、内部タプルはそのすべてのメンバーを記述する<em class="firstterm">接頭辞</em>の値を持つことができます。
基数木では、これは表現される文字列に共通の接頭辞とすることができます。
接頭辞の値は、必ずしも本当の接頭辞である必要はなく、演算子クラスが必要とする任意の値で良いです。
例えば四分木では、その中心点を保持し、4つの象限をそこから相対的に測るようにできます。
そうすると、四分木の内部タプルはこの中心点の周りの象限に対応する4つのノードも含むことになるでしょう。
 </p><p>木構造のアルゴリズムには、現在のタプルのレベル(深さ)を知っていることが必要なものがあります。そこで、<acronym class="acronym">SP-GiST</acronym>のコアは、演算子クラスが木構造をたどって下がるときにレベル数の管理を可能にしています。
また、必要であれば、表現される値を加算的に再構築すること、また木構造を下る間に追加データ（<em class="firstterm">探索値</em>と呼ばれます）を渡すこともサポートしています。
 </p><div class="note"><h3 class="title">Note</h3><p><acronym class="acronym">SP-GiST</acronym>のコアのコードはnullエントリについても対応しています。
<acronym class="acronym">SP-GiST</acronym>のインデックスはインデックス列がnullのエントリについても格納しますが、これはインデックスの演算子クラスのコードからは隠されているので、nullのインデックスエントリや検索条件が演算子クラスのメソッドに渡されることはありません。
(<acronym class="acronym">SP-GiST</acronym>の演算子は厳格なのでNULL値について成功を返すことはできないと想定されています。)
従って、ここではこれ以上、NULLについて議論しません。
  </p></div><p><acronym class="acronym">SP-GiST</acronym>のインデックス演算子クラスが提供しなければならないユーザ定義メソッドが5つあります。
5つのメソッドはいずれも2つの<code class="type">internal</code>引数をとり、1番目の引数はサポートメソッドの入力値を含むCの構造体へのポインタ、2番目の引数は出力値が置かれるCの構造体へのポインタという形式に従っています。
メソッドのうち4つは、その結果がすべて出力構造体の中にあるので、単に<code class="type">void</code>を返しますが、<code class="function">leaf_consistent</code>は、さらに<code class="type">boolean</code>の結果を返します。
メソッドは、その入力構造体のどのフィールドも変更してはいけません。
どんな場合でも、出力構造体はユーザ定義メソッドを呼び出す前にゼロに初期化されます。
 </p><p>5つのユーザ定義メソッドは以下のとおりです。
 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">config</code></span></dt><dd><p>接頭辞とノードラベルのデータ型のデータ型OIDを含め、インデックスの実装に関する静的情報を返します。
      </p><p>関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。
</p><pre class="programlisting">CREATE FUNCTION my_config(internal, internal) RETURNS void ...</pre><p>
1番目の引数はCの<code class="structname">spgConfigIn</code>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<code class="structname">spgConfigOut</code>構造体へのポインタで、関数が結果のデータを入れます。
</p><pre class="programlisting">typedef struct spgConfigIn
{
    Oid         attType;        /* インデックス付けされるデータ型 */
} spgConfigIn;

typedef struct spgConfigOut
{
    Oid         prefixType;     /* 内部タプルの接頭辞のデータ型 */
    Oid         labelType;      /* 内部タプルのノードのラベルのデータ型 */
    bool        canReturnData;  /* 演算子クラスは元のデータを再構築できる */
    bool        longValuesOK;   /* 演算子クラスは1ページより大きな値を扱える */
} spgConfigOut;</pre><p>

<code class="structfield">attType</code>は多様のインデックス演算子クラスをサポートするために渡されます。
通常の固定データ型の演算子クラスでは、それは常に同じ値を持っているので無視できます。
     </p><p>接頭辞を使わない演算子クラスでは、<code class="structfield">prefixType</code>を<code class="literal">VOIDOID</code>に設定することができます。
同様に、ノードラベルを使わない演算子クラスでは、<code class="structfield">labelType</code>を<code class="literal">VOIDOID</code>に設定することができます。
演算子クラスが、元々提供されていたインデックスの値を再構築できるときは、<code class="structfield">canReturnData</code>をtrueにします。
<code class="structfield">attType</code>が可変長で、演算子クラスが接尾辞付けの繰り返しによって長い値を分割できるときにのみ、<code class="structfield">longValuesOK</code>をtrueにします(<a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="63.4.1. SP-GiSTの制限">Section 63.4.1</a>参照)。
     </p></dd><dt><span class="term"><code class="function">choose</code></span></dt><dd><p>内部タプルに新しい値を挿入するときのメソッドを選択します。
      </p><p>関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。
</p><pre class="programlisting">CREATE FUNCTION my_choose(internal, internal) RETURNS void ...</pre><p>
1番目の引数はCの<code class="structname">spgChooseIn</code>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<code class="structname">spgChooseOut</code>構造体へのポインタで、関数が結果のデータを入れます。
</p><pre class="programlisting">typedef struct spgChooseIn
{
    Datum       datum;          /* インデックス付けされる元のデータ */
    Datum       leafDatum;      /* リーフに保存されている現在のデータ */
    int         level;          /* (0から数えた)現在のレベル */

    /* 現在の内部タプルからのデータ */
    bool        allTheSame;     /* タプルはall-the-sameの印を付けられているか */
    bool        hasPrefix;      /* タプルは接頭辞を持っているか */
    Datum       prefixDatum;    /* そうであれば、接頭辞の値 */
    int         nNodes;         /* 内部タプル内のノード数 */
    Datum      *nodeLabels;     /* ノードのラベルの値(なければNULL) */
} spgChooseIn;

typedef enum spgChooseResultType
{
    spgMatchNode = 1,           /* 既存のノードに下がる */
    spgAddNode,                 /* ノードに内部タプルを追加する */
    spgSplitTuple               /* 内部タプルを分割する(その接頭辞を変更する) */
} spgChooseResultType;

typedef struct spgChooseOut
{
    spgChooseResultType resultType;     /* アクションコード、上記参照 */
    union
    {
        struct                  /* spgMatchNodeの結果 */
        {
            int         nodeN;      /* このノードに下がる(0からのインデックス) */
            int         levelAdd;   /* この分だけレベルを増やす */
            Datum       restDatum;  /* 新しいリーフデータ */
        }           matchNode;
        struct                  /* spgAddNodeの結果 */
        {
            Datum       nodeLabel;  /* 新しいノードのラベル */
            int         nodeN;      /* 挿入する場所(0からのインデックス) */
        }           addNode;
        struct                  /* spgSplitTupleの結果 */
        {
            /* 子タプルを1つ持つ新しい上位のレベルの内部タプルを生成するための情報 */
            bool        prefixHasPrefix;    /* タプルは接頭辞を持つか */
            Datum       prefixPrefixDatum;  /* そうならば、その値 */
            int         prefixNNodes;       /* ノード数 */
            Datum      *prefixNodeLabels;   /* そのラベル(ラベルがなければNULL) */
            int         childNodeN;         /* どのタプルが子タプルを得るか */

            /* 古いノードをすべて持つ新しい低位の内部タプルを生成するための情報 */
            bool        postfixHasPrefix;   /* タプルは接頭辞を持つか */
            Datum       postfixPrefixDatum; /* そうならば、その値 */
        }           splitTuple;
    }           result;
} spgChooseOut;</pre><p>

<code class="structfield">datum</code>はインデックスに挿入される元のデータです。
<code class="structfield">leafDatum</code>は最初は<code class="structfield">datum</code>と同じですが、<code class="function">choose</code>あるいは<code class="function">picksplit</code>メソッドがそれを変更すると、ツリーのより低いレベルで変更されることがあります。
挿入の探索がリーフのページに到達したとき、<code class="structfield">leafDatum</code>の現在値が、新しく作成されるリーフタプルに格納される値となります。
<code class="structfield">level</code>は、ルートレベルを0として、現在の内部タプルのレベルを示します。
現在の内部タプルが複数の同等なノードを含むとして印を付けられているとき、<code class="structfield">allTheSame</code>をtrueにします(<a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="63.4.3. “All-the-same”内部タプル">Section 63.4.3</a>参照)。
現在の内部タプルが接頭辞を含むとき、<code class="structfield">hasPrefix</code>をtrueにします。
このとき、<code class="structfield">prefixDatum</code>がその値になります。
<code class="structfield">nNodes</code>は内部タプルが含む子ノードの数で、<code class="structfield">nodeLabels</code>はそれらのラベル値の配列、あるいはラベルがなければNULLになります。
      </p><p><code class="function">choose</code>関数は、新しい値が既存の子ノードの1つとマッチするか、新しい子ノードを追加する必要があるか、あるいは新しい値がタプルの接頭辞と適合しないので内部タプルを分割してより制限のない接頭辞を作成する必要があるか、を決定することができます。
      </p><p>新しい値が既存の子ノードの1つにマッチしたときは、<code class="structfield">resultType</code>を<code class="literal">spgMatchNode</code>にセットします。
<code class="structfield">nodeN</code>はノードの配列中のそのノードの(0からの)番号にセットします。
<code class="structfield">levelAdd</code>は、そのノードをたどって下がるときに生じた<code class="structfield">level</code>の増分にセットします。あるいは演算子クラスがレベルを使っていなければ0のままにします。
<code class="structfield">restDatum</code>は、演算子クラスがデータをあるレベルから次のレベルに変更しないのであれば、<code class="structfield">datum</code>に等しくセットします。そうでなければ、次のレベルで<code class="structfield">leafDatum</code>として使われる修正された値にセットします。
      </p><p>新しい子ノードを追加しなければならないときは、<code class="structfield">resultType</code>を<code class="literal">spgAddNode</code>にセットします。
<code class="structfield">nodeLabel</code>は、新しいノードで使われるラベルにセットし、<code class="structfield">nodeN</code>はノードの配列中の挿入される場所のノードの(0からの)番号にセットします。
ノードを追加した後で、<code class="function">choose</code>関数を修正された内部タプルを使って再び呼び出しますが、このときは、<code class="literal">spgMatchNode</code>という結果になるはずです。
      </p><p>新しい値がタプルの接頭辞と適合しないときは、<code class="structfield">resultType</code>を<code class="literal">spgSplitTuple</code>にセットします。
このアクションは、すべての既存のノードを新しい低位の内部タプルに移動し、新しい低位の内部タプルを指す単一の下向きのリンクを持つ新しいタプルで既存のタプルを置換します。
<code class="structfield">prefixHasPrefix</code>は新しい上位のタプルが接頭辞を持つかどうかを示し、持つ場合には<code class="structfield">prefixPrefixDatum</code>をその接頭辞の値にセットします。
インデックスに追加される新しい値を受け入れるため、新しい接頭辞の値は元のものよりも十分に制限の緩いものになっていなければなりません。
<code class="structfield">prefixNNodes</code>は新しいタプルで必要なノード数にセットし、<code class="structfield">prefixNodeLabels</code>はラベルを保持するためにpallocされた配列に、ノードのラベルが必要でないときはNULLにセットします。
新しい上位のタプルの全サイズは置き換えるタプルの全サイズよりも大きくはないことに注意してください。これは新しい接頭辞と新しいラベルの長さを制約します。
<code class="structfield">childNodeN</code>は、新しい低位の内部タプルへ下向きにリンクするノードの(0からの)番号にセットします。
<code class="structfield">postfixHasPrefix</code>は、新しい低位のタプルが接頭辞を持つかどうかを示し、持つときには<code class="structfield">postfixPrefixDatum</code>を接頭辞の値にセットします。
新しい低位に移動したタプルのノードのラベルを変更する機会も、子のインデックスのエントリを変更する機会もありませんから、これら2つの接頭辞と(もしあれば)下向きのリンクのノードのラベルの組み合わせは、元の接頭辞と同じ意味を持つ必要があります。
ノードが分割された後で、置換した内部タプルを使って<code class="function">choose</code>関数を再び呼び出します。
この呼び出しは、<code class="literal">spgSplitTuple</code>アクションにより適切なノードが作られなければ、<code class="literal">spgAddNode</code>という結果になります。
そのうち、<code class="function">choose</code>が<code class="literal">spgMatchNode</code>を返し、次のレベルに下がる挿入が可能となります。
      </p></dd><dt><span class="term"><code class="function">picksplit</code></span></dt><dd><p>リーフタプルの集合に対し、新しい内部タプルをどうやって作るかを決定します。
      </p><p>関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。
</p><pre class="programlisting">CREATE FUNCTION my_picksplit(internal, internal) RETURNS void ...</pre><p>
1番目の引数はCの<code class="structname">spgPickSplitIn</code>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<code class="structname">spgPickSplitOut</code>構造体へのポインタで、関数が結果のデータを入れます。
</p><pre class="programlisting">typedef struct spgPickSplitIn
{
    int         nTuples;        /* リーフタプルの数 */
    Datum      *datums;         /* そのデータ(長さnTuplesの配列) */
    int         level;          /* (0から数えた)現在のレベル */
} spgPickSplitIn;

typedef struct spgPickSplitOut
{
    bool        hasPrefix;      /* 新しい内部タプルは接頭辞を持つか */
    Datum       prefixDatum;    /* もしそうなら、その値 */

    int         nNodes;         /* 新しい内部タプルのノード数 */
    Datum      *nodeLabels;     /* そのラベル(ラベルがなければNULL) */

    int        *mapTuplesToNodes;   /* 各リーフタプルへのノードのインデックス */
    Datum      *leafTupleDatums;    /* 新しい各リーフタプルに保存されているデータ */
} spgPickSplitOut;</pre><p>

<code class="structfield">nTuples</code>は入力されるリーフタプルの個数です。
<code class="structfield">datums</code>はデータの値の配列です。
<code class="structfield">level</code>はすべてのリーフタプルの現在のレベルで、これが新しい内部タプルのレベルになります。
      </p><p><code class="structfield">hasPrefix</code>は新しい内部タプルが接頭辞を持つかどうかを示し、持つ場合は<code class="structfield">prefixDatum</code>を接頭辞の値にセットします。
<code class="structfield">nNodes</code>は新しい内部タプルが含むノードの数を示し、<code class="structfield">nodeLabels</code>はそのラベル値の配列に、ノードのラベルが必要でないときはNULLにセットします。
<code class="structfield">mapTuplesToNodes</code>は、それぞれのリーフタプルが割り当てられるノードの(0からの)番号の配列にセットします。
<code class="structfield">leafTupleDatums</code>は新しいリーフタプルに格納される値の配列にセットします(演算子クラスがデータをあるレベルから次のレベルに変更しなければこれらは入力の<code class="structfield">datums</code>と同じになります)。
<code class="function">picksplit</code>関数は、<code class="structfield">nodeLabels</code>、<code class="structfield">mapTuplesToNodes</code>、<code class="structfield">leafTupleDatums</code>の配列についてpallocしなければならないことに注意してください。
      </p><p>2つ以上のリーフタプルを与えた場合、<code class="function">picksplit</code>関数はそれらを2つ以上のノードに分類すると予想されます。そうでなければ、リーフタプルを複数のページにまたがって分割するという、この操作の究極の目的を実現できないからです。
従って、<code class="function">picksplit</code>がすべてのリーフタプルを同じノードに置くことになった場合には、SP-GiSTのコアのコードがその決定を覆して内部タプルを生成し、その中の複数の同一のラベルが付けられたノードに、リーフタプルが無作為に割り当てられます。
そのようなタプルは、このことが発生したことを明示するため、<code class="literal">allTheSame</code>と印がつけられます。
<code class="function">choose</code>関数と<code class="function">inner_consistent</code>関数は、これらの内部タプルについて、適切な注意をして取り扱わなければなりません。
詳細な情報は<a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="63.4.3. “All-the-same”内部タプル">Section 63.4.3</a>を参照してください。
      </p><p><code class="function">config</code>関数が<code class="structfield">longValuesOK</code>をtrueにセットし、1ページよりも大きな入力値を与える場合にのみ、<code class="function">picksplit</code>を1つだけのリーフタプルに適用できます。
この場合の操作の重要な点は、接頭辞をはがして、新しい、より短いリーフデータの値を生成することです。
この呼出は、1ページに収まる短さのリーフデータが生成されるまで繰り返されます。
詳細な情報は<a class="xref" href="spgist-implementation.html#SPGIST-LIMITS" title="63.4.1. SP-GiSTの制限">Section 63.4.1</a>を参照してください。
      </p></dd><dt><span class="term"><code class="function">inner_consistent</code></span></dt><dd><p>ツリーの探索でたどるべきノード(枝)の集合を返します。
      </p><p>関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。
</p><pre class="programlisting">CREATE FUNCTION my_inner_consistent(internal, internal) RETURNS void ...</pre><p>
1番目の引数はCの<code class="structname">spgInnerConsistentIn</code>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<code class="structname">spgInnerConsistentOut</code>構造体へのポインタで、関数が結果のデータを入れます。

</p><pre class="programlisting">typedef struct spgInnerConsistentIn
{
    ScanKey     scankeys;       /* 演算子と比較する値の配列 */
    int         nkeys;          /* 配列の長さ */

    Datum       reconstructedValue;     /* 親で再構築された値 */
    void       *traversalValue; /* 演算子クラスに固有の探索値 */
    MemoryContext traversalMemoryContext;   /* 新しい探索値をここに入れる */
    int         level;          /* (0から数えた)現在のレベル */
    bool        returnData;     /* 元のデータを返さなければならないか */

    /* 現在の内部タプルからのデータ */
    bool        allTheSame;     /* タプルはall-the-sameと印が付けられているか */
    bool        hasPrefix;      /* タプルは接頭辞を持つか */
    Datum       prefixDatum;    /* もしそうなら、接頭辞の値 */
    int         nNodes;         /* 内部タプルの中のノード数 */
    Datum      *nodeLabels;     /* ノードのラベルの値(なければNULL) */
} spgInnerConsistentIn;

typedef struct spgInnerConsistentOut
{
    int         nNodes;         /* 訪れるべき子ノードの数 */
    int        *nodeNumbers;    /* ノードの配列でのそのインデックス */
    int        *levelAdds;      /* この分だけそれぞれレベルを挙げる */
    Datum      *reconstructedValues;    /* 関連する再構築された値 */
    void      **traversalValues;        /* 演算子クラスに固有の探索値 */
} spgInnerConsistentOut;</pre><p>

配列<code class="structfield">scankeys</code>は長さが<code class="structfield">nkeys</code>で、インデックス検索の条件を記述します。
複数の条件はANDで結合されます。つまり、条件のすべてを満たすインデックスエントリのみが対象となります。
(<code class="structfield">nkeys</code>が0ならば、すべてのエントリが検索条件を満たすことになる、ということに注意してください。)
通常、consistent関数では、配列のそれぞれのエントリの<code class="structfield">sk_strategy</code>および<code class="structfield">sk_argument</code>フィールドのみが問題となります。これらのフィールドにはそれぞれインデックス付け可能な演算子と比較値が入ります。
なお、比較値がNULLかどうかを確認するために<code class="structfield">sk_flags</code>を検査する必要はありません。なぜならSP-GiSTのコアのコードがそのような条件を除外するからです。
<code class="structfield">reconstructedValue</code>は親タプルのために再構築された値で、ルートレベルの場合、あるいは親レベルの<code class="function">inner_consistent</code>関数が値を返さなかった場合は<code class="literal">(Datum) 0</code>となります。
<code class="structfield">traversalValue</code>は親インデックスのタプルの<code class="function">inner_consistent</code>の前の呼び出しから渡された探索データへのポインタで、ルートレベルならNULLです。
<code class="structfield">traversalMemoryContext</code>は出力探索値が格納されるメモリコンテキストです（以下を参照）。
<code class="structfield">level</code>は現在の内部タプルのレベルを、ルートレベルを0として数えたものです。
<code class="structfield">returnData</code>は、この問い合わせで再構築されたデータが必要な場合に<code class="literal">true</code>となりますが、これは<code class="function">config</code>関数が<code class="structfield">canReturnData</code>を確認した場合にのみ、そうなります。
<code class="structfield">allTheSame</code>は、現在の内部タプルに<span class="quote">“<span class="quote">all-the-same</span>”</span>の印が付いている場合にtrueになります。この場合、すべてのノードは(ラベルがあれば)同じラベルを持っていますから、そのすべてが問い合わせにマッチするか、いずれもマッチしないかのいずれかになります(<a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="63.4.3. “All-the-same”内部タプル">Section 63.4.3</a>参照)。
<code class="structfield">hasPrefix</code>は現在の内部タプルが接頭辞を持っている場合にtrueとなり、このとき<code class="structfield">prefixDatum</code>がその値となります。
<code class="structfield">nNodes</code>は内部タプルが含む子ノードの数です。<code class="structfield">nodeLabels</code>はそれらのラベル値の配列で、ノードにラベルがないときはNULLになります。
      </p><p><code class="structfield">nNodes</code>は探索で訪れる必要のある子ノードの数にセットされなければなりません。また、<code class="structfield">nodeNumbers</code>はそれらの番号の配列にセットされなければなりません。
演算子クラスがレベルを監視しているときは、それぞれのノードへと下って訪れるときに必要なレベルの増分の配列を<code class="structfield">levelAdds</code>にセットします。
(この増分はすべてのノードについて同じになることも多いですが、必ずしもそうなるとは限らないので配列が使われます。)
値の再構築が必要なときには、訪れるそれぞれの子ノードについて再構築された値の配列を<code class="structfield">reconstructedValues</code>にセットします。再構築が必要でなければ、<code class="structfield">reconstructedValues</code>をNULLのままにします。
追加の外部情報（<span class="quote">“<span class="quote">探索値</span>”</span>）をツリー探索の下位レベルに渡したい場合は、<code class="structfield">traversalValues</code>を適切な探索値、訪れるそれぞれの子ノードについて1つの配列にセットします。
それ以外の場合は<code class="structfield">traversalValues</code>をNULLのままにします。
<code class="function">inner_consistent</code>関数は、現在のメモリコンテキスト内の<code class="structfield">nodeNumbers</code>、<code class="structfield">levelAdds</code>、<code class="structfield">reconstructedValues</code>、<code class="structfield">traversalValues</code>の配列についてpallocしなければならないことに注意してください。
ただし、<code class="structfield">traversalValues</code>配列が指すすべての出力探索値は<code class="structfield">traversalMemoryContext</code>内に割り当てられます。
それぞれの探索値は1つのpallocされた塊でなければなりません。
      </p></dd><dt><span class="term"><code class="function">leaf_consistent</code></span></dt><dd><p>リーフタプルが問い合わせを満たす場合、trueを返します。
      </p><p>関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。
</p><pre class="programlisting">CREATE FUNCTION my_leaf_consistent(internal, internal) RETURNS bool ...</pre><p>
1番目の引数はCの<code class="structname">spgLeafConsistentIn</code>構造体へのポインタで、関数の入力データを含みます。
2番目の引数はCの<code class="structname">spgLeafConsistentOut</code>構造体へのポインタで、関数が結果のデータを入れます。
</p><pre class="programlisting">typedef struct spgLeafConsistentIn
{
    ScanKey     scankeys;       /* 演算子と比較する値の配列 */
    int         nkeys;          /* 配列の長さ */

    Datum       reconstructedValue;     /* 親で再構築された値 */
    void       *traversalValue; /* 演算子クラスに固有の探索値 */
    int         level;          /* (0から数えた)現在のレベル */
    bool        returnData;     /* 元のデータを返さなければならないか */

    Datum       leafDatum;      /* リーフタプルのデータ */
} spgLeafConsistentIn;

typedef struct spgLeafConsistentOut
{
    Datum       leafValue;      /* もしあれば、再構築された元のデータ */
    bool        recheck;        /* 演算子を再チェックする必要があればtrue */
} spgLeafConsistentOut;</pre><p>

配列<code class="structfield">scankeys</code>は長さが<code class="structfield">nkeys</code>で、インデックス探索の条件を記述します。
複数の条件はANDで結合されます。つまり、条件のすべてを満たすインデックスエントリのみが対象となります。
(<code class="structfield">nkeys</code>が0ならば、すべてのエントリが検索条件を満たすことになる、ということに注意してください。)
通常、consistent関数では、配列のそれぞれのエントリの<code class="structfield">sk_strategy</code>および<code class="structfield">sk_argument</code>フィールドのみが問題となります。これらのフィールドにはそれぞれインデックス付け可能な演算子と比較値が入ります。
なお、比較値がNULLかどうかを確認するために<code class="structfield">sk_flags</code>を検査する必要はありません。なぜならSP-GiSTのコアのコードがそのような条件を除外するからです。
<code class="structfield">reconstructedValue</code>は親タプルのために再構築された値で、ルートレベルの場合、あるいは親レベルの<code class="function">inner_consistent</code>関数が値を返さなかった場合は<code class="literal">(Datum) 0</code>となります。
<code class="structfield">traversalValue</code>は親インデックスのタプルの<code class="function">inner_consistent</code>の前の呼び出しから渡された探索データへのポインタで、ルートレベルならNULLです。
<code class="structfield">level</code>は現在のリーフタプルのレベルを、ルートレベルを0として数えたものです。
<code class="structfield">returnData</code>は、この問い合わせで再構築されたデータが必要な場合に<code class="literal">true</code>となりますが、これは<code class="function">config</code>関数が<code class="structfield">canReturnData</code>を確認した場合にのみ、そうなります。
<code class="structfield">leafDatum</code>は現在のリーフタプルに格納されている鍵の値です。
      </p><p>この関数は、リーフタプルが問い合わせにマッチすれば<code class="literal">true</code>を返し、マッチしなければ<code class="literal">false</code>を返します。
<code class="literal">true</code>の場合、<code class="structfield">returnData</code>が<code class="literal">true</code>であれば、<code class="structfield">leafValue</code>は、このリーフタプルにインデックス付けするために元々提供された値にセットされなければなりません。
また、マッチするかどうかが不確実で、マッチするかの確認のために実際のヒープタプルに演算子を再適用しなければならないときは、<code class="structfield">recheck</code>が<code class="literal">true</code>にセットされることがあります。
      </p></dd></dl></div><p>SP-GiSTのすべてのサポートメソッドは、通常は短期間有効なメモリコンテキスト内で呼び出されます。つまり、それぞれのタプルについて処理した後で<code class="varname">CurrentMemoryContext</code>はリセットされます。
したがって、pallocしたものすべてについてpfreeすることを気にかけることはあまり重要ではありません。
(<code class="function">config</code>メソッドは例外で、メモリリークを避けるようにする必要があります。
しかし、通常は<code class="function">config</code>メソッドは、パラメータとして渡された構造体に定数を代入する以外、何もする必要がありません。)
  </p><p>インデックス付けされた列が照合可能なデータ型の場合、インデックスの照合は、標準的な<code class="function">PG_GET_COLLATION()</code>の仕組みを使ってすべてのサポートメソッドに渡されます。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spgist-builtin-opclasses.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="spgist.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="spgist-implementation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">63.2. 組み込み演算子クラス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 63.4. 実装</td></tr></table></div></body></html>