<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>26.4. この他のログシッピングの方法</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="warm-standby-failover.html" title="26.3. フェールオーバ" /><link rel="next" href="hot-standby.html" title="26.5. ホットスタンバイ" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">26.4. この他のログシッピングの方法</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="warm-standby-failover.html" title="26.3. フェールオーバ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="Chapter 26. 高可用性、負荷分散およびレプリケーション">Up</a></td><th width="60%" align="center">Chapter 26. 高可用性、負荷分散およびレプリケーション</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="hot-standby.html" title="26.5. ホットスタンバイ">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LOG-SHIPPING-ALTERNATIVE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">26.4. この他のログシッピングの方法</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="log-shipping-alternative.html#WARM-STANDBY-CONFIG">26.4.1. 実装</a></span></dt><dt><span class="sect2"><a href="log-shipping-alternative.html#WARM-STANDBY-RECORD">26.4.2. レコードベースのログシッピング</a></span></dt></dl></div><p>これまでの節で説明した組み込みのスタンバイモードの他の方法として、アーカイブ場所を順次問い合わせる<code class="varname">restore_command</code>を使用する方法があります。
これはバージョン8.4以前では唯一の利用可能な選択肢でした。
この設定では、スタンバイ操作で必要とするポーリングを自身で実施しますので、<code class="varname">standby_mode</code>を無効にします。
このリファレンス実装として<a class="xref" href="pgstandby.html" title="pg_standby"><span class="refentrytitle"><span class="application">pg_standby</span></span></a>を参照してください。
   </p><p>このモードでは、サーバは1度に1つのWALファイルを適用することに注意してください。
このため問い合わせ用にスタンバイサーバを使用する場合(ホットスタンバイを参照)、マスタにおける動作とそれがスタンバイで可視になるまでの間に、WALファイルをみたすために必要とする時間に相当する、遅延が存在します。
<code class="varname">archive_timeout</code>を使用して遅延を短くすることができます。
また、この方法とストリーミングレプリケーションと組み合わせることができないことにも注意してください。
   </p><p>プライマリおよびスタンバイサーバの両方で発生する操作は通常の継続的なアーカイブ処理とリカバリ処理です。
2つのデータベースサーバが連携する唯一の点は、両者が共有するWALファイルのアーカイブです。
プライマリがアーカイブに書き出し、スタンバイがアーカイブから読み取ります。
注意して他のプライマリサーバ由来のWALアーカイブが混在しないことを確実にしなければなりません。
さもないと混乱が発生します。
スタンバイ操作でのみ必要なものですので、アーカイブは必ずしも巨大になりません。
   </p><p>2つの疎結合サーバを協調させる秘訣は簡単で、スタンバイサーバにて使用される<code class="varname">restore_command</code>です。
これは次のWALファイルを問い合わせ、それをプライマリから利用可能になるまで待機します。
この<code class="varname">restore_command</code>はスタンバイサーバの<code class="filename">recovery.conf</code>ファイルで指定されます。
通常のリカバリ処理はWALアーカイブからファイルを要求し、ファイルが利用できなければ失敗を報告します。
スタンバイ処理では、次のWALファイルを入手できないことは異常ではありませんので、スタンバイは利用可能になるまで待機しなければなりません。
<code class="literal">.history</code>で終わるファイルについては、待機する必要はなく、非ゼロの終了コードを返さなければなりません。
<code class="varname">restore_command</code>を待機させるには、次のWALファイルの存在を確認した後にループする独自のスクリプトを作成することで実現できます。
また、<code class="varname">restore_command</code>に割り込み、ループを終了させ、ファイルが存在しないというエラーをスタンバイサーバに返す、フェールオーバを発生させる何らかの方法がなければなりません。
これがリカバリ処理を停止しますので、スタンバイサーバは通常のサーバになります。
   </p><p><code class="varname">restore_command</code>の擬似コードの一例は以下です。
</p><pre class="programlisting">triggered = false;
while (!NextWALFileReady() &amp;&amp; !triggered)
{
    sleep(100000L);         /* wait for ~0.1 sec */
    if (CheckForExternalTrigger())
        triggered = true;
}
if (!triggered)
        CopyWALFileForRecovery();</pre><p>
   </p><p>待機を行う<code class="varname">restore_command</code>の実例は<a class="xref" href="pgstandby.html" title="pg_standby"><span class="refentrytitle"><span class="application">pg_standby</span></span></a>モジュール内で提供されています。
これは上記のロジックをどのように正確に実装するかについての参照として使用すべきです。
また、これを特定の設定または環境をサポートするため必要に応じて拡張することができます。
   </p><p>フェールオーバを通知する手段は計画・設計段階で重要な部分です。
考えられる選択肢の1つは<code class="varname">restore_command</code>です。
これは各WALファイルに対して1度実行されるものですが、<code class="varname">restore_command</code>を実行するプロセスは各ファイルに対して起動・終了します。
このようにデーモンやサーバプロセスはありませんので、シグナルやシグナルハンドラを使用することはできません。
したがって、<code class="varname">restore_command</code>はフェールオーバの通知には適していません。
特にプライマリサーバ上の既知の<code class="varname">archive_timeout</code>設定と連係して使用できるならば、単純なタイムアウト機能を使用することができます。
しかし、これはネットワーク障害や高負荷なプライマリサーバによりフェールオーバが始まってしまうため、どちらかというとエラーになりやすいものです。
実現可能ならば、明示的な通知用ファイルの作成などの通知機構の方が理想的です。
   </p><div class="sect2" id="WARM-STANDBY-CONFIG"><div class="titlepage"><div><div><h3 class="title">26.4.1. 実装</h3></div></div></div><p>この代替方式を使用してスタンバイサーバを構築する短めの手順を以下に示します。
各段階の詳細については、注記していますので、前の節を参照してください。
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>できる限り同じようにプライマリシステムとスタンバイシステムを設定してください。
同じリリースレベルの<span class="productname">PostgreSQL</span>の同一コピーの導入も含みます。
      </p></li><li class="listitem"><p>プライマリサーバで、継続的アーカイブをスタンバイサーバ上のディレクトリ上にWALをアーカイブするように設定してください。
プライマリサーバで、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>および<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</a>が適切に設定されていることを確認してください（<a class="xref" href="continuous-archiving.html#BACKUP-ARCHIVING-WAL" title="25.3.1. WALアーカイブの設定">Section 25.3.1</a>を参照してください）。
      </p></li><li class="listitem"><p>プライマリサーバでベースバックアップを作成（<a class="xref" href="continuous-archiving.html#BACKUP-BASE-BACKUP" title="25.3.2. ベースバックアップの作成">Section 25.3.2</a>を参照してください）し、スタンバイサーバでこのデータをロードしてください。
      </p></li><li class="listitem"><p>スタンバイサーバで、上記の通り待機を行う<code class="varname">restore_command</code>を指定した<code class="filename">recovery.conf</code>を使用して、ローカルなWALアーカイブからリカバリ処理を実行してください（<a class="xref" href="continuous-archiving.html#BACKUP-PITR-RECOVERY" title="25.3.4. 継続的アーカイブによるバックアップを使用した復旧">Section 25.3.4</a>を参照してください）。
      </p></li></ol></div><p>
   </p><p>リカバリ処理はWALアーカイブを読み取り専用として扱います。
このため、WALファイルがスタンバイシステムにコピーされた後、スタンバイデータベースサーバによる読み取りと同時にWALファイルをテープにコピーすることができます。
このように、高可用性スタンバイサーバの実行を、災害からのリカバリを目的とした長期的な保管と同時に行うことができます。
   </p><p>試験のためにプライマリサーバとスタンバイサーバを同じシステムで稼動させることができます。
これによりサーバ堅牢性が向上することも、高可用性と呼べることもありません。
   </p></div><div class="sect2" id="WARM-STANDBY-RECORD"><div class="titlepage"><div><div><h3 class="title">26.4.2. レコードベースのログシッピング</h3></div></div></div><p>この代替手法を用いたレコード単位のログシッピングの実装も可能ですが、利用者側の開発が必要です。
さらに、完全なWALファイルが転送された後のみで、変更がホットスタンバイ問い合わせで可視になります。
   </p><p>外部プログラムは<code class="function">pg_walfile_name_offset()</code>関数（<a class="xref" href="functions-admin.html" title="9.26. システム管理関数">Section 9.26</a>を参照）を呼び出して、WALの現在の終了点のファイル名と正確なバイトオフセットを見つけ出すことができます。
そして、WALファイルに直接アクセスし、直前の既知のWAL終了点から現在の終了点までのデータをスタンバイサーバにコピーすることができます。
この方法では、データ損失期間はコピー処理プログラムの実行周期となります。
非常に短くすることができますし、部分的に使用されたセグメントファイルを強制的にアーカイブするため無駄な帯域もありません。
スタンバイサーバの<code class="varname">restore_command</code>スクリプトがWALファイル全体しか扱うことができないことに注意してください。
このため、逐次的にコピーしたデータは通常はスタンバイサーバで利用することができません。
プライマリサーバが停止した時のみこれを使用します。
その場合、プライマリサーバが立ち上がる前に、最後の部分的なWALファイルがセカンダリサーバに渡されます。
この処理の正しい実装では、データコピープログラムと<code class="varname">restore_command</code>スクリプトとの連係が必要です。
   </p><p><span class="productname">PostgreSQL</span>バージョン9.0から、同じ利点をより少ない設定で実現できるストリーミングレプリケーション(<a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. ストリーミングレプリケーション">Section 26.2.5</a>参照)を使用することができます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="warm-standby-failover.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="hot-standby.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">26.3. フェールオーバ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 26.5. ホットスタンバイ</td></tr></table></div></body></html>