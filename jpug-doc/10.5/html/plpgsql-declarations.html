<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.3. 宣言</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-structure.html" title="42.2. PL/pgSQLの構造" /><link rel="next" href="plpgsql-expressions.html" title="42.4. 式" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.3. 宣言</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-structure.html" title="42.2. PL/pgSQLの構造">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-expressions.html" title="42.4. 式">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-DECLARATIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.3. 宣言</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-PARAMETERS">42.3.1. 関数引数の宣言</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-ALIAS">42.3.2. <code class="literal">ALIAS</code></a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-TYPE">42.3.3. 型のコピー</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-ROWTYPES">42.3.4. 行型</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-RECORDS">42.3.5. レコード型</a></span></dt><dt><span class="sect2"><a href="plpgsql-declarations.html#PLPGSQL-DECLARATION-COLLATION">42.3.6. <span class="application">PL/pgSQL</span>変数の照合</a></span></dt></dl></div><p>ブロック内で使用される全ての変数はそのブロックの宣言部で宣言されなければなりません。
（唯一の例外は、<code class="literal">FOR</code>ループである整数値の範囲に渡って繰り返されるループ変数で、これは、自動的に整数型変数として宣言されます。
同様に、カーソルの結果に対して繰り返し適用される<code class="literal">FOR</code>ループのループ変数はレコード変数として自動的に宣言されます。）
    </p><p><span class="application">PL/pgSQL</span>変数は、<code class="type">integer</code>、<code class="type">varchar</code>、<code class="type">char</code>といった、任意のSQLデータ型を持つことができます。
    </p><p>変数宣言の例を以下に示します。
</p><pre class="programlisting">user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;</pre><p>
    </p><p>変数宣言の一般的な構文は以下の通りです。
</p><pre class="synopsis"><em class="replaceable"><code>name</code></em> [<span class="optional"> CONSTANT </span>] <em class="replaceable"><code>type</code></em> [<span class="optional"> COLLATE <em class="replaceable"><code>collation_name</code></em> </span>] [<span class="optional"> NOT NULL </span>] [<span class="optional"> { DEFAULT | := | = } <em class="replaceable"><code>expression</code></em> </span>];</pre><p>
<code class="literal">DEFAULT</code>句が指定された場合、ブロックに入った時に変数に代入される初期値を指定します。
<code class="literal">DEFAULT</code>句が指定されない場合、変数は<acronym class="acronym">SQL</acronym>のNULL値に初期化されます。
<code class="literal">CONSTANT</code>オプションにより、そのブロック内でその値が不変になるように、その変数への初期化後の代入は禁止されます。
<code class="literal">COLLATE</code>オプションは、変数として使用するための照合を指定します（<a class="xref" href="plpgsql-declarations.html#PLPGSQL-DECLARATION-COLLATION" title="42.3.6. PL/pgSQL変数の照合">Section 42.3.6</a>を参照してください）。
<code class="literal">NOT NULL</code>が指定された場合、NULL値の代入は実行時エラーになります。
<code class="literal">NOT NULL</code>として宣言した変数は全て、非NULLのデフォルト値を指定しなければなりません。
等号（<code class="literal">=</code>）がPL/SQLにおける代入記号（<code class="literal">:=</code>）の代わりに使用できます。
     </p><p>変数のデフォルト値はブロックに入る度に評価され、変数に代入されます（関数を呼び出す時に一度だけではありません）。
ですから、例えば<code class="literal">now()</code>を<code class="type">timestamp</code>型の変数に代入することで、その変数には関数をプリコンパイルした時刻ではなく、関数呼び出し時の現在時刻が格納されます。
     </p><p>例：
</p><pre class="programlisting">quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;</pre><p>
     </p><div class="sect2" id="PLPGSQL-DECLARATION-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">42.3.1. 関数引数の宣言</h3></div></div></div><p>関数に渡されるパラメータの名前には<code class="literal">$1</code>、<code class="literal">$2</code>という識別子が付けられます。
省略することもできますが、<code class="literal">$n</code>というパラメータ名に別名を宣言することができ、可読性が向上します。
別名、数字による識別子の両方とも引数の値を参照する時に使用することができます。
     </p><p>別名を作成する方法は2つあり、望ましい方法は<code class="command">CREATE FUNCTION</code>コマンドの中でパラメータを命名するものです。
以下に例を示します。
</p><pre class="programlisting">CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><p>
他の方法は、宣言構文を用いて別名を明確に宣言するものです。

</p><pre class="synopsis"><em class="replaceable"><code>name</code></em> ALIAS FOR $<em class="replaceable"><code>n</code></em>;</pre><p>

以下にこの方法による例を示します。
</p><pre class="programlisting">CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><p>
     </p><div class="note"><h3 class="title">Note</h3><p>この二例は完全に同等ではありません。
最初の例では、<code class="literal">subtotal</code>を<code class="literal">sales_tax.subtotal</code>で参照できますが、次の例ではできません
（その代わり、内部ブロックにラベルを付与すれば、<code class="literal">subtotal</code>をラベルで修飾することができます）。
     </p></div><p>さらに数例を示します。
</p><pre class="programlisting">CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- v_string とインデックスを使用した何らかの演算を行なう
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;</pre><p>
     </p><p><span class="application">PL/pgSQL</span>関数が出力パラメータと共に宣言されると、通常の入力パラメータと同様に、出力パラメータには<code class="literal">$<em class="replaceable"><code>n</code></em></code>というパラメータ名と任意の別名が与えられます。
出力パラメータは実質的には最初がNULL値の変数であり、関数の実行中に値が指定されるはずです。
出力パラメータの最後の値は戻り値です。
例えば、消費税の例題は、次のようにすることもできます。

</p><pre class="programlisting">CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;</pre><p>

<code class="literal">RETURNS real</code>を省略したことに注意してください。
含めることもできますが、冗長になります。
     </p><p>出力パラメータは複数の値を返す時に最も有用になります。
簡単な例題を示します。

</p><pre class="programlisting">CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;</pre><p>

<a class="xref" href="xfunc-sql.html#XFUNC-OUTPUT-PARAMETERS" title="37.4.4. 出力パラメータを持つSQL関数">Section 37.4.4</a>で述べたように、この方法は関数の結果に対する匿名のレコード型を実質的に作成します。
<code class="literal">RETURNS</code>句が与えられた時は、<code class="literal">RETURNS record</code>と言わなければなりません。
     </p><p><span class="application">PL/pgSQL</span>関数を宣言する他の方法として、<code class="literal">RETURNS TABLE</code>を伴うことが挙げられます。
以下に例を示します。

</p><pre class="programlisting">CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;</pre><p>

これは、１つ、またはそれ以上の<code class="literal">OUT</code>パラメータを宣言すること、および<code class="literal">RETURNS SETOF <em class="replaceable"><code>何らかのデータ型</code></em></code>を指定することと全く等価です。
     </p><p><span class="application">PL/pgSQL</span>関数の戻り値が多様型（<code class="type">anyelement</code>、<code class="type">anyarray</code>、<code class="type">anynonarray</code>、<code class="type">anyenum</code>または<code class="type">anyrange</code>）として宣言されると、特別な<code class="literal">$0</code>パラメータが作成されます。
このデータ型が、実際の入力型から推定（<a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="37.2.5. 多様型">Section 37.2.5</a>を参照）された関数の実際の戻り値型です。
<code class="literal">$0</code>はNULLで初期化され、関数内で変更することができます。
ですので、必須ではありませんが、これを戻り値を保持するために使用しても構いません。
また<code class="literal">$0</code>に別名を付与することもできます。
例えば、以下の関数は<code class="literal">+</code>演算子を持つ任意のデータ型に対して稼働します。

</p><pre class="programlisting">CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;</pre><p>
     </p><p>1つ以上の出力パラメータを多様型として宣言することにより、同様の結果を得ることができます。
この場合、特殊な<code class="literal">$0</code>パラメータは使用されません。
出力パラメータ自身が同じ目的を果たします。
以下に例を示します。

</p><pre class="programlisting">CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;</pre><p>
     </p></div><div class="sect2" id="PLPGSQL-DECLARATION-ALIAS"><div class="titlepage"><div><div><h3 class="title">42.3.2. <code class="literal">ALIAS</code></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>newname</code></em> ALIAS FOR <em class="replaceable"><code>oldname</code></em>;</pre><p><code class="literal">ALIAS</code>構文は前節で示したものより一般的です。
関数の引数だけではなく、任意の変数に別名を宣言することができます。
この現実的な使用は主に、トリガプロシージャにおける<code class="varname">NEW</code>や<code class="varname">OLD</code>など、前もって決まった名前の変数に別の名前を割り当てることです。
   </p><p>以下に例を示します。
</p><pre class="programlisting">DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;</pre><p>
   </p><p><code class="literal">ALIAS</code>は同じオブジェクトを命名する2つの異なる手段を提供しますので、無制限に使用すると混乱を招くかもしれません。
前もって決まっている名前を上書きする目的に限定して使用することが最善です。
   </p></div><div class="sect2" id="PLPGSQL-DECLARATION-TYPE"><div class="titlepage"><div><div><h3 class="title">42.3.3. 型のコピー</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>variable</code></em>%TYPE</pre><p><code class="type">%TYPE</code>は変数やテーブル列のデータ型を提供します。
これを使用してデータベース値を保持する変数を宣言することができます。
例えば、<code class="type">users</code>テーブルに<code class="type">user_id</code>という列があるものとします。
<code class="literal">users.user_id</code>と同じデータ型の変数を宣言するには、以下のように記述します。
</p><pre class="programlisting">user_id users.user_id%TYPE;</pre><p>
   </p><p><code class="literal">%TYPE</code>を使用することで、参照する構造のデータ型を把握する必要がなくなります。
また、これが最も重要なことですが、参照される項目のデータ型が将来変更された（例えば、user_idのテーブル定義を<code class="type">integer</code>から<code class="type">real</code>に変更した）場合でも、関数定義を変更する必要をなくすことができます。
   </p><p>内部変数用のデータ型は呼び出す度に変わるかもしれませんので<code class="literal">%TYPE</code>は特に多様関数で有用です。
関数の引数や結果用のプレースホルダに<code class="literal">%TYPE</code>を適用することで、適切な変数を作成することができます。
   </p></div><div class="sect2" id="PLPGSQL-DECLARATION-ROWTYPES"><div class="titlepage"><div><div><h3 class="title">42.3.4. 行型</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>name</code></em> <em class="replaceable"><code>table_name</code></em><code class="literal">%ROWTYPE</code>;
<em class="replaceable"><code>name</code></em> <em class="replaceable"><code>composite_type_name</code></em>;</pre><p>複合型の変数は、<em class="firstterm">行</em>変数（または<em class="firstterm">行型</em>変数）と呼ばれます。
こういった変数には、問い合わせの列集合が変数の型宣言と一致する限り、<code class="command">SELECT</code>や<code class="command">FOR</code>問い合わせの結果の行全体を保持することができます。
行変数の個々のフィールド値には、例えば、<code class="literal">rowvar.field</code>といったドット記法を使用してアクセスすることができます。
   </p><p><em class="replaceable"><code>table_name</code></em><code class="literal">%ROWTYPE</code>という記法を使用して、既存のテーブルやビューの行と同じ型を持つ行変数を宣言することができます。
もしくは、複合型の名前を付与して宣言することができます。
（全てのテーブルは、同じ名前の関連する複合型を持ちますので、実際のところ<span class="productname">PostgreSQL</span>では、<code class="literal">%ROWTYPE</code>と書いても書かなくても問題にはなりません。
しかし、<code class="literal">%ROWTYPE</code>の方がより移植性が高まります。）
   </p><p>関数へのパラメータとして複合型（テーブル行全体）を取ることができます。
その場合、対応する識別子<code class="literal">$<em class="replaceable"><code>n</code></em></code>は行変数であり、そのフィールドを、例えば、<code class="literal">$1.user_id</code>で選択することができます。
   </p><p>テーブル行のユーザ定義の属性のみに行型変数でアクセスすることができます。
OIDやその他のシステム属性にはアクセスできません（ビューからの行があり得るためです）。
行型のフィールドは、例えば<code class="type">char(<em class="replaceable"><code>n</code></em>)</code>などのテーブルのフィールドの大きさやデータ型の精度を継承します。
   </p><p>以下に複合型を使用する例を示します。
<code class="structname">table1</code>及び<code class="structname">table2</code>は、
少なくとも言及するフィールドを有する既存のテーブルです。

</p><pre class="programlisting">CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;</pre><p>
   </p></div><div class="sect2" id="PLPGSQL-DECLARATION-RECORDS"><div class="titlepage"><div><div><h3 class="title">42.3.5. レコード型</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>name</code></em> RECORD;</pre><p>レコード変数は行型変数と似ていますが、事前に定義された構造を持っていません。
これは<code class="command">SELECT</code>や<code class="command">FOR</code>コマンドの間で代入された行の実際の行構造を取ります。
レコード変数の副構造は、代入を行う度に変更できます。
つまり、レコード変数は、最初に代入されるまで副構造を持たず、したがって、フィールドへのアクセスを試みると実行時エラーが発生します。
   </p><p><code class="literal">RECORD</code>は本当のデータ型ではなく、単なるプレースホルダであることに注意してください。
<span class="application">PL/pgSQL</span>関数が<code class="type">record</code>型を返す時、この関数ではレコード変数を使用してその結果を保持することができますが、これはレコード変数としての概念とはまったく異なることを認識すべきです。
両方とも、関数の作成段階では実際の行構造は不明です。
しかし、レコード変数はその場その場でその行構造を変更できるにもかかわらず、<code class="type">record</code>を返す関数では呼び出し元の問い合わせが解析された時点で実際の構造は決定されます。
   </p></div><div class="sect2" id="PLPGSQL-DECLARATION-COLLATION"><div class="titlepage"><div><div><h3 class="title">42.3.6. <span class="application">PL/pgSQL</span>変数の照合</h3></div></div></div><a id="id-1.8.8.5.13.2" class="indexterm"></a><p><span class="application">PL/pgSQL</span>関数が照合可能なデータ型のパラメータを 1つ以上保有する場合、<a class="xref" href="collation.html" title="23.2. 照合順序サポート">Section 23.2</a>に記述したように、実際の引数に割り当てられた照合に従って、関数呼び出し毎に照合が識別されます。
照合の識別に成功した場合（すなわち、引数の間に事実上の照合における衝突がない場合）、照合可能な全てのパラメータは暗黙の照合を有するとして扱われます。
これは関数内部において、照合に依存する操作の作用に影響します。
以下の例を考えてください。

</p><pre class="programlisting">CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;</pre><p>

第一の使用方法において<code class="function">less_than</code>は、<code class="structfield">text_field_1</code>と<code class="structfield">text_field_2</code>の比較のための通常の照合として用いられます。
第二の使用方法においては、<code class="literal">C</code>照合として用いられます。
   </p><p>さらに、識別された照合は、照合可能なデータ型の全ての局所変数の照合としても仮定されます。
したがって、この関数は下に記述する関数と差異なく作動します。

</p><pre class="programlisting">CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;</pre><p>
   </p><p>照合可能なデータ型のパラメータが存在しない場合、または、それらで共通する照合順序を識別できない場合、パラメータと局所変数は自身のデータ型のデフォルトの照合順序（通常これはデータベースのデフォルトの照合順序ですが、ドメイン型の変数の場合は異なるかもしれません）を使用します。
   </p><p>照合可能なデータ型の局所変数は、宣言内で<code class="literal">COLLATE</code>オプションを含めることにより、別の照合と関連づけることができます。
例を示します。

</p><pre class="programlisting">DECLARE
    local_a text COLLATE "en_US";</pre><p>

このオプションは上記ルールにより、変数に他の方法で付与されるはずであった照合を上書きします。
   </p><p>また当然ながら、強制的に特定の操作において特定の照合順序を使用したい場合、明示的な<code class="literal">COLLATE</code>句を関数内部に記述することができます。
例を示します。

</p><pre class="programlisting">CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;</pre><p>

単純な SQL コマンドで起こるように、これはテーブルの列、パラメータ、または式の中の局所変数に関連づけられた照合を上書きします
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-structure.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-expressions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.2. <span class="application">PL/pgSQL</span>の構造 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.4. 式</td></tr></table></div></body></html>