<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>53.4. その他のコーディング規約</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="error-style-guide.html" title="53.3. エラーメッセージのスタイルガイド" /><link rel="next" href="nls.html" title="Chapter 54. 多言語サポート" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">53.4. その他のコーディング規約</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="error-style-guide.html" title="53.3. エラーメッセージのスタイルガイド">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="source.html" title="Chapter 53. PostgreSQLコーディング規約">Up</a></td><th width="60%" align="center">Chapter 53. PostgreSQLコーディング規約</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="nls.html" title="Chapter 54. 多言語サポート">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SOURCE-CONVENTIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">53.4. その他のコーディング規約</h2></div></div></div><div class="simplesect" id="id-1.10.6.5.2"><div class="titlepage"><div><div><h3 class="title">標準C</h3></div></div></div><p><span class="productname">PostgreSQL</span>のコードはC89の標準で利用可能な言語機能にのみ依存することになっています。
つまり、C89に準拠したコンパイラであれば、少数のプラットフォーム依存の部分を除けばpostgresをコンパイルできるはずです。
代替策が用意されているのであれば、それより後のバージョンの標準Cの機能、あるいはコンパイラに依存した機能を使用することもできます。
    </p><p>例えば、<code class="literal">static inline</code>と<code class="literal">_StaticAssert()</code>は標準Cのより新しいバージョンにあるものですが、現在、使用されています。
それらが利用できない場合は、<code class="literal">static inline</code>の代わりにインラインを使わない関数を定義し、<code class="literal">_StaticAssert()</code>については、同じチェックをする（ただし、やや暗号的なメッセージを発する）C89互換のもので代用します。
    </p></div><div class="simplesect" id="id-1.10.6.5.3"><div class="titlepage"><div><div><h3 class="title">関数のようなマクロとインライン関数</h3></div></div></div><p>引数付きのマクロと<code class="literal">static inline</code>の関数のどちらも使用することができます。
マクロとして記述した場合に、複数回評価されるリスクがあるならば、後者を選択します。
例えば次のような場合です。
</p><pre class="programlisting">#define Max(x, y)       ((x) &gt; (y) ? (x) : (y))</pre><p>
あるいは、マクロにすると非常に長くなる場合も、インライン関数を選択します。
その他に、マクロだけしか利用できない、あるいはマクロの方が使いやすい場合があります。
例えば、マクロに式や様々な型を渡す必要がある場合などです。
    </p><p>インライン関数の定義がバックエンドの一部としてのみ利用可能なシンボル（つまり、変数、関数）を参照する場合、その関数はフロントエンドのコードからインクルードされたときに不可視かもしれません。
</p><pre class="programlisting">#ifndef FRONTEND
static inline MemoryContext
MemoryContextSwitchTo(MemoryContext context)
{
    MemoryContext old = CurrentMemoryContext;

    CurrentMemoryContext = context;
    return old;
}
#endif   /* FRONTEND */</pre><p>
この例では、バックエンドのみで利用可能な<code class="literal">CurrentMemoryContext</code>が参照されているため、関数は<code class="literal">#ifndef FRONTEND</code>で隠されています。
一部のコンパイラはインライン関数に含まれるシンボルの参照を、その関数が使われていなくても吐き出すため、この規則があります。
    </p></div><div class="simplesect" id="id-1.10.6.5.4"><div class="titlepage"><div><div><h3 class="title">シグナルハンドラの作成</h3></div></div></div><p>シグナルハンドラの内部で実行されるのに適切であるためには、注意深くコードを書く必要があります。
根本的問題は、シグナルハンドラは、ブロックされない限り、いつでもコードに対して割り込むことができるということです。
シグナルハンドラの内側のコードが、外側のコードと同じ状態を使うと、混沌が発生するかもしれません。
例えば、シグナルハンドラが、割り込まれたコードで既に保持されているロックを獲得しようとしたら何が起きるか考えてみてください。
    </p><p>特別に準備された状況を別にすると、シグナルハンドラのコードは、（POSIXで定義される通りの）非同期シグナルで安全な関数だけを呼ぶことができ、型<code class="literal">volatile sig_atomic_t</code>の変数だけにアクセスできます。
<code class="command">postgres</code>でも、いくつかの関数はシグナルで安全とされており、なかでも重要なのは<code class="function">SetLatch()</code>です。
    </p><p>ほとんどの場合、シグナルハンドラはシグナルが到着したことを記録し、ハンドラの外部で動作しているコードをラッチを使って呼び起こす以上のことをすべきではありません。
以下はそのようなハンドラの例です。
</p><pre class="programlisting">static void
handle_sighup(SIGNAL_ARGS)
{
    int         save_errno = errno;

    got_SIGHUP = true;
    SetLatch(MyLatch);

    errno = save_errno;
}</pre><p>
<code class="varname">errno</code>は<code class="function">SetLatch()</code>によって変更されるかもしれないので、保存して、リストアされます。
そうしなければ、割り込まれたコードが、現在<code class="varname">errno</code>を参照している場合、誤った値を見ることになるかもしれません。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="error-style-guide.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="source.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="nls.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">53.3. エラーメッセージのスタイルガイド </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 54. 多言語サポート</td></tr></table></div></body></html>