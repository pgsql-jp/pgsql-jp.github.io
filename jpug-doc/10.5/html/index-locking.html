<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>60.4. インデックスのロック処理に関する検討</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="index-scanning.html" title="60.3. インデックススキャン" /><link rel="next" href="index-unique-checks.html" title="60.5. インデックス一意性検査" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">60.4. インデックスのロック処理に関する検討</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="index-scanning.html" title="60.3. インデックススキャン">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Up</a></td><th width="60%" align="center">Chapter 60. インデックスアクセスメソッドのインタフェース定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="index-unique-checks.html" title="60.5. インデックス一意性検査">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEX-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">60.4. インデックスのロック処理に関する検討</h2></div></div></div><p>インデックスアクセスメソッドは、複数のプロセスによるインデックスの同時更新を取り扱えなければなりません。
<span class="productname">PostgreSQL</span>コアシステムはインデックススキャン中にインデックスに対して<code class="literal">AccessShareLock</code>を獲得します。
また、（通常の<code class="command">VACUUM</code>を含む）インデックスの更新中に<code class="literal">RowExclusiveLock</code>を獲得します。
これらの種類のロックは競合しませんので、アクセスメソッドは必要になるかもしれない粒度の細かなロック処理に関して責任を持ちます。
インデックスの生成、破棄、<code class="literal">REINDEX</code>時にインデックス全体に対する排他ロックが獲得されます。
  </p><p>同時更新をサポートするインデックス種類を構築することは通常、必要な動作について広範かつ微細にわたる解析が必要です。
B-treeおよびハッシュインデックス種類では、<code class="filename">src/backend/access/nbtree/README</code>と <code class="filename">src/backend/access/hash/README</code>にある設計に関する決定事項を読むことができます。
  </p><p>インデックス自身の内部的な一貫性要求の他に、同時実行更新には、親テーブル（<em class="firstterm">ヒープ</em>）とインデックス間の一貫性に関する問題が発生します。
<span class="productname">PostgreSQL</span>はヒープへのアクセスおよび更新とインデックスへのアクセスおよび更新を分離していますので、インデックスとヒープとの間の一貫性が無くなる間隔が存在します。
以下の規則でこうした問題を扱います。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>新しいヒープ項目はインデックス項目を作成する前に作成されます。
（このため、同時実行インデックススキャンはヒープエントリを確認する時によく失敗します。
インデックスの読み取りは、未コミットの行を対象としませんので問題ありません。
しかし、<a class="xref" href="index-unique-checks.html" title="60.5. インデックス一意性検査">Section 60.5</a>を参照してください。）
      </p></li><li class="listitem"><p>ヒープエントリが（<code class="command">VACUUM</code>によって）削除される時、これに対するすべてのインデックス項目が先に削除されます。
      </p></li><li class="listitem"><p>インデックススキャンは、最後に<code class="function">amgettuple</code>が返した項目を保持するインデックスページ上のピンを管理しなければなりません。
また、<code class="function">ambulkdelete</code>は、他のバックエンドがピンを持つページから項目を削除することはできません。
この規則の必要性については後で説明します。
      </p></li></ul></div><p>

３番目の規則がないと、<code class="command">VACUUM</code>によって削除される直前に、インデックス読み取りがインデックス項目を見つけ、そして、<code class="command">VACUUM</code>によって削除された後に対応するヒープ項目に達する可能性があります。
空の項目スロットは<code class="function">heap_fetch()</code>で無視されますので、これは読み取りが達した時にその項目番号が未使用である場合でも大きな問題は起こりません。
しかし、第三のバックエンドがすでにその項目スロットを他のものに再使用した場合はどうなるでしょうか？
そのスロット内の新しいものが、スナップショット試験を通過するには新しすぎることが確実ですので、MVCCに則ったスナップショットを使用する場合は問題ありません。
しかし、MVCCに則らないスナップショット(<code class="literal">SnapshotNow</code>など)では、実際にはスキャンキーに合わない行を受付け、返す可能性があります。
すべての場合においてヒープ行に対しスキャンキーの再検査を行うことを必須とすることで、こうした状況から保護することができますが、これは高価すぎます。
代わりに、読み取りがまだ一致するヒープ項目へのインデックス項目の<span class="quote">“<span class="quote">作業中</span>”</span>であることを示す代理として、インデックスページに対するピンを使用します。
このピンに対して<code class="function">ambulkdelete</code>がブロックするようにすることで、読み取りの作業が終わる前に<code class="command">VACUUM</code>がそのヒープ項目を削除できないことを確実にします。
実行時におけるこの対策のコストは小さく、実際に競合が発生するごく稀な場合にのみブロックするためのオーバーヘッドが加わります。
  </p><p>この対策は、インデックススキャンが<span class="quote">“<span class="quote">同期</span>”</span>していることを要求します。
対応するインデックス項目のスキャンの後即座に各ヒープタプルを取り出さなければなりません。
多くの理由のため、これは高価です。
インデックスから多くのTIDを収集し、少し後でのみヒープタプルにアクセスする<span class="quote">“<span class="quote">非同期</span>”</span>スキャンでは、必要なロック処理オーバーヘッドがかなり少なくなり、また、より効率的なヒープへのアクセスパターンを取ることができます。
上の解析に従うと、MVCCに則らないスナップショットでは同期方式を使用しなければなりませんが、問い合わせがMVCCスナップショットを使用する場合は非同期スキャンを使用することができます。
  </p><p><code class="function">amgetbitmap</code>インデックススキャンでは、アクセスメソッドは返されるタプル上にインデックスピンをまったく保持しません。
したがって、MVCCに則ったスナップショットでこうしたスキャンを使用することのみが安全です。
  </p><p><code class="structfield">ampredlocks</code>フラグが設定されていない場合、シリアライザブルトランザクション内でそのインデックスアクセスメソッドを使用するスキャンはいずれもインデックス全体に対するブロックしない述語ロックを獲得します。
これは、同時実行のシリアライザブルトランザクションによるそのインデックスへの何らかのタプル挿入で、読み書きの競合が発生することがあります。
同時実行のシリアライザブルトランザクションの集合の中で特定の読み書きの競合パターンが検知された場合、データの整合性を保護するためにこれらのトランザクションの１つはキャンセルされます。
このフラグが設定されている場合、こうしたトランザクションのキャンセルの頻度を低減することになる、より粒度の細かな述語ロックをインデックスアクセスメソッドが実装していることを示します。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="index-scanning.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexam.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="index-unique-checks.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">60.3. インデックススキャン </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 60.5. インデックス一意性検査</td></tr></table></div></body></html>