<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>COPY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-commit-prepared.html" title="COMMIT PREPARED" /><link rel="next" href="sql-create-access-method.html" title="CREATE ACCESS METHOD" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">COPY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-commit-prepared.html" title="COMMIT PREPARED">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-create-access-method.html" title="CREATE ACCESS METHOD">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-COPY"><div class="titlepage"></div><a id="id-1.9.3.52.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">COPY</span></h2><p>COPY — ファイルとテーブルの間でデータをコピーする</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">COPY <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]
    FROM { '<em class="replaceable"><code>filename</code></em>' | PROGRAM '<em class="replaceable"><code>command</code></em>' | STDIN }
    [ [ WITH ] ( <em class="replaceable"><code>option</code></em> [, ...] ) ]

COPY { <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ] | ( <em class="replaceable"><code>query</code></em> ) }
    TO { '<em class="replaceable"><code>filename</code></em>' | PROGRAM '<em class="replaceable"><code>command</code></em>' | STDOUT }
    [ [ WITH ] ( <em class="replaceable"><code>option</code></em> [, ...] ) ]

<span class="phrase">ここで<em class="replaceable"><code>option</code></em>は以下のいずれかです。</span>

    FORMAT <em class="replaceable"><code>format_name</code></em>
    OIDS [ <em class="replaceable"><code>boolean</code></em> ]
    FREEZE [ <em class="replaceable"><code>boolean</code></em> ]
    DELIMITER '<em class="replaceable"><code>delimiter_character</code></em>'
    NULL '<em class="replaceable"><code>null_string</code></em>'
    HEADER [ <em class="replaceable"><code>boolean</code></em> ]
    QUOTE '<em class="replaceable"><code>quote_character</code></em>'
    ESCAPE '<em class="replaceable"><code>escape_character</code></em>'
    FORCE_QUOTE { ( <em class="replaceable"><code>column_name</code></em> [, ...] ) | * }
    FORCE_NOT_NULL ( <em class="replaceable"><code>column_name</code></em> [, ...] )
    FORCE_NULL ( <em class="replaceable"><code>column_name</code></em> [, ...] )
    ENCODING '<em class="replaceable"><code>encoding_name</code></em>'</pre></div><div class="refsect1" id="id-1.9.3.52.5"><h2>説明</h2><p><code class="command">COPY</code>コマンドは、<span class="productname">PostgreSQL</span>のテーブルと標準のファイルシステムのファイル間でデータを移動します。
<code class="command">COPY TO</code>コマンドはテーブルの内容をファイル<span class="emphasis"><em>に</em></span>コピーします。
また、<code class="command">COPY FROM</code>コマンドは、ファイル<span class="emphasis"><em>から</em></span>テーブルへとデータをコピーします（この時、既にテーブルにあるデータにコピーした内容を追加します）。
また、<code class="command">COPY TO</code>により<code class="command">SELECT</code>問い合わせの結果をコピーすることができます。
  </p><p>列リストが指定されている場合、<code class="command">COPY</code>は、指定された列のデータのみをファイルからまたはファイルへコピーします。
列リストに含まれていない列がテーブル内にある場合、<code class="command">COPY FROM</code>はそれらの列にデフォルトの値を挿入します。
  </p><p>ファイル名付きの<code class="command">COPY</code>コマンドは、<span class="productname">PostgreSQL</span>サーバに対して直接ファイルへの読み書きをするように命じます。
指定したファイルは必ず<span class="productname">PostgreSQL</span>ユーザ(サーバを実行しているユーザID)からアクセスできる必要があります。
また、ファイル名はサーバから見たように指定されなければなりません。
<code class="literal">PROGRAM</code>が指定された場合、サーバは指定したコマンドを実行しその標準出力を読み取る、または、プログラムの標準入力に書き出します。
コマンドはサーバからの視点で指定しなければならず、また、<code class="literal">PostgreSQL</code>ユーザによって実行できなければなりません。
<code class="literal">STDIN</code>や<code class="literal">STDOUT</code>が指定された場合、データはクライアントとサーバ間を流れます。
  </p></div><div class="refsect1" id="id-1.9.3.52.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>既存のテーブルの名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>コピー対象の列リストで、省略可能です。
列リストが指定されていない場合は、テーブルの全ての列がコピーされます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>query</code></em></span></dt><dd><p><a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>、<a class="xref" href="sql-values.html" title="VALUES"><span class="refentrytitle">VALUES</span></a>、<a class="xref" href="sql-insert.html" title="INSERT"><span class="refentrytitle">INSERT</span></a>、<a class="xref" href="sql-update.html" title="UPDATE"><span class="refentrytitle">UPDATE</span></a>あるいは<a class="xref" href="sql-delete.html" title="DELETE"><span class="refentrytitle">DELETE</span></a>コマンドで、その結果がコピーされます。
問い合わせを括弧でくくる必要があることに注意してください。
     </p><p><code class="command">INSERT</code>、<code class="command">UPDATE</code>および<code class="command">DELETE</code>についてはRETURNING句を付けなければならず、また、対象のリレーションには、複数の文に展開される条件付きルール、<code class="literal">ALSO</code>ルール、<code class="literal">INSTEAD</code>ルールがあってはなりません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>filename</code></em></span></dt><dd><p>入出力ファイルのパス名です。
入力ファイル名は絶対パスでも相対パスでも記述することができますが、出力ファイル名は絶対パスでなければなりません。
Windowsユーザの場合、<code class="literal">E''</code>文字列を使用し、パス名内のバックスラッシュを二重にする必要があるかもしれません。
     </p></dd><dt><span class="term"><code class="literal">PROGRAM</code></span></dt><dd><p>実行するコマンドです。
<code class="command">COPY FROM</code>では、入力はコマンドの標準出力から読み取られ、<code class="command">COPY TO</code>では、出力はコマンドの標準入力に書き出されます。
     </p><p>コマンドはシェルから呼び出されることに注意してください。
このためシェルコマンドに信頼できない入力元からの任意の引数を渡す必要がある場合、シェルにとって特殊な意味を持つかもしれない特殊文字の除去やエスケープを注意深く実施してください、
セキュリティ上の理由のため、固定のコマンド文字列を使用することが最善です。または少なくともユーザからの入力が渡されることを防止してください。
     </p></dd><dt><span class="term"><code class="literal">STDIN</code></span></dt><dd><p>入力がクライアントアプリケーションからであることを指定します。
     </p></dd><dt><span class="term"><code class="literal">STDOUT</code></span></dt><dd><p>出力がクライアントアプリケーションへであることを指定します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>boolean</code></em></span></dt><dd><p>指定のオプションを有効とするか無効とするかを指定します。
オプションを有効にするには、<code class="literal">TRUE</code>、<code class="literal">ON</code>または<code class="literal">1</code>と、無効にするには<code class="literal">FALSE</code>、<code class="literal">OFF</code>または<code class="literal">0</code>と記述します。
また<em class="replaceable"><code>boolean</code></em>値は省略可能であり、省略時は<code class="literal">TRUE</code>とみなされます。
     </p></dd><dt><span class="term"><code class="literal">FORMAT</code></span></dt><dd><p>読み取りまたは書き込みに使用するデータ形式を選択します。
<code class="literal">text</code>、<code class="literal">csv</code>（カンマ区切り値）、または<code class="literal">binary</code>です。
デフォルトは<code class="literal">text</code>です。
     </p></dd><dt><span class="term"><code class="literal">OIDS</code></span></dt><dd><p>各行のOIDをコピーするよう指定します
（OIDを持たないテーブルに<code class="literal">OIDS</code>を指定する場合、または、<em class="replaceable"><code>query</code></em>コピーの場合、エラーが発生します）。
     </p></dd><dt><span class="term"><code class="literal">FREEZE</code></span></dt><dd><p><code class="command">VACUUM FREEZE</code>コマンドを実行した直後の、凍結状態の行を用いたデータコピー処理を要求します。
これは、初期データロード処理用の性能オプションとしての利用を意図しています。
ロード元のテーブルが現在の副トランザクションで作成または切り詰めされ、開いているカーソルは存在せず、またこのトランザクションで保持される古めのスナップショットが存在しない場合のみ、行は凍結されます。
     </p><p>データのロードに成功すると、他のすべてのセッションから即座にデータが参照可能になることに注意してください。
これはMVCC可視性に関する一般的な規則に違反しますので、指定するユーザはこれが引き起こすかもしれない潜在的な問題に注意しなければなりません。
     </p></dd><dt><span class="term"><code class="literal">DELIMITER</code></span></dt><dd><p>ファイルの各行内の列を区切る文字を指定します。
テキスト形式でのデフォルトはタブ文字、<code class="literal">CSV</code>形式ではカンマです。
これは単一の1バイト文字でなければなりません。
このオプションは<code class="literal">binary</code>形式を使用する場合は許されません。
     </p></dd><dt><span class="term"><code class="literal">NULL</code></span></dt><dd><p>NULL値を表す文字列を指定します。
デフォルトは、テキスト形式では<code class="literal">\N</code>（バックスラッシュN）、<code class="literal">CSV</code>形式では引用符のない空文字です。
NULL値と空文字列を区別する必要がない場合は、テキスト形式であっても空文字列を使用した方が良いかもしれません。
このオプションは<code class="literal">binary</code>形式を使用する場合は許されません。
     </p><div class="note"><h3 class="title">Note</h3><p><code class="command">COPY FROM</code>の場合、この文字列と一致するデータ要素はNULL値として格納されます。
<code class="command">COPY TO</code>実行時に使用した同じ文字列を使用するようにしてください。
      </p></div></dd><dt><span class="term"><code class="literal">HEADER</code></span></dt><dd><p>ヘッダ行を含むファイルを指定します。
このファイルには各列の名前が記載されています。
出力では、先頭行にテーブルの列名が入り、入力では先頭行は無視されます。
このオプションは<code class="literal">CSV</code>形式を使用する場合にのみ許されます。
     </p></dd><dt><span class="term"><code class="literal">QUOTE</code></span></dt><dd><p>データ値を引用符付けする際に使用される引用符文字を指定します。
デフォルトは二重引用符です。
これは単一の1バイト文字でなければなりません。
このオプションは<code class="literal">CSV</code>形式を使用する場合にのみ許されます。
     </p></dd><dt><span class="term"><code class="literal">ESCAPE</code></span></dt><dd><p>データ内の文字が<code class="literal">QUOTE</code>の値と一致する場合に、その前に現れなければならない文字を指定します。
デフォルトは<code class="literal">QUOTE</code>の値と同じです（このためデータ内に引用符用文字があるときは二つ続けます）。
これは単一の1バイト文字でなければなりません。
このオプションは<code class="literal">CSV</code>形式を使用する場合のみ許されます。
     </p></dd><dt><span class="term"><code class="literal">FORCE_QUOTE</code></span></dt><dd><p>指定された各列内にある全ての非<code class="literal">NULL</code>値を強制的に引用符で囲みます。
<code class="literal">NULL</code>出力は引用符で囲まれません。
<code class="literal">*</code>が指定された場合、非<code class="literal">NULL</code>値はすべての列で引用符付けされます。
このオプションは<code class="command">COPY TO</code>において、かつ、<code class="literal">CSV</code>形式を使用する場合のみ許されます。
     </p></dd><dt><span class="term"><code class="literal">FORCE_NOT_NULL</code></span></dt><dd><p>指定された列の値をNULL文字列に対して比較しません。
NULL文字列が空であるデフォルトでは、空の値は引用符付けされていなくてもNULLではなく長さが0の文字列として読み取られることを意味します。
このオプションは<code class="command">COPY FROM</code>において、かつ、<code class="literal">CSV</code>形式を使用する場合のみで許されます。
     </p></dd><dt><span class="term"><code class="literal">FORCE_NULL</code></span></dt><dd><p>指定された列の値を、それが引用符付きであったとしても、NULL文字列と比較し、一致した場合は値を<code class="literal">NULL</code>にセットします。
NULL文字列が空であるデフォルトでは、引用符付きの空文字列をNULLに変換します。
このオプションは<code class="command">COPY FROM</code>で、かつ<code class="literal">CSV</code>形式を使用する場合のみ許されます。
     </p></dd><dt><span class="term"><code class="literal">ENCODING</code></span></dt><dd><p>ファイルが<em class="replaceable"><code>encoding_name</code></em>で符号化されていることを指定します。
このオプションが省略された場合、現在のクライアント符号化方式が使用されます。
後述の注釈を参照してください。
     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.52.7"><h2>出力</h2><p>正常に完了した場合、<code class="command">COPY</code>コマンドは以下の形式のコマンドタグを返します。
</p><pre class="screen">COPY <em class="replaceable"><code>count</code></em></pre><p>
<em class="replaceable"><code>count</code></em>はコピーされた行数です。
  </p><div class="note"><h3 class="title">Note</h3><p><span class="application">psql</span>はコマンドが<code class="literal">COPY ... TO STDOUT</code>であった場合、および、それと同等な<span class="application">psql</span>のメタコマンド<code class="literal">\copy ... to stdout</code>であった場合は、このコマンドタグを表示しません。
これは、コマンドタグが表示されたデータと混同されないようにするためです。
   </p></div></div><div class="refsect1" id="id-1.9.3.52.8"><h2>注釈</h2><p><code class="command">COPY TO</code>は通常のテーブルに対してのみ使用することができます。
ビューに対して使用することはできません。
しかし、<code class="literal">COPY (SELECT * FROM <em class="replaceable"><code>viewname</code></em>) TO ...</code>と記述して、ビューの現在の内容をコピーすることはできます。
   </p><p><code class="command">COPY FROM</code>は通常のテーブル、および<code class="literal">INSTEAD OF INSERT</code>トリガを持つビューに対して使用することができます。
   </p><p><code class="command">COPY</code>は指定された特定のテーブルのみを扱います。
つまり子テーブルへまたは子テーブルからのデータのコピーは行いません。
したがって例えば、<code class="literal">COPY <em class="replaceable"><code>table</code></em> TO</code>は<code class="literal">SELECT * FROM ONLY <em class="replaceable"><code>table</code></em></code>と同じデータを示します。
しかし<code class="literal">COPY (SELECT * FROM <em class="replaceable"><code>table</code></em>) TO ...</code>を使用して、継承階層内のすべてのデータをダンプすることができます。
   </p><p><code class="command">COPY TO</code>の場合は値を読み込むテーブルに対するSELECT権限が、<code class="command">COPY FROM</code>の場合は値を挿入するテーブルに対するINSERT権限が必要です。
コマンド内で列挙された列に対する列権限があれば十分です。
   </p><p>テーブルの行単位セキュリティが有効な場合、適切な<code class="command">SELECT</code>ポリシーが<code class="literal">COPY <em class="replaceable"><code>table</code></em> TO</code>文に適用されます。
現在のところ、<code class="command">COPY FROM</code>は行単位セキュリティが有効なテーブルに対してはサポートされません。
代わりにそれと等価な<code class="command">INSERT</code>を使ってください。
   </p><p><code class="command">COPY</code>コマンドで指定するファイルは、クライアントアプリケーションではなく、サーバが直接読み込み/書き込みを行います。
したがって、それらのファイルは、クライアントではなく、データベースサーバマシン上に存在するか、または、データベースサーバマシンからアクセス可能である必要があります。
さらに、クライアントではなく、<span class="productname">PostgreSQL</span>ユーザ（サーバを実行しているユーザID）が、アクセス権限と読み書き権限を持っている必要があります。
同様に、<code class="literal">PROGRAM</code>で指定されたコマンドは、クライアントアプリケーションではなくサーバにより直接実行されるため、<span class="productname">PostgreSQL</span>ユーザによって実行可能でなければなりません。
ファイル名またはコマンドを指定した<code class="command">COPY</code>の実行は、データベースのスーパーユーザのみに許可されています。このコマンドによって、サーバがアクセス権限を持つ全てのファイルの読み込み、書き込みが可能になってしまうためです。
   </p><p><code class="command">COPY</code>を<span class="application">psql</span>の<code class="command"><a class="link" href="app-psql.html#APP-PSQL-META-COMMANDS-COPY">\copy</a></code>と混同しないでください。
<code class="command">\copy</code>は<code class="command">COPY FROM STDIN</code>や<code class="command">COPY TO STDOUT</code>を呼び出し、<span class="application">psql</span>クライアントからアクセスできるファイルにデータの書き込み/読み込みを行います。
したがって、<code class="command">\copy</code>コマンドでは、ファイルへのアクセスが可能かどうかと、ファイルに対するアクセス権限の有無は、サーバではなくクライアント側に依存します。
   </p><p><code class="command">COPY</code>でファイル名を指定する時は、常に絶対パスで記述することをお勧めします。
<code class="command">COPY TO</code>コマンドの場合はサーバによって絶対パス指定に変更させられますが、<code class="command">COPY FROM</code>コマンドでは相対パスで指定されたファイルを読み込むことも可能となっています。
後者では、クライアントの作業ディレクトリではなく、サーバプロセスの作業ディレクトリ（通常はクラスタのデータディレクトリ）からの相対的なディレクトリとして解釈されます。
   </p><p><code class="literal">PROGRAM</code>を用いたコマンド実行は、SELinuxなどのオペレーティングシステムのアクセス制御機構によって制限されるかもしれません。
   </p><p><code class="command">COPY FROM</code>は、宛先テーブル上で任意のトリガと検査制約を呼び出しますが、ルールは呼び出しません。
   </p><p>IDENTITY列については、<code class="command">COPY FROM</code>コマンドは<code class="command">INSERT</code>のオプション<code class="literal">OVERRIDING SYSTEM VALUE</code>と同じように、必ず入力データが提供した列の値を書き込みます。
   </p><p><code class="command">COPY</code>の入出力は<code class="varname">DateStyle</code>の影響を受けます。
デフォルト以外の<code class="varname">DateStyle</code>が設定された可能性がある<span class="productname">PostgreSQL</span>インストレーションとの移植を確実に行いたい場合は、<code class="command">COPY</code>を使う前に<code class="varname">DateStyle</code>を<code class="literal">ISO</code>に設定しなければなりません。
また、<code class="varname">IntervalStyle</code>を<code class="literal">sql_standard</code>としてデータをダンプすることは避けることを勧めます。
負の時間間隔値が別の<code class="varname">IntervalStyle</code>設定を持つサーバで誤解釈される可能性があるためです。
   </p><p>たとえデータがクライアント経由ではなくサーバにより直接ファイルから読み書きされるとしても、入力データは<code class="literal">ENCODING</code>オプションまたは現在のクライアント符号化方式にしたがって解釈され、出力データは<code class="literal">ENCODING</code>オプションまたは現在のクライアント符号化方式で符号化されます。
   </p><p><code class="command">COPY</code>では、エラーが発生するとすぐに処理を停止します。
<code class="command">COPY TO</code>コマンドの実行では何ら問題ありませんが、<code class="command">COPY FROM</code>の場合は、対象となるテーブルは初めの方の行を既に受け取っています。
これらの行は不可視となり、アクセスすることもできませんが、ディスク領域を占有します。
したがって、大きなコピー処理がかなり進んだ後で失敗した場合には、それなりの量の無駄なディスク領域が使われてしまいます。
この無駄な領域を取り戻すには、<code class="command">VACUUM</code>を行う必要があります。
   </p><p><code class="literal">FORCE_NULL</code>と<code class="literal">FORCE_NOT_NULL</code>は同じ列について同時に使うことができます。
その場合の結果は、引用符付きのNULL文字列をNULL値に変換し、引用符なしのNULL文字列を空文字列に変換します。
   </p></div><div class="refsect1" id="id-1.9.3.52.9"><h2>ファイルの形式</h2><div class="refsect2" id="id-1.9.3.52.9.2"><h3>テキスト形式</h3><p><code class="literal">text</code>形式を使用する場合、読み書きされるデータはテーブルの1つの行を1行で表したテキストファイルとなります。
行内の列は区切り文字で区切られます。
列の値自体は、その属性のデータ型の出力関数で生成された、または、その入力関数で受け付け可能な文字列です。
値がNULLの列では、代わりに指定されたNULL値を表す文字列が使用されます。
入力ファイルのいずれかの行にある列数が予期された数と違う場合、<code class="command">COPY FROM</code>はエラーを発生します。
<code class="literal">OIDS</code>が指定された場合、OIDは、ユーザデータの列の前にある、1番目の列として読み書きされます。
   </p><p>データの終了は、バックスラッシュとピリオド（<code class="literal">\.</code>）のみから構成される1行で表されます。
ファイルの終了により同じ動作になるので、ファイルからの読み込みの場合はデータ終了マークは不要です。
しかし、3.0以前のクライアントプロトコルを使用したクライアントアプリケーションとデータのコピーを行う場合だけは、読み込み、書き込みを問わず、終了マークが必要です。
   </p><p>バックスラッシュ文字（<code class="literal">\</code>）は、<code class="command">COPY</code>対象データ内で、行や列の区切り文字と判定される可能性があるデータ文字列の引用符付けに使用します。
特に、バックスラッシュ自体、改行、復帰、使用中の区切り文字などの文字が列の値に含まれている場合は、<span class="emphasis"><em>必ず</em></span>前にバックスラッシュを付けなければなりません。

   </p><p>指定されたNULL文字列はバックスラッシュを付けずに<code class="command">COPY TO</code>に送られます。
一方、<code class="command">COPY FROM</code>では、バックスラッシュを削除する前にNULL文字列と入力を比較します。
したがって、<code class="literal">\N</code>といったNULL文字列が実際の<code class="literal">\N</code>というデータ値と混乱することはあり得ません。
（これは<code class="literal">\\N</code>として表現されます。）
   </p><p><code class="command">COPY FROM</code>は、バックスラッシュで始まる次のような文字の並びを識別します。

   </p><div class="informaltable"><table class="informaltable" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>文字の並び</th><th>表現</th></tr></thead><tbody><tr><td><code class="literal">\b</code></td><td>バックスペース（ASCII 8）</td></tr><tr><td><code class="literal">\f</code></td><td>改ページ（ASCII 12）</td></tr><tr><td><code class="literal">\n</code></td><td>改行（ASCII 10）</td></tr><tr><td><code class="literal">\r</code></td><td>復帰（ASCII 13）</td></tr><tr><td><code class="literal">\t</code></td><td>タブ（ASCII 9）</td></tr><tr><td><code class="literal">\v</code></td><td>垂直タブ（ASCII 11）</td></tr><tr><td><code class="literal">\</code><em class="replaceable"><code>数字</code></em></td><td>バックスラッシュに続き1から3個の8進数の数字をコード番号として指定すると、そのコード番号が表す文字を指定できます。</td></tr><tr><td><code class="literal">\x</code><em class="replaceable"><code>digits</code></em></td><td>バックスラッシュ、<code class="literal">x</code> という並びに続き1から2個の16進数の数字を指定すると、そのコード番号が表す文字を指定できます。</td></tr></tbody></table></div><p>

現在、<code class="command">COPY TO</code>は、バックスラッシュの後ろに8進数や16進数を付けた形式で文字を出力することはありませんが、上記一覧にある制御文字については、バックスラッシュの文字並びを使用します。
   </p><p>上表で記載されていないバックスラッシュ付きの文字はすべて、その文字自体として解釈されます。
しかし、不要なバックスラッシュの追加には注意してください。
偶然にデータの終わりを示す印（<code class="literal">\.</code>）やヌル文字列（デフォルトでは<code class="literal">\N</code>）と合致する文字列を生成してしまうかもしれないためです。
これらの文字列は他のバックスラッシュの処理を行う前に解釈されます。
   </p><p><code class="command">COPY</code>データを生成するアプリケーションは、データ内の改行と復帰をそれぞれ、<code class="literal">\n</code>と<code class="literal">\r</code>に変換することを強く推奨されています。
現在のところ、バックスラッシュと復帰文字でデータ内の復帰を表したり、バックスラッシュと改行文字でデータ内の改行を表すことが可能です。
しかし、こういった表現は今後のリリースでは、受け付けられなくなる可能性があります。
また、<code class="command">COPY</code>ファイルが異なるマシンをまたがって転送される場合、破損するおそれがかなりあります
（例えば、UnixからWindowsあるいはその逆）。
   </p><p><code class="command">COPY TO</code>は各行の行末にUnix形式の改行（<span class="quote">“<span class="quote"><code class="literal">\n</code></span>”</span>）を出力します。
なお、Microsoft Windowsで稼働するサーバの場合は、サーバ上のファイルへの<code class="command">COPY</code>の場合にのみ復帰/改行（<span class="quote">“<span class="quote"><code class="literal">\r\n</code></span>”</span>）を出力します。
プラットフォームをまたがる一貫性のために、サーバのプラットフォームにかかわらず、<code class="command">COPY TO STDOUT</code>は常に<span class="quote">“<span class="quote"><code class="literal">\n</code></span>”</span>を送信します。
<code class="command">COPY FROM</code>は、改行、復帰、復帰/改行を行末として扱うことができます。
データを意図したバックスラッシュのない改行や復帰によるエラーの危険性を減らすために、<code class="command">COPY FROM</code>は、入力行の行末が全て共通でない場合に警告を発します。
   </p></div><div class="refsect2" id="id-1.9.3.52.9.3"><h3>CSV形式</h3><p>この形式オプションは、スプレッドシートなど他の多くのプログラムで使用されるカンマ区切り値（<code class="literal">CSV</code>）ファイル形式をインポート、エクスポートするために使用されます。
<span class="productname">PostgreSQL</span>の標準テキスト形式で使用されるエスケープ規則の代わりに、一般的なCSVのエスケープ機構を生成、認識します。
   </p><p>各レコードの値は<code class="literal">DELIMITER</code>文字で区切られます。
区切り文字、<code class="literal">QUOTE</code>文字、<code class="literal">NULL</code>文字列、復帰、改行文字を含む値の場合、全体の値の前後に<code class="literal">QUOTE</code>文字が付与されます。値の中で<code class="literal">QUOTE</code>文字や<code class="literal">ESCAPE</code>文字が現れる場合、その前にエスケープ用の文字が付与されます。
また、<code class="literal">FORCE_QUOTE</code>を使用して、特定列内の非<code class="literal">NULL</code>値を出力する時に強制的に引用符を付与することもできます。
   </p><p><code class="literal">CSV</code>形式には<code class="literal">NULL</code>値と空文字列とを区別する標準的な方法はありません。
<span class="productname">PostgreSQL</span>のCOPYでは引用符によってこれを区別しています。
<code class="literal">NULL</code>は<code class="literal">NULL</code>パラメータの文字列として出力され、引用符で囲まれません。
一方、<code class="literal">NULL</code>パラメータの文字列に一致する非<code class="literal">NULL</code>値は引用符で囲まれます。
たとえばデフォルトの設定では、<code class="literal">NULL</code>は引用符付けのない空文字列として出力され、空文字列のデータ値は2つの引用符（<code class="literal">""</code>）で出力されます。
データの読み込みの際も同様の規則に従います。
<code class="literal">FORCE_NOT_NULL</code>を使用して、特定列に対し<code class="literal">NULL</code>入力の比較を行わないようにすることもできます。
また<code class="literal">FORCE_NULL</code>を使うことで、引用符付きのNULL文字列のデータの値を<code class="literal">NULL</code>に変換することもできます。

   </p><p><code class="literal">CSV</code>形式ではバックスラッシュは特別な文字ではありませんので、データ終端記号<code class="literal">\.</code>がデータ値として現れることがあります。
誤った解釈を防ぐために、行内の唯一の項目として<code class="literal">\.</code>というデータ値が現れる場合、出力に自動的に引用符が付けられます。
また、入力では引用符で括られた場合データ終端記号として解釈されません。
他のアプリケーションで作成されたファイルをロードしようとする場合、引用符で括られない列が1つあるだけで、それが<code class="literal">\.</code>という値を持つ可能性があるなら、入力ファイル内のこうした値を引用符で括る必要があります。
   </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">CSV</code>形式では文字はすべて意味を持ちます。
空白文字で括られた引用符付きの値など<code class="literal">DELIMITER</code>以外のすべての文字がこうした文字に含まれます。
これにより、固定長にするために<code class="literal">CSV</code>の行に空白文字を埋めるシステムから取り出したデータをインポートする時にエラーが発生する可能性があります。
このような状況になった場合、<span class="productname">PostgreSQL</span>にデータをインポートする前に、その<code class="literal">CSV</code>ファイルから余分な空白を除去する前処理が必要になります。
    </p></div><div class="note"><h3 class="title">Note</h3><p>CSV形式は、復帰文字や改行文字が埋め込まれ引用符で囲まれた値を含むCSVファイルを認識し、生成します。
したがって、このファイルでは、テキスト形式とは異なり、1つのテーブル行が1行で表されているとは限りません。
    </p></div><div class="note"><h3 class="title">Note</h3><p>奇妙な（時には間違った）CSVファイルを生成するプログラムは多く存在するので、このファイル形式は標準というよりも慣習と言えるものです。
したがって、この機能でインポートできないファイルが存在するかもしれませんし、<code class="command">COPY</code>が他のプログラムで処理できないファイルを生成するかもしれません。
    </p></div></div><div class="refsect2" id="id-1.9.3.52.9.4"><h3>バイナリ形式</h3><p><code class="literal">binary</code>形式オプションにより、すべてのデータはテキストではなくバイナリ形式で書き込み/読み取りされるようになります。
テキストや<code class="literal">CSV</code>形式よりも多少高速になりますが、バイナリ形式のファイルはマシンアーキテクチャや<span class="productname">PostgreSQL</span>のバージョンをまたがる移植性が落ちます。
またバイナリ形式はデータ型に非常に依存します。
たとえば、<code class="type">smallint</code>列からバイナリデータを出力し、それを<code class="type">integer</code>列として読み込むことはできません。同じことをテキスト形式で実行すれば動作するのですが。
   </p><p><code class="literal">binary</code>ファイルの形式は、ファイルヘッダ、行データを含む0以上のタプル、ファイルトレーラから構成されます。
ヘッダとデータはネットワークバイトオーダです。
   </p><div class="note"><h3 class="title">Note</h3><p>7.4以前のリリースの<span class="productname">PostgreSQL</span>では異なるバイナリファイル形式を使用していました。
    </p></div><div class="refsect3" id="id-1.9.3.52.9.4.5"><h4>ファイルヘッダ</h4><p>ファイルヘッダは15バイトの固定フィールドとその後に続く可変長ヘッダ拡張領域から構成されます。
固定フィールドは以下の通りです。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">署名</span></dt><dd><p><code class="literal">PGCOPY\n\377\r\n\0</code>という11バイトの並びです。
この署名の必須部分にNULLバイトが含まれていることに注意してください
（この署名は、8ビットを通過させない転送方式によってファイルが破損した場合、これを容易に識別できるように設計されています。
署名は、改行コード変換やNULLバイトの削除、上位ビット落ち、パリティの変更などによって変化します）。
       </p></dd><dt><span class="term">フラグフィールド</span></dt><dd><p>このファイル形式の重要な部分となる32ビット整数のビットマスクです。
ビットには0（<acronym class="acronym">LSB</acronym>） から31（<acronym class="acronym">MSB</acronym>）までの番号が付いています。
このフィールドは、このファイル形式で使用される他の全ての整数フィールドも同様、ネットワークバイトオーダ（最上位バイトが最初に現れる）で保存されていることに注意してください。
ファイル形式上の致命的な問題を表すために、16-31ビットは予約されています。
この範囲に想定外のビットが設定されていることが判明した場合、読み込み先は処理を中断しなければなりません。
後方互換における形式の問題を通知するために、0-15ビットは予約されています。
この範囲に想定外のビットが設定されていても、読み込み先は無視すべきです。
現在、1つのビットだけがフラグビットとして定義されており、残りは0でなければなりません。
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ビット16</span></dt><dd><p>1ならば、OIDがデータに含まれています。
0ならば、含まれていません。
           </p></dd></dl></div></dd><dt><span class="term">ヘッダ拡張領域長</span></dt><dd><p>自分自身を除いた、ヘッダの残り部分のバイト長を示す32ビットの整数です。
現在、これは0となっており、すぐ後に最初のタプルが続きます。
今後、ヘッダ内に追加データを格納するような形式の変更があるかもしれません。
読み込み側では、ヘッダ拡張データの扱いがわからない場合、そのデータをスキップしなければなりません。
       </p></dd></dl></div><p>
    </p><p>ヘッダ拡張領域は、それ自身で認識することができる塊の並びを保持するために用意されています。
フラグフィールドは読み込み先に拡張領域の内容を知らせるものではありません。
ヘッダ拡張内容の個々の設計は今後のリリースのために残してあります。
    </p><p>この設計によって、後方互換性を維持するヘッダの追加（ヘッダ拡張チャンクの追加や下位フラグビットの設定）と後方互換性のない変更（変更を通知するための高位フラグビットの設定や必要に応じた拡張領域へのサポート情報追加）の両方に対応できます。
    </p></div><div class="refsect3" id="id-1.9.3.52.9.4.6"><h4>タプル</h4><p>全てのタプルはタプル内のフィールド数を表す16ビットの整数から始まります（現時点では、テーブル内の全てのタプルは同一のフィールド数を持つことになっていますが、今後、これは変更される可能性があります）。
その後に、タプル中のそれぞれのフィールドが続きます。これらのフィールドには、先頭にフィールドデータが何バイトあるかを表す32ビット長のワードが付けられています
（このワードが表す長さには自分自身は含まれません。したがって、0になることもあります）。
特殊な値としてNULLフィールドを表す-1が用意されています。
このNULLが指定された場合、値用のバイトはありません。
    </p><p>フィールド間には整列用のパッドやその他の余計なデータはありません。
    </p><p>現在、バイナリ形式のファイル内の全てのデータ値は、バイナリ形式（形式コード1）であると想定されています。
将来の拡張によって、列単位に形式コードを指定するヘッダフィールドが追加される可能性があります。
    </p><p>実際のタプルデータとして適切なバイナリ形式を決定するためには、<span class="productname">PostgreSQL</span>のソース、特に各列のデータ型用の<code class="function">*send</code> 関数と<code class="function">*recv</code>関数（通常はソースの配布物内の<code class="filename">src/backend/utils/adt</code>ディレクトリにあります）を調べなければなりません。
    </p><p>このファイルにOIDが含まれる場合、OIDフィールドがフィールド数ワードの直後に続きます。
これは、フィールド数に含まれない点を除いて、通常のフィールドです。
特に長さワードがありますが、苦労することなく、4バイトのOIDも8バイトのOIDも扱うことができます。
また、これにより、望ましいと判断されれば、OIDをNULLとして表示することができます。
    </p></div><div class="refsect3" id="id-1.9.3.52.9.4.7"><h4>ファイルトレーラ</h4><p>ファイルトレーラは、16ビットの整数ワードで構成され、-1が入っています。
タプルのフィールド数ワードとは、容易に区別できます。
    </p><p>読み込み側は、フィールドカウントワードが-1でも、想定した列数でもなかった場合はエラーを報告しなければなりません。
これにより、何らかの理由でデータと一致しなかったことを判定する特別な検査を行うことが可能になります。
    </p></div></div></div><div class="refsect1" id="id-1.9.3.52.10"><h2>例</h2><p>次の例では、フィールド区切り文字として縦棒（<code class="literal">|</code>）を使用してテーブルをクライアントにコピーします。
</p><pre class="programlisting">COPY country TO STDOUT (DELIMITER '|');</pre><p>
  </p><p>ファイルから<code class="literal">country</code>テーブルにデータをコピーします。
</p><pre class="programlisting">COPY country FROM '/usr1/proj/bray/sql/country_data';</pre><p>
  </p><p>名前が'A'から始まる国のみをファイルにコピーします。
</p><pre class="programlisting">COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';</pre><p>
  </p><p>圧縮したファイルにコピーするためには、以下のように出力を外部の圧縮プログラムにパイプで渡すことができます。
</p><pre class="programlisting">COPY country TO PROGRAM 'gzip &gt; /usr1/proj/bray/sql/country_data.gz';</pre><p>
  </p><p>これは<code class="literal">STDIN</code>からテーブルにコピーするのに適したデータの例です。
</p><pre class="programlisting">AF      AFGHANISTAN
AL      ALBANIA
DZ      ALGERIA
ZM      ZAMBIA
ZW      ZIMBABWE</pre><p>
各行の空白文字は実際にはタブ文字であることに注意してください。
  </p><p>以下は同一のデータをバイナリ形式で出力したものです。
データをUnixユーティリティ<code class="command">od -c</code>を使ってフィルタしたものを示します。
テーブルには3列あり、最初のデータ型は<code class="type">char(2)</code>、2番目は<code class="type">text</code>、3番目は<code class="type">integer</code>です。
全ての行の3列目はNULL値です。
</p><pre class="programlisting">0000000   P   G   C   O   P   Y  \n 377  \r  \n  \0  \0  \0  \0  \0  \0
0000020  \0  \0  \0  \0 003  \0  \0  \0 002   A   F  \0  \0  \0 013   A
0000040   F   G   H   A   N   I   S   T   A   N 377 377 377 377  \0 003
0000060  \0  \0  \0 002   A   L  \0  \0  \0 007   A   L   B   A   N   I
0000100   A 377 377 377 377  \0 003  \0  \0  \0 002   D   Z  \0  \0  \0
0000120 007   A   L   G   E   R   I   A 377 377 377 377  \0 003  \0  \0
0000140  \0 002   Z   M  \0  \0  \0 006   Z   A   M   B   I   A 377 377
0000160 377 377  \0 003  \0  \0  \0 002   Z   W  \0  \0  \0  \b   Z   I
0000200   M   B   A   B   W   E 377 377 377 377 377 377</pre></div><div class="refsect1" id="id-1.9.3.52.11"><h2>互換性</h2><p>標準SQLには<code class="command">COPY</code>文はありません。
  </p><p>以下の構文は、<span class="productname">PostgreSQL</span>バージョン9.0より前に使用されていたもので、まだサポートされています。

</p><pre class="synopsis">COPY <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]
    FROM { '<em class="replaceable"><code>filename</code></em>' | STDIN }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<em class="replaceable"><code>delimiter</code></em>' ]
          [ NULL [ AS ] '<em class="replaceable"><code>null string</code></em>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<em class="replaceable"><code>quote</code></em>' ]
                [ ESCAPE [ AS ] '<em class="replaceable"><code>escape</code></em>' ]
                [ FORCE NOT NULL <em class="replaceable"><code>column_name</code></em> [, ...] ] ] ]

COPY { <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ] | ( <em class="replaceable"><code>query</code></em> ) }
    TO { '<em class="replaceable"><code>filename</code></em>' | STDOUT }
    [ [ WITH ]
          [ BINARY ]
          [ OIDS ]
          [ DELIMITER [ AS ] '<em class="replaceable"><code>delimiter</code></em>' ]
          [ NULL [ AS ] '<em class="replaceable"><code>null string</code></em>' ]
          [ CSV [ HEADER ]
                [ QUOTE [ AS ] '<em class="replaceable"><code>quote</code></em>' ]
                [ ESCAPE [ AS ] '<em class="replaceable"><code>escape</code></em>' ]
                [ FORCE QUOTE { <em class="replaceable"><code>column_name</code></em> [, ...] | * } ] ] ]</pre><p>

この構文では、<code class="literal">BINARY</code>と<code class="literal">CSV</code>が<code class="literal">FORMAT</code>オプションの引数ではなく、独立したキーワードとして扱われることに注意してください。
  </p><p>以下の構文は、<span class="productname">PostgreSQL</span>バージョン7.3より前に使用されていたもので、まだサポートされています。

</p><pre class="synopsis">COPY [ BINARY ] <em class="replaceable"><code>table_name</code></em> [ WITH OIDS ]
    FROM { '<em class="replaceable"><code>filename</code></em>' | STDIN }
    [ [USING] DELIMITERS '<em class="replaceable"><code>delimiter</code></em>' ]
    [ WITH NULL AS '<em class="replaceable"><code>null string</code></em>' ]

COPY [ BINARY ] <em class="replaceable"><code>table_name</code></em> [ WITH OIDS ]
    TO { '<em class="replaceable"><code>filename</code></em>' | STDOUT }
    [ [USING] DELIMITERS '<em class="replaceable"><code>delimiter</code></em>' ]
    [ WITH NULL AS '<em class="replaceable"><code>null string</code></em>' ]</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-commit-prepared.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-create-access-method.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">COMMIT PREPARED </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE ACCESS METHOD</td></tr></table></div></body></html>