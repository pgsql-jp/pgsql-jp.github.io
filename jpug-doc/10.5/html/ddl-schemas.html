<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.8. スキーマ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ddl-rowsecurity.html" title="5.7. 行セキュリティポリシー" /><link rel="next" href="ddl-inherit.html" title="5.9. 継承" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.8. スキーマ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-rowsecurity.html" title="5.7. 行セキュリティポリシー">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Chapter 5. データ定義">Up</a></td><th width="60%" align="center">Chapter 5. データ定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-inherit.html" title="5.9. 継承">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="DDL-SCHEMAS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.8. スキーマ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-CREATE">5.8.1. スキーマの作成</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PUBLIC">5.8.2. publicスキーマ</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PATH">5.8.3. スキーマ検索パス</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PRIV">5.8.4. スキーマおよび権限</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-CATALOG">5.8.5. システムカタログスキーマ</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS">5.8.6. 使用パターン</a></span></dt><dt><span class="sect2"><a href="ddl-schemas.html#DDL-SCHEMAS-PORTABILITY">5.8.7. 移植性</a></span></dt></dl></div><a id="id-1.5.4.10.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>データベースクラスタには、1つ以上の名前付きデータベースが含まれます。
ユーザおよびユーザのグループはクラスタ全体で共有されますが、他のデータは複数のデータベース間で共有されません。
サーバに接続しているクライアントは、単一のデータベース、つまり接続要求で指定したデータベース内のデータにしかアクセスできません。
  </p><div class="note"><h3 class="title">Note</h3><p>クラスタのユーザは、クラスタ内の全てのデータベースへのアクセス権限を持っているとは限りません。
ユーザ名を共有するということは、例えば<code class="literal">joe</code>という同じユーザ名を持つ異なるユーザが同じクラスタ内の2つのデータベースに存在することはできないということです。
しかし、<code class="literal">joe</code>が一部のデータベースにのみアクセスできるようにシステムを構成することはできます。
   </p></div><p>データベースには、1つ以上の名前付き<em class="firstterm">スキーマ</em>が含まれ、スキーマにはテーブルが含まれます。
スキーマには、データ型、関数および演算子などの他の名前付きオブジェクトも含まれます。
同じオブジェクト名を異なるスキーマで使用しても競合は起こりません。
例えば、<code class="literal">schema1</code>と<code class="literal">myschema</code>の両方のスキーマに<code class="literal">mytable</code>というテーブルが含まれていても構いません。
スキーマはデータベースとは異なり厳格に分離されていないので、ユーザは、権限さえ持っていれば接続しているデータベース内のどのスキーマのオブジェクトにでもアクセスすることができます。
  </p><p>スキーマの使用が好まれる理由はいくつかあります。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>1つのデータベースを多数のユーザが互いに干渉することなく使用できるようにするため。
     </p></li><li class="listitem"><p>管理しやすくなるよう、データベースオブジェクトを論理グループに編成するため。
     </p></li><li class="listitem"><p>サードパーティのアプリケーションを別々のスキーマに入れることにより、他のオブジェクトの名前と競合しないようにするため。
     </p></li></ul></div><p>

スキーマは、入れ子にできないという点を除き、オペレーティングシステムのディレクトリと似ています。
  </p><div class="sect2" id="DDL-SCHEMAS-CREATE"><div class="titlepage"><div><div><h3 class="title">5.8.1. スキーマの作成</h3></div></div></div><a id="id-1.5.4.10.7.2" class="indexterm"></a><p>スキーマを作成するには、<a class="xref" href="sql-createschema.html" title="CREATE SCHEMA"><span class="refentrytitle">CREATE SCHEMA</span></a>コマンドを使用します。
スキーマに自由に名前を付けます。
例を示します。
</p><pre class="programlisting">CREATE SCHEMA myschema;</pre><p>
   </p><a id="id-1.5.4.10.7.4" class="indexterm"></a><a id="id-1.5.4.10.7.5" class="indexterm"></a><p>スキーマ内にオブジェクトを作成したりこれにアクセスするには、スキーマ名とテーブル名をドットで区切った<em class="firstterm">修飾名</em>を書きます。
</p><pre class="synopsis"><em class="replaceable"><code>schema</code></em><code class="literal">.</code><em class="replaceable"><code>table</code></em></pre><p>
この方法は、後の章で説明するテーブル変更コマンドやデータアクセスコマンドなど、テーブル名を必要とする場合すべてに使用できます。
（話を簡単にするため、テーブルについてのみ述べます。
しかし型や関数といった名前付きのオブジェクトの他の種類について同様の考え方が適用できます。）
   </p><p>実際には、より一般的な以下の構文
</p><pre class="synopsis"><em class="replaceable"><code>database</code></em><code class="literal">.</code><em class="replaceable"><code>schema</code></em><code class="literal">.</code><em class="replaceable"><code>table</code></em></pre><p>
を使用することもできますが、現在ではこの構文は標準SQLに<span class="foreignphrase"><em class="foreignphrase">形式的に</em></span>準拠するためにのみ存在しています。
記述されるデータベース名は、接続しているデータベースと同じ名前でなければなりません。
   </p><p>ですから、新しいスキーマにテーブルを作成するには次のようにします。
</p><pre class="programlisting">CREATE TABLE myschema.mytable (
 ...
);</pre><p>
   </p><a id="id-1.5.4.10.7.9" class="indexterm"></a><p>空のスキーマ（全てのオブジェクトが削除されたスキーマ）を削除するには次のようにします。
</p><pre class="programlisting">DROP SCHEMA myschema;</pre><p>
スキーマ内の全オブジェクトも含めてスキーマを削除する場合には次のようにします。
</p><pre class="programlisting">DROP SCHEMA myschema CASCADE;</pre><p>
この背後にある一般的な機構についての詳細は<a class="xref" href="ddl-depend.html" title="5.13. 依存関係の追跡">Section 5.13</a>を参照してください。
   </p><p>他のユーザが所有するスキーマを作成したい場合があります（これは他のユーザの活動を明確に定義された名前空間内に制限する方法の1つです）。
そのための構文は次の通りです。
</p><pre class="programlisting">CREATE SCHEMA <em class="replaceable"><code>schema_name</code></em> AUTHORIZATION <em class="replaceable"><code>user_name</code></em>;</pre><p>
スキーマ名は省略することもでき、その場合スキーマ名はユーザ名と同じになります。
この構文の便利な使用方法は<a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">Section 5.8.6</a>に記載されています。
   </p><p><code class="literal">pg_</code>で始まるスキーマ名は、システム上の使用のため予約されており、ユーザが作成することはできません。
   </p></div><div class="sect2" id="DDL-SCHEMAS-PUBLIC"><div class="titlepage"><div><div><h3 class="title">5.8.2. publicスキーマ</h3></div></div></div><a id="id-1.5.4.10.8.2" class="indexterm"></a><p>これまでの節ではスキーマ名を指定せずにテーブルを作成してきました。
デフォルトでは、このようなテーブル（および他のオブジェクト）は自動的に<span class="quote">“<span class="quote">public</span>”</span>という名前のスキーマに入れられます。
新しいデータベースには全てこのようなスキーマが含まれています。
そのため、以下の2つの構文は同等です。
</p><pre class="programlisting">CREATE TABLE products ( ... );</pre><p>
および
</p><pre class="programlisting">CREATE TABLE public.products ( ... );</pre><p>
   </p></div><div class="sect2" id="DDL-SCHEMAS-PATH"><div class="titlepage"><div><div><h3 class="title">5.8.3. スキーマ検索パス</h3></div></div></div><a id="id-1.5.4.10.9.2" class="indexterm"></a><a id="id-1.5.4.10.9.3" class="indexterm"></a><a id="id-1.5.4.10.9.4" class="indexterm"></a><p>修飾名を書くのは手間がかかりますし、どちらにしても、アプリケーションに特定のスキーマ名を書き込まない方が良いことも多いのです。
そのため、テーブルは多くの場合、テーブル名しか持たない<em class="firstterm">非修飾名</em>として参照されます。
システムは、検索するスキーマのリストである<em class="firstterm">検索パス</em>に従って、どのテーブルを指しているのかを判別します。
検索パスで最初に一致したテーブルが、該当テーブルだと解釈されます。
検索パス内に一致するテーブルがないと、データベースの他のスキーマ内に一致するテーブルがある場合でもエラーが報告されます。
   </p><p>同じ名前のオブジェクトを異なるスキーマに作成できる結果、正確に同じオブジェクトを参照する問合せを書く作業が、いつも複雑になります。
また、ユーザが悪意を持って、あるいは偶然に他のユーザの問合せの挙動を変える可能性をもたらします。
<span class="productname">PostgreSQL</span>内部では非修飾名を問合せ中で使うことが一般的なので、<code class="varname">search_path</code>にスキーマを追加することは、<code class="literal">CREATE</code>の書き込み権限を持っているすべてのユーザを、実質的に信頼することになります。
あなたが通常の問合せを実行する際、あなたのサーチパス内のスキーマにオブジェクトを作成できる悪意のあるユーザは、支配権を奪い、あたかもあなたが実行したように任意のSQL関数を実行できます。
  </p><a id="id-1.5.4.10.9.7" class="indexterm"></a><p>検索パスの最初に列挙されているスキーマは、「現在のスキーマ」と呼ばれます。
現在のスキーマは、検索される最初のスキーマであると同時に、スキーマ名を指定せずに<code class="command">CREATE TABLE</code>コマンドでテーブルを作成した場合に新しいテーブルが作成されるスキーマでもあります。
   </p><a id="id-1.5.4.10.9.9" class="indexterm"></a><p>現行の検索パスを示すには次のコマンドを使用します。
</p><pre class="programlisting">SHOW search_path;</pre><p>
デフォルトの設定では次のように返されます。
</p><pre class="screen"> search_path
--------------
 "$user", public</pre><p>
最初の要素は、現行ユーザと同じ名前のスキーマを検索することを指定しています。
そのようなスキーマが存在していない場合、この項目は無視されます。
2番目の要素は、先ほど説明したpublicスキーマを参照しています。
   </p><p>実存するスキーマのうち、検索パス内で最初に現れるスキーマが、新規オブジェクトが作成されるデフォルトの場所になります。
これが、デフォルトでオブジェクトがpublicスキーマに作成される理由です。
オブジェクトがスキーマ修飾なしで別の文脈で参照される場合（テーブル変更、データ変更、あるいは問い合わせコマンドなど）、一致するオブジェクトが見つかるまで検索パス内で探索されます。
そのためデフォルト構成では、非修飾のアクセスはpublicスキーマしか参照できません。
   </p><p>新しいスキーマをパスに追加するには次のようにします。
</p><pre class="programlisting">SET search_path TO myschema,public;</pre><p>
（<code class="literal">$user</code>はまだ必要ないので、ここでは省略しています。）
そして、次のようにしてスキーマ修飾なしでテーブルにアクセスします。
</p><pre class="programlisting">DROP TABLE mytable;</pre><p>
また、<code class="literal">myschema</code>はパス内の最初の要素なので、新しいオブジェクトはデフォルトでここに作成されます。
   </p><p>以下のように書くこともできます。
</p><pre class="programlisting">SET search_path TO myschema;</pre><p>
このようにすると、今後は修飾名なしでpublicスキーマにアクセスすることができなくなります。
publicスキーマはデフォルトで存在するということ以外に特別な意味はありません。
他のスキーマと同様に削除することもできます。
   </p><p>スキーマ検索パスを操作する他の方法については<a class="xref" href="functions-info.html" title="9.25. システム情報関数">Section 9.25</a>を参照してください。
   </p><p>検索パスはデータ型名、関数名、演算子名についても、テーブル名の場合と同じように機能します。
データ型および関数の名前は、テーブル名とまったく同じように修飾することができます。
式で修飾演算子名を書く場合には、特別な決まりがあります。
それは以下の通りです。
</p><pre class="synopsis"><code class="literal">OPERATOR(</code><em class="replaceable"><code>schema</code></em><code class="literal">.</code><em class="replaceable"><code>operator</code></em><code class="literal">)</code></pre><p>
この規則は構文が曖昧になることを防ぐためのものです。
以下に例を示します。
</p><pre class="programlisting">SELECT 3 OPERATOR(pg_catalog.+) 4;</pre><p>
実際の場面ではこのような見づらい構文を書かなくて済むように、演算子についても検索パスが使用されています。
   </p></div><div class="sect2" id="DDL-SCHEMAS-PRIV"><div class="titlepage"><div><div><h3 class="title">5.8.4. スキーマおよび権限</h3></div></div></div><a id="id-1.5.4.10.10.2" class="indexterm"></a><p>ユーザは、デフォルトでは所有していないスキーマのオブジェクトをアクセスすることはできません。
アクセスするためには、そのスキーマの所有者からスキーマの<code class="literal">USAGE</code>権限を付与してもらわなければなりません。
そのスキーマ内のオブジェクトに対して操作を行うには、そのオブジェクトに応じて、さらに追加の権限が必要となる場合があります。
   </p><p>他のユーザのスキーマ内でオブジェクトを作成できるようにすることも可能です。
それには、スキーマ上で<code class="literal">CREATE</code>権限が付与されていなければなりません。
デフォルトでは、<code class="literal">public</code> スキーマに関しては全てのユーザが<code class="literal">CREATE</code>と<code class="literal">USAGE</code>権限を持っていることに注意してください。
つまり、全てのユーザは、そのユーザが接続できる任意のデータベース上の<code class="literal">public</code>スキーマにオブジェクトを作成できるということです。
<a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">利用パターン</a>では、その権限を剥奪することを求めています。
</p><pre class="programlisting">REVOKE CREATE ON SCHEMA public FROM PUBLIC;</pre><p>
（最初の<span class="quote">“<span class="quote">public</span>”</span>はスキーマです。2番目の<span class="quote">“<span class="quote">public</span>”</span>は<span class="quote">“<span class="quote">全てのユーザ</span>”</span>を意味します。
最初のpublicは識別子で、2番目のpublicはキーワードなので、それぞれ小文字、大文字を使用しています。<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS" title="4.1.1. 識別子とキーワード">Section 4.1.1</a>のガイドラインを思い出してください。）
   </p></div><div class="sect2" id="DDL-SCHEMAS-CATALOG"><div class="titlepage"><div><div><h3 class="title">5.8.5. システムカタログスキーマ</h3></div></div></div><a id="id-1.5.4.10.11.2" class="indexterm"></a><p>各データベースには、<code class="literal">public</code>およびユーザ作成のスキーマの他に<code class="literal">pg_catalog</code>スキーマが含まれています。
このスキーマにはシステムテーブルと全ての組み込みデータ型、関数および演算子が含まれています。
<code class="literal">pg_catalog</code>は常に検索パスに含まれています。
パスに明示的にリストされていない場合は、パスのスキーマを検索する<span class="emphasis"><em>前</em></span>に暗黙的に検索されます。
これにより組み込みの名前が常に検索されることが保証されます。
しかし、ユーザ定義の名前で組み込みの名前を上書きする場合は、<code class="literal">pg_catalog</code>を明示的にパスの最後に置くことができます。
   </p><p>システムカタログの名前は<code class="literal">pg_</code>で始まりますので、このような名前は使用しないのが得策と言えます。
今後のバージョンでユーザのテーブルと同じ名前のシステムカタログが定義され、競合する事態を避けるためです。
（その結果、デフォルトの検索パスでは、ユーザのテーブル名への非修飾の参照はシステムカタログとして解決されることになります。）
システムカタログは今後も<code class="literal">pg_</code>で始まる規則に従うので、ユーザが<code class="literal">pg_</code>という接頭辞を使わない限り、非修飾のユーザ定義テーブル名がシステムカタログと競合することはありません。
   </p></div><div class="sect2" id="DDL-SCHEMAS-PATTERNS"><div class="titlepage"><div><div><h3 class="title">5.8.6. 使用パターン</h3></div></div></div><p>スキーマは様々な方法でデータの編成に使用できます。
デフォルト構成で簡単にサポートできるお勧めの使用パターンがいくつかあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>一般ユーザに、ユーザ個人用のスキーマだけを使わせます。
これを実現するには、<code class="literal">REVOKE CREATE ON SCHEMA public FROM PUBLIC</code>を発行し、個々のユーザにユーザと同じ名前でスキーマを作成してください。
以前からログインしているユーザに対しては、<code class="literal">pg_catalog</code>スキーマ内にあるのと同じ名前のpublicスキーマ内のオブジェクトを監視することを考慮してください。
デフォルトサーチパスは、ユーザ名として解釈される<code class="literal">$user</code>で始まることを思い出してください。
ですから、デフォルトではユーザは別々のスキーマを所有し、自身のスキーマにアクセスします。
      </p></li><li class="listitem"><p><code class="literal">ALTER ROLE <em class="replaceable"><code>user</code></em> SET search_path = "$user"</code>を使って個々のユーザのデフォルトサーチパスからpublicスキーマを削除します。
すべてのユーザは依然としてpublicスキーマにオブジェクトを作ることはできますが、修飾名を使わなければそのオブジェクトを選択できません。
<code class="literal">CREATEROLE</code>権限を保持するユーザは、この設定を元に戻して、この設定に依存しているユーザの資格で任意の問合せを発行できます。
この、ほとんどスーパユーザと言える能力を与えずに<code class="literal">CREATEROLE</code>をユーザに許可したいのであれば、最初に述べたパターンを代わりに使用してください。
      </p></li><li class="listitem"><p><a class="link" href="config-setting.html#CONFIG-SETTING-CONFIGURATION-FILE" title="19.1.2. 設定ファイルによるパラメータ操作"><code class="filename">postgresql.conf</code></a>の<code class="varname">search_path</code>からpublicスキーマを削除します。
これによるユーザ体験は一つ前のパターンと合致します。
<code class="literal">CREATEROLE</code>のもたらす結果に加え、これはデータベース所有者を同じ方法で信頼することになります。
ほとんどスーパユーザアクセスと言えるアクセス権を与えずに、<code class="literal">CREATEROLE</code>権限、<code class="literal">CREATEDB</code>権限、あるいは個々のデータベース所有権をユーザに割り当てるには、最初のパターンを代わりに使用してください。
      </p></li><li class="listitem"><p>デフォルトを維持します。
すべてのユーザがpublicスキーマに暗黙的にアクセスします。
これはスキーマを考慮しない世界からのスムースな移行を可能にしながら、スキーマがまったく利用できない状況をシミュレートします。
しかし、ユーザは自分自身を守る気がなく、任意のユーザ権限で任意の問合せを発行できます。
このパターンは、データベースに一人、あるいは少数のお互いに信頼できるユーザだけが存在する場合にのみ受け入れ可能です。
      </p></li></ul></div><p>
   </p><p>どのパターンでも、共有のアプリケーション（全員が使うテーブル、サードパーティが提供する追加の関数など）をインストールするには、別のスキーマにアプリケーションを入れてください。
他のユーザがアプリケーションにアクセスするために、適切な権限を与えることを忘れないようにしてください。
ユーザはスキーマ名で名前を修飾するか、あるいは追加スキーマをサーチパスに入れるかを選択し、これらの追加オブジェクトを参照できます。
   </p></div><div class="sect2" id="DDL-SCHEMAS-PORTABILITY"><div class="titlepage"><div><div><h3 class="title">5.8.7. 移植性</h3></div></div></div><p>標準SQLでは、1つのスキーマ内のオブジェクトを異なるユーザが所有するという概念は存在しません。
それどころか、実装によっては所有者と異なる名前のスキーマを作成することが許可されていない場合もあります。
実際、標準で規定されている基本スキーマサポートのみを実装しているデータベースシステムでは、スキーマという概念とユーザという概念はほとんど同じなのです。
そのため、修飾名とは<code class="literal"><em class="replaceable"><code>username</code></em>.<em class="replaceable"><code>tablename</code></em></code>のことであると思っているユーザはたくさんいます。
<span class="productname">PostgreSQL</span>においても、ユーザごとに1つのスキーマを作成すると、このようになります。
   </p><p>また、標準SQLには、<code class="literal">public</code>スキーマという概念もありません。
標準に最大限従うためには、<code class="literal">public</code>スキーマは使用すべきではありません。
   </p><p>もちろん、スキーマをまったく実装していなかったり、または、データベース間アクセスを（場合によっては制限付きで）許可することによって名前空間の使用をサポートしているSQLデータベースもあります。
このようなシステムで作業する必要がある場合は、スキーマをまったく使わないようにすることで最大限の移植性を実現できます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-rowsecurity.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-inherit.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.7. 行セキュリティポリシー </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.9. 継承</td></tr></table></div></body></html>