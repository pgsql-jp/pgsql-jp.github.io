<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>40.7. ルール対トリガ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="rules-status.html" title="40.6. ルールおよびコマンドの状態" /><link rel="next" href="xplang.html" title="Chapter 41. 手続き言語" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">40.7. ルール対トリガ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules-status.html" title="40.6. ルールおよびコマンドの状態">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Chapter 40. ルールシステム">Up</a></td><th width="60%" align="center">Chapter 40. ルールシステム</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="xplang.html" title="Chapter 41. 手続き言語">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="RULES-TRIGGERS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">40.7. ルール対トリガ</h2></div></div></div><a id="id-1.8.6.12.2" class="indexterm"></a><a id="id-1.8.6.12.3" class="indexterm"></a><p>トリガによって行われる多くの操作は<span class="productname">PostgreSQL</span>のルールシステムで実装可能です。
ルールで実装できないものの1つはある種の制約、特に外部キーに関してです。
もし他のテーブルに列の値がなかった場合、条件ルールでコマンドを<code class="literal">NOTHING</code>に書き換えてしまうことも可能ですが、これではデータがだまって消去されてしまい、良いアイディアとは言えません。
有効な値かどうかのチェックが必要で、無効な値についてはエラーメッセージを表示する必要があるなら、このことは今のところトリガを使って行わなければなりません。</p><p>この章ではビューを更新するのにルールを使うことに焦点を当ててきました。
この章の更新ルールの例はすべてビューの<code class="literal">INSTEAD OF</code>トリガを使っても実装できます。
特に更新を実行するのに複雑な論理が要求される場合には、そのようなトリガを書くことはしばしばルールを書くよりも簡単です。</p><p>どちらでも実装できる事項に関してどちらがベストかはデータベースの使用方法によります。
トリガは各行に対して一度起動します。
ルールは問い合わせを修正するか追加の問い合わせを生成します。
ですから、1つの文が多くの行に影響を与える場合、1つの行を処理する度に呼び出され、何をするかを何度も再決定しなければならないトリガよりも、追加の問い合わせを1つ発行するルールの方がほとんどの場合高速になります。
しかし、トリガ方式は概念的にルールシステムよりかなり単純であり、初心者は簡単に正しく扱うことができます。</p><p>ここで、ある状況下でルールとトリガのどちらを選択するかを示す例を挙げます。
例えば、2つのテーブルがあるとします。

</p><pre class="programlisting">CREATE TABLE computer (
    hostname        text,    -- インデックスあり
    manufacturer    text     -- インデックスあり
);

CREATE TABLE software (
    software        text,    -- インデックスあり
    hostname        text     -- インデックスあり
);</pre><p>

2つのテーブルにはともに数千の行があって、<code class="structfield">hostname</code>上のインデックスは一意です。
ルール/トリガは削除されたホストを参照する、<code class="literal">software</code>の行を削除する制限を実装しなければなりません。
トリガの場合は以下のコマンドを使用します。

</p><pre class="programlisting">DELETE FROM software WHERE hostname = $1;</pre><p>

<code class="literal">computer</code>から削除された行1つひとつに対してこのトリガが呼び出されますので、このコマンドの準備を行い、計画を保存し、パラメータとして<code class="structfield">hostname</code>を渡すことができます。
ルールの場合は以下のように作成されます。

</p><pre class="programlisting">CREATE RULE computer_del AS ON DELETE TO computer
    DO DELETE FROM software WHERE hostname = OLD.hostname;</pre><p>
   </p><p>ここで別の類の削除を考えてみましょう。

</p><pre class="programlisting">DELETE FROM computer WHERE hostname = 'mypc.local.net';</pre><p>

上のような場合では、<code class="literal">computer</code>はインデックスにより（高速に）スキャンされます。
トリガによってこのコマンドが発行された場合もインデックススキャンが使用されます（高速です）。
ルールによる追加コマンドは以下のようになります。

</p><pre class="programlisting">DELETE FROM software WHERE computer.hostname = 'mypc.local.net'
                       AND software.hostname = computer.hostname;</pre><p>

適切なインデックスが設定されていますので、プランナは以下の計画を作成します。

</p><pre class="literallayout">Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software</pre><p>

ですので、トリガとルールの実装間での速度差はあまりありません。
   </p><p>次の削除処理では<code class="structfield">hostname</code>が<code class="literal">old</code>で始まる2,000台全てのcomputerを削除しようと思います。
方法として2つの有効な問い合わせがあって、1つは以下のようなものです。

</p><pre class="programlisting">DELETE FROM computer WHERE hostname &gt;= 'old'
                       AND hostname &lt;  'ole'</pre><p>

ルールによって追加されるコマンドは以下のようになります。

</p><pre class="programlisting">DELETE FROM software WHERE computer.hostname &gt;= 'old' AND computer.hostname &lt; 'ole'
                       AND software.hostname = computer.hostname;</pre><p>

これに対する計画は以下のようになります。

</p><pre class="literallayout">Hash Join
  -&gt;  Seq Scan on software
  -&gt;  Hash
    -&gt;  Index Scan using comp_hostidx on computer</pre><p>

もう1つのコマンドは以下のようなものです。

</p><pre class="programlisting">DELETE FROM computer WHERE hostname ~ '^old';</pre><p>

これにより、ルールによって追加されるコマンド用の実行計画は以下のようになります。

</p><pre class="literallayout">Nestloop
  -&gt;  Index Scan using comp_hostidx on computer
  -&gt;  Index Scan using soft_hostidx on software</pre><p>

これが示していることは、<code class="literal">AND</code>で結合された複数の検索条件が存在する場合、プランナは正規表現版のコマンドでは行っていることですが、<code class="literal">computer</code>上の<code class="structfield">hostname</code>に対する検索条件を<code class="literal">software</code>上のインデックススキャンにも同様に使用できることを理解しないということです。
トリガは削除されるべき2,000台の旧式コンピュータのそれぞれについて1回呼び出され、結果<code class="literal">computer</code>上で1回のインデックススキャンと<code class="literal">software</code>上で2,000回のインデックススキャンが行われます。
ルールによる実装ではインデックスを使用する2つの問い合わせによって実行されます。
シーケンシャルスキャンの場合でもルールがより速いかどうかは<code class="literal">software</code>テーブルの大きさに依存します。
参照する全てのインデックスブロックがすぐにキャッシュに現れるとしても、トリガによるSPIマネージャ経由の2,000回のコマンドの実行には時間を要します。</p><p>最後のコマンドを見てみましょう。

</p><pre class="programlisting">DELETE FROM computer WHERE manufacturer = 'bim';</pre><p>

この文でも<code class="literal">computer</code>から多くの行が削除される結果となります。
ですので、ここでもトリガはエクゼキュータを通して多くのコマンドを実行することになります。
ルールで作成されるコマンドは以下のようなものです。

</p><pre class="programlisting">DELETE FROM software WHERE computer.manufacturer = 'bim'
                       AND software.hostname = computer.hostname;</pre><p>

このコマンド用の計画もまた前回同様2つのインデックススキャンのネステッドループとなります。
<code class="literal">computer</code>の別のインデックスを使用する点のみが異なります。

</p><pre class="programlisting">Nestloop
  -&gt;  Index Scan using comp_manufidx on computer
  -&gt;  Index Scan using soft_hostidx on software</pre><p>

いずれの場合においても、ルールシステムが生成する追加コマンドは影響を受ける行数からは多かれ少なかれ独立しています。</p><p>まとめると、問い合わせ結果が大きく、プランナがうまく結合条件を設定できないような状況下でのみルールはトリガに比べて明らかに遅くなります。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules-status.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="xplang.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">40.6. ルールおよびコマンドの状態 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 41. 手続き言語</td></tr></table></div></body></html>