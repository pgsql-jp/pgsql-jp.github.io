<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.6. 制御構造</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-statements.html" title="42.5. 基本的な文" /><link rel="next" href="plpgsql-cursors.html" title="42.7. カーソル" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.6. 制御構造</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-statements.html" title="42.5. 基本的な文">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-cursors.html" title="42.7. カーソル">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-CONTROL-STRUCTURES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.6. 制御構造</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-STATEMENTS-RETURNING">42.6.1. 関数からの復帰</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-CONDITIONALS">42.6.2. 条件分岐</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-CONTROL-STRUCTURES-LOOPS">42.6.3. 単純なループ</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-RECORDS-ITERATING">42.6.4. 問い合わせ結果による繰り返し</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-FOREACH-ARRAY">42.6.5. 配列を巡回</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING">42.6.6. エラーの捕捉</a></span></dt><dt><span class="sect2"><a href="plpgsql-control-structures.html#PLPGSQL-CALL-STACK">42.6.7. 実行位置情報の取得</a></span></dt></dl></div><p>制御構造はおそらく<span class="application">PL/pgSQL</span>の最も有用（かつ重要）な部分です。
<span class="application">PL/pgSQL</span>の制御構造を使用して、<span class="productname">PostgreSQL</span>のデータを非常に柔軟、強力に操作することができます。
   </p><div class="sect2" id="PLPGSQL-STATEMENTS-RETURNING"><div class="titlepage"><div><div><h3 class="title">42.6.1. 関数からの復帰</h3></div></div></div><p>関数からデータを返すために使用できるコマンドが2つあります。
<code class="command">RETURN</code>および<code class="command">RETURN NEXT</code>です。
    </p><div class="sect3" id="id-1.8.8.8.3.3"><div class="titlepage"><div><div><h4 class="title">42.6.1.1. <code class="command">RETURN</code></h4></div></div></div><pre class="synopsis">RETURN <em class="replaceable"><code>expression</code></em>;</pre><p>式を持つ<code class="command">RETURN</code>は関数を終了し、<em class="replaceable"><code>expression</code></em>の値を呼び出し元に返します。
この形式は集合を返さない<span class="application">PL/pgSQL</span>関数で使用されます。
     </p><p>スカラ型を返す関数において、代入のところで説明したように、式の結果は自動的に関数の戻り値の型にキャストされます。
しかし、複合（行）値を返すためには、要求された列集合を正確に導出する式を記述しなければなりません。
これにより、明示的なキャストの使用が必要となることがあります。
     </p><p>出力パラメータを持った関数を宣言した時は、式の無い<code class="command">RETURN</code>を記述してください。
その時点における出力パラメータの値が返されます。
     </p><p><code class="type">void</code>を返すように関数を宣言した場合でも、関数を直ちに抜け出すために<code class="command">RETURN</code>を使用できますが、<code class="command">RETURN</code>の後に式を記述しないでください。
     </p><p>関数の戻り値は未定義とさせたままにすることはできません。
制御が、<code class="command">RETURN</code>文が見つからない状態で関数の最上位のブロックの終わりまで達した時、実行時エラーが発生します。
しかし、この制限は出力パラメータを持った関数及び<code class="type">void</code>を返す関数には当てはまりません。
このような場合は最上位のブロックが終わった時、<code class="command">RETURN</code>文が自動的に実行されます。
     </p><p>例を示します。

</p><pre class="programlisting">-- スカラ型を返す関数
RETURN 1 + 2;
RETURN scalar_var;

-- 複合型を返す関数
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- 正しい型の列にキャストしなければなりません</pre><p>
     </p></div><div class="sect3" id="id-1.8.8.8.3.4"><div class="titlepage"><div><div><h4 class="title">42.6.1.2. <code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code></h4></div></div></div><a id="id-1.8.8.8.3.4.2" class="indexterm"></a><a id="id-1.8.8.8.3.4.3" class="indexterm"></a><pre class="synopsis">RETURN NEXT <em class="replaceable"><code>expression</code></em>;
RETURN QUERY <em class="replaceable"><code>query</code></em>;
RETURN QUERY EXECUTE <em class="replaceable"><code>command-string</code></em> [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>];</pre><p><span class="application">PL/pgSQL</span>関数が<code class="literal">SETOF <em class="replaceable"><code>sometype</code></em></code>を返すように宣言した場合、後続の処理が多少違います。
この場合、戻り値の個々の項目は、<code class="command">RETURN NEXT</code>コマンドまたは<code class="command">RETURN QUERY</code>コマンドで指定されます。
そして、引数のない最後の<code class="command">RETURN</code>コマンドにより、関数が実行を終了したことが示されます。
<code class="command">RETURN NEXT</code>は、スカラ型および複合型の両方で使用することができます。
複合型の場合、結果の<span class="quote">“<span class="quote">テーブル</span>”</span>全体が返されます。
<code class="command">RETURN QUERY</code>は、問い合わせを実行した結果を関数の結果集合に追加します。
<code class="command">RETURN NEXT</code>と<code class="command">RETURN QUERY</code>は、単一の集合を返す関数の中で自由に混合できます。
この場合、連結されたものが結果となります。
     </p><p>実際には、<code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code>は関数から戻りません。
単に関数の結果集合に行を追加しているだけです。
そして、その実行は<span class="application">PL/pgSQL</span>関数内の次の文に継続します。
<code class="command">RETURN NEXT</code>または<code class="command">RETURN QUERY</code>コマンドが連続して実行されると、結果集合が作成されます。
最後の、引数を持ってはならない<code class="command">RETURN</code>により、関数の終了を制御します
(または制御を関数の最後に移すことができます)。
     </p><p><code class="command">RETURN QUERY</code>には<code class="command">RETURN QUERY EXECUTE</code>という亜種があり、それは問い合わせが動的に実行されることを指定します。
パラメータ式を、<code class="command">EXECUTE</code>コマンド内と全く同じように、<code class="literal">USING</code>によって演算された問い合わせ文字列に挿入することができます。
     </p><p>出力パラメータを持つ関数を宣言した時は、式の無い<code class="command">RETURN NEXT</code>だけを記述してください。
実行の度に、その時点における出力パラメータの値が、関数からの戻り値のために結果の行として保存されます。
出力パラメータを持つ集合を返す関数を作成するためには、出力パラメータが複数の時は<code class="literal">SETOF record</code>を返すように関数を宣言し、単一の<em class="replaceable"><code>sometype</code></em>型の出力パラメータの時は<code class="literal">SETOF <em class="replaceable"><code>sometype</code></em></code>を返すように関数を宣言しなければならないことに注意してください。
     </p><p><code class="command">RETURN NEXT</code>を使用する関数の例を以下に示します。

</p><pre class="programlisting">CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- ここで処理を実行できます
        RETURN NEXT r; -- SELECTの現在の行を返します
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();</pre><p>
     </p><p><code class="command">RETURN QUERY</code>を使用する関数の例を以下に示します。

</p><pre class="programlisting">CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);

-- 実行が終わっていないので、行が返されたか検査して、行がなければ例外を発生させます。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- 利用できるフライトを返し、フライトがない場合は例外を発生させます。
SELECT * FROM get_available_flightid(CURRENT_DATE);</pre><p>
     </p><div class="note"><h3 class="title">Note</h3><p>上記のように、<code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code>の現在の実装では、関数から返される前に結果集合全体を保管します。
これにより、<span class="application">PL/pgSQL</span>関数が非常に大量の結果集合を返した場合、性能が低下する可能性があります。
メモリの枯渇を避けるため、データはディスクに書き込まれます。
しかし、関数自体は結果集合全体が生成されるまでは戻りません。
将来の<span class="application">PL/pgSQL</span>のバージョンでは、この制限を受けずに集合を返す関数をユーザが定義できるようになるかもしれません。
現在、データがディスクに書き込まれ始まる時点は<a class="xref" href="runtime-config-resource.html#GUC-WORK-MEM">work_mem</a>設定変数によって制御されています。
大量の結果集合を保管するのに十分なメモリがある場合、管理者はこのパラメータの値を大きくすることを考慮すべきです。
      </p></div></div></div><div class="sect2" id="PLPGSQL-CONDITIONALS"><div class="titlepage"><div><div><h3 class="title">42.6.2. 条件分岐</h3></div></div></div><p><code class="command">IF</code>と<code class="command">CASE</code>文はある条件に基づいて代わりのコマンドを実行させます。
<span class="application">PL/pgSQL</span>には、以下のような３つの<code class="command">IF</code>の形式があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">IF ... THEN ... END IF</code></p></li><li class="listitem"><p><code class="literal">IF ... THEN ... ELSE ... END IF</code></p></li><li class="listitem"><p><code class="literal">IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</code></p></li></ul></div><p>

また、以下のような２つの<code class="command">CASE</code>の形式があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">CASE ... WHEN ... THEN ... ELSE ... END CASE</code></p></li><li class="listitem"><p><code class="literal">CASE WHEN ... THEN ... ELSE ... END CASE</code></p></li></ul></div><p>
    </p><div class="sect3" id="id-1.8.8.8.4.3"><div class="titlepage"><div><div><h4 class="title">42.6.2.1. <code class="literal">IF-THEN</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
END IF;</pre><p><code class="literal">IF-THEN</code>文は最も単純な<code class="literal">IF</code>の形式です。
<code class="literal">THEN</code>と<code class="literal">END IF</code>の間の文が条件が真の場合に実行されます。
さもなければそれらは飛ばされます。
       </p><p>例：
</p><pre class="programlisting">IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.8.4.4"><div class="titlepage"><div><div><h4 class="title">42.6.2.2. <code class="literal">IF-THEN-ELSE</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
ELSE
    <em class="replaceable"><code>statements</code></em>
END IF;</pre><p><code class="literal">IF-THEN-ELSE</code>文は<code class="literal">IF-THEN</code>に加え、条件評価が偽の場合に実行すべき代替となる文の集合を指定することができます。
（これには条件がNULLと評価した場合も含まれることに注意してください。）
       </p><p>例：
</p><pre class="programlisting">IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;</pre><p>

</p><pre class="programlisting">IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;</pre><p>
     </p></div><div class="sect3" id="id-1.8.8.8.4.5"><div class="titlepage"><div><div><h4 class="title">42.6.2.3. <code class="literal">IF-THEN-ELSIF</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
[<span class="optional"> ELSIF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
[<span class="optional"> ELSIF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
    ...</span>]</span>]
[<span class="optional"> ELSE
    <em class="replaceable"><code>statements</code></em> </span>]
END IF;</pre><p>選択肢が２つだけではなくより多くになる場合があります。
<code class="literal">IF-THEN-ELSIF</code>は、順番に複数の代替手段を検査する、より便利な方法を提供します。
<code class="literal">IF</code>条件は最初の真である結果が見つかるまで連続して検査されます。
そして関連した文が実行され、その後<code class="literal">END IF</code>以降の次の文に制御が渡されます。
（以降にある<code class="literal">IF</code>条件の検査はすべて実行<span class="emphasis"><em>されません</em></span>。）
全ての<code class="literal">IF</code>条件が真でない場合、<code class="literal">ELSE</code>ブロックが（もし存在すれば）実行されます。
機能的には、<code class="literal">IF-THEN-ELSE-IF-THEN</code>コマンドを入れ子にしたものと同じですが、必要な<code class="literal">END IF</code>は1つだけです。
       </p><p>以下に例を示します。

</p><pre class="programlisting">IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- ふうむ、残る唯一の可能性はその値がNULLであることだ
    result := 'NULL';
END IF;</pre><p>
       </p><p><code class="literal">ELSIF</code>キーワードは<code class="literal">ELSEIF</code>のように書くことができます。
       </p><p>同じ作業を遂行する別の方法は、以下の例のように<code class="literal">IF-THEN-ELSE</code>文を入れ子にすることです。

</p><pre class="programlisting">IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;</pre><p>
       </p><p>しかし、この方法はそれぞれの<code class="literal">IF</code>に対応する<code class="literal">END IF</code>の記述が必要です。
従って、多くの選択肢がある場合<code class="literal">ELSIF</code>を使用するよりも厄介です。
       </p></div><div class="sect3" id="id-1.8.8.8.4.6"><div class="titlepage"><div><div><h4 class="title">42.6.2.4. 単純な<code class="literal">CASE</code></h4></div></div></div><pre class="synopsis">CASE <em class="replaceable"><code>search-expression</code></em>
    WHEN <em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> [<span class="optional"> ... </span>]</span>] THEN
      <em class="replaceable"><code>statements</code></em>
  [<span class="optional"> WHEN <em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> [<span class="optional"> ... </span>]</span>] THEN
      <em class="replaceable"><code>statements</code></em>
    ... </span>]
  [<span class="optional"> ELSE
      <em class="replaceable"><code>statements</code></em> </span>]
END CASE;</pre><p><code class="command">CASE</code>の単純な形式はオペランドの等価性にもとづく条件的実行を提供します。
<em class="replaceable"><code>search-expression</code></em>は（一度だけ）評価され、その後<code class="literal">WHEN</code>句内のそれぞれの<em class="replaceable"><code>expression</code></em>と比較されます。
一致するものが見つかると、関連した<em class="replaceable"><code>statements</code></em>が実行され、<code class="literal">END CASE</code>の次の文に制御が渡されます。
（以降の<code class="literal">WHEN</code>式は評価されません。）
一致するものが見つからない場合、<code class="literal">ELSE</code> <em class="replaceable"><code>statements</code></em>が実行されますが、<code class="literal">ELSE</code>が無いときは<code class="literal">CASE_NOT_FOUND</code>例外を引き起こします。
      </p><p>以下は簡単な例です。

</p><pre class="programlisting">CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;</pre><p>
      </p></div><div class="sect3" id="id-1.8.8.8.4.7"><div class="titlepage"><div><div><h4 class="title">42.6.2.5. 検索付き<code class="literal">CASE</code></h4></div></div></div><pre class="synopsis">CASE
    WHEN <em class="replaceable"><code>boolean-expression</code></em> THEN
      <em class="replaceable"><code>statements</code></em>
  [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> THEN
      <em class="replaceable"><code>statements</code></em>
    ... </span>]
  [<span class="optional"> ELSE
      <em class="replaceable"><code>statements</code></em> </span>]
END CASE;</pre><p><code class="command">CASE</code>の検索された形式は論理値式の真の結果に基づく条件付き実行を提供します。
それぞれの<code class="literal">WHEN</code>句の<em class="replaceable"><code>boolean-expression</code></em>は<code class="literal">true</code>となる１つが見つかるまで順番に評価されます。
その後、関連する<em class="replaceable"><code>statements</code></em>が実行され、その結果<code class="literal">END CASE</code>の次の文に制御が渡されます。
（以降の<code class="literal">WHEN</code>式は評価されません。）
真となる結果が見つからない場合、<code class="literal">ELSE</code> <em class="replaceable"><code>statements</code></em>が実行されますが、<code class="literal">ELSE</code>が存在しないときは<code class="literal">CASE_NOT_FOUND</code>例外を引き起こします。
      </p><p>以下は簡単な例です。

</p><pre class="programlisting">CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;</pre><p>
      </p><p>この形式の<code class="command">CASE</code>は、判定基準が省略された<code class="literal">ELSE</code>句に達した場合に何もしないのではなくエラーなる点を除き、<code class="literal">IF-THEN-ELSIF</code>と全く同一です。
      </p></div></div><div class="sect2" id="PLPGSQL-CONTROL-STRUCTURES-LOOPS"><div class="titlepage"><div><div><h3 class="title">42.6.3. 単純なループ</h3></div></div></div><a id="id-1.8.8.8.5.2" class="indexterm"></a><p><code class="literal">LOOP</code>、<code class="literal">EXIT</code>、<code class="literal">CONTINUE</code>、<code class="literal">WHILE</code>、<code class="literal">FOR</code>、<code class="literal">FOREACH</code>文を使用して、<span class="application">PL/pgSQL</span>関数で、一連のコマンドを繰り返すことができます。
    </p><div class="sect3" id="id-1.8.8.8.5.4"><div class="titlepage"><div><div><h4 class="title">42.6.3.1. <code class="literal">LOOP</code></h4></div></div></div><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><code class="literal">LOOP</code>は、<code class="literal">EXIT</code>文または<code class="command">RETURN</code>文によって終了されるまで無限に繰り返される、条件なしのループを定義します。
省略可能な<em class="replaceable"><code>label</code></em>は、ネステッドループにおいて<code class="literal">EXIT</code>および<code class="literal">CONTINUE</code>文がどのレベルの入れ子を参照するかを指定するために使用されます。
     </p></div><div class="sect3" id="id-1.8.8.8.5.5"><div class="titlepage"><div><div><h4 class="title">42.6.3.2. <code class="literal">EXIT</code></h4></div></div></div><a id="id-1.8.8.8.5.5.2" class="indexterm"></a><pre class="synopsis">EXIT [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>] [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> </span>];</pre><p><em class="replaceable"><code>label</code></em>が指定されない場合、最も内側のループを終わらせ、<code class="literal">END LOOP</code>の次の文がその後に実行されます。
<em class="replaceable"><code>label</code></em>が指定された場合、それは現在またはその上位のネステッドループやブロックのラベルである必要があります。
その後、指名されたループまたはブロックを終わらせ、そのループまたはブロックの対応する<code class="literal">END</code>の次の文に制御を移します。
       </p><p><code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>boolean-expression</code></em>が真の場合のみループの終了が起こります。
さもなければ、<code class="literal">EXIT</code>の後の行に制御が移ります。
       </p><p><code class="literal">EXIT</code>は、すべての種類のループと共に使用できます。
条件なしのループでの使用に限定されません。
       </p><p><code class="literal">BEGIN</code>ブロックと共に使用した時、<code class="literal">EXIT</code>によりブロックの次の文に制御が移ります。
この目的のためにラベルが使用されなければならないことに注意してください。
ラベル無しの<code class="literal">EXIT</code>は<code class="literal">BEGIN</code>ブロックに対応するとは決して考えられません。
（これは、ラベル無しの<code class="literal">EXIT</code>が<code class="literal">BEGIN</code>ブロックに対応することを許容する<span class="productname">PostgreSQL</span>の8.4より前のリリースからの変更です。）
       </p><p>例：
</p><pre class="programlisting">LOOP
    -- 何らかの演算
    IF count &gt; 0 THEN
        EXIT;  -- ループを抜け出す
    END IF;
END LOOP;

LOOP
-- 何らかの演算
    EXIT WHEN count &gt; 0;  -- 上例と同じ結果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- 何らかの演算
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- これによりBEGINブロックを抜け出す
    END IF;
    -- stokcs &gt; 100000 であればここでの演算は省略
END;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.8.5.6"><div class="titlepage"><div><div><h4 class="title">42.6.3.3. <code class="literal">CONTINUE</code></h4></div></div></div><a id="id-1.8.8.8.5.6.2" class="indexterm"></a><pre class="synopsis">CONTINUE [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>] [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> </span>];</pre><p><em class="replaceable"><code>label</code></em>が無い場合、すぐ外側のループの次の繰り返しが開始されます。
すなわち、ループ本体の残りの文は飛ばされて、他のループの繰り返しが必要かどうかを決めるため、制御がループ制御式(もし存在すれば)に戻ります。
<em class="replaceable"><code>label</code></em>が存在する場合、実行を継続するループのラベルを指定します。
       </p><p><code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>boolean-expression</code></em>が真の場合のみループにおける次の繰り返しが始まります。
さもなければ、<code class="literal">CONTINUE</code>の後の行に制御が移ります。
       </p><p><code class="literal">CONTINUE</code>は全ての種類のループで使用可能です。
条件なしのループに限定されません。
       </p><p>例
</p><pre class="programlisting">LOOP
    -- 何らかの演算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- 50から100を数える、何らかの演算
END LOOP;</pre><p>
       </p></div><div class="sect3" id="id-1.8.8.8.5.7"><div class="titlepage"><div><div><h4 class="title">42.6.3.4. <code class="literal">WHILE</code></h4></div></div></div><a id="id-1.8.8.8.5.7.2" class="indexterm"></a><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
WHILE <em class="replaceable"><code>boolean-expression</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><code class="literal">WHILE</code>文は<em class="replaceable"><code>boolean-expression</code></em>の評価が真である間、一連の文を繰り返します。
条件式は、ループ本体に入る前にのみ検査されます。
       </p><p>以下に例を示します。
</p><pre class="programlisting">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- ここで演算をいくつか行います。
END LOOP;

WHILE NOT done LOOP
    -- ここで演算をいくつか行います。
END LOOP;</pre><p>
       </p></div><div class="sect3" id="PLPGSQL-INTEGER-FOR"><div class="titlepage"><div><div><h4 class="title">42.6.3.5. 整数<code class="literal">FOR</code>ループ</h4></div></div></div><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>name</code></em> IN [<span class="optional"> REVERSE </span>] <em class="replaceable"><code>expression</code></em> .. <em class="replaceable"><code>expression</code></em> [<span class="optional"> BY <em class="replaceable"><code>expression</code></em> </span>] LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>この形式の<code class="literal">FOR</code>は整数値の範囲内で繰り返すループを生成します。
<em class="replaceable"><code>name</code></em>変数は<code class="type">integer</code>型として自動的に定義され、ループ内部のみで存在します
（ループ外部で定義しても、ループ内部では全て無視されます）。
範囲の下限、上限として与えられる2つの式はループに入った時に一度だけ評価されます。
<code class="literal">BY</code>句を指定しない時の繰り返し刻みは1ですが、<code class="literal">BY</code>句を用いて指定でき、ループに入った時に一度だけ評価されます。
<code class="literal">REVERSE</code>が指定された場合、繰り返し刻みの値は加算されるのではなく、繰り返しごとに減算されます。
       </p><p>整数FORループの例を以下に示します。
</p><pre class="programlisting">FOR i IN 1..10 LOOP
    -- i はループ内で 1、2、3、4、5、6、7、8、9、10 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- i はループ内で 10、9、8、7、6、5、4、3、2、1 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- i はループ内で 10、8、6、4、2 の値を取ります。
END LOOP;</pre><p>
       </p><p>下限が上限よりも大きい（<code class="literal">REVERSE</code>の場合はより小さい）場合、ループ本体はまったく実行されません。
エラーは発生しません。
       </p><p><em class="replaceable"><code>label</code></em>を<code class="literal">FOR</code>ループに付加することにより、<em class="replaceable"><code>label</code></em>を用いて修飾した名前の整数ループ変数を参照できます。
       </p></div></div><div class="sect2" id="PLPGSQL-RECORDS-ITERATING"><div class="titlepage"><div><div><h3 class="title">42.6.4. 問い合わせ結果による繰り返し</h3></div></div></div><p>別の種類の<code class="literal">FOR</code>ループを使用して、問い合わせの結果を繰り返し、そのデータを扱うことができます。
以下に構文を示します。
</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>target</code></em> IN <em class="replaceable"><code>query</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>
<em class="replaceable"><code>target</code></em>は、レコード変数、行変数またはカンマで区切ったスカラ変数のリストです。
<em class="replaceable"><code>target</code></em>には順次、<em class="replaceable"><code>query</code></em>の結果の全ての行が代入され、各行に対してループ本体が実行されます。
以下に例を示します。
</p><pre class="programlisting">CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- ここで"mviews"はcs_materialized_viewsの1つのレコードを持ちます

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;</pre><p>

このループが<code class="literal">EXIT</code>文で終了した場合、最後に割り当てられた行の値はループを抜けた後でもアクセスすることができます。
    </p><p>この種類の<code class="literal">FOR</code>文の<em class="replaceable"><code>query</code></em>としては、呼び出し元に行を返すSQLコマンドをすべて使用できます。
通常は<code class="command">SELECT</code>ですが、<code class="literal">RETURNING</code>句を持つ<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>も使用できます。
<code class="command">EXPLAIN</code>などのユーティリティコマンドも作動します。
    </p><p><span class="application">PL/pgSQL</span>変数は問い合わせテキストに置き換えられます。
問い合わせ計画は、<a class="xref" href="plpgsql-implementation.html#PLPGSQL-VAR-SUBST" title="42.10.1. 変数置換">Section 42.10.1</a>および<a class="xref" href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING" title="42.10.2. 計画のキャッシュ">Section 42.10.2</a>で述べたように、再利用のためにキャッシュされます。
    </p><p><code class="literal">FOR-IN-EXECUTE</code>文は行を繰り返すもう1つの方法です。
</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>target</code></em> IN EXECUTE <em class="replaceable"><code>text_expression</code></em> [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>] LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>
この方法は、問い合わせのソースが文字列式で指定される点を除き、前の形式と似ています。
この式は<code class="literal">FOR</code>ループの各項目で評価され、再計画が行われます。
これにより、プログラマは、通常の<code class="command">EXECUTE</code>文と同じように事前に計画された問い合わせによる高速性と、動的な問い合わせの持つ柔軟性を選択することができます。
<code class="command">EXECUTE</code>の場合と同様、パラメータ値は<code class="literal">USING</code>により動的コマンドに挿入できます。
    </p><p>結果を通して繰り返さなければならない問い合わせを指定するもう１つの方法として、カーソルの宣言があります。
これは<a class="xref" href="plpgsql-cursors.html#PLPGSQL-CURSOR-FOR-LOOP" title="42.7.4. カーソル結果に対するループ">Section 42.7.4</a>で説明します。
    </p></div><div class="sect2" id="PLPGSQL-FOREACH-ARRAY"><div class="titlepage"><div><div><h3 class="title">42.6.5. 配列を巡回</h3></div></div></div><p><code class="literal">FOREACH</code>ループは<code class="literal">FOR</code>ループにとてもよく似ています。
しかし、SQL 問い合わせが抽出した行を繰り返す代わりに、配列の要素を繰り返します。
（一般的に<code class="literal">FOREACH</code>は、複合値で表現される構成要素の巡回を意味しますが、配列でない複合値も巡回する亜種が将来は追加されるかもしれません。）
配列を巡回する<code class="literal">FOREACH</code>文を示します。

</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOREACH <em class="replaceable"><code>target</code></em> [<span class="optional"> SLICE <em class="replaceable"><code>number</code></em> </span>] IN ARRAY <em class="replaceable"><code>expression</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>
    </p><p><code class="literal">SLICE</code>がない、または<code class="literal">SLICE 0</code>が指定された場合、ループは<em class="replaceable"><code>expression</code></em>によって評価されて作成された配列の各要素を繰り返します。
<em class="replaceable"><code>target</code></em>変数が各要素の値に順次割り当てられ、各要素に対してループ本体が実行されます。
整数配列の要素を巡回する例を示します。

</p><pre class="programlisting">CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;</pre><p>

配列の次元数に関係なく、要素は格納した順番で処理されます。
通常<em class="replaceable"><code>target</code></em>は単一の変数ですが、複合値（レコード）の配列を巡回するときは、変数のリストも可能です。
その場合、配列の各要素に対して、変数は複合値（レコード）の列から連続的に割り当てられます。
    </p><p>正の<code class="literal">SLICE</code>値を持つ場合、<code class="literal">FOREACH</code>は単一の要素ではなく多次元配列の低次元部分配列を通して繰り返します。
<code class="literal">SLICE</code>値は、配列の次元数より小さい整数定数でなければなりません。
<em class="replaceable"><code>target</code></em>変数は配列でなければなりません。
この変数は、配列値から連続した部分配列を受けとります
ここで部分配列は<code class="literal">SLICE</code>で指定した次数となります。
以下に1次元の部分配列を通した繰り返しの例を示します。

</p><pre class="programlisting">CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}</pre><p>
    </p></div><div class="sect2" id="PLPGSQL-ERROR-TRAPPING"><div class="titlepage"><div><div><h3 class="title">42.6.6. エラーの捕捉</h3></div></div></div><a id="id-1.8.8.8.8.2" class="indexterm"></a><p>デフォルトでは、<span class="application">PL/pgSQL</span>関数の内部で発生したエラーは関数の実行を中止し、実際に上位のトランザクションをアボートします。
<code class="command">BEGIN</code>ブロックおよび<code class="literal">EXCEPTION</code>句を使用すれば、エラーを捕捉してその状態から回復できます。
その構文は通常の<code class="command">BEGIN</code>ブロックの構文を拡張したものです。

</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
[<span class="optional"> DECLARE
    <em class="replaceable"><code>declarations</code></em> </span>]
BEGIN
    <em class="replaceable"><code>statements</code></em>
EXCEPTION
    WHEN <em class="replaceable"><code>condition</code></em> [<span class="optional"> OR <em class="replaceable"><code>condition</code></em> ... </span>] THEN
        <em class="replaceable"><code>handler_statements</code></em>
    [<span class="optional"> WHEN <em class="replaceable"><code>condition</code></em> [<span class="optional"> OR <em class="replaceable"><code>condition</code></em> ... </span>] THEN
          <em class="replaceable"><code>handler_statements</code></em>
      ... </span>]
END;</pre><p>
    </p><p>エラーが発生しない時、この形式のブロックは単に全ての<em class="replaceable"><code>statements</code></em>を実行し、<code class="literal">END</code>の次の文に制御が移ります。
しかし、<em class="replaceable"><code>statements</code></em>の内部でエラーが発生すると、それ以後の<em class="replaceable"><code>statements</code></em>の処理は中断され、<code class="literal">EXCEPTION</code>リストに制御が移ります。
そしてリストの中から、発生したエラーと合致する最初の<em class="replaceable"><code>condition</code></em>を探します。
合致するものがあれば、対応する<em class="replaceable"><code>handler_statements</code></em>を実行し、<code class="literal">END</code>の次の文に制御が移ります。
合致するものがなければ、<code class="literal">EXCEPTION</code>句が存在しないのと同じで、エラーは外側に伝播します。
<code class="literal">EXCEPTION</code>を含んだ外側のブロックはエラーを捕捉できますが、失敗すると関数の処理は中断されます。
    </p><p>全ての<em class="replaceable"><code>condition</code></em>の名前は<a class="xref" href="errcodes-appendix.html" title="Appendix A. PostgreSQLエラーコード">Appendix A</a>に示したもののいずれかを取ることができます。
分類名はそこに分類される全てのエラーに合致します。
<code class="literal">OTHERS</code>という特別の状態名は<code class="literal">QUERY_CANCELED</code>と<code class="literal">ASSERT_FAILURE</code>を除く全てのエラーに合致します。
（<code class="literal">QUERY_CANCELED</code>と<code class="literal">ASSERT_FAILURE</code>を名前で捕捉することは可能ですが、賢明ではありません。）
状態名は大文字小文字を区別しません。
同時に、エラー状態は<code class="literal">SQLSTATE</code>コードで指定可能です。
例えば以下は等価です。
</p><pre class="programlisting">WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...</pre><p>
    </p><p>エラーが該当する<em class="replaceable"><code>handler_statements</code></em>内部で新たに発生した時、<code class="literal">EXCEPTION</code>句はそのエラーを捕捉できずエラーは外側に伝播します。
なお、上位の<code class="literal">EXCEPTION</code>句はそのエラーを捕捉できます。
    </p><p><code class="literal">EXCEPTION</code>句がエラーを捕捉した時、<span class="application">PL/pgSQL</span>関数のローカル変数はエラーが起こった後の状態を保ちます。
しかし、ブロック内部における永続的なデータベースの状態は、ロールバックされます。
そのような例を以下に示します。

</p><pre class="programlisting">INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;</pre><p>

制御が変数<code class="literal">y</code>の代入に移ると、<code class="literal">division_by_zero</code>エラーとなり、<code class="literal">EXCEPTION</code>句がそのエラーを捕捉します。
<code class="command">RETURN</code>文による関数の戻り値は、1を加算した後の<code class="literal">x</code>の値となりますが、<code class="command">UPDATE</code>コマンドによる結果はロールバックされます。
しかし、前のブロックの<code class="command">INSERT</code>コマンドはロールバックされません。
したがって、データベースの内容の最終結果は<code class="literal">Tom Jones</code>であり、<code class="literal">Joe Jones</code>ではありません。
    </p><div class="tip"><h3 class="title">Tip</h3><p><code class="literal">EXCEPTION</code>句を含んだブロックの実行に要する時間は、含まないブロックに比べてとても長くなります。
したがって、必要のない時に<code class="literal">EXCEPTION</code>を使用してはいけません。
     </p></div><div class="example" id="PLPGSQL-UPSERT-EXAMPLE"><p class="title"><strong>Example 42.2. <code class="command">UPDATE</code>/<code class="command">INSERT</code>の例外</strong></p><div class="example-contents"><p>
これは<code class="command">UPDATE</code>または<code class="command">INSERT</code>の実行における例外処理を使用した適当な例題です。
アプリケーションでは実際にこの方式を使うよりも、<code class="literal">ON CONFLICT DO UPDATE</code>を伴った<code class="command">INSERT</code>を使うことが推奨されます。本例は主として<span class="application">PL/pgSQL</span>の制御構造の使い方を示すものです。

</p><pre class="programlisting">CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- 最初にキーを更新する
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- キーが存在しないので、キーの挿入を試行する
        -- 他者がすでに同一のキーを挿入していたならば
        -- 一意性に違反する欠陥となります
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
        -- 何もしないで、更新を再試行します
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');</pre><p>

このコーディングでは<code class="literal">unique_violation</code>エラーの原因が<code class="command">INSERT</code>によるものであり、テーブルのトリガ関数内部の<code class="command">INSERT</code>によるものでないと仮定します。
また、テーブルに2つ以上の一意インデックスが存在した場合、どちらのインデックスがエラーの原因になろうと操作を再試行するので、誤作動となります。
捕捉したエラーが予測したものであるか検証するために、次節で記述するエラー情報を利用すれば、より安全となります。
    </p></div></div><br class="example-break" /><div class="sect3" id="PLPGSQL-EXCEPTION-DIAGNOSTICS"><div class="titlepage"><div><div><h4 class="title">42.6.6.1. エラーに関する情報の取得</h4></div></div></div><p>例外ハンドラはしばしば、起こった特定のエラーを識別する必要があります。
現在の例外に関する情報を取得する方法は2つあります。
特殊な変数と<code class="command">GET STACKED DIAGNOSTICS</code>コマンドです。
    </p><p>例外ハンドラの内部では、特殊な変数<code class="varname">SQLSTATE</code>変数が起こった例外に対応したエラーコード（<a class="xref" href="errcodes-appendix.html#ERRCODES-TABLE" title="Table A.1. PostgreSQLエラーコード">Table A.1</a>のエラーコード表を参照してください）を保有します。
特殊な変数<code class="varname">SQLERRM</code>は例外に関連したエラーメッセージを保有します。
これらの変数は、例外ハンドラの外部では定義されていません。
    </p><p>例外ハンドラの内部では、<code class="command">GET STACKED DIAGNOSTICS</code>コマンドを使用して、現在の例外に関する情報を取り出すこともできます。
次のようなやり方となります。

</p><pre class="synopsis">GET STACKED DIAGNOSTICS <em class="replaceable"><code>variable</code></em> { = | := } <em class="replaceable"><code>item</code></em> [<span class="optional"> , ... </span>];</pre><p>

各<em class="replaceable"><code>item</code></em>は、指定された変数（これは受け取るために正しいデータ型でなければなりません）に代入される状態値を識別するキーワードです。
現在使用可能なステータス項目は<a class="xref" href="plpgsql-control-structures.html#PLPGSQL-EXCEPTION-DIAGNOSTICS-VALUES" title="Table 42.2. エラーの診断値">Table 42.2</a>に表示されています。
    </p><div class="table" id="PLPGSQL-EXCEPTION-DIAGNOSTICS-VALUES"><p class="title"><strong>Table 42.2. エラーの診断値</strong></p><div class="table-contents"><table class="table" summary="エラーの診断値" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名前</th><th>型</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">RETURNED_SQLSTATE</code></td><td><code class="type">text</code></td><td>例外のSQLSTATEエラーコード</td></tr><tr><td><code class="literal">COLUMN_NAME</code></td><td><code class="type">text</code></td><td>例外に関する列名</td></tr><tr><td><code class="literal">CONSTRAINT_NAME</code></td><td><code class="type">text</code></td><td>例外に関する制約名</td></tr><tr><td><code class="literal">PG_DATATYPE_NAME</code></td><td><code class="type">text</code></td><td>例外に関するデータ型名</td></tr><tr><td><code class="literal">MESSAGE_TEXT</code></td><td><code class="type">text</code></td><td>例外の主要なメッセージのテキスト</td></tr><tr><td><code class="literal">TABLE_NAME</code></td><td><code class="type">text</code></td><td>例外に関するテーブル名</td></tr><tr><td><code class="literal">SCHEMA_NAME</code></td><td><code class="type">text</code></td><td>例外に関するスキーマ名</td></tr><tr><td><code class="literal">PG_EXCEPTION_DETAIL</code></td><td><code class="type">text</code></td><td>例外の詳細なメッセージのテキスト、存在する場合</td></tr><tr><td><code class="literal">PG_EXCEPTION_HINT</code></td><td><code class="type">text</code></td><td>例外のヒントとなるメッセージのテキスト、存在する場合</td></tr><tr><td><code class="literal">PG_EXCEPTION_CONTEXT</code></td><td><code class="type">text</code></td><td>例外時における呼び出しスタックを記述するテキストの行（<a class="xref" href="plpgsql-control-structures.html#PLPGSQL-CALL-STACK" title="42.6.7. 実行位置情報の取得">Section 42.6.7</a>を参照）</td></tr></tbody></table></div></div><br class="table-break" /><p>例外が項目の値を設定しない場合、空文字列が返されます。
    </p><p>以下に例を示します。
</p><pre class="programlisting">DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- 例外を引き起こす処理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;</pre><p>
    </p></div></div><div class="sect2" id="PLPGSQL-CALL-STACK"><div class="titlepage"><div><div><h3 class="title">42.6.7. 実行位置情報の取得</h3></div></div></div><p>以前、<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-DIAGNOSTICS" title="42.5.5. 結果ステータスの取得">Section 42.5.5</a>に記載されていた<code class="command">GET DIAGNOSTICS</code>コマンドは、現在の実行状態に関する情報を取得します（対して、前述の<code class="command">GET STACKED DIAGNOSTICS</code>コマンドは一つ前のエラー時点の実行状態を報告します）。
これの<code class="literal">PG_CONTEXT</code>ステータス項目は現在の実行位置を識別するのに役立ちます。
<code class="literal">PG_CONTEXT</code>は呼び出しスタックを記述したテキスト行を含むテキスト文字列を返します。
最初の行は現在の関数と現在実行中の<code class="command">GET DIAGNOSTICS</code>コマンドを参照します。
次行および後の行は、呼び出しスタック上の呼び出し関数を参照します。
例を示します。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)</pre><p>

   </p><p>    <code class="literal">GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</code>は同種のスタックトレースを返しますが、現在の位置ではなく、エラーが検出されたところの位置を記述します。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-statements.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-cursors.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.5. 基本的な文 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.7. カーソル</td></tr></table></div></body></html>