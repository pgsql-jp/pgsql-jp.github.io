<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>33.11. 雑多な関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq-control.html" title="33.10. 制御関数" /><link rel="next" href="libpq-notice-processing.html" title="33.12. 警告処理" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">33.11. 雑多な関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-control.html" title="33.10. 制御関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Up</a></td><th width="60%" align="center">Chapter 33. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C ライブラリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-notice-processing.html" title="33.12. 警告処理">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LIBPQ-MISC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">33.11. 雑多な関数</h2></div></div></div><p>よくあることですが、うまく分類できない関数がいくつか存在します。
  </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQFREEMEM"><span class="term">     <code class="function">PQfreemem</code>
     <a id="id-1.7.3.18.3.1.1.2" class="indexterm"></a>
    </span></dt><dd><p><span class="application">libpq</span>が割り当てたメモリを解放します。
</p><pre class="synopsis">void PQfreemem(void *ptr);</pre><p>
     </p><p>具体的には<code class="function">PQescapeByteaConn</code>、<code class="function">PQescapeBytea</code>、<code class="function">PQunescapeBytea</code>および<code class="function">PQnotifies</code>により<span class="application">libpq</span>が割り当てたメモリを解放します。
Microsoft Windowsにおいて<code class="function">free()</code>ではなく、この関数を使用することが特に重要です。
DLLにおけるメモリ割り当てとアプリケーションにおけるその解放が、DLLとアプリケーションとでマルチスレッド/シングルスレッド、リリース用/デバッグ用、静的/動的フラグが同じ場合でのみ動作するためです。
Microsoft Windowsプラットフォーム以外では、この関数は標準ライブラリの<code class="function">free()</code>関数と同じです。
     </p></dd><dt id="LIBPQ-PQCONNINFOFREE"><span class="term">     <code class="function">PQconninfoFree</code>
     <a id="id-1.7.3.18.3.2.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="function">PQconndefaults</code>もしくは<code class="function">PQconninfoParse</code>が割り当てたデータ構造を解放します。
</p><pre class="synopsis">void PQconninfoFree(PQconninfoOption *connOptions);</pre><p>
     </p><p>単純な<code class="function">PQfreemem</code>は、配列が補助文字列への参照を含んでいることから、このためには作業しません。
     </p></dd><dt id="LIBPQ-PQENCRYPTPASSWORDCONN"><span class="term">     <code class="function">PQencryptPasswordConn</code>
     <a id="id-1.7.3.18.3.3.1.2" class="indexterm"></a>
    </span></dt><dd><p><span class="productname">PostgreSQL</span>パスワードの暗号化された形式を準備します。
</p><pre class="synopsis">char *PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm);</pre><p>
この関数は、<code class="literal">ALTER USER joe PASSWORD 'pwd'</code>のようなコマンドを送信したいクライアントアプリケーションで使用されることを意図したものです。
こうしたコマンドでは、コマンドログが活動の監視などで晒されてしまうため、元々の平文テキストでパスワードを送信しないことが推奨されています。
その代わりに、この関数を使用して送信前にパスワードを暗号化形式に変換してください。
     </p><p><em class="parameter"><code>passwd</code></em>と<em class="parameter"><code>user</code></em>引数は、関数が使用する平文のパスワードとそのSQL上のユーザ名です。
<em class="parameter"><code>algorithm</code></em>は、パスワードを暗号化するために使用する暗号化アルゴリズムを指定します。
現在サポートされているアルゴリズムは、<code class="literal">md5</code>と<code class="literal">scram-sha-256</code>です。
(古いサーババージョンとの互換性のために、<code class="literal">md5</code>の別名として、<code class="literal">on</code>と<code class="literal">off</code>も受け付けます。）
<code class="literal">scram-sha-256</code>のサポートは、<span class="productname">PostgreSQL</span>バージョン10で導入されたので、古いサーババージョンでは正しく動作しないことに注意してください。
<em class="parameter"><code>algorithm</code></em>がNULLなら、この関数はサーバに問合せて現在の<a class="xref" href="runtime-config-connection.html#GUC-PASSWORD-ENCRYPTION">password_encryption</a>設定を返します。
これは、ブロックする可能性があり、また現在のトランザクションがアボートしているか、あるいは他の問合せを実行中でビジーなら失敗します。
サーバのデフォルトアルゴリズムを使用したいが、ブロックは避けたい、という場合は、<code class="function">PQencryptPasswordConn</code>を呼び出す前に<code class="function">PQencryptPasswordConn</code>を自分で調べ、その値を<em class="parameter"><code>algorithm</code></em>に渡してください。
     </p><p>戻り値は<code class="function">malloc</code>で割り当てられた文字列です。
呼び出し元は、その文字列にエスケープしなければならない特殊な文字列が含まれていないことを仮定することができます。
処理が終わった時に<code class="function">PQfreemem</code>を使用して結果を解放してください。
エラーの場合に<code class="symbol">NULL</code>が返され、接続オブジェクトに対応するメッセージが格納されます。
     </p></dd><dt id="LIBPQ-PQENCRYPTPASSWORD"><span class="term">     <code class="function">PQencryptPassword</code>
     <a id="id-1.7.3.18.3.4.1.2" class="indexterm"></a>
    </span></dt><dd><p>md5暗号化形式の<span class="productname">PostgreSQL</span>パスワードを準備します。
</p><pre class="synopsis">char *PQencryptPassword(const char *passwd, const char *user);</pre><p>
<code class="function">PQencryptPassword</code>は、古くて非推奨のバージョンの<code class="function">PQencryptPasswodConn</code>です。
違いは、<code class="function">PQencryptPassword</code>はコネクションオブジェクトを必要とせず、<code class="literal">md5</code>が常に暗号化アルゴリズムに使用されることです。
     </p></dd><dt id="LIBPQ-PQMAKEEMPTYPGRESULT"><span class="term">     <code class="function">PQmakeEmptyPGresult</code>
     <a id="id-1.7.3.18.3.5.1.2" class="indexterm"></a>
    </span></dt><dd><p>与えられたステータスで空の<code class="structname">PGresult</code>オブジェクトを構築します。
</p><pre class="synopsis">PGresult *PQmakeEmptyPGresult(PGconn *conn, ExecStatusType status);</pre><p>
     </p><p>これは空の<code class="structname">PGresult</code>オブジェクトを割り当てて、初期化する<span class="application">libpq</span>の内部関数です。
メモリが割り当てられなかった場合、この関数は<code class="symbol">NULL</code>を返します。
一部のアプリケーションで結果オブジェクト（特にエラーステータスを伴ったオブジェクト）それ自身を生成することが便利であることが分かりましたので、外部公開されました。
<em class="parameter"><code>conn</code></em>が非ヌルで、<em class="parameter"><code>status</code></em>がエラーを示唆している場合、特定された接続の現在のエラーメッセージは<code class="structname">PGresult</code>にコピーされます。
同時に、<em class="parameter"><code>conn</code></em>が非ヌルの場合、接続で登録された任意のイベントプロシージャは<code class="structname">PGresult</code>にコピーされます。
（それらは<code class="literal">PGEVT_RESULTCREATE</code>呼び出しを受けませんが、<code class="function">PQfireResultCreateEvents</code>を理解します。）
<span class="application">libpq</span>自身で返された<code class="structname">PGresult</code>と同様に、最終的にはこのオブジェクトに対して<code class="function">PQclear</code>を呼び出さなければならないことに注意してください。
     </p></dd><dt id="LIBPQ-PQFIRERESULTCREATEEVENTS"><span class="term">     <code class="function">PQfireResultCreateEvents</code>
     <a id="id-1.7.3.18.3.6.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトに登録されたそれぞれのイベントプロシージャに対し、<code class="literal">PGEVT_RESULTCREATE</code>イベント（<a class="xref" href="libpq-events.html" title="33.13. イベントシステム">Section 33.13</a>を参照）を発行します。
イベントプロシージャが成功の場合は非ゼロ、失敗の場合はゼロを返します。

</p><pre class="synopsis">int PQfireResultCreateEvents(PGconn *conn, PGresult *res);</pre><p>
     </p><p><code class="literal">conn</code>引数はイベントプロシージャに渡されますが、直接には使用されません。
イベントプロシージャが使用しない場合は<code class="symbol">NULL</code>で構いません。
     </p><p>このオブジェクトに対し、<code class="literal">PGEVT_RESULTCREATE</code>もしくは<code class="literal">PGEVT_RESULTCOPY</code>イベントを過去に受け取ったイベントプロシージャは再び発行されません。
     </p><p>この関数が<code class="function">PQmakeEmptyPGresult</code>と分離されている主たる理由は、多くの場合イベントプロシージャを呼び出す前に<code class="structname">PGresult</code>を作成し、データを挿入するのが適切であることによります。
     </p></dd><dt id="LIBPQ-PQCOPYRESULT"><span class="term">     <code class="function">PQcopyResult</code>
     <a id="id-1.7.3.18.3.7.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトのコピーを作ります。
コピーは元の結果にいかなる方法でもリンクされず、コピーが不要になった時に<code class="function">PQclear</code>を呼び出されなければなりません。
関数が失敗すると<code class="symbol">NULL</code>が返されます。

</p><pre class="synopsis">PGresult *PQcopyResult(const PGresult *src, int flags);</pre><p>
     </p><p>これは正確なコピーの作成を目的としたものではありません。
返された結果は常に<code class="literal">PGRES_TUPLES_OK</code>状態の中に置かれ、元の結果におけるエラーメッセージはまったくコピーされません。
（しかしコマンド状態文字列をコピーします。）
<em class="parameter"><code>flags</code></em>引数はその他にコピーするものがないかを決定します。
それはいくつかのフラグのビット単位のORです。
<code class="literal">PG_COPYRES_ATTRS</code>は元の結果の属性（列定義）のコピーを指定します。
<code class="literal">PG_COPYRES_TUPLES</code>は元の結果のタプルのコピーを指定します。
（これは属性もコピーされることを意味しています。）
<code class="literal">PG_COPYRES_NOTICEHOOKS</code>は元の結果の警告フックのコピーを指定します。
<code class="literal">PG_COPYRES_EVENTS</code>は元の結果イベントのコピーを指定します。
（しかし、元の結果に関連したインスタンスデータはまったくコピーされません。）
     </p></dd><dt id="LIBPQ-PQSETRESULTATTRS"><span class="term">     <code class="function">PQsetResultAttrs</code>
     <a id="id-1.7.3.18.3.8.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトの属性を設定します。
</p><pre class="synopsis">int PQsetResultAttrs(PGresult *res, int numAttributes, PGresAttDesc *attDescs);</pre><p>
     </p><p>提供された<em class="parameter"><code>attDescs</code></em>は結果にコピーされます。
もし<em class="parameter"><code>attDescs</code></em>ポインタが<code class="symbol">NULL</code>、または<em class="parameter"><code>numAttributes</code></em>が１未満の場合、要求は無視され、関数は成功します。
<em class="parameter"><code>res</code></em>が既に属性を所有している場合、関数は失敗に終わります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </p></dd><dt id="LIBPQ-PQSETVALUE"><span class="term">     <code class="function">PQsetvalue</code>
     <a id="id-1.7.3.18.3.9.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトのタプルフィールド値を設定します。
</p><pre class="synopsis">int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len);</pre><p>
     </p><p>必要に応じて関数は自動的に結果の内部タプル配列を肥大化させます。
しかし、<em class="parameter"><code>tup_num</code></em>引数は<code class="function">PQntuples</code>と同じか、もしくは小さくなければなりません。
その意味は、この関数は一回にタプル配列を１タプル大きくさせるだけだからです。
とは言っても、存在するいかなるタプルの任意のフィールドも、順序を問わず変更できます。
もし<em class="parameter"><code>field_num</code></em>に値が既に存在すれば、書き換えられます。
<em class="parameter"><code>len</code></em>が-1、または<em class="parameter"><code>value</code></em>が<code class="symbol">NULL</code>であれば、フィールドの値はSQLのNULLに設定されます。
<em class="parameter"><code>value</code></em>は結果のプライベート格納領域にコピーされるため、関数が返った後ではもう必要がなくなります。
関数が失敗すると、戻り値はゼロです。
関数が成功すると戻り値は非ゼロになります。
     </p></dd><dt id="LIBPQ-PQRESULTALLOC"><span class="term">     <code class="function">PQresultAlloc</code>
     <a id="id-1.7.3.18.3.10.1.2" class="indexterm"></a>
    </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトに補助ストレージを割り当てます。
</p><pre class="synopsis">void *PQresultAlloc(PGresult *res, size_t nBytes);</pre><p>
     </p><p><em class="parameter"><code>res</code></em>が消去された時、この関数で割り付けられたメモリは解放されます。
関数が失敗すると戻り値は<code class="symbol">NULL</code>です。
<code class="function">malloc</code>と同じように、どのような種類のデータでも結果は適切に整列されることが保証されています。
     </p></dd><dt id="LIBPQ-PQLIBVERSION"><span class="term">     <code class="function">PQlibVersion</code>
     <a id="id-1.7.3.18.3.11.1.2" class="indexterm"></a>
    </span></dt><dd><p>使用中の<span class="productname">libpq</span>のバージョンを返します。
</p><pre class="synopsis">int PQlibVersion(void);</pre><p>
     </p><p>この関数の結果を使用して、現在読み込まれているバージョンのlibpqで特定の機能が利用可能かどうかを実行時に決定することができます。
例えばこの関数を使用して、<code class="function">PQconnectdb</code>でどの接続オプションが利用できるかを確認することができます。
     </p><p>返却値の形式は、メジャーバージョン番号に10000を掛け、マイナーバージョン番号を加えたものです。
例えば、バージョン10.1では100001を返し、バージョン11.0では110000を返します。
     </p><p>バージョン10よりも前では、<span class="productname">PostgreSQL</span>では、最初の2つの部分がメジャーバージョンを表す、3つの部分からなるバージョン番号が使われていました。
これらのバージョンでは、<code class="function">PQserverVersion</code>はそれぞれの部分に2桁の数字を使います。
たとえば、バージョン9.1.5では90105が返され、バージョン9.2.0では90200が返されます。
     </p><p>ですから、機能の互換性を見極めるのが目的なら、アプリケーションは<code class="function">PQserverVersion</code>の結果を10000ではなく、100で割り、論理的なメジャーバージョンを求めるべきです。
すべてのリリースで、最後の2桁だけがマイナーリリースで異なります。
（バグ修正リリースです。）
     </p><div class="note"><h3 class="title">Note</h3><p>この関数は<span class="productname">PostgreSQL</span>バージョン9.1で追加されました。
このため以前のバージョンにおいて要求される機能を検知するために使用することができません。
この関数の呼び出しがバージョン9.1以降とのリンク依存性を作成するためです。
      </p></div></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-control.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-notice-processing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">33.10. 制御関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 33.12. 警告処理</td></tr></table></div></body></html>