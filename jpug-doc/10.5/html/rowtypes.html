<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.16. 複合型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="arrays.html" title="8.15. 配列" /><link rel="next" href="rangetypes.html" title="8.17. 範囲型" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.16. 複合型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="arrays.html" title="8.15. 配列">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Chapter 8. データ型">Up</a></td><th width="60%" align="center">Chapter 8. データ型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="rangetypes.html" title="8.17. 範囲型">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ROWTYPES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.16. 複合型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-DECLARING">8.16.1. 複合型の宣言</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#id-1.5.7.24.6">8.16.2. 複合型の値の構成</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-ACCESSING">8.16.3. 複合型へのアクセス</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#id-1.5.7.24.8">8.16.4. 複合型の変更</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-USAGE">8.16.5. 問い合わせでの複合型の使用</a></span></dt><dt><span class="sect2"><a href="rowtypes.html#ROWTYPES-IO-SYNTAX">8.16.6. 複合型の入出力構文</a></span></dt></dl></div><a id="id-1.5.7.24.2" class="indexterm"></a><a id="id-1.5.7.24.3" class="indexterm"></a><p><em class="firstterm">複合型</em>は、行もしくはレコードの構造を表現します。
本質的には、これは単なるフィールド名とそのデータ型のリストです。
<span class="productname">PostgreSQL</span>では、単純な型において使用される方法と多くは同じ方法で複合型を使用できます。
例えば、テーブルの列は複合型の型のものとして宣言することができます。
 </p><div class="sect2" id="ROWTYPES-DECLARING"><div class="titlepage"><div><div><h3 class="title">8.16.1. 複合型の宣言</h3></div></div></div><p>複合型の宣言の例を以下に2つ示します。
</p><pre class="programlisting">CREATE TYPE complex AS (
    r       double precision,
    i       double precision
);

CREATE TYPE inventory_item AS (
    name            text,
    supplier_id     integer,
    price           numeric
);</pre><p>
この構文は、フィールド名とその型のみを指定できるという点を除き、<code class="command">CREATE TABLE</code>と同等です。
現在は、制約（<code class="literal">NOT NULL</code>など）を含めることはできません。
<code class="literal">AS</code>キーワードが重要であることに注意してください。
これがないと、システムは<code class="command">CREATE TYPE</code>の意味を異なって解釈し、おかしな構文エラーを引き起こします。
 </p><p>定義済みの型を使用して、以下のようにテーブルや関数を生成することができます。

</p><pre class="programlisting">CREATE TABLE on_hand (
    item      inventory_item,
    count     integer
);

INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);</pre><p>

また、関数においては以下のように利用できます。

</p><pre class="programlisting">CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric
AS 'SELECT $1.price * $2' LANGUAGE SQL;

SELECT price_extension(item, 10) FROM on_hand;</pre><p>

 </p><p>テーブルを生成する時には、テーブルの行型を表現するために、テーブル名と同じ名前の複合型も自動的に生成されます。
例えば、以下のように
</p><pre class="programlisting">CREATE TABLE inventory_item (
    name            text,
    supplier_id     integer REFERENCES suppliers,
    price           numeric CHECK (price &gt; 0)
);</pre><p>
テーブルを作成すると、上述のものと同じ<code class="literal">inventory_item</code>という複合型が副次的に作成され、同様に使用することができるようになります。
しかし、現在の実装には、次のような重要な制限があることに注意してください。
複合型には制約が関連付けられませんので、テーブル定義に含まれる制約は、テーブルの外部に作成される複合型には<span class="emphasis"><em>適用されません</em></span>。
（部分的な回避方法は、複合型のメンバとしてドメイン型を使用することです。）
 </p></div><div class="sect2" id="id-1.5.7.24.6"><div class="titlepage"><div><div><h3 class="title">8.16.2. 複合型の値の構成</h3></div></div></div><a id="id-1.5.7.24.6.2" class="indexterm"></a><p>複合型をリテラル定数として記述するには、フィールド値をカンマで区切り、それらを括弧で括ります。
フィールド値を二重引用符で括ることができ、また、値にカンマや括弧を含む場合は二重引用符で括らなければなりません
（より詳細については<a class="link" href="rowtypes.html#ROWTYPES-IO-SYNTAX" title="8.16.6. 複合型の入出力構文">後</a>で説明します）。
したがって、複合型の定数の一般的な書式は以下のようになります。
</p><pre class="synopsis">'( <em class="replaceable"><code>val1</code></em> , <em class="replaceable"><code>val2</code></em> , ... )'</pre><p>
以下に例を示します。
</p><pre class="programlisting">'("fuzzy dice",42,1.99)'</pre><p>
これは、上述の<code class="literal">inventory_item</code>型の値として有効なものです。
フィールドをNULLにするには、リスト中の該当位置を空にします。
例えば、以下の定数は3番目のフィールドにNULLを指定しています。
</p><pre class="programlisting">'("fuzzy dice",42,)'</pre><p>
NULLではなく空文字列にしたいのであれば、以下のように引用符を二重に記述します。
</p><pre class="programlisting">'("",42,)'</pre><p>
これにより、最初のフィールドは非NULLの空文字列に、3番目のフィールドはNULLになります。
  </p><p>（実際には、こうした定数は<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 他の型の定数">Section 4.1.2.7</a>で説明した、一般的な型の定数の特殊な場合に過ぎません。
定数はまず、文字列として扱われ、複合型の入力変換処理に渡されます。
定数をどの型に変換するかを示すため、明示的な型指定が必要になることもあります。）
  </p><p>また、<code class="literal">ROW</code>式構文も、複合値を生成する際に使用することができます。
複数の階層に渡る引用符について考慮する必要がないため、おそらくほとんどの場合、これは文字列リテラル構文よりも簡単に使用できます。
上記において、既にこの方法を使用しています。
</p><pre class="programlisting">ROW('fuzzy dice', 42, 1.99)
ROW('', 42, NULL)</pre><p>
式の中に2つ以上のフィールドがある場合には、ROWキーワードは実際には省略することができます。
ですので、以下のように簡略化することができます。
</p><pre class="programlisting">('fuzzy dice', 42, 1.99)
('', 42, NULL)</pre><p>
<code class="literal">ROW</code>構文については<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. 行コンストラクタ">Section 4.2.13</a>でより詳細に説明します。
 </p></div><div class="sect2" id="ROWTYPES-ACCESSING"><div class="titlepage"><div><div><h3 class="title">8.16.3. 複合型へのアクセス</h3></div></div></div><p>複合型の列のフィールドにアクセスするには、テーブル名からフィールドを選択する場合とほぼ同様に、ドットとフィールド名を記述します。
実際、テーブル名からの選択とかなり似ていますので、パーサを混乱させないように括弧を使用しなければならないことがしばしばあります。
例えば、<code class="literal">on_hand</code>というテーブルの例からサブフィールドを選択しようとした場合、以下のように書くかもしれません。

</p><pre class="programlisting">SELECT item.name FROM on_hand WHERE item.price &gt; 9.99;</pre><p>

これは、SQLの構文規則に従って<code class="literal">item</code>が<code class="literal">on_hand</code>の列名ではなくテーブル名として解釈されるため、動作しません。
以下のように記述しなければなりません。

</p><pre class="programlisting">SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;</pre><p>

また、テーブル名も使用しなければならない場合（例えば複数テーブルに対する問い合わせ）、以下のようになります。

</p><pre class="programlisting">SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;</pre><p>

これで、括弧で括られたオブジェクトは正しく<code class="literal">item</code>列への参照として解釈され、サブフィールドはそこから選択できるようになります。
 </p><p>似たような構文上の問題は、複合型からフィールドを選択する時、常に発生します。
例えば、複合型の値を返す関数の結果から1つだけフィールドを選択する場合、以下のように記述しなければなりません。

</p><pre class="programlisting">SELECT (my_func(...)).field FROM ...</pre><p>

追加の括弧がないと、これは構文エラーを生成します。
 </p><p><a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>でより詳細に説明する通り、<code class="literal">*</code>という特別なフィールド名は<span class="quote">“<span class="quote">すべてのフィールド</span>”</span>を意味します。
 </p></div><div class="sect2" id="id-1.5.7.24.8"><div class="titlepage"><div><div><h3 class="title">8.16.4. 複合型の変更</h3></div></div></div><p>複合型の列への挿入と更新についての適切な構文の例をいくつか示します。
まず、列全体を挿入、更新する例です。

</p><pre class="programlisting">INSERT INTO mytab (complex_col) VALUES((1.1,2.2));

UPDATE mytab SET complex_col = ROW(1.1,2.2) WHERE ...;</pre><p>

最初の例では<code class="literal">ROW</code>を省略し、2番目の例では<code class="literal">ROW</code>を使用しています。
どちらの方法でも行うことができます。
 </p><p>以下のようにして、複合型の列の個々のサブフィールドを更新することができます。

</p><pre class="programlisting">UPDATE mytab SET complex_col.r = (complex_col).r + 1 WHERE ...;</pre><p>

ここで、<code class="literal">SET</code>直後の列名の周りに括弧を記述する必要がないこと（実際には記述できないこと）、しかし、等号の右で同じ列を参照する場合には括弧が必要なことに注意してください。
 </p><p>また、<code class="command">INSERT</code>の対象としてサブフィールドを指定することもできます。

</p><pre class="programlisting">INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);</pre><p>

列のサブフィールド全ての値を与えていなければ、残りのサブフィールドはNULL値になります。
 </p></div><div class="sect2" id="ROWTYPES-USAGE"><div class="titlepage"><div><div><h3 class="title">8.16.5. 問い合わせでの複合型の使用</h3></div></div></div><p>問い合わせ内での複合型に関連して様々な特別な構文規則や動作があります。
これらの規則により便利なショートカットが提供されますが、その背後にある論理を知らないと混乱を招くかもしれません。
  </p><p><span class="productname">PostgreSQL</span>では、問い合わせでのテーブル名（または別名）の参照は、実質的にはテーブルの現在行の複合型の値への参照と同じになります。
例えば、<a class="link" href="rowtypes.html#ROWTYPES-DECLARING" title="8.16.1. 複合型の宣言">前に</a>示した<code class="structname">inventory_item</code>というテーブルがあるとして、次のように記述することができます。
</p><pre class="programlisting">SELECT c FROM inventory_item c;</pre><p>
この問い合わせは単一の複合型の値の列を生成するので、出力は以下のようになります。
</p><pre class="programlisting">           c
------------------------
 ("fuzzy dice",42,1.99)
(1 row)</pre><p>
ただし、単純な名前はテーブル名より先に列名に対してマッチさせられるので、この例は問い合わせのテーブルに<code class="structfield">c</code>という名前の列がないから動作したに過ぎないことに注意してください。
  </p><p>通常の<em class="replaceable"><code>table_name</code></em><code class="literal">.</code><em class="replaceable"><code>column_name</code></em>という列名修飾の構文は、<a class="link" href="sql-expressions.html#FIELD-SELECTION" title="4.2.4. フィールド選択">フィールド選択</a>をテーブルの現在行の複合型の値に対して適用していると考えることもできます。
（効率の問題から、実際にはそのような実装にはなっていません。）
  </p><pre class="programlisting">SELECT c.* FROM inventory_item c;</pre><p>
上記のSQLについて、標準SQLではテーブルの内容が別々の列に展開されて、次のような結果になることを定めています。
</p><pre class="programlisting">    name    | supplier_id | price
------------+-------------+-------
 fuzzy dice |          42 |  1.99
(1 row)</pre><p>
つまりこれは、問い合わせが以下であったかのように動作するということです。
</p><pre class="programlisting">SELECT c.name, c.supplier_id, c.price FROM inventory_item c;</pre><p>
<span class="productname">PostgreSQL</span>では、この展開の動作をすべての複合型の値の式に適用します。
ただし、<a class="link" href="rowtypes.html#ROWTYPES-ACCESSING" title="8.16.3. 複合型へのアクセス">前に</a>説明したように、<code class="literal">.*</code>をつける値が単純なテーブル名でないときは、必ずそれを括弧で括る必要があります。
例えば、<code class="function">myfunc()</code>が列<code class="structfield">a</code>、<code class="structfield">b</code>、<code class="structfield">c</code>からなる複合型を返す関数だとすると、次の２つの問い合わせは同じ結果を返します。
</p><pre class="programlisting">SELECT (myfunc(x)).* FROM some_table;
SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;</pre><p>
  </p><div class="tip"><h3 class="title">Tip</h3><p><span class="productname">PostgreSQL</span>では、上の１番目の構文を２番目の構文に実際に変換することで列の展開を処理します。
従って、この例ではどちらの構文を使っても<code class="function">myfunc()</code>は各行に対して３回ずつ呼び出されます。
それが高価な関数でそのような事態を避けたいなら、次のような問い合わせにすることもできます。
</p><pre class="programlisting">SELECT (m).* FROM (SELECT myfunc(x) AS m FROM some_table OFFSET 0) ss;</pre><p>
<code class="literal">OFFSET 0</code>の句により、オプティマイザがsub-SELECTを<span class="quote">“<span class="quote">押しつぶして</span>”</span><code class="function">myfunc()</code>が複数回呼び出される構文になってしまうことを防ぎます。
   </p></div><p><em class="replaceable"><code>composite_value</code></em><code class="literal">.*</code>の構文は、それが<a class="link" href="queries-select-lists.html" title="7.3. 選択リスト"><code class="command">SELECT</code>の出力リスト</a>、<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>の<a class="link" href="dml-returning.html" title="6.4. 更新された行のデータを返す"><code class="literal">RETURNING</code>リスト</a>、<a class="link" href="queries-values.html" title="7.7. VALUESリスト"><code class="literal">VALUES</code>句</a>あるいは<a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. 行コンストラクタ">行コンストラクタ</a>の最上位に記述された場合、この種の列展開がされます。
それ以外の場合（これらの構文の内側に入れ子になっている場合を含みます）は、複合型の値に<code class="literal">.*</code>を付加しても、値は変わりません。
なぜなら、それは<span class="quote">“<span class="quote">すべての列</span>”</span>を意味するため、同じ複合型の値が繰り返し生成されるからです。
例えば、<code class="function">somefunc()</code>が複合型の値の引数をとるとして、以下の問い合わせは同じです。

</p><pre class="programlisting">SELECT somefunc(c.*) FROM inventory_item c;
SELECT somefunc(c) FROM inventory_item c;</pre><p>

どちらの場合も<code class="structname">inventory_item</code>の現在行が単一の複合型の値の引数として関数に渡されます。
このような場合に<code class="literal">.*</code>は何もしませんが、それをつけることにより、複合型の値であることを意図しているのが明確になるので、つけるのは良い習慣です。
特に、パーサが<code class="literal">c.*</code>の<code class="literal">c</code>を列名ではなくテーブル名あるいは別名を参照するものとみなす一方、<code class="literal">.*</code>がないと<code class="literal">c</code>がテーブル名なのか列名なのか明らかではなく、実際には、<code class="literal">c</code>という名前の列があれば列名としての解釈が優先されてしまいます。
  </p><p>これらの考え方を示す別の例をあげると、以下の３つの問い合わせは同じ意味になります。
</p><pre class="programlisting">SELECT * FROM inventory_item c ORDER BY c;
SELECT * FROM inventory_item c ORDER BY c.*;
SELECT * FROM inventory_item c ORDER BY ROW(c.*);</pre><p>
これらの<code class="literal">ORDER BY</code>句はすべて行の複合型の値を指定しており、<a class="xref" href="functions-comparisons.html#COMPOSITE-TYPE-COMPARISON" title="9.23.6. 複合型の比較">Section 9.23.6</a>で説明される規則に従って行を並べ替えた結果になります。
ただし、<code class="structname">inventory_item</code>に<code class="structfield">c</code>という名前の列がある場合は、最初の例はその列によってのみ並べ替えられるので、他の２つとは異なるものになります。
以前に示したのと同じ列名であるとしたら、以下の問い合わせも上記のものと同じになります。
</p><pre class="programlisting">SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);
SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);</pre><p>
（最後の例はキーワード<code class="literal">ROW</code>を省略した行コンストラクタを使用しています。）
  </p><p>複合型の値に関連したもう一つの特別な構文的動作は、複合型の値のフィールドを取り出す時に<em class="firstterm">関数的記法</em>を使用できることです。
これを簡単に説明するなら、<code class="literal"><em class="replaceable"><code>field</code></em>(<em class="replaceable"><code>table</code></em>)</code>という記法と<code class="literal"><em class="replaceable"><code>table</code></em>.<em class="replaceable"><code>field</code></em></code>という記法は相互に交換可能です。
例えば、以下の問い合わせは同等です。

</p><pre class="programlisting">SELECT c.name FROM inventory_item c WHERE c.price &gt; 1000;
SELECT name(c) FROM inventory_item c WHERE price(c) &gt; 1000;</pre><p>

さらに、複合型の引数を１つだけとる関数があるとして、それをどちらの記法でも呼び出すことができます。
以下の問い合わせはすべて同等です。

</p><pre class="programlisting">SELECT somefunc(c) FROM inventory_item c;
SELECT somefunc(c.*) FROM inventory_item c;
SELECT c.somefunc FROM inventory_item c;</pre><p>
  </p><p>この関数的記法とフィールド記法の同等性により、複合型に対する関数を使用して<span class="quote">“<span class="quote">計算されたフィールド</span>”</span>を実装することができます。
   <a id="id-1.5.7.24.9.10.2" class="indexterm"></a>
   <a id="id-1.5.7.24.9.10.3" class="indexterm"></a>
上の最後の問い合わせを使用するアプリケーションは、<code class="literal">somefunc</code>がテーブルの真の列ではないことを直接には意識する必要がありません。
  </p><div class="tip"><h3 class="title">Tip</h3><p>このような動作になるため、複合型の引数を一つだけとる関数に、その複合型に含まれるフィールドと同じ名前をつけることは賢明ではありません。
曖昧なときにはフィールド名の解釈が優先されるため、何かの仕掛けをしないと関数を呼び出すことができません。
関数としての解釈を強制する一つの方法は、関数名をスキーマ修飾する、つまり<code class="literal"><em class="replaceable"><code>schema</code></em>.<em class="replaceable"><code>func</code></em>(<em class="replaceable"><code>compositevalue</code></em>)</code>とすることです。
   </p></div></div><div class="sect2" id="ROWTYPES-IO-SYNTAX"><div class="titlepage"><div><div><h3 class="title">8.16.6. 複合型の入出力構文</h3></div></div></div><p>複合型の外部テキスト表現は、個々のフィールド用のI/O変換規則に従って解釈される項目群と、複合構造を意味する修飾から構成されます。
この修飾は、値全体を括る括弧（<code class="literal">(</code>および<code class="literal">)</code>）と隣接した項目間のカンマ（<code class="literal">,</code>）で構成されます。
括弧の外側の空白文字は無視されますが、括弧の内部ではフィールド値の一部とみなされます。
ただし、空白に意味があるかないかについては、そのフィールドのデータ型用の入力変換規則に従います。
例えば、
</p><pre class="programlisting">'(  42)'</pre><p>
括弧内の空白文字は、そのフィールド型が整数の場合は無視されますが、テキストの場合は無視されません。
  </p><p>前述の通り、複合型の値を記述する時には、個々のフィールド値を二重引用符で括ることができます。
もし、フィールド値が複合型値用のパーサを混乱させる場合には、これは<span class="emphasis"><em>必須</em></span>です。
具体的には、括弧、カンマ、二重引用符、バックスラッシュを含むフィールドの場合、二重引用符で括る必要があります。
引用符で括った複合型のフィールド値内に二重引用符やバックスラッシュが存在する場合、その前にバックスラッシュを付けてください
（また、引用符で括った複合型のフィールド値内に二重の引用符の組み合わせがあると、これは二重引用符を表す文字として解釈されます。
これは、SQLリテラル文字列内の単一引用符の規則と同じです）。
そのままでは複合型に対する構文として解釈されてしまう、全てのデータ文字を保護する他の方法として、引用符付けをせずにバックスラッシュによるエスケープを使用することができます。
  </p><p>完全な空フィールド値（カンマや括弧の間にまったく文字がないもの）はNULLを表します。
NULLではなく空文字列を値として記述するには <code class="literal">""</code> と記述してください。
  </p><p>複合型の出力処理では、もしフィールド値が空文字列の場合や括弧、カンマ、二重引用符、バックスラッシュ、空白文字を含む場合には、そのフィールド値を二重引用符で括って出力します
（空白文字に対するこの処理は重要ではありませんが、可読性を高めます）。
フィールド値内に埋め込まれた二重引用符やバックスラッシュは二重化されます。
  </p><div class="note"><h3 class="title">Note</h3><p>SQLコマンド内部に記述したものは、まず文字列リテラルとして、その後、複合型として解釈されることを覚えておいてください。
これは必要なバックスラッシュの数を倍にします（エスケープ文字列構文が使用されることを仮定しています）。
例えば、複合型の値の中に二重引用符とバックスラッシュを持つ<code class="type">text</code>フィールドに挿入するには、以下のように書かなければなりません。
</p><pre class="programlisting">INSERT ... VALUES (E'("\\"\\\\")');</pre><p>
文字列リテラルプロセッサが第1レベルのバックスラッシュを取り除くため、複合型値のパーサに渡されるものは <code class="literal">("\"\\")</code> のようになります。
そして、<code class="type">text</code>データ型の入力関数に渡される文字列は<code class="literal">"\</code>になります
（もし、例えば<code class="type">bytea</code>といった、その入力関数もバックスラッシュを特別に扱うデータ型を扱っている場合、1つのバックスラッシュを複合型のフィールドに格納するためにコマンド内に8個ものバックスラッシュが必要になります）。
ドル引用符付け（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. ドル記号で引用符付けされた文字列定数">Section 4.1.2.4</a>を参照）を使用して、このバックスラッシュの二重化を防ぐことができます。
  </p></div><div class="tip"><h3 class="title">Tip</h3><p>SQLコマンド内に複合型の値を書く時、通常、<code class="literal">ROW</code>生成構文の方が複合型のリテラル構文より作業が簡単です。
<code class="literal">ROW</code>による記述では、複合型のメンバ以外の記述方法と同じ方法で個々のフィールド値を記述することができます。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="arrays.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="rangetypes.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.15. 配列 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 8.17. 範囲型</td></tr></table></div></body></html>