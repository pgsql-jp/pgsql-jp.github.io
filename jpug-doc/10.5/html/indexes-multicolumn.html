<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.3. 複数列インデックス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-types.html" title="11.2. インデックスの種類" /><link rel="next" href="indexes-ordering.html" title="11.4. インデックスとORDER BY" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.3. 複数列インデックス</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-types.html" title="11.2. インデックスの種類">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-ordering.html" title="11.4. インデックスとORDER BY">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-MULTICOLUMN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.3. 複数列インデックス</h2></div></div></div><a id="id-1.5.10.6.2" class="indexterm"></a><p>インデックスは、テーブルの2つ以上の列に定義することができます。
例えば、以下のようなテーブルがあるとします。
</p><pre class="programlisting">CREATE TABLE test2 (
  major int,
  minor int,
  name varchar
);</pre><p>
（例えば、<code class="filename">/dev</code>ディレクトリの内容をデータベースに保持していて）頻繁に下記のような問い合わせを発行するとします。
</p><pre class="programlisting">SELECT name FROM test2 WHERE major = <em class="replaceable"><code>constant</code></em> AND minor = <em class="replaceable"><code>constant</code></em>;</pre><p>
このような場合、<code class="structfield">major</code>および<code class="structfield">minor</code>という２つの列に1つのインデックスを定義する方が適切かもしれません。
</p><pre class="programlisting">CREATE INDEX test2_mm_idx ON test2 (major, minor);</pre><p>
  </p><p>現在、B-tree、GiST、GINおよびBRINインデックス型でのみ、複数列インデックスをサポートしています。
最高32列まで指定可能です。
（この上限は、<span class="productname">PostgreSQL</span>を構築する際に変更可能です。
<code class="filename">pg_config_manual.h</code>ファイルを参照してください。）
  </p><p>複数列に対するB-treeインデックスをインデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
しかし、先頭側の（左側）列に制約がある場合に、このインデックスはもっとも効率的になります。
正確な規則は、先頭側の列への等価制約、および、等価制約を持たない先頭列への不等号制約がスキャン対象のインデックス範囲を制限するために使用されます。
これらの列の右側の列に対する制約は、このインデックス内から検査されます。
ですので、テーブルアクセスを適切に抑えますが、スキャンされるインデックスの範囲を減らしません。
例えば、<code class="literal">(a, b, c)</code>に対するインデックスがあり、<code class="literal">WHERE a = 5 AND b &gt;= 42 AND c &lt; 77</code>という問い合わせ条件があったとすると、
<code class="literal">a</code> = 5かつ<code class="literal">b</code> = 42を持つ項目を先頭に、<code class="literal">a</code> = 5となる最後の項目までのインデックスをスキャンしなければなりません。
<code class="literal">c</code> &gt;= 77を持つインデックス項目は飛ばされますが、スキャンを行わなければなりません。
このインデックスは原理上、 <code class="literal">a</code>に対する制約を持たず、<code class="literal">b</code>あるいは<code class="literal">c</code>に制約に持つ問い合わせでも使用することができます。
しかし、インデックス全体がスキャンされますので、ほとんどの場合、プランナはインデックスの使用よりもシーケンシャルテーブルスキャンを選択します。
  </p><p>複数列GiSTインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
他の列に対する条件は、インデックスで返される項目を制限します。
しかし、先頭列に対する条件が、インデックスのスキャン量を決定するもっとも重要なものです。
先頭列の個別値がわずかな場合、他の列が多くの個別値を持っていたとしても、相対的にGiSTインデックスは非効率的になります。
  </p><p>複数列GINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
B-treeやGiSTと異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
  </p><p>複数列BRINインデックスは、インデックス対象列の任意の部分集合を含む問い合わせ条件で使用することができます。
GINと同様に、またB-treeやGiSTとは異なり、インデックス検索の効果はどのインデックス列が問い合わせ条件で使用されているかに関係なく同じです。
一つのテーブルに対して複数列BRINインデックスを一つ持つ代わりに複数のBRINインデックスを持つ唯一の理由は、異なる<code class="literal">pages_per_range</code>ストレージパラメータを持つためです。
  </p><p>当然ながら、インデックス種類に対して適切な演算子を各列に使用しなければなりません。
他の演算子を含む句は考慮されません。
  </p><p>複数列インデックスは慎重に使用する必要があります。
多くの場合、単一列のインデックスで十分であり、また、その方がディスク領域と時間を節約できます。
テーブルの使用方法が極端に様式化されていない限り、4つ以上の列を使用しているインデックスは、不適切である可能性が高いでしょう。
異なるインデックス構成の利点に関するこの他の説明について<a class="xref" href="indexes-bitmap-scans.html" title="11.5. 複数のインデックスの組み合わせ">Section 11.5</a>および<a class="xref" href="indexes-index-only-scans.html" title="11.11. インデックスオンリースキャン">Section 11.11</a>も参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-types.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-ordering.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.2. インデックスの種類 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.4. インデックスと<code class="literal">ORDER BY</code></td></tr></table></div></body></html>