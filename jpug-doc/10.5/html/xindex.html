<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.14. インデックス拡張機能へのインタフェース</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xoper-optimization.html" title="37.13. 演算子最適化に関する情報" /><link rel="next" href="extend-extensions.html" title="37.15. 関連するオブジェクトを拡張としてパッケージ化" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.14. インデックス拡張機能へのインタフェース</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xoper-optimization.html" title="37.13. 演算子最適化に関する情報">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="extend-extensions.html" title="37.15. 関連するオブジェクトを拡張としてパッケージ化">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="XINDEX"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.14. インデックス拡張機能へのインタフェース</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS">37.14.1. インデックスメソッドと演算子クラス</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-STRATEGIES">37.14.2. インデックスメソッドのストラテジ</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-SUPPORT">37.14.3. インデックスメソッドのサポートルーチン</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-EXAMPLE">37.14.4. 例</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPFAMILY">37.14.5. 演算子クラスと演算子族</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS-DEPENDENCIES">37.14.6. システムの演算子クラスに対する依存性</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-ORDERING-OPS">37.14.7. 順序付け演算子</a></span></dt><dt><span class="sect2"><a href="xindex.html#XINDEX-OPCLASS-FEATURES">37.14.8. 演算子クラスの特殊な機能</a></span></dt></dl></div><a id="id-1.8.3.17.2" class="indexterm"></a><p>これまでのところでは、新しい型や新しい関数、および新しい演算子をどの様に定義するかについて説明してきました。
しかしながら、新しい型の列に対するインデックスをまだ作成することができません。
このためには、新しいデータ型に対する<em class="firstterm">演算子クラス</em>を定義する必要があります。
本節では、複素数を値の絶対値の昇順にソートし格納するB-treeインデックスメソッドを使った新しい演算子クラスについての実行例を用いて、演算子クラスの概念を説明します。
  </p><p>演算子クラスを<em class="firstterm">演算子族</em>にまとめ、意味的に互換性を持つクラス間の関係を表すことができます。
1つのデータ型のみが含まれる場合、演算子クラスで十分です。
そこでまずこうした状況に注目し、その後で演算子族に戻ります。
  </p><div class="sect2" id="XINDEX-OPCLASS"><div class="titlepage"><div><div><h3 class="title">37.14.1. インデックスメソッドと演算子クラス</h3></div></div></div><p><code class="classname">pg_am</code>テーブルには各インデックスメソッド（内部ではアクセスメソッドとして知られています）に対して1つの行が含まれています。
テーブルへの通常のアクセスのサポートは<span class="productname">PostgreSQL</span>に組み込まれていますが、すべてのインデックスメソッドは、<code class="classname">pg_am</code>で記述されています。
必要なコードを書いた後、<code class="classname">pg_am</code>に行を作成することによって、新しいインデックスアクセスメソッドを追加することができます。
しかし、この方法についての説明は本章での範囲を超えています（<a class="xref" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Chapter 60</a>を参照してください）。
  </p><p>インデックスメソッドのルーチンには、直接的にインデックスメソッドが演算するデータ型の情報は何も与えられていません。
代わりに、<em class="firstterm">演算子クラス</em>が、特定のデータ型の操作においてインデックスメソッドを使用する必要がある演算の集合を識別します。
<a id="id-1.8.3.17.5.3.2" class="indexterm"></a>
演算子クラスという名前の由来は、それらが指定するものの1つにインデックスで使用できる（つまり、インデックススキャン条件に変換できる）<code class="literal">WHERE</code>句演算子の集合があるからです。
また、演算子クラスは、インデックスメソッドの内部演算で必要な、しかしインデックスで使用できる<code class="literal">WHERE</code>句演算子には直接的には対応しない、<em class="firstterm">サポートプロシージャ</em>をいくつか指定することができます。
  </p><p>同じ入力データ型およびインデックスメソッドに対して複数の演算子クラスを定義することが可能です。
これにより、1つのデータ型に対して、複数のインデックス付けセマンティックの集合を定義することができます。
例えば、B-treeインデックスでは、処理するデータ型ごとにソート順を定義する必要があります。
複素数データ型では、複素数の絶対値によりデータをソートするB-tree演算子クラスと、実部の数値によりソートするB-tree演算子クラスを持つといった方法は、有用かもしれません。
通常は演算子クラスの1つが一般的に最も有用であると判断され、そのデータ型およびインデックスメソッドに対するデフォルトの演算子クラスとして設定されます。
  </p><p>複数の異なるインデックスメソッドに、同一の演算子クラス名を使用することができます（例えば、B-treeとハッシュインデックスメソッドは、両方とも<code class="literal">int4_ops</code>という名前の演算子クラスを持つことができます）。
ただし、そのような各クラスは独立した実体であり、別々に定義される必要があります。
  </p></div><div class="sect2" id="XINDEX-STRATEGIES"><div class="titlepage"><div><div><h3 class="title">37.14.2. インデックスメソッドのストラテジ</h3></div></div></div><p>演算子クラスに関連付けられている演算子は、<span class="quote">“<span class="quote">ストラテジ番号</span>”</span>により識別されます。
<span class="quote">“<span class="quote">ストラテジ番号</span>”</span>は、演算子クラスのコンテキスト内における各演算子のセマンティクスを識別するためのものです。
例えば、B-treeの場合、キーが小さい方から大きい方へ厳密に並んでいなければなりません。
したがって、B-treeに関しては、<span class="quote">“<span class="quote">より小さい</span>”</span>および<span class="quote">“<span class="quote">以上</span>”</span>のような演算子は興味深いと言えます。
<span class="productname">PostgreSQL</span>ではユーザが演算子を定義できるため、<span class="productname">PostgreSQL</span>は演算子の名前（例えば<code class="literal">&lt;</code>や<code class="literal">&gt;=</code>）を見つけても、その演算子がどのような比較を行うかを判断することはできません。
その代わり、インデックスメソッドは<span class="quote">“<span class="quote">ストラテジ</span>”</span>の集合を定義します。
<span class="quote">“<span class="quote">ストラテジ</span>”</span>は汎用演算子と考えることができます。
各演算子クラスは、特定のデータ型およびインデックスセマンティックスの解釈において、実際のどの演算子が各ストラテジに対応しているかを指定します。
  </p><p><a class="xref" href="xindex.html#XINDEX-BTREE-STRAT-TABLE" title="Table 37.2. B-treeストラテジ">Table 37.2</a>に示すように、B-treeインデックスメソッドではストラテジを5つ定義します。
  </p><div class="table" id="XINDEX-BTREE-STRAT-TABLE"><p class="title"><strong>Table 37.2. B-treeストラテジ</strong></p><div class="table-contents"><table class="table" summary="B-treeストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>小なり</td><td>1</td></tr><tr><td>以下</td><td>2</td></tr><tr><td>等しい</td><td>3</td></tr><tr><td>以上</td><td>4</td></tr><tr><td>大なり</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>ハッシュインデックスは等価性のみをサポートします。
したがって、<a class="xref" href="xindex.html#XINDEX-HASH-STRAT-TABLE" title="Table 37.3. ハッシュストラテジ">Table 37.3</a>に示すように、ストラテジを1つのみ定義します。

  </p><div class="table" id="XINDEX-HASH-STRAT-TABLE"><p class="title"><strong>Table 37.3. ハッシュストラテジ</strong></p><div class="table-contents"><table class="table" summary="ハッシュストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>等しい</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p>GiSTインデックスはより柔軟です。
固定のストラテジの集合をまったく持ちません。
代わりに、特定のGiST演算子クラスの<span class="quote">“<span class="quote">consistent</span>”</span>サポートルーチンが、ストラテジ番号が何を意味するかを解釈します。
例として、2次元幾何オブジェクトをインデックス付けし、<span class="quote">“<span class="quote">R-tree</span>”</span>ストラテジを提供する組み込みのGiSTインデックス演算子クラスのいくつかを<a class="xref" href="xindex.html#XINDEX-RTREE-STRAT-TABLE" title="Table 37.4. GiSTによる2次元の“R-tree”ストラテジ">Table 37.4</a>に示します。
この内4個は2次元に対する（重複、合同、包含、被包含）試験です。
残りの内4個はX方向のみに対する、残り4個はY方向のみに対する同一の試験を提供します。
  </p><div class="table" id="XINDEX-RTREE-STRAT-TABLE"><p class="title"><strong>Table 37.4. GiSTによる2次元の<span class="quote">“<span class="quote">R-tree</span>”</span>ストラテジ</strong></p><div class="table-contents"><table class="table" summary="GiSTによる2次元のR-treeストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>完全に左側</td><td>1</td></tr><tr><td>右側にはみ出さない</td><td>2</td></tr><tr><td>重なる</td><td>3</td></tr><tr><td>左側にはみ出さない</td><td>4</td></tr><tr><td>完全に右側</td><td>5</td></tr><tr><td>同じ</td><td>6</td></tr><tr><td>含む</td><td>7</td></tr><tr><td>含まれる</td><td>8</td></tr><tr><td>上側にはみ出さない</td><td>9</td></tr><tr><td>完全に下側</td><td>10</td></tr><tr><td>完全に上側</td><td>11</td></tr><tr><td>下側にはみ出さない</td><td>12</td></tr></tbody></table></div></div><br class="table-break" /><p>SP-GiSTインデックスは柔軟性という点でGiSTと似ており、固定のストラテジ群を持ちません。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、点に対する組み込みの演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-SPGIST-POINT-STRAT-TABLE" title="Table 37.5. SP-GiSTの点に関するストラテジ">Table 37.5</a>に示します。
  </p><div class="table" id="XINDEX-SPGIST-POINT-STRAT-TABLE"><p class="title"><strong>Table 37.5. SP-GiSTの点に関するストラテジ</strong></p><div class="table-contents"><table class="table" summary="SP-GiSTの点に関するストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>厳密に左側</td><td>1</td></tr><tr><td>厳密に右側</td><td>5</td></tr><tr><td>同一</td><td>6</td></tr><tr><td>包含される</td><td>8</td></tr><tr><td>厳密に下</td><td>10</td></tr><tr><td>厳密に上</td><td>11</td></tr></tbody></table></div></div><br class="table-break" /><p>GINインデックスは、いずれも固定のストラテジ群を持たないという点で、GiSTおよびSP-GiSTインデックスと似ています。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、配列に対する組み込みの演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-GIN-ARRAY-STRAT-TABLE" title="Table 37.6. GIN 配列のストラテジ">Table 37.6</a>に示します。
  </p><div class="table" id="XINDEX-GIN-ARRAY-STRAT-TABLE"><p class="title"><strong>Table 37.6. GIN 配列のストラテジ</strong></p><div class="table-contents"><table class="table" summary="GIN 配列のストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>重複</td><td>1</td></tr><tr><td>包含</td><td>2</td></tr><tr><td>包含される</td><td>3</td></tr><tr><td>等しい</td><td>4</td></tr></tbody></table></div></div><br class="table-break" /><p>BRINインデックスは、いずれも固定のストラテジ群を持たないという点で、GiST、SP-GiSTおよびGINインデックスと似ています。
その代わりに、各演算子クラスのサポートルーチンが演算子クラスの定義に従ってストラテジ番号を解釈します。
例として、組み込みの<code class="literal">Minmax</code>演算子クラスで使用されるストラテジ番号を<a class="xref" href="xindex.html#XINDEX-BRIN-MINMAX-STRAT-TABLE" title="Table 37.7. BRIN Minmaxストラテジ">Table 37.7</a>に示します。
  </p><div class="table" id="XINDEX-BRIN-MINMAX-STRAT-TABLE"><p class="title"><strong>Table 37.7. BRIN Minmaxストラテジ</strong></p><div class="table-contents"><table class="table" summary="BRIN Minmaxストラテジ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>演算</th><th>ストラテジ番号</th></tr></thead><tbody><tr><td>小なり</td><td>1</td></tr><tr><td>以下</td><td>2</td></tr><tr><td>等しい</td><td>3</td></tr><tr><td>以上</td><td>4</td></tr><tr><td>大なり</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p>上記の演算子はすべて論理値を返すことに注意してください。
実際、インデックスで使用されるために<code class="literal">WHERE</code>の最上位レベルで現れなければなりませんので、インデックスメソッド検索演算子として定義された、すべての演算子の戻り値の型は<code class="type">boolean</code>でなければなりません。
（一部のインデックスアクセスメソッドは、通常論理型の値を返さない<em class="firstterm">順序付け演算子</em>もサポートします。
この機能については<a class="xref" href="xindex.html#XINDEX-ORDERING-OPS" title="37.14.7. 順序付け演算子">Section 37.14.7</a>で説明します。）
  </p></div><div class="sect2" id="XINDEX-SUPPORT"><div class="titlepage"><div><div><h3 class="title">37.14.3. インデックスメソッドのサポートルーチン</h3></div></div></div><p>ストラテジは通常、システムがインデックスを使う方法を判断するために十分な情報ではありません。
実際には、インデックスメソッドが動作するためには、さらにサポートルーチンを必要とします。
例えばB-treeインデックスメソッドは、2つのキーを比較し、より大きいのか、等しいのか、より小さいのかを決定できなければなりません。
同様に、ハッシュインデックスは、キー値のハッシュコードを計算できなければなりません。
これらの操作はSQLコマンドの条件内で使用される演算子とは対応しません。
これらはインデックスメソッドで内部的に使用される管理用ルーチンです。
  </p><p>ストラテジと同じように、演算子クラスにより、与えられたデータ型およびセマンティックス解釈に対して、どの特定の関数がこれらの各役割を果たすべきであるかが識別されます。
インデックスメソッドは必要な関数の集合を定義し、演算子クラスは、これらをインデックスメソッドで指定された<span class="quote">“<span class="quote">サポート関数番号</span>”</span>に代入することによって、使用すべき正しい関数を識別します。
  </p><p><a class="xref" href="xindex.html#XINDEX-BTREE-SUPPORT-TABLE" title="Table 37.8. B-treeサポート関数">Table 37.8</a>に示すように、B-treeでは１つのサポート関数が必須ですが、演算子クラス作成者のオプションとして提供されるもう１つのサポート関数を持つことができます。
  </p><div class="table" id="XINDEX-BTREE-SUPPORT-TABLE"><p class="title"><strong>Table 37.8. B-treeサポート関数</strong></p><div class="table-contents"><table class="table" summary="B-treeサポート関数" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>関数</th><th>サポート番号</th></tr></thead><tbody><tr><td>2つのキーを比較し、最初のキーが2番目のキーより小さいか、等しいか、大きいかを示す、0未満、0、もしくは0より大きい整数を返します。
       </td><td>1</td></tr><tr><td><code class="filename">utils/sortsupport.h</code>に記載した、C言語から呼び出し可能なソートサポート関数のアドレスを返します(省略可能)。
       </td><td>2</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="xindex.html#XINDEX-HASH-SUPPORT-TABLE" title="Table 37.9. ハッシュサポート関数">Table 37.9</a>に示すように、ハッシュインデックスでは単一のサポート関数が必要です。
  </p><div class="table" id="XINDEX-HASH-SUPPORT-TABLE"><p class="title"><strong>Table 37.9. ハッシュサポート関数</strong></p><div class="table-contents"><table class="table" summary="ハッシュサポート関数" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>関数</th><th>サポート番号</th></tr></thead><tbody><tr><td>キーのハッシュ値を計算</td><td>1</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="xindex.html#XINDEX-GIST-SUPPORT-TABLE" title="Table 37.10. GiSTサポート関数">Table 37.10</a>に示すように、GiSTインデックスには9つのサポート関数があり、また、そのうち２つは省略可能です。
(詳細については<a class="xref" href="gist.html" title="Chapter 62. GiSTインデックス">Chapter 62</a>を参照してください。)
  </p><div class="table" id="XINDEX-GIST-SUPPORT-TABLE"><p class="title"><strong>Table 37.10. GiSTサポート関数</strong></p><div class="table-contents"><table class="table" summary="GiSTサポート関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">consistent</code></td><td>キーが問い合わせ条件を満たすかどうかを決定します。</td><td>1</td></tr><tr><td><code class="function">union</code></td><td>キー集合の和集合を計算します。</td><td>2</td></tr><tr><td><code class="function">compress</code></td><td>キーまたはインデックス付けされる値の圧縮表現を計算します。</td><td>3</td></tr><tr><td><code class="function">decompress</code></td><td>圧縮されたキーを伸張した表現を計算します。</td><td>4</td></tr><tr><td><code class="function">penalty</code></td><td>指定された副ツリーキーを持つ副ツリーに新しいキーを挿入する時のペナルティを計算します。</td><td>5</td></tr><tr><td><code class="function">picksplit</code></td><td>ページのどのエントリを新しいページに移動させるかを決定し、結果ページ用の統合キーを計算します。</td><td>6</td></tr><tr><td><code class="function">equal</code></td><td>2つのキーを比較し、等しければ真を返します。</td><td>7</td></tr><tr><td><code class="function">distance</code></td><td>キーと問い合わせ値との間の距離を決定します（省略可能）。
       </td><td>8</td></tr><tr><td><code class="function">fetch</code></td><td>インデックスオンリースキャンのために圧縮されたキーの元の表現を計算します（省略可能）。
       </td><td>9</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="xindex.html#XINDEX-SPGIST-SUPPORT-TABLE" title="Table 37.11. SP-GiSTサポート関数">Table 37.11</a>に示すように、SP-GiSTインデックスでは５つのサポート関数が必要です。
(詳細については<a class="xref" href="spgist.html" title="Chapter 63. SP-GiSTインデックス">Chapter 63</a>を参照してください。)
  </p><div class="table" id="XINDEX-SPGIST-SUPPORT-TABLE"><p class="title"><strong>Table 37.11. SP-GiSTサポート関数</strong></p><div class="table-contents"><table class="table" summary="SP-GiSTサポート関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">config</code></td><td>演算子クラスに関する基本情報を提供します。</td><td>1</td></tr><tr><td><code class="function">choose</code></td><td>新しい値を内部タプルに挿入する方法を決定します。</td><td>2</td></tr><tr><td><code class="function">picksplit</code></td><td>値集合を分割する方法を決定します。</td><td>3</td></tr><tr><td><code class="function">inner_consistent</code></td><td>ある問い合わせでサブパーティションの検索が必要かどうか決定します。</td><td>4</td></tr><tr><td><code class="function">leaf_consistent</code></td><td>キーが問い合わせ修飾子を満たすかどうか決定します。</td><td>5</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="xindex.html#XINDEX-GIN-SUPPORT-TABLE" title="Table 37.12. GINサポート関数">Table 37.12</a>に示すように、GINインデックスには、6つのサポート関数があり、また、そのうち３つは省略可能です。
(詳細については<a class="xref" href="gin.html" title="Chapter 64. GINインデックス">Chapter 64</a>を参照してください。)
  </p><div class="table" id="XINDEX-GIN-SUPPORT-TABLE"><p class="title"><strong>Table 37.12. GINサポート関数</strong></p><div class="table-contents"><table class="table" summary="GINサポート関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">compare</code></td><td>2つのキーを比較し、0未満、0、0より大きな整数を返します。
それぞれ最初のキーの方が大きい、等しい、小さいを示します。
       </td><td>1</td></tr><tr><td><code class="function">extractValue</code></td><td>インデックス付けされる値からキーを抽出します。</td><td>2</td></tr><tr><td><code class="function">extractQuery</code></td><td>問い合わせ条件からキーを抽出します。</td><td>3</td></tr><tr><td><code class="function">consistent</code></td><td>問い合わせ条件に一致する値かどうかを決定します(2値の亜種)。
(サポート関数6があれば、省略可能)
       </td><td>4</td></tr><tr><td><code class="function">comparePartial</code></td><td>問い合わせからの部分キーとインデックスからのキーを比較し、それぞれ、GINがこのインデックス項目を無視しなければならないか、一致する項目として扱わなければならないか、インデックススキャンを中止しなければならないかを示す、ゼロより小さい、ゼロ、ゼロより大きい整数値のいずれかを返します(省略可能)。
       </td><td>5</td></tr><tr><td><code class="function">triConsistent</code></td><td>問い合わせ条件に一致する値かどうかを決定します(3値の亜種)。
(サポート関数4があれば、省略可能)
       </td><td>6</td></tr></tbody></table></div></div><br class="table-break" /><p><a class="xref" href="xindex.html#XINDEX-BRIN-SUPPORT-TABLE" title="Table 37.13. BRINサポート関数">Table 37.13</a>に示すようにBRINインデックスには、4つの基本サポート関数があります。この基本関数は追加のサポート関数の提供を要求するかもしれません。
(詳細については<a class="xref" href="brin-extensibility.html" title="65.3. 拡張性">Section 65.3</a>を参照してください。)
  </p><div class="table" id="XINDEX-BRIN-SUPPORT-TABLE"><p class="title"><strong>Table 37.13. BRINサポート関数</strong></p><div class="table-contents"><table class="table" summary="BRINサポート関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>説明</th><th>サポート番号</th></tr></thead><tbody><tr><td><code class="function">opcInfo</code></td><td>インデックスが貼られた列の要約データを記述する内部情報を返します
       </td><td>1</td></tr><tr><td><code class="function">add_value</code></td><td>既存のサマリーインデックスタプルに新しい値を足します</td><td>2</td></tr><tr><td><code class="function">consistent</code></td><td>値が問い合わせ条件に一致するかどうかを決めます</td><td>3</td></tr><tr><td><code class="function">union</code></td><td>2つのサマリータプルの結合を計算します
       </td><td>4</td></tr></tbody></table></div></div><br class="table-break" /><p>検索演算子と異なり、サポート関数は特定のインデックスメソッドが想定するデータ型、例えばB-tree用の比較関数の場合、符号付き整数を返します。
同様に各サポート関数に渡す引数の数と型はインデックスメソッドに依存します。
B-treeとハッシュでは、比較関数とハッシュ処理サポート関数はその演算子クラスに含まれる演算子と同じ入力データ型を取りますが、GIN、SP-GiST、GiST、およびBRINサポート関数のほとんどはそうではありません。
  </p></div><div class="sect2" id="XINDEX-EXAMPLE"><div class="titlepage"><div><div><h3 class="title">37.14.4. 例</h3></div></div></div><p>ここまでで概念について説明してきました。
ここで、新しい演算子クラスを作成する有用な例を紹介します。
（この例を作業できるように、ソース配布物内の<code class="filename">src/tutorial/complex.c</code>と<code class="filename">src/tutorial/complex.sql</code>にコピーがあります。）
この演算子クラスは、複素数をその絶対値による順番でソートする演算子をカプセル化します。
ですので、その名前に<code class="literal">complex_abs_ops</code>を選びました。
最初に演算子の集合が必要になります。
演算子を定義する処理は<a class="xref" href="xoper.html" title="37.12. ユーザ定義の演算子">Section 37.12</a>で説明しました。
B-tree上の演算子クラスでは、以下の演算子が必要です。

   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem">絶対値による、小なり（ストラテジ1）</li><li class="listitem">絶対値による、以下（ストラテジ2）</li><li class="listitem">絶対値による、等しい（ストラテジ3）</li><li class="listitem">絶対値による、以上（ストラテジ4）</li><li class="listitem">絶対値による、大なり（ストラテジ5）</li></ul></div><p>
  </p><p>比較演算子の関連する集合を定義する時にエラーの発生を最小にする方法は、まず、B-tree比較サポート関数を作成し、その後に、他の関数をサポート関数に対する1行のラッパとして作成することです。
これにより、境界となる条件で一貫性のない結果を得る確率が減少します。
この手法に従って、まず以下を作成します。

</p><pre class="programlisting">#define Mag(c)  ((c)-&gt;x*(c)-&gt;x + (c)-&gt;y*(c)-&gt;y)

static int
complex_abs_cmp_internal(Complex *a, Complex *b)
{
    double      amag = Mag(a),
                bmag = Mag(b);

    if (amag &lt; bmag)
        return -1;
    if (amag &gt; bmag)
        return 1;
    return 0;
}</pre><p>

これで、小なり関数は以下のようになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(complex_abs_lt);

Datum
complex_abs_lt(PG_FUNCTION_ARGS)
{
    Complex    *a = (Complex *) PG_GETARG_POINTER(0);
    Complex    *b = (Complex *) PG_GETARG_POINTER(1);

    PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) &lt; 0);
}</pre><p>

他の4関数での違いは、内部関数の結果とゼロとをどのように比べるかだけです。
  </p><p>次に、関数と、この関数に基づく演算子をSQLで宣言します。

</p><pre class="programlisting">CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool
    AS '<em class="replaceable"><code>filename</code></em>', 'complex_abs_lt'
    LANGUAGE C IMMUTABLE STRICT;

CREATE OPERATOR &lt; (
   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,
   commutator = &gt; , negator = &gt;= ,
   restrict = scalarltsel, join = scalarltjoinsel
);</pre><p>
正しく交代演算子と否定演算子を指定する他、適切な制限選択性関数と結合関数を指定することが重要です。
さもないと、オプティマイザはインデックスを効率的に使用することができません。
小なり、等価、大なりの場合に異なる選択性関数を使用しなければならないことに注意してください。
  </p><p>他にも注意すべきことがここで発生します。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>例えば、<code class="type">complex</code>型を両オペランドに取る<code class="literal">=</code>という名前の演算子を1つしか作成できません。
この場合、<code class="type">complex</code>用の他の<code class="literal">=</code>演算子を持てません。
しかし、実際にデータ型を作成しているとしたら、おそらく、複素数の（絶対値の等価性ではない）通常の等価性演算を行う<code class="literal">=</code>を欲するでしょう。
この場合、<code class="function">complex_abs_eq</code>用の演算子名に別の名前を使用しなければなりません。
    </p></li><li class="listitem"><p><span class="productname">PostgreSQL</span>では異なる引数のデータ型であれば同じSQL名の演算子を使うことができますが、Cでは1つの名前で1つのグローバル関数が使えるだけです。
ですから、C関数は<code class="filename">abs_eq</code>のような単純な名前にするべきではありません。
通常は、他のデータ型の関数と衝突しないように、C関数名にデータ型名を入れておくことを勧めます。
    </p></li><li class="listitem"><p><code class="filename">abs_eq</code>関数のSQL名は、<span class="productname">PostgreSQL</span>が引数のデータ型によって同じ名前を持つ他のSQL関数から区別してくれることを期待して作ることができます。
ここでは例を簡単にするために、関数にCレベルとSQLレベルで同じ名前を与えています。
    </p></li></ul></div><p>
  </p><p>次のステップは、B-treeに必要なサポートルーチンの登録です。
これを実装するCコードは、演算子関数と同じファイルに入っています。
以下は、関数をどのように宣言するかを示します。

</p><pre class="programlisting">CREATE FUNCTION complex_abs_cmp(complex, complex)
    RETURNS integer
    AS '<em class="replaceable"><code>filename</code></em>'
    LANGUAGE C IMMUTABLE STRICT;</pre><p>
  </p><p>これまでで、必要な演算子およびサポートルーチンを持つようになりました。
最後に演算子クラスを作成することができます。

</p><pre class="programlisting">CREATE OPERATOR CLASS complex_abs_ops
    DEFAULT FOR TYPE complex USING btree AS
        OPERATOR        1       &lt; ,
        OPERATOR        2       &lt;= ,
        OPERATOR        3       = ,
        OPERATOR        4       &gt;= ,
        OPERATOR        5       &gt; ,
        FUNCTION        1       complex_abs_cmp(complex, complex);</pre><p>
  </p><p>これで終わりです！
これで<code class="type">complex</code>列にB-treeインデックスを作って使用することが可能になったはずです。
  </p><p>以下のように、演算子エントリをより冗長に記述することができます。
</p><pre class="programlisting">        OPERATOR        1       &lt; (complex, complex) ,</pre><p>
しかし、演算子が、演算子クラスの定義と同一のデータ型を取る場合、このような記述をする必要はありません。
  </p><p>上記の例は、ユーザがこの新しい演算子クラスを<code class="type">complex</code>データ型のデフォルトのB-tree演算子クラスにしようとしていると仮定しています。
このようにしない場合、<code class="literal">DEFAULT</code>という単語を取り除いてください。
  </p></div><div class="sect2" id="XINDEX-OPFAMILY"><div class="titlepage"><div><div><h3 class="title">37.14.5. 演算子クラスと演算子族</h3></div></div></div><p>これまでは暗黙的に、演算子クラスは1つのデータ型のみを扱うものと仮定してきました。
確かに特定のインデックス列にはたった1つのデータ型しかあり得ませんが、異なるデータ型の値とインデックス列の比較を行うインデックス操作はよく役に立ちます。
また、演算子クラスと関連したデータ型を跨る演算子を使用できる場合、他のデータ型は独自の関連した演算子クラスを持つことがよくあります。
SQL問い合わせを最適化する際にプランナを補助することができますので、関連したクラスを明示的に関連付けることは（どのように動作するかに関する知識をプランナは多く持ちますので、特にB-tree演算子クラスで）有用です。

  </p><p>こうした要望に応えるために<span class="productname">PostgreSQL</span>は<em class="firstterm">演算子族</em>という概念を使用します。<a id="id-1.8.3.17.9.3.3" class="indexterm"></a>
演算子族は1つ以上の演算子クラスから構成されます。
また、演算子族全体に属するが、演算子族内の個々のクラスには属さないインデックス可能演算子や対応するサポート関数を含めることもできます。
こうした演算子や関数を、特定のクラスに束縛されていないことから、演算子族内で<span class="quote">“<span class="quote">自由</span>”</span>であると呼びます。
通常、各演算子クラスは1つのデータ型演算子を持ちますが、データ型を跨る演算子は演算子族内で自由になります。
  </p><p>演算子族内の演算子と関数はすべて、意味的な互換性を持たなければなりません。
この互換性についての必要条件はインデックスメソッドによって設定されます。
このため、演算子族の特定の部分集合を演算子クラスとして選び出す方法に疑問を持つかもしれません。
実際多くの目的では、クラスの分類は不適切で、演算子族が唯一の興味深いグループ化です。
演算子クラスを定義する理由は、どれだけ多くの演算子族が何らかのインデックスをサポートするために必要かを指定することです。
ある演算子クラスを使用するインデックスが存在する場合、演算子クラスはそのインデックスを削除しない限り削除することができません。
しかし、演算子族の他の部分、すなわち、他の演算子クラスや自由な演算子を削除することができます。
したがって、演算子クラスは、特定のデータ型に対するインデックスを操作する上で理論上必要となる最少の演算子と関数の集合を含むように指定すべきです。
そして、関連するが基本的なものではない演算子を演算子族の自由なメンバとして追加することができます。
  </p><p>例えば<span class="productname">PostgreSQL</span>には<code class="literal">integer_ops</code>という組み込みのB-tree演算子族があります。
ここには<code class="type">bigint</code> (<code class="type">int8</code>)、<code class="type">integer</code> (<code class="type">int4</code>)、<code class="type">smallint</code> (<code class="type">int2</code>)型の列上へのインデックスにそれぞれ対応した<code class="literal">int8_ops</code>、<code class="literal">int4_ops</code>、<code class="literal">int2_ops</code>という演算子クラスが含まれています。
また、上記の型の内任意の2つの型を比較できるように、この演算子族にはデータ型を跨る比較演算子も含まれます。
このため、上記の型のいずれかに対するインデックスを他の型の値との比較の際に使用することができます。
この演算子族は以下の定義により多重化されています。

</p><pre class="programlisting">CREATE OPERATOR FAMILY integer_ops USING btree;

CREATE OPERATOR CLASS int8_ops
DEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS
  -- 標準int8比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint8cmp(int8, int8) ,
  FUNCTION 2 btint8sortsupport(internal) ;

CREATE OPERATOR CLASS int4_ops
DEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS
  -- 標準int4比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint4cmp(int4, int4) ,
  FUNCTION 2 btint4sortsupport(internal) ;

CREATE OPERATOR CLASS int2_ops
DEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS
  -- 標準int2比較
  OPERATOR 1 &lt; ,
  OPERATOR 2 &lt;= ,
  OPERATOR 3 = ,
  OPERATOR 4 &gt;= ,
  OPERATOR 5 &gt; ,
  FUNCTION 1 btint2cmp(int2, int2) ,
  FUNCTION 2 btint2sortsupport(internal) ;

ALTER OPERATOR FAMILY integer_ops USING btree ADD
  -- 型を跨ぐ比較 int8対int2
  OPERATOR 1 &lt; (int8, int2) ,
  OPERATOR 2 &lt;= (int8, int2) ,
  OPERATOR 3 = (int8, int2) ,
  OPERATOR 4 &gt;= (int8, int2) ,
  OPERATOR 5 &gt; (int8, int2) ,
  FUNCTION 1 btint82cmp(int8, int2) ,

  -- 型を跨ぐ比較 int8対int4
  OPERATOR 1 &lt; (int8, int4) ,
  OPERATOR 2 &lt;= (int8, int4) ,
  OPERATOR 3 = (int8, int4) ,
  OPERATOR 4 &gt;= (int8, int4) ,
  OPERATOR 5 &gt; (int8, int4) ,
  FUNCTION 1 btint84cmp(int8, int4) ,

  -- 型を跨ぐ比較 int4対int2
  OPERATOR 1 &lt; (int4, int2) ,
  OPERATOR 2 &lt;= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 &gt;= (int4, int2) ,
  OPERATOR 5 &gt; (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,

  -- 型を跨ぐ比較 int4対int8
  OPERATOR 1 &lt; (int4, int8) ,
  OPERATOR 2 &lt;= (int4, int8) ,
  OPERATOR 3 = (int4, int8) ,
  OPERATOR 4 &gt;= (int4, int8) ,
  OPERATOR 5 &gt; (int4, int8) ,
  FUNCTION 1 btint48cmp(int4, int8) ,

  -- 型を跨ぐ比較 int2対int8
  OPERATOR 1 &lt; (int2, int8) ,
  OPERATOR 2 &lt;= (int2, int8) ,
  OPERATOR 3 = (int2, int8) ,
  OPERATOR 4 &gt;= (int2, int8) ,
  OPERATOR 5 &gt; (int2, int8) ,
  FUNCTION 1 btint28cmp(int2, int8) ,

  -- 型を跨ぐ比較 int2対int4
  OPERATOR 1 &lt; (int2, int4) ,
  OPERATOR 2 &lt;= (int2, int4) ,
  OPERATOR 3 = (int2, int4) ,
  OPERATOR 4 &gt;= (int2, int4) ,
  OPERATOR 5 &gt; (int2, int4) ,
  FUNCTION 1 btint24cmp(int2, int4) ;</pre><p>

 この定義は演算子ストラテジ関数番号とサポート関数番号を<span class="quote">“<span class="quote">上書き</span>”</span>していることに注意してください。
各番号は演算子族内で複数回現れます。
特定番号のインスタンスがそれぞれ異なる入力データ型を持つ限り、これは許されます。
入力型の両方が演算子クラスの入力型と同じインスタンスは、演算子クラスの主演算子および主サポート関数であり、ほとんどの場合、演算子族の自由メンバではなく演算子クラスの一部として宣言しなければなりません。
  </p><p>B-tree演算子族では、演算子族内のすべての演算子はソート互換、つまり、演算子族でサポートされるデータ型すべてに渡って推移規則、<span class="quote">“<span class="quote">A = BかつB = CならばA = C</span>”</span>および<span class="quote">“<span class="quote">A &lt; BかつB &lt; CならばA &lt; C</span>”</span>を維持しなければなりません。
さらに、演算子族内で表現される型の間の暗黙的キャストとバイナリキャストは、関連するソート順序を変更してはいけません。
演算子族内の各演算子では、演算子と同じデータ型の2つのデータ型を取るサポート関数が存在しなければなりません。
演算子族を完結させること、つまり、データ型の組み合わせそれぞれに対する演算子をすべて含めることを推奨します。
各演算子クラスは、自身のデータ型に対してデータ型を跨らない演算子とサポート関数だけを含めなければなりません。
  </p><p>複数データ型のハッシュ演算子族を構築するには、演算子族でサポートされるデータ型それぞれに対する互換性を持つハッシュサポート関数を作成しなければなりません。
ここで、互換性とは、関数がその演算子族の等価性演算子で等価であるとみなされる任意の2つの値では同一のハッシュコードが生成されることを保証することを意味します。
通常、型が異なる物理表現を持つ場合、これを実現することは困難ですが、実現可能な場合もあります。
さらに、暗黙的またはバイナリ変換により、ある演算子族で表現されるデータ型から同じ演算子族で表現されるデータ型に値をキャストしても、計算されたハッシュ値を変更してはいけません。
データ型1つに対してサポート関数が1つしか存在しないことに注意してください。
等価性演算子ごとに１つではありません。
演算子族を完結させること、つまり、データ型の組み合わせそれぞれに対する等価性演算子をすべて含めることを推奨します。
各演算子クラスは、自身のデータ型に対してデータ型を跨らない演算子とサポート関数だけを含めなければなりません。
  </p><p>GiST、SP-GiST、GINインデックスではデータ型を跨る操作についての明示的な記法はありません。
サポートされる演算子群は単に指定演算子クラスの主サポート関数が扱うことができるものです。
  </p><p>BRINでは、要求は演算子クラスを提供するフレームワークに依存します。
<code class="literal">minmax</code>に基づく演算子クラスに対しては、求められる振る舞いはB-tree演算子クラスに対するものと同じです。族内のすべての演算子はソート互換でなければならず、キャストは関連するソート順序を変更してはいけません。
  </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>8.3より前のバージョンでは演算子族という概念はありませんでした。
そのため、インデックスで使用する予定のデータ型を跨る演算子はすべて、インデックスの演算子クラスに結びつけなければなりませんでした。
この手法もまだ使用できますが、インデックスの依存性を広げる点、および、両データ型が同一演算子族内で演算子を持つ場合、プランナがデータ型を跨った比較をより効率的に扱うことができる点より、廃止予定です。
   </p></div></div><div class="sect2" id="XINDEX-OPCLASS-DEPENDENCIES"><div class="titlepage"><div><div><h3 class="title">37.14.6. システムの演算子クラスに対する依存性</h3></div></div></div><a id="id-1.8.3.17.10.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は演算子クラスを、単にインデックスで使用できるかどうかだけではなく、多くの方式で演算子の性質を推定するために使用します。
したがって、データ型の列をインデックス付けするつもりがなくても、演算子クラスを作成した方が良い可能性があります。
  </p><p>具体的には、<code class="literal">ORDER BY</code>や<code class="literal">DISTINCT</code>など、値の比較とソートを必要とするSQL機能があります。
ユーザ定義のデータ型に対してこの機能を実装するために、<span class="productname">PostgreSQL</span>はそのデータ型用のデフォルトのB-tree演算子クラスを検索します。
この演算子クラスの<span class="quote">“<span class="quote">等価判定</span>”</span>メンバが、<code class="literal">GROUP BY</code>や<code class="literal">DISTINCT</code>用の値の等価性についてのシステムの意向を定義し、この演算子クラスによって強制されるソート順序が、デフォルトの<code class="literal">ORDER BY</code>順序を定義します。
  </p><p>また、ユーザ定義型の配列の比較は、デフォルトのB-tree演算子クラスによって定義されるセマンティックに依存します。
  </p><p>データ型用のデフォルトのB-tree演算子クラスが存在しないと、システムはデフォルトのハッシュ演算子クラスを検索します。
しかし、この種類の演算子クラスは等価性のみを提供しますので、実際にこれは、配列等価性のサポートだけに対して十分です。
  </p><p>データ型用のデフォルトの演算子クラスが存在しない場合に、こうしたSQL機能をデータ型に使用しようとすると、<span class="quote">“<span class="quote">順序付け演算子を識別できなかった</span>”</span>といったエラーとなります。
  </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>バージョン7.4より前まででは、ソートやグループ化演算は暗黙的に<code class="literal">=</code>、<code class="literal">&lt;</code>、<code class="literal">&gt;</code>という名前の演算子を使用していました。
この新しい、デフォルトの演算子クラスに依存する振舞いによって、特定の名前を持つ演算子の振舞いについて何らかの仮定を立てることを防止しています。

    </p></div><p>他の重要な点として、ハッシュ演算子族内に現れる演算子がハッシュ結合、ハッシュ集約、関連する最適化の候補となることがあります。
使用するハッシュ関数を識別するため、ここでのハッシュ演算子族は基本的なものです。

  </p></div><div class="sect2" id="XINDEX-ORDERING-OPS"><div class="titlepage"><div><div><h3 class="title">37.14.7. 順序付け演算子</h3></div></div></div><p>一部のインデックスアクセスメソッド（現時点ではGiSTのみ）は<em class="firstterm">順序付け演算子</em>という概念をサポートします。
これまで説明してきたものは<em class="firstterm">検索演算子</em>でした。
検索演算子は、<code class="literal">WHERE</code> <em class="replaceable"><code>indexed_column</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>を満たすすべての行を見つけるために、インデックスを検索可能にするためのものです。
一致した行がどの順序で返されるかについては保証がないことに注意してください。
反対に、順序付け演算子は返すことができる行集合を限定しませんが、その順序を決定します。
順序付け演算子は、<code class="literal">ORDER BY</code> <em class="replaceable"><code>indexed_column</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>constant</code></em>で表される順序で行を返すために、インデックスをスキャン可能にするためのものです。
このように順序付け演算子を定義する理由は、その演算子が距離を測るものであれば最近傍検索をサポートすることです。
例えば以下のような問い合わせを考えます。
</p><pre class="programlisting">SELECT * FROM places ORDER BY location &lt;-&gt; point '(101,456)' LIMIT 10;</pre><p>
これは指定した対象地点に最も近い10地点を見つけ出します。
<code class="literal">&lt;-&gt;</code>は順序付け演算子ですので、location列上のGiSTインデックスは、これを効率的に行うことができます。
  </p><p>検索演算子が論理値結果を返さなければなりませんが、順序付け演算子は普通、距離を表す浮動小数点や数値型など、何らかの他の型を返します。
この型は通常、インデックス対象のデータ型と同じにはなりません。
異なるデータ型の動作についての固定化された前提を防ぐために、順序付け演算子の定義では、結果データ型のソート順序を指定するB-tree演算子族の名前を必要とします。
前節で述べたように、B-tree演算子族は<span class="productname">PostgreSQL</span>の順序付け記法を定義します。
ですのでこれは自然な表現です。
pointに対する<code class="literal">&lt;-&gt;</code>演算子は<code class="type">float8</code>を返しますので、演算子クラスを作成するコマンド内で以下のように指定します。

</p><pre class="programlisting">OPERATOR 15    &lt;-&gt; (point, point) FOR ORDER BY float_ops</pre><p>
ここで<code class="literal">float_ops</code>は、<code class="type">float8</code>に対する操作を含んだ組み込みの演算子族です。
この宣言は、インデックスが<code class="literal">&lt;-&gt;</code>演算子の値が増加する方向で行を返すことができることを表しています。
  </p></div><div class="sect2" id="XINDEX-OPCLASS-FEATURES"><div class="titlepage"><div><div><h3 class="title">37.14.8. 演算子クラスの特殊な機能</h3></div></div></div><p>演算子クラスには、まだ説明していない2つの特殊な機能があります。
説明していない主な理由は、最もよく使用するインデックスメソッドでは、これらがあまり有用ではないためです。
  </p><p>通常、演算子を演算子クラス（または演算子族）のメンバとして宣言すると、インデックスメソッドでその演算子を使用して、<code class="literal">WHERE</code>条件を満たす行の集合を正確に抽出することができます。
以下に例を示します。
</p><pre class="programlisting">SELECT * FROM table WHERE integer_column &lt; 4;</pre><p>
この式は、整数列にB-treeインデックスを使用することにより、正確に満たすことができます。
しかし、一致する行へ厳密ではなくとも導く手段としてインデックスが有用である場合があります。
例えば、GiSTインデックスで、幾何オブジェクトの外接矩形のみを格納したとします。
その結果、多角形のような長方形でないオブジェクトとの重なりをテストするWHERE条件は正確に満たすことができません。
もっとも、このインデックスを使用して、対象オブジェクトの外接矩形に重なる外接矩形を持つオブジェクトを検索し、さらに、検索されたオブジェクトのみに対して正確に重なるかどうかをテストすることはできます。
この筋書きを適用する場合、インデックスは演算子に対して<span class="quote">“<span class="quote">非可逆</span>”</span>と言われます。
非可逆インデックス検索は、ある行が問い合わせ条件を実際に満足するかしないかの時に<em class="firstterm">recheck</em>フラグを返すインデックスメソッドを持つことで実装されます。
コアシステムは、そこで有効なマッチとして行が返されるか否かを確認するために、抽出された行に対して元の問い合わせ条件を検査します。
この手法はインデックスがすべての必要な行を返すことが保証された上で、元の演算子呼び出しを実行することによって除外することができる、いくつか余分な行を返す可能性がある場合に動作します。
非可逆検索を提供するインデックス方式（現時点ではGiST、SP-GiSTおよびGIN）は個々の演算子クラスのサポート関数がrecheckフラグを設定することを許可します。
このためこれは原則的に演算子クラスの機能です。
  </p><p>再度、多角形のような複雑なオブジェクトの外接矩形のみをインデックスに格納している状況を考えてみてください。
この場合、インデックスエントリに多角形全体を格納するのは、それほど有用なことではありません。
単に、より単純な<code class="literal">box</code>型のオブジェクトを格納した方が良いかもしれません。
このような状況は、<code class="command">CREATE OPERATOR CLASS</code>の<code class="literal">STORAGE</code>オプションによって表現することができます。
例えば、以下のように記述します。

</p><pre class="programlisting">CREATE OPERATOR CLASS polygon_ops
    DEFAULT FOR TYPE polygon USING gist AS
        ...
        STORAGE box;</pre><p>

現時点では、GiST、GINおよびBRINインデックスメソッドが、列のデータ型と異なる<code class="literal">STORAGE</code>型をサポートしています。
<code class="literal">STORAGE</code>が使用された場合、GiSTの<code class="function">compress</code>および<code class="function">decompress</code>サポートルーチンは、データ型を変換する必要があります。
GINでは、<code class="literal">STORAGE</code>型は<span class="quote">“<span class="quote">キー</span>”</span>の値の型を識別します。
通常これはインデックス付けされる列の型とは異なります。
例えば、整数配列の列用の演算子クラスは単なる整数をキーとして持つかもしれません。
GINの<code class="literal">extractValue</code>および<code class="literal">extractQuery</code>サポートルーチンが、インデックス付けされた値からキーを取り出す責任を負います。
BRINはGINと同様です。<code class="literal">STORAGE</code>型は格納された要約値の型を識別し、演算子クラスのサポートプロシージャは要約値を正しく解釈する責任を負います。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xoper-optimization.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="extend-extensions.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.13. 演算子最適化に関する情報 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.15. 関連するオブジェクトを拡張としてパッケージ化</td></tr></table></div></body></html>