<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.23. 行と配列の比較</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-subquery.html" title="9.22. 副問い合わせ式" /><link rel="next" href="functions-srf.html" title="9.24. 集合を返す関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.23. 行と配列の比較</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-subquery.html" title="9.22. 副問い合わせ式">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="Chapter 9. 関数と演算子">Up</a></td><th width="60%" align="center">Chapter 9. 関数と演算子</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-srf.html" title="9.24. 集合を返す関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="FUNCTIONS-COMPARISONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.23. 行と配列の比較</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-comparisons.html#FUNCTIONS-COMPARISONS-IN-SCALAR">9.23.1. <code class="literal">IN</code></a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#id-1.5.8.28.15">9.23.2. <code class="literal">NOT IN</code></a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#id-1.5.8.28.16">9.23.3. <code class="literal">ANY</code>/<code class="literal">SOME</code> (配列)</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#id-1.5.8.28.17">9.23.4. <code class="literal">ALL</code> (配列)</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#ROW-WISE-COMPARISON">9.23.5. 行コンストラクタの比較</a></span></dt><dt><span class="sect2"><a href="functions-comparisons.html#COMPOSITE-TYPE-COMPARISON">9.23.6. 複合型の比較</a></span></dt></dl></div><a id="id-1.5.8.28.2" class="indexterm"></a><a id="id-1.5.8.28.3" class="indexterm"></a><a id="id-1.5.8.28.4" class="indexterm"></a><a id="id-1.5.8.28.5" class="indexterm"></a><a id="id-1.5.8.28.6" class="indexterm"></a><a id="id-1.5.8.28.7" class="indexterm"></a><a id="id-1.5.8.28.8" class="indexterm"></a><a id="id-1.5.8.28.9" class="indexterm"></a><a id="id-1.5.8.28.10" class="indexterm"></a><a id="id-1.5.8.28.11" class="indexterm"></a><a id="id-1.5.8.28.12" class="indexterm"></a><p>本節では、値のグループ間で複数の比較を行う、さまざまな特殊化したコンストラクトについて説明します。
この形式は構文的には、前節の副問い合わせ形式と関係しています。しかし、副問い合わせを含みません。
配列副式を含む形式は<span class="productname">PostgreSQL</span>の拡張ですが、それ以外は<acronym class="acronym">SQL</acronym>準拠です。
本節で記載した全ての式形式は結果として論理値（真/偽）を返します。
  </p><div class="sect2" id="FUNCTIONS-COMPARISONS-IN-SCALAR"><div class="titlepage"><div><div><h3 class="title">9.23.1. <code class="literal">IN</code></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>expression</code></em> IN (<em class="replaceable"><code>value</code></em> [<span class="optional">, ...</span>])</pre><p>右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式のいずれかと等しい場合、結果は<span class="quote">“<span class="quote">true（真）</span>”</span>になります。
これは以下の省略形です。

</p><pre class="synopsis"><em class="replaceable"><code>expression</code></em> = <em class="replaceable"><code>value1</code></em>
OR
<em class="replaceable"><code>expression</code></em> = <em class="replaceable"><code>value2</code></em>
OR
...</pre><p>
  </p><p>左辺の式がNULLを生じる場合、または右側の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<code class="token">IN</code>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </p></div><div class="sect2" id="id-1.5.8.28.15"><div class="titlepage"><div><div><h3 class="title">9.23.2. <code class="literal">NOT IN</code></h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>expression</code></em> NOT IN (<em class="replaceable"><code>value</code></em> [<span class="optional">, ...</span>])</pre><p>右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式の全てと等しくない場合、結果は<span class="quote">“<span class="quote">真</span>”</span>です。
これは以下の省略形です。

</p><pre class="synopsis"><em class="replaceable"><code>expression</code></em> &lt;&gt; <em class="replaceable"><code>value1</code></em>
AND
<em class="replaceable"><code>expression</code></em> &lt;&gt; <em class="replaceable"><code>value2</code></em>
AND
...</pre><p>
  </p><p>左辺の式でNULLが生じる場合、または右辺の値に左辺の式と等しいものがなく、かつ少なくとも1つの右辺の式がNULLを生じる場合、<code class="token">NOT IN</code>構文の結果は、一部の人が予想する真ではなく、NULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </p><div class="tip"><h3 class="title">Tip</h3><p>全ての場合において、<code class="literal">x NOT IN y</code>は<code class="literal">NOT (x IN y)</code>と等価です。
しかし、<code class="token">IN</code>を使用するよりも<code class="token">NOT IN</code>を使用する方が初心者がNULL値による間違いをしやすくなります。
可能な限り条件を肯定的に表現することが最善です。
  </p></div></div><div class="sect2" id="id-1.5.8.28.16"><div class="titlepage"><div><div><h3 class="title">9.23.3. <code class="literal">ANY</code>/<code class="literal">SOME</code> (配列)</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> ANY (<em class="replaceable"><code>array expression</code></em>)
<em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> SOME (<em class="replaceable"><code>array expression</code></em>)</pre><p>右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列要素それぞれに対して、指定された<em class="replaceable"><code>operator</code></em>を使用して評価、比較されます。なお、<em class="replaceable"><code>operator</code></em>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<code class="token">ANY</code>の結果は<span class="quote">“<span class="quote">true（真）</span>”</span>です。
真の結果がない（配列の要素数がゼロである場合を含む）と、結果は<span class="quote">“<span class="quote">false（偽）</span>”</span>です。
  </p><p>配列式がNULL配列を生成する場合、<code class="token">ANY</code>の結果はNULLになります。
左辺式がNULLとなる場合、<code class="token">ANY</code>の結果は通常NULLになります（STRICTでない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、真が得られなかった場合、<code class="token">ANY</code>の結果は偽ではなくNULLになります（ここでも、STRICTな演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </p><p><code class="token">SOME</code>は<code class="token">ANY</code>の同義語です。
  </p></div><div class="sect2" id="id-1.5.8.28.17"><div class="titlepage"><div><div><h3 class="title">9.23.4. <code class="literal">ALL</code> (配列)</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> ALL (<em class="replaceable"><code>array expression</code></em>)</pre><p>右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列の要素それぞれに対して、指定された<em class="replaceable"><code>operator</code></em>を使用して評価、比較されます。なお、<em class="replaceable"><code>operator</code></em>は結果として論理値を生成する必要があります。
全ての比較が真になる場合（配列の要素数がゼロである場合を含む）、<code class="token">ALL</code>の結果は<span class="quote">“<span class="quote">true（真）</span>”</span>です。
1つでも偽の結果があると、結果は<span class="quote">“<span class="quote">false（偽）</span>”</span>です。
  </p><p>配列式がNULL配列を生成する場合、<code class="token">ALL</code>の結果はNULLになります。
左辺式がNULLとなる場合、<code class="token">ALL</code>の結果は通常NULLになります（厳格でない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、偽が得られなかった場合、<code class="token">ALL</code>の結果は真ではなくNULLになります（ここでも、厳格な演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </p></div><div class="sect2" id="ROW-WISE-COMPARISON"><div class="titlepage"><div><div><h3 class="title">9.23.5. 行コンストラクタの比較</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>row_constructor</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>row_constructor</code></em></pre><p>両辺とも<a class="xref" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. 行コンストラクタ">Section 4.2.13</a>で説明する行コンストラクタです。
この２つの行値は同じフィールド数でなければなりません。
両辺はそれぞれ評価され、行として比較されます。
行コンストラクタの比較は、<em class="replaceable"><code>operator</code></em>が<code class="literal">=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>の場合に認められます。
各行の要素はデフォルトのB-tree演算子クラスを持つ型でなければなりません。そうでなければ、比較を試みるとエラーが発生します。
  </p><div class="note"><h3 class="title">Note</h3><p>比較が先行する列で解決された場合、要素の数や型に関係するエラーは起きないこともあります。
   </p></div><p><code class="literal">=</code>と<code class="literal">&lt;&gt;</code>の場合、他と動作が多少異なります。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。
１つでも構成要素が非NULLかつ等しくない場合、2つの行は等しくないとみなされます。
それ以外の場合、その行の比較結果は不明（NULL）です。
  </p><p><code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>の場合、行の要素は左から右に比較されます。そして、不等またはNULLの組み合わせが見つかったところで停止します。
要素の組み合わせのどちらかがNULLであった場合、行比較の結果は不明（NULL）です。さもなくば、要素の組み合わせの比較により結果が決まります。
例えば、<code class="literal">ROW(1,2,NULL) &lt; ROW(1,3,0)</code>は、３番目の要素の組み合わせまで進まないため、NULLではなく真を返します。
  </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>の8.2より前では、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;</code> 、<code class="literal">&gt;=</code>の場合SQL仕様に従っていませんでした。
<code class="literal">ROW(a,b) &lt; ROW(c,d)</code>などの比較は正しくは<code class="literal">a &lt; c OR (a = c AND b &lt; d)</code>ですが、<code class="literal">a &lt; c AND b &lt; d</code>として実装されていました。
   </p></div><pre class="synopsis"><em class="replaceable"><code>row_constructor</code></em> IS DISTINCT FROM <em class="replaceable"><code>row_constructor</code></em></pre><p>このコンストラクトは<code class="literal">&lt;&gt;</code>行比較と類似していますが、NULL入力に対してNULLを生成しない点が異なります。
その代わりに、全てのNULL値は非NULL値と等しくない（DISTINCT FROM）ものとみなされ、また、２つのNULLは等しい（NOT DISTINCT）ものとみなされます。
したがって、結果は真か偽のいずれかで、NULLにはなりません。
  </p><pre class="synopsis"><em class="replaceable"><code>row_constructor</code></em> IS NOT DISTINCT FROM <em class="replaceable"><code>row_constructor</code></em></pre><p>このコンストラクトは<code class="literal">=</code>行比較と類似していますが、NULL入力に対してNULLを生成しません。
代わりに、NULL値を、すべての非NULLの値に対して不等（DISTINCT FROM）とみなし、２つのNULLを等しいもの（NOT DISTINCT）とみなします。
したがって、結果は常に真か偽となり、NULLになることはありません
  </p></div><div class="sect2" id="COMPOSITE-TYPE-COMPARISON"><div class="titlepage"><div><div><h3 class="title">9.23.6. 複合型の比較</h3></div></div></div><pre class="synopsis"><em class="replaceable"><code>record</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>record</code></em></pre><p>SQL仕様では、結果が2つのNULL値、またはNULLと非NULLの比較に依存するのであれば、行の観点からの比較はNULLを返すことを要求されています。
<span class="productname">PostgreSQL</span>は、(<a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.23.5. 行コンストラクタの比較">Section 9.23.5</a>にあるように)２つの行コンストラクタの出力の比較を行う時、または副問い合わせの出力に対し(<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">Section 9.22</a>にあるように)行コンストラクタの比較を行う時のみこれを実施します。
２つの複合型の値が比較されるほかの状況では、２つのNULLフィールドの値は等しいと考えられ、NULLは非NULLより大きいとみなされます。
複合型に対して、これは一貫した並び替えとインデックス付け動作担保のため必要です。
  </p><p>各辺が評価され、行単位で比較が行なわれます。
複合型の比較は<em class="replaceable"><code>operator</code></em>が<code class="literal">=</code>、<code class="literal">&lt;&gt;</code>、<code class="literal">&lt;</code>、<code class="literal">&lt;=</code>、<code class="literal">&gt;</code>、<code class="literal">&gt;=</code>またはそのいずれかと類似の意味を持つ場合に許されます。
(正確には、演算子はB-tree演算子クラスのメンバである場合、またはB-tree演算子クラスの<code class="literal">=</code>メンバの否定子である場合に行比較演算子となり得ます。)
上記の演算子のデフォルトの動作は、行コンストラクタに対する<code class="literal">IS [ NOT ] DISTINCT FROM</code>と同じです（<a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.23.5. 行コンストラクタの比較">Section 9.23.5</a>参照）。
  </p><p>デフォルトのB-tree演算子クラスを持たない要素を含む行の一致をサポートするために、いくつかの演算子が複合型の比較のために定義されています。
それは<code class="literal">*=</code>、<code class="literal">*&lt;&gt;</code>、<code class="literal">*&lt;</code>、<code class="literal">*&lt;=</code>、<code class="literal">*&gt;</code>、<code class="literal">*&gt;=</code>です。
上記の演算子は2つの行の内部バイナリ表現を比較します。
2つの行の等価演算子での比較が真であっても、2つの行はバイナリ表現が異なるかもしれません。
上記の比較演算子での行の順序は決定論的ですが、それ以外は意味がありません。
上記の演算子はマテリアライズドビューで内部的に使われ、レプリケーションのような他の特定の目的のためには有用かもしれませんが、問い合わせを書くのに一般的に有用であるようにとは意図していません。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-subquery.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-srf.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">9.22. 副問い合わせ式 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 9.24. 集合を返す関数</td></tr></table></div></body></html>