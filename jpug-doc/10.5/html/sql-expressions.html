<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4.2. 評価式</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-syntax-lexical.html" title="4.1. 字句の構造" /><link rel="next" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">4.2. 評価式</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-syntax-lexical.html" title="4.1. 字句の構造">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-syntax.html" title="Chapter 4. SQLの構文">Up</a></td><th width="60%" align="center">Chapter 4. SQLの構文</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SQL-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">4.2. 評価式</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-COLUMN-REFS">4.2.1. 列の参照</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-PARAMETERS-POSITIONAL">4.2.2. 位置パラメータ</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-SUBSCRIPTS">4.2.3. 添字</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#FIELD-SELECTION">4.2.4. フィールド選択</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-OPERATOR-CALLS">4.2.5. 演算子の呼び出し</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-EXPRESSIONS-FUNCTION-CALLS">4.2.6. 関数呼び出し</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-AGGREGATES">4.2.7. 集約式</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS">4.2.8. ウィンドウ関数呼び出し</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS">4.2.9. 型キャスト</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS">4.2.10. 照合順序式</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES">4.2.11. スカラ副問い合わせ</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-ARRAY-CONSTRUCTORS">4.2.12. 配列コンストラクタ</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS">4.2.13. 行コンストラクタ</a></span></dt><dt><span class="sect2"><a href="sql-expressions.html#SYNTAX-EXPRESS-EVAL">4.2.14. 式の評価規則</a></span></dt></dl></div><a id="id-1.5.3.6.2" class="indexterm"></a><a id="id-1.5.3.6.3" class="indexterm"></a><a id="id-1.5.3.6.4" class="indexterm"></a><p>評価式は、例えば<code class="command">SELECT</code>コマンドの目的リストとして、<code class="command">INSERT</code>や<code class="command">UPDATE</code>の新しい列の値として、もしくはいくつかのコマンドの検索条件として様々な文脈の中で使われます。
評価式の結果は、テーブル式の結果（つまりテーブル）から区別するために、<em class="firstterm">スカラ</em>と呼ばれることもあります。
したがって、評価式は<em class="firstterm">スカラ式</em>（またはもっと簡単に<em class="firstterm">式</em>）とも呼ばれます。
式の構文によって、基本的な部分から算術、論理、集合などの演算を使って値の計算を行うことができます。
  </p><p>評価式は下記のうちのいずれかです。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>定数あるいはリテラル値
     </p></li><li class="listitem"><p>列の参照
     </p></li><li class="listitem"><p>関数定義の本体やプリペアド文における、位置パラメータ参照
     </p></li><li class="listitem"><p>添字付きの式
     </p></li><li class="listitem"><p>フィールド選択式
     </p></li><li class="listitem"><p>演算子の呼び出し
     </p></li><li class="listitem"><p>関数呼び出し
     </p></li><li class="listitem"><p>集約式
     </p></li><li class="listitem"><p>      ウィンドウ関数呼び出し
     </p></li><li class="listitem"><p>型キャスト
     </p></li><li class="listitem"><p>照合順序(collation)式
     </p></li><li class="listitem"><p>スカラ副問い合わせ
     </p></li><li class="listitem"><p>配列コンストラクタ
     </p></li><li class="listitem"><p>行コンストラクタ
     </p></li><li class="listitem"><p>      （副式をグループ化したり<a id="id-1.5.3.6.6.1.15.1.1" class="indexterm"></a>優先順位を変更するのに使用される）括弧で囲まれた別の評価式
     </p></li></ul></div><p>
  </p><p>これ以外にも、式として分類されるけれども一般的な構文規約には従わない、いくつかの構成要素があります。
これらは一般的に関数あるいは演算子の意味を持ちます。
<a class="xref" href="functions.html" title="Chapter 9. 関数と演算子">Chapter 9</a>の該当部分で説明されています。
例を挙げると<code class="literal">IS NULL</code>句があります。
  </p><p><a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS" title="4.1.2. 定数">Section 4.1.2</a>で既に定数については説明しました。
続く節では残りのオプションについて説明します。
  </p><div class="sect2" id="SQL-EXPRESSIONS-COLUMN-REFS"><div class="titlepage"><div><div><h3 class="title">4.2.1. 列の参照</h3></div></div></div><a id="id-1.5.3.6.9.2" class="indexterm"></a><p>列は、下記のような形式で参照することができます。
</p><pre class="synopsis"><em class="replaceable"><code>correlation</code></em>.<em class="replaceable"><code>columnname</code></em></pre><p>
   </p><p><em class="replaceable"><code>correlation</code></em>は、テーブル名（スキーマで修飾されている場合もあります）、あるいは<code class="literal">FROM</code>句で定義されたテーブルの別名です。
correlationの名前と区切り用のドットは、もし列名が現在の問い合わせで使われる全てのテーブルを通して一意である場合は省略することができます。
（<a class="xref" href="queries.html" title="Chapter 7. 問い合わせ">Chapter 7</a>も参照してください）。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-PARAMETERS-POSITIONAL"><div class="titlepage"><div><div><h3 class="title">4.2.2. 位置パラメータ</h3></div></div></div><a id="id-1.5.3.6.10.2" class="indexterm"></a><a id="id-1.5.3.6.10.3" class="indexterm"></a><p>位置パラメータ参照は、外部からSQL文に渡される値を示すために使用されます。
パラメータはSQL関数定義およびプリペアド問い合わせの中で使用されます。
また、クライアントライブラリの中には、SQLコマンド文字列とデータ値を分離して指定できる機能をサポートするものもあります。
この場合、パラメータは行外データ値を参照するために使用されます。
パラメータ参照の形式は以下の通りです。
</p><pre class="synopsis">$<em class="replaceable"><code>number</code></em></pre><p>
   </p><p>例えば、関数 <code class="function">dept</code> の定義が以下のようにされたとします。

</p><pre class="programlisting">CREATE FUNCTION dept(text) RETURNS dept
    AS $$ SELECT * FROM dept WHERE name = $1 $$
    LANGUAGE SQL;</pre><p>

ここで<code class="literal">$1</code>は関数が呼び出される時に最初の関数引数の値を参照します。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-SUBSCRIPTS"><div class="titlepage"><div><div><h3 class="title">4.2.3. 添字</h3></div></div></div><a id="id-1.5.3.6.11.2" class="indexterm"></a><p>式が配列型の値となる場合、配列値の特定要素は以下のように記述することで抽出できます。
</p><pre class="synopsis"><em class="replaceable"><code>expression</code></em>[<em class="replaceable"><code>subscript</code></em>]</pre><p>
また、隣接する複数の要素（<span class="quote">“<span class="quote">配列の一部分</span>”</span>）は以下のように記述することで抽出できます。
</p><pre class="synopsis"><em class="replaceable"><code>expression</code></em>[<em class="replaceable"><code>lower_subscript</code></em>:<em class="replaceable"><code>upper_subscript</code></em>]</pre><p>
（ここで大括弧<code class="literal">[ ]</code>は文字通りに記述してください（訳注：これはオプション部分を表す大括弧ではありません）。）
各<em class="replaceable"><code>subscript</code></em>はそれ自体が式であり、整数値を生成しなければなりません。
   </p><p>一般的には、配列<em class="replaceable"><code>expression</code></em>は括弧で括らなければなりませんが、添字を付けるそのexpressionが単なる列参照や位置パラメータであった場合、その括弧を省略することができます。
また、元の配列が多次元の場合は複数の添字を連結することができます。
以下に例を示します。

</p><pre class="programlisting">mytable.arraycolumn[4]
mytable.two_d_column[17][34]
$1[10:42]
(arrayfunction(a,b))[42]</pre><p>

最後の例では括弧が必要です。
配列の詳細は<a class="xref" href="arrays.html" title="8.15. 配列">Section 8.15</a>を参照してください。
   </p></div><div class="sect2" id="FIELD-SELECTION"><div class="titlepage"><div><div><h3 class="title">4.2.4. フィールド選択</h3></div></div></div><a id="id-1.5.3.6.12.2" class="indexterm"></a><p>式が複合型（行型）の値を生成する場合、行の特定のフィールドは以下のように記述することで抽出できます。
</p><pre class="synopsis"><em class="replaceable"><code>expression</code></em>.<em class="replaceable"><code>fieldname</code></em></pre><p>
   </p><p>一般的には、行<em class="replaceable"><code>expression</code></em>は括弧で括らなければなりません。
しかし、選択元となる式が単なるテーブル参照や位置パラメータの場合、括弧を省略することができます。
以下に例を示します。

</p><pre class="programlisting">mytable.mycolumn
$1.somecolumn
(rowfunction(a,b)).col3</pre><p>

（したがって、修飾された列参照は実際のところ、単なるこのフィールド選択構文の特殊な場合です。）
重要となる特殊な場合としては、複合型のテーブル列からフィールドを抽出するときです。

</p><pre class="programlisting">(compositecol).somefield
(mytable.compositecol).somefield</pre><p>

<code class="structfield">compositecol</code>がテーブル名でなく列名であること、または２番目の場合の<code class="structname">mytable</code>がスキーマ名でなくテーブル名であることを示すため丸括弧が要求されます。
   </p><p><code class="literal">.*</code>を記述することで、複合型の全ての値を問い合わせることが可能です。
</p><pre class="programlisting">(compositecol).*</pre><p>
この表記はコンテキストに依存して異なった振る舞いをします。詳細は<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>を参照してください。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-OPERATOR-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.5. 演算子の呼び出し</h3></div></div></div><a id="id-1.5.3.6.13.2" class="indexterm"></a><p>演算子の呼び出しには以下の3構文が可能です。
    </p><table border="0" summary="Simple list" class="simplelist"><tr><td><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>expression</code></em> （二項中置演算子）</td></tr><tr><td><em class="replaceable"><code>operator</code></em> <em class="replaceable"><code>expression</code></em> （単項前置演算子）</td></tr><tr><td><em class="replaceable"><code>expression</code></em> <em class="replaceable"><code>operator</code></em> （単項後置演算子）</td></tr></table><p>
ここで<em class="replaceable"><code>operator</code></em>トークンは、<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-OPERATORS" title="4.1.3. 演算子">Section 4.1.3</a>構文規則に従うもの、もしくはキーワード<code class="token">AND</code>、<code class="token">OR</code>、<code class="token">NOT</code>のいずれか、または以下の形式の修飾された演算子名です。
</p><pre class="synopsis"><code class="literal">OPERATOR(</code><em class="replaceable"><code>schema</code></em><code class="literal">.</code><em class="replaceable"><code>operatorname</code></em><code class="literal">)</code></pre><p>
具体的にどんな演算子が存在し、それが単項か二項かどうかは、システムやユーザによってどんな演算子が定義されたかに依存します。
<a class="xref" href="functions.html" title="Chapter 9. 関数と演算子">Chapter 9</a>にて、組み込み演算子について説明します。
   </p></div><div class="sect2" id="SQL-EXPRESSIONS-FUNCTION-CALLS"><div class="titlepage"><div><div><h3 class="title">4.2.6. 関数呼び出し</h3></div></div></div><a id="id-1.5.3.6.14.2" class="indexterm"></a><p>関数呼び出しの構文は、関数名（スキーマ名で修飾されている場合があります）に続けてその引数を丸括弧で囲んで列挙したものです。

</p><pre class="synopsis"><em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>] )</pre><p>
   </p><p>例えば、以下のものは2の平方根を計算します。
</p><pre class="programlisting">sqrt(2)</pre><p>
   </p><p>組み込み関数の一覧は<a class="xref" href="functions.html" title="Chapter 9. 関数と演算子">Chapter 9</a>にあります。
他の関数はユーザが追加できます。
   </p><p>引数には名前を任意で付与することができます。詳細は<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">Section 4.3</a>を見て下さい。
   </p><div class="note"><h3 class="title">Note</h3><p>複合型の単一引数をとる関数はフィールド選択の構文を使っても呼び出すことができます。
反対にフィールド選択を関数形式で記述することもできます。
つまり、<code class="literal">col(table)</code>や<code class="literal">table.col</code>のどちらを使っても良いということです。
この動作は標準SQLにはありませんが、<span class="productname">PostgreSQL</span>では、これにより<span class="quote">“<span class="quote">計算されたフィールド</span>”</span>のエミュレートをする関数の利用が可能になるため、提供しています。
詳しくは<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>を参照してください。
    </p></div></div><div class="sect2" id="SYNTAX-AGGREGATES"><div class="titlepage"><div><div><h3 class="title">4.2.7. 集約式</h3></div></div></div><a id="id-1.5.3.6.15.2" class="indexterm"></a><a id="id-1.5.3.6.15.3" class="indexterm"></a><a id="id-1.5.3.6.15.4" class="indexterm"></a><a id="id-1.5.3.6.15.5" class="indexterm"></a><p><em class="firstterm">集約式</em>は、問い合わせによって選択される行に対して集約関数を適用することを表現します。
集約関数は、例えば入力の合計や平均などのように、複数の入力を単一の出力値にします。
集約式の構文は下記のうちのいずれかです。

</p><pre class="synopsis"><em class="replaceable"><code>aggregate_name</code></em> (<em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> (ALL <em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> (DISTINCT <em class="replaceable"><code>expression</code></em> [ , ... ] [ <em class="replaceable"><code>order_by_clause</code></em> ] ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]
<em class="replaceable"><code>aggregate_name</code></em> ( [ <em class="replaceable"><code>expression</code></em> [ , ... ] ] ) WITHIN GROUP ( <em class="replaceable"><code>order_by_clause</code></em> ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ]</pre><p>

ここで、<em class="replaceable"><code>aggregate_name</code></em>は事前に定義された集約（スキーマ名で修飾された場合もあります）、<em class="replaceable"><code>expression</code></em>はそれ自体に集約式またはウィンドウ関数呼び出しを含まない任意の値評価式です。
省略可能な<em class="replaceable"><code>order_by_clause</code></em>と<em class="replaceable"><code>filter_clause</code></em>は後述します。
   </p><p>集約式の最初の構文は、それぞれの入力行に対して1回ずつ集計を呼び出します。
<code class="literal">ALL</code>はデフォルトなので、2つ目の形式は最初の形式と同じです。
3番目の形式は、入力行の中にある式の、全ての重複しない値（複数式では重複しない値集合）の集約を呼び出します。
4番目の形式はそれぞれの入力行に対して1回ずつ集約を呼び出します。具体的な入力値が指定されていないため、これは一般的に<code class="function">count(*)</code>集約関数でのみ役に立ちます。
最後の形式は<em class="firstterm">順序集合</em>集約関数で使われるもので、順序集合集約関数については後述します。
   </p><p>ほとんどの集約関数はNULL入力を無視するため、行内の1つ以上の式がNULLを返す行は破棄されます。
特記されていない限り、すべての組み込み集約がそのような動作になると想定して良いです。
   </p><p>例えば、<code class="literal">count(*)</code>は入力行の合計数を求めます。
<code class="function">count</code>はNULLを無視しますので、<code class="literal">count(f1)</code>は<code class="literal">f1</code>が非NULLである入力行の数を求めます。
<code class="literal">count(distinct f1)</code>は<code class="literal">f1</code>の重複しない非NULL値の数を求めます。
   </p><p>通常、入力行は順序を指定されずに集計関数に与えられます。
多くの場合では問題になりません。たとえば<code class="function">min</code>は入力順序に関係なく同一の結果を返します。
しかし一部の集約関数(<code class="function">array_agg</code>および<code class="function">string_agg</code>など)は入力行の順序に依存した結果を返します。
こうした集約関数を使用する際は、オプションの<em class="replaceable"><code>order_by_clause</code></em>を使用して必要とする順序を指定できます。
<em class="replaceable"><code>order_by_clause</code></em>は、<a class="xref" href="queries-order.html" title="7.5. 行の並べ替え">Section 7.5</a>で説明する問い合わせレベルの<code class="literal">ORDER BY</code>句と同じ構文を取りますが、その式は常に単なる式であり、出力列名や序数とすることはできません。
以下に例を示します。
</p><pre class="programlisting">SELECT array_agg(a ORDER BY b DESC) FROM table;</pre><p>
   </p><p>複数の引数を取る集約関数を扱う場合、<code class="literal">ORDER BY</code>句はすべての集約引数の後に指定することに注意してください。
例えば、
</p><pre class="programlisting">SELECT string_agg(a, ',' ORDER BY a) FROM table;</pre><p>
であり、
</p><pre class="programlisting">SELECT string_agg(a ORDER BY a, ',') FROM table;  -- incorrect</pre><p>
ではありません。
    後者は構文的には有効なものですが、2つの<code class="literal">ORDER BY</code>キーを持つ単一引数の集約関数の呼び出しを表しています。(2つ目のキーは定数なので役には立ちません。)
   </p><p><em class="replaceable"><code>order_by_clause</code></em>に加え<code class="literal">DISTINCT</code>が指定された場合、すべての<code class="literal">ORDER BY</code>式が集約関数の通常の引数に一致しなければなりません。つまり、<code class="literal">DISTINCT</code>リストに含まれない式でソートすることはできません。
   </p><div class="note"><h3 class="title">Note</h3><p>集計関数において<code class="literal">DISTINCT</code>と<code class="literal">ORDER BY</code>の両方を指定できる機能はPostgreSQLの拡張です。
    </p></div><p>上記のように集約の通常の引数リストに<code class="literal">ORDER BY</code>を置くことは、汎用的で統計的な集約への入力行を整列する時に使いますが、その整列は省略可能です。
たいていは集約の計算がその入力行の特定の順序に関してのみ意味を持つために、<em class="replaceable"><code>order_by_clause</code></em>が<span class="emphasis"><em>必要な</em></span><em class="firstterm">順序集合集約</em>と呼ばれる集約関数の副クラスがあります。
順序集合集約の典型的な例は順位や百分位数の計算を含みます。
順序集合集約では、<em class="replaceable"><code>order_by_clause</code></em>は上の構文の最後に示したように<code class="literal">WITHIN GROUP (...)</code>の中に書かれます。
<em class="replaceable"><code>order_by_clause</code></em>の式は、通常の集約の引数のように入力行1行につき一度評価され、<em class="replaceable"><code>order_by_clause</code></em>の要求に従って整列され、集約関数に入力引数として渡されます。
(非<code class="literal">WITHIN GROUP</code> <em class="replaceable"><code>order_by_clause</code></em>ではない場合はこれとは異なり、集約関数の引数としては扱われません。)
<code class="literal">WITHIN GROUP</code>の前に引数の式があれば、<em class="replaceable"><code>order_by_clause</code></em>に書かれた<em class="firstterm">集約引数</em>と区別するために<em class="firstterm">直接引数</em>と呼ばれます。
通常の集約引数とは異なり、直接引数は集約の呼び出しの時に一度だけ評価され、入力行1行に一度ではありません。
これは、変数が<code class="literal">GROUP BY</code>によりグループ化された場合にのみ、その変数を含むことが可能であることを意味します。この制限は直接引数が集約式の中に全くない場合と同じです。
直接引数は、典型的には1度の集約計算で1つの値だけが意味がある百分位数のようなもので使われます。
直接引数のリストは空でも構いません。この場合、<code class="literal">(*)</code>ではなく<code class="literal">()</code>と書いてください。
(<span class="productname">PostgreSQL</span>は実際にどちらの綴りも受け付けますが、後者だけが標準SQLに準拠しています。)
   </p><p>    <a id="id-1.5.3.6.15.15.1" class="indexterm"></a>
順序集合集約の例は以下の通りです。

</p><pre class="programlisting">SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;
 percentile_cont
-----------------
           50489</pre><p>

これは、テーブル<code class="structname">households</code>から<code class="structfield">income</code>列の50番目の百分位数、すなわち中央値を得ます。
ここで<code class="literal">0.5</code>は直接引数です。百分位数が行毎に変化する値であったら意味がありません。
   </p><p><code class="literal">FILTER</code>が指定されていれば、<em class="replaceable"><code>filter_clause</code></em>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
例えば、
</p><pre class="programlisting">SELECT
    count(*) AS unfiltered,
    count(*) FILTER (WHERE i &lt; 5) AS filtered
FROM generate_series(1,10) AS s(i);
 unfiltered | filtered
------------+----------
         10 |        4
(1 row)</pre><p>
   </p><p>定義済みの集約関数は<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">Section 9.20</a>で説明されています。
ユーザは他の集約関数を追加することができます。
   </p><p>集約式は、<code class="command">SELECT</code>コマンドの結果リストもしくは<code class="literal">HAVING</code>句内でのみ記述することができます。
<code class="literal">WHERE</code>などの他の句では許されません。
これらの句は集計結果が形成される前に論理的に評価されるためです。
   </p><p>集約式が副問い合わせ（<a class="xref" href="sql-expressions.html#SQL-SYNTAX-SCALAR-SUBQUERIES" title="4.2.11. スカラ副問い合わせ">Section 4.2.11</a>と<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">Section 9.22</a>を参照）内に現れた場合、通常、集約は副問い合わせの行全体に対して評価されます。
しかし、その集約の引数(と、もしあれば<em class="replaceable"><code>filter_clause</code></em>)が上位レベルの変数のみを持つ場合は例外です。
その場合、集約は最も近い外側のレベルに属し、その問い合わせの行全体に対して評価されます。
全体として、その集約式は、その後、その集約を含む副問い合わせでは外部参照となり、その副問い合わせにおける評価に対しては定数として動作します。
結果リストもしくは<code class="literal">HAVING</code>句にのみ現れるという制約は、その集約が属する問い合わせレベルに関連して適用されます。
   </p></div><div class="sect2" id="SYNTAX-WINDOW-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">4.2.8. ウィンドウ関数呼び出し</h3></div></div></div><a id="id-1.5.3.6.16.2" class="indexterm"></a><a id="id-1.5.3.6.16.3" class="indexterm"></a><p><em class="firstterm">ウィンドウ関数呼び出し</em>は、問い合わせにより選択された行のある部分に渡って集約のような機能を実現することを表します。
非ウィンドウ集約関数呼び出しと異なり、これは選択された行を1つの行にグループ化することに束縛されず、各行は別途問い合わせ出力に残ります。
しかしウィンドウ関数は、ウィンドウ関数呼び出しのグループ化指定（<code class="literal">PARTITION BY</code>リスト）に従った、現在の行のグループの一部となる行にすべてアクセスできます。
ウィンドウ関数呼び出しの構文は以下のいずれかです。

</p><pre class="synopsis"><em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER <em class="replaceable"><code>window_name</code></em>
<em class="replaceable"><code>function_name</code></em> ([<span class="optional"><em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ... </span>]</span>]) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER ( <em class="replaceable"><code>window_definition</code></em> )
<em class="replaceable"><code>function_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER <em class="replaceable"><code>window_name</code></em>
<em class="replaceable"><code>function_name</code></em> ( * ) [ FILTER ( WHERE <em class="replaceable"><code>filter_clause</code></em> ) ] OVER ( <em class="replaceable"><code>window_definition</code></em> )</pre><p>
ここで、<em class="replaceable"><code>window_definition</code></em>は以下の構文になります。
</p><pre class="synopsis">[ <em class="replaceable"><code>existing_window_name</code></em> ]
[ PARTITION BY <em class="replaceable"><code>expression</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>frame_clause</code></em> ]</pre><p>
オプションの<em class="replaceable"><code>frame_clause</code></em>は次の中の１つです。
</p><pre class="synopsis">{ RANGE | ROWS } <em class="replaceable"><code>frame_start</code></em>
{ RANGE | ROWS } BETWEEN <em class="replaceable"><code>frame_start</code></em> AND <em class="replaceable"><code>frame_end</code></em></pre><p>
ここで<em class="replaceable"><code>frame_start</code></em>および<em class="replaceable"><code>frame_end</code></em>は以下のいずれかです。
</p><pre class="synopsis">UNBOUNDED PRECEDING
<em class="replaceable"><code>value</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>value</code></em> FOLLOWING
UNBOUNDED FOLLOWING</pre><p>
   </p><p>ここで、<em class="replaceable"><code>expression</code></em>はそれ自身ウィンドウ関数呼び出しを含まない任意の値式を表わします。
   </p><p><em class="replaceable"><code>window_name</code></em>は、問い合わせの<code class="literal">WINDOW</code>句で定義された名前付きウィンドウ仕様への参照です。
あるいはまた、完全な<em class="replaceable"><code>window_definition</code></em>を<code class="literal">WINDOW</code>句で定義された名前付きウィンドウと同じ構文を使って丸括弧の中に書くことができます。
詳細は<a class="xref" href="sql-select.html" title="SELECT"><span class="refentrytitle">SELECT</span></a>マニュアルページを見てください。
<code class="literal">OVER wname</code>は<code class="literal">OVER (wname ...)</code>とは厳密には等価ではないことを指摘しておくのは価値のあることでしょう。
後者はウィンドウ定義をコピーしたり修正したりすることを示唆しており、参照されるウィンドウ仕様がフレーム句を含む場合には拒絶されます。
   </p><p><code class="literal">PARTITION BY</code>句は問い合わせの行を<em class="firstterm">パーティション</em>に纏め、パーティションはウィンドウ関数により別々に処理されます。
<code class="literal">PARTITION BY</code>は、その式が常に式であって出力列名や番号ではないという点を除いて、問い合わせレベルの<code class="literal">GROUP BY</code>句と同様に動作します。
<code class="literal">PARTITION BY</code>がなければ、問い合わせで生じる行すべてが一つのパーティションとして扱われます。
<code class="literal">ORDER BY</code>句はパーティションの行がウィンドウ関数により処理される順序を決定します。
問い合わせレベルの<code class="literal">ORDER BY</code>句と同様に動作しますが、やはり出力列名や番号は使えません。
<code class="literal">ORDER BY</code>がなければ、行は不定の順序で処理されます。
   </p><p><em class="replaceable"><code>frame_clause</code></em>は、パーティション全体ではなくフレーム上で作動するウィンドウ関数に対して、<em class="firstterm">ウィンドウフレーム</em>を構成する行の集合を指定します。
ウィンドウフレームは現在のパーティションの部分集合になります。
フレームは<code class="literal">RANGE</code>モードでも<code class="literal">ROWS</code>モードでも指定できます。
どちらの場合でも<em class="replaceable"><code>frame_start</code></em>から<em class="replaceable"><code>frame_end</code></em>までです。
<em class="replaceable"><code>frame_end</code></em>を省略した場合のデフォルトは<code class="literal">CURRENT ROW</code>です。
   </p><p><em class="replaceable"><code>frame_start</code></em>が<code class="literal">UNBOUNDED PRECEDING</code>であるのはフレームがパーティションの最初の行から始まること意味し、同様に、<em class="replaceable"><code>frame_end</code></em>が<code class="literal">UNBOUNDED FOLLOWING</code>であるのはフレームがパーティションの最後の行で終わること意味します。
   </p><p><code class="literal">RANGE</code>モードでは、<em class="replaceable"><code>frame_start</code></em>が<code class="literal">CURRENT ROW</code>であるのは、フレームが現在行の最初の<em class="firstterm">ピア</em>行（<code class="literal">ORDER BY</code>が現在行と同じ順序とみなす行）から始まることを意味し、一方、<em class="replaceable"><code>frame_end</code></em>が<code class="literal">CURRENT ROW</code>であるのはフレームが現在行の最後の同等な<code class="literal">ORDER BY</code>ピア行で終わることを意味します。
<code class="literal">ROWS</code>モードでは、<code class="literal">CURRENT ROW</code>は単に現在行を意味します。
   </p><p><em class="replaceable"><code>value</code></em> <code class="literal">PRECEDING</code>と<em class="replaceable"><code>value</code></em> <code class="literal">FOLLOWING</code>の形式は、現在のところ<code class="literal">ROWS</code>モードでのみ許可されています。
これは、フレームの開始もしくは終了点となる現在行の前や後に、指定数の行があることを意味します。
<em class="replaceable"><code>value</code></em>は一切の変数、集計関数、あるいはウィンドウ関数を含まない整数式でなければなりません。
またNULLや負数も許可されませんが、現在行を選択することになる0は指定可能です。
   </p><p>デフォルトのフレーム化オプションは<code class="literal">RANGE UNBOUNDED PRECEDING</code>で、<code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>と同じです。
<code class="literal">ORDER BY</code>があると、フレームはパーティションの開始から現在行の最後の<code class="literal">ORDER BY</code>ピア行までのすべての行になります。
<code class="literal">ORDER BY</code>が無い場合は、すべての行が現在行のピアとなるので、パーティションのすべての行がウィンドウフレームに含まれます。
   </p><p>制限は、<em class="replaceable"><code>frame_start</code></em>を<code class="literal">UNBOUNDED FOLLOWING</code>とすることができない点、<em class="replaceable"><code>frame_end</code></em>を<code class="literal">UNBOUNDED PRECEDING</code>とすることができない点、および<em class="replaceable"><code>frame_end</code></em>の選択は上のリストの中で<em class="replaceable"><code>frame_start</code></em>の選択より先に記述することができない点です。例えば、<code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>value</code></em> PRECEDING</code>は許されません。
   </p><p><code class="literal">FILTER</code>が指定されていれば、<em class="replaceable"><code>filter_clause</code></em>が真と評価した入力行のみがウィンドウ関数に渡されます。それ以外の行は破棄されます。
集約ウィンドウ関数だけが<code class="literal">FILTER</code>句を受け付けます。
   </p><p>組み込みウィンドウ関数は<a class="xref" href="functions-window.html#FUNCTIONS-WINDOW-TABLE" title="Table 9.57. 汎用ウィンドウ関数">Table 9.57</a>に記載されています。その他のウィンドウ関数をユーザが追加することが可能です。
また、全ての組み込み、またはユーザ定義の、汎用または統計集約関数もウィンドウ関数として使用できます。
(順序集合と仮想集合集約は現在のところウィンドウ関数として使用できません。)
   </p><p><code class="literal">*</code>を使用した構文は、例えば<code class="literal">count(*) OVER (PARTITION BY x ORDER BY y)</code>のように、パラメータのない集約関数をウィンドウ関数として呼び出すために使用されます。
アスタリスク(<code class="literal">*</code>)は習慣的にウィンドウ固有の関数には使われません。
ウィンドウ固有の関数は、関数引数リストの中で<code class="literal">DISTINCT</code>や<code class="literal">ORDER BY</code>が使われることを許可しません。
   </p><p>ウィンドウ関数呼び出しは問い合わせの<code class="literal">SELECT</code>リストと<code class="literal">ORDER BY</code>句の中でのみ許可されます。
   </p><p>更なるウィンドウ関数についての情報は<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">Section 3.5</a>、<a class="xref" href="functions-window.html" title="9.21. ウィンドウ関数">Section 9.21</a>、<a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. ウィンドウ関数処理">Section 7.2.5</a>にあります。
   </p></div><div class="sect2" id="SQL-SYNTAX-TYPE-CASTS"><div class="titlepage"><div><div><h3 class="title">4.2.9. 型キャスト</h3></div></div></div><a id="id-1.5.3.6.17.2" class="indexterm"></a><a id="id-1.5.3.6.17.3" class="indexterm"></a><a id="id-1.5.3.6.17.4" class="indexterm"></a><p>型キャストは、あるデータ型から他のデータ型への変換を指定します。
<span class="productname">PostgreSQL</span>は型キャストに2つの等価な構文を受け付けます。
</p><pre class="synopsis">CAST ( <em class="replaceable"><code>expression</code></em> AS <em class="replaceable"><code>type</code></em> )
<em class="replaceable"><code>expression</code></em>::<em class="replaceable"><code>type</code></em></pre><p>
<code class="literal">CAST</code>構文はSQLに準拠したものです。
<code class="literal">::</code>を使用する構文は、<span class="productname">PostgreSQL</span>で伝統的に使用されている方法です。
   </p><p>キャストが既知の型の評価式に適用された場合、それは実行時型変換を表します。
このキャストは、適切な型変換操作が定義されている場合のみ成功します。
<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 他の型の定数">Section 4.1.2.7</a>で示すように、これと定数のキャストの使用との微妙な違いに注意してください。
修飾されていない文字列リテラルに対するキャストは、リテラル定数値の初期に割り当てられる型を表します。
ですから、これは（文字列リテラル定数の内容がそのデータ型の入力構文で受け付けられるのであれば）全ての型で成功します。
   </p><p>評価式が生成しなければならない型に曖昧さがない場合（例えばテーブル列への代入時など）、明示的な型キャストは通常は省略することができます。
その場合、システムは自動的に型キャストを適用します。
しかし、自動キャストは、システムカタログに<span class="quote">“<span class="quote">暗黙的に適用しても問題なし</span>”</span>と示されている場合にのみ実行されます。
その他のキャストは明示的なキャスト構文で呼び出す必要があります。
この制限は、知らないうちに変換が実行されてしまうことを防ぐためのものです。
   </p><p>また、関数のような構文を使用して型キャストを指定することもできます。
</p><pre class="synopsis"><em class="replaceable"><code>typename</code></em> ( <em class="replaceable"><code>expression</code></em> )</pre><p>
しかし、これはその型の名前が関数の名前としても有効な場合にのみ動作します。
例えば、<code class="literal">double precision</code> はこの方式で使用できませんが、同等の<code class="literal">float8</code>は使用できます。
また、<code class="literal">interval</code>、<code class="literal">time</code>、<code class="literal">timestamp</code>という名前は、構文が衝突するため、二重引用符で括った場合にのみこの方式で使用できます。
このように、この関数のようなキャスト構文は一貫性がなくなりがちですので、おそらくアプリケーションでは使用すべきではありません
   </p><div class="note"><h3 class="title">Note</h3><p>この関数のような構文は、実際には単なる関数呼び出しです。
2つの標準的なキャスト構文のうちの1つが実行時変換で使用されると、この構文は登録済みの関数を内部的に呼び出して変換を実行します。
慣習的に、これらの変換関数は自身の出力型と同じ名前を持ち、これにより、<span class="quote">“<span class="quote">関数のような構文</span>”</span>は背後にある変換用関数を直接呼び出す以上のことを行いません。
移植性を持つアプリケーションが依存すべきものでないことは明確です。
詳細については<a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>を参照してください。
    </p></div></div><div class="sect2" id="SQL-SYNTAX-COLLATE-EXPRS"><div class="titlepage"><div><div><h3 class="title">4.2.10. 照合順序式</h3></div></div></div><a id="id-1.5.3.6.18.2" class="indexterm"></a><p><code class="literal">COLLATE</code>句は式の照合順序規則を上書きします。
適用するため次の様に式の後に追記します。
</p><pre class="synopsis"><em class="replaceable"><code>expr</code></em> COLLATE <em class="replaceable"><code>collation</code></em></pre><p>
ここで<em class="replaceable"><code>collation</code></em>は識別子で、スキーマ修飾可能です。
<code class="literal">COLLATE</code>句は演算子よりも結合優先度が高いです。
必要に応じて括弧で囲うことができます。
   </p><p>もし照合順序が何も指定されなければ、データベースシステムは式にある列から照合順序を取得します。もし列に関する照合順序が式になければ、データベースのデフォルトの照合順序を使います。
   </p><p><code class="literal">COLLATE</code>句の主な使われ方が２つあります。
１つは<code class="literal">ORDER BY</code>句での並び替え順序を上書きをするもので、例えば次のようにします。
</p><pre class="programlisting">SELECT a, b, c FROM tbl WHERE ... ORDER BY a COLLATE "C";</pre><p>
もう一つは、計算結果がロケールに依存する関数や演算子の呼び出しについて、照合順序を上書きするもので、例えば次のようにします。
</p><pre class="programlisting">SELECT * FROM tbl WHERE a &gt; 'foo' COLLATE "C";</pre><p>
とします。後者の場合、<code class="literal">COLLATE</code>句が、処理対象と想定している入力演算子の引数に対して付与されることに注意してください。演算子や関数の呼び出しのどの引数に対して<code class="literal">COLLATE</code>句が付与されるかは問題ではありません。演算子や関数により適用される照合順序は対象となる全ての引数を考慮して引き出され、そして明示的に指定された<code class="literal">COLLATE</code>句がその他の全ての引数に対しての照合順序を上書きするからです。(しかし、複数の引数に対して一致しない<code class="literal">COLLATE</code>句の付与はエラーとなります。詳細は<a class="xref" href="collation.html" title="23.2. 照合順序サポート">Section 23.2</a>を参照してください)。このため、前述の例と同じ結果を次の様にして取得することができます。
</p><pre class="programlisting">SELECT * FROM tbl WHERE a COLLATE "C" &gt; 'foo';</pre><p>
ただし、次の例はエラーになります。
</p><pre class="programlisting">SELECT * FROM tbl WHERE (a &gt; 'foo') COLLATE "C";</pre><p>
<code class="literal">&gt;</code>演算子の結果に対して照合順序を適用しようとしますが、<code class="literal">&gt;</code>演算子は照合不可能なデータ型である<code class="type">boolean</code>となるからです。
   </p></div><div class="sect2" id="SQL-SYNTAX-SCALAR-SUBQUERIES"><div class="titlepage"><div><div><h3 class="title">4.2.11. スカラ副問い合わせ</h3></div></div></div><a id="id-1.5.3.6.19.2" class="indexterm"></a><p>スカラ副問い合わせは、正確に1行1列を返す、括弧内の通常の<code class="command">SELECT</code>問い合わせです
（問い合わせの記述方法については<a class="xref" href="queries.html" title="Chapter 7. 問い合わせ">Chapter 7</a>を参照してください）。
その<code class="command">SELECT</code>問い合わせは実行され、返される単一の値はその値の前後の評価式で使用されます。
1行を超える行や1列を超える列がスカラ副問い合わせ用の問い合わせとして使用された場合はエラーになります
（しかし、ある実行時に、副問い合わせが行を返さない場合はエラーとはなりません。
そのスカラ結果はNULLとして扱われます）。
副問い合わせは、その周りの問い合わせ内の値を参照することができます。
その値は副問い合わせの評価時には定数として扱われます。
副問い合わせに関する他の式については<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">Section 9.22</a>も参照してください。
   </p><p>例えば、以下は各州の最大都市の人口を検索します。
</p><pre class="programlisting">SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)
    FROM states;</pre><p>
   </p></div><div class="sect2" id="SQL-SYNTAX-ARRAY-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.12. 配列コンストラクタ</h3></div></div></div><a id="id-1.5.3.6.20.2" class="indexterm"></a><a id="id-1.5.3.6.20.3" class="indexterm"></a><p>配列コンストラクタは、メンバー要素に対する値を用いて配列値を構築する式です。
単純な配列コンストラクタの構成は、<code class="literal">ARRAY</code>キーワード、左大括弧<code class="literal">[</code>、（カンマで区切った）配列要素値用の式のリストで、最後に右大括弧<code class="literal">]</code>です。
以下に例を示します。
</p><pre class="programlisting">SELECT ARRAY[1,2,3+4];
  array
---------
 {1,2,7}
(1 row)</pre><p>
    デフォルトで配列要素型は、メンバ式の型と同じで、<code class="literal">UNION</code>や<code class="literal">CASE</code>構文と同じ規則を使用して決定されます
（<a class="xref" href="typeconv-union-case.html" title="10.5. UNION、CASEおよび関連する構文">Section 10.5</a>を参照してください）。これを明示的に配列コンストラクタを希望する型にキャストすることで書き換えることができます。例をあげます。
</p><pre class="programlisting">SELECT ARRAY[1,2,22.7]::integer[];
  array
----------
 {1,2,23}
(1 row)</pre><p>
これはそれぞれの式を配列要素の型に個別にキャストするのと同じ効果があります。
キャストについてより多くは<a class="xref" href="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS" title="4.2.9. 型キャスト">Section 4.2.9</a>を参照してください。
   </p><p>多次元配列値は、配列コンストラクタを入れ子にすることで構築できます。
内側のコンストラクタでは<code class="literal">ARRAY</code>キーワードは省略可能です。
例えば、以下は同じ結果になります。

</p><pre class="programlisting">SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)

SELECT ARRAY[[1,2],[3,4]];
     array
---------------
 {{1,2},{3,4}}
(1 row)</pre><p>

多次元配列は長方形配列でなければなりませんので、同一レベルの内部コンストラクタは同一次元の副配列を生成しなければなりません。外部<code class="literal">ARRAY</code>コンストラクタに適用される全てのキャストは自動的に全ての内部コンストラクタに伝播します。
  </p><p>多次元配列コンストラクタの要素は、副<code class="literal">ARRAY</code>構文だけでなく、適切な種類の配列を生成するものをとることができます。
以下に例を示します。
</p><pre class="programlisting">CREATE TABLE arr(f1 int[], f2 int[]);

INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);

SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;
                     array
------------------------------------------------
 {{{1,2},{3,4}},{{5,6},{7,8}},{{9,10},{11,12}}}
(1 row)</pre><p>
  </p><p>空配列を構築できますが、型を所有しない配列を持つことは不可能なので、空配列を望まれる型に明示的にキャストしなければなりません。例をあげます。
</p><pre class="programlisting">SELECT ARRAY[]::integer[];
 array
-------
 {}
(1 row)</pre><p>
  </p><p>また、副問い合わせの結果から配列を構成することも可能です。
この形式の場合、配列コンストラクタは<code class="literal">ARRAY</code>キーワードの後に括弧（大括弧ではない）で括られた副問い合わせとして記述されます。
以下に例を示します。
</p><pre class="programlisting">SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');
                                 array
-----------------------------------------------------------------------
 {2011,1954,1948,1952,1951,1244,1950,2005,1949,1953,2006,31,2412,2413}
(1 row)

SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i));
              array
----------------------------------
 {{1,2},{2,4},{3,6},{4,8},{5,10}}
(1 row)</pre><p>
副問い合わせは単一の列を返さなければなりません。
副問い合わせの出力列が非配列型であれば、その結果である一次元配列は、副問い合わせの出力列と一致する型を要素型とした、副問い合わせの結果内の各行を要素として持ちます。
副問い合わせの出力列が配列型であれば、その結果は、同じ型で1つ次元の高い配列になります。この場合、副問い合わせの列はすべて同じ次元の配列とならなければなりません。そうでないと結果が長方形になりません。
  </p><p><code class="literal">ARRAY</code>で構築された配列値の添字は、常に1から始まります。
配列についての詳細は<a class="xref" href="arrays.html" title="8.15. 配列">Section 8.15</a>を参照してください。
  </p></div><div class="sect2" id="SQL-SYNTAX-ROW-CONSTRUCTORS"><div class="titlepage"><div><div><h3 class="title">4.2.13. 行コンストラクタ</h3></div></div></div><a id="id-1.5.3.6.21.2" class="indexterm"></a><a id="id-1.5.3.6.21.3" class="indexterm"></a><a id="id-1.5.3.6.21.4" class="indexterm"></a><p>行コンストラクタは、そのメンバフィールドに対する値を用いて行値（複合値とも呼ばれます）を構築する式です。
行コンストラクタは、<code class="literal">ROW</code>キーワード、左括弧、行のフィールド値用の0個以上の式（カンマ区切り）、最後に右括弧からなります。
以下に例を示します。
</p><pre class="programlisting">SELECT ROW(1,2.5,'this is a test');</pre><p>
<code class="literal">ROW</code>キーワードは、2つ以上の式がリスト内にある場合は省略することができます。
   </p><p>行コンストラクタには<em class="replaceable"><code>rowvalue</code></em><code class="literal">.*</code>構文を含めることができます。
これは、<code class="command">SELECT</code>リストの最上位レベルで<code class="literal">.*</code>構文が使用された時とまったく同様に、行値の要素の列挙に展開されます(<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 問い合わせでの複合型の使用">Section 8.16.5</a>参照)。
たとえば、テーブル<code class="literal">t</code>が<code class="literal">f1</code>列と<code class="literal">f2</code>列を持つ場合、以下は同一です。
</p><pre class="programlisting">SELECT ROW(t.*, 42) FROM t;
SELECT ROW(t.f1, t.f2, 42) FROM t;</pre><p>
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span> 8.2より前では、<code class="literal">.*</code>構文は行コンストラクタ内では展開されませんでした。
<code class="literal">ROW(t.*, 42)</code>と記述すると、1つ目のフィールドにもう一つの行値を持つ、2つのフィールドからなる行が作成されました。
たいていの場合、新しい動作はより使いやすくなっています。
入れ子状の行値という古い動作が必要であれば、内側の行値には<code class="literal">.*</code>を使用せずに、たとえば<code class="literal">ROW(t, 42)</code>と記述してください。
    </p></div><p>デフォルトでは、<code class="literal">ROW</code>式により作成される値は匿名レコード型になります。
必要に応じて、名前付きの複合型、つまりテーブルの行型あるいは<code class="command">CREATE TYPE AS</code>で作成された複合型にキャストすることができます。
曖昧性を防止するために明示的なキャストが必要となることもあります。
以下に例を示します。
</p><pre class="programlisting">CREATE TABLE mytable(f1 int, f2 float, f3 text);

CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- getf1()が1つしか存在しないためキャスト不要。
SELECT getf1(ROW(1,2.5,'this is a test'));
 getf1
-------
     1
(1 row)

CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric);

CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;

-- ここでは、どの関数を呼び出すのかを示すためにキャストが必要。
SELECT getf1(ROW(1,2.5,'this is a test'));
ERROR:  function getf1(record) is not unique

SELECT getf1(ROW(1,2.5,'this is a test')::mytable);
 getf1
-------
     1
(1 row)

SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype));
 getf1
-------
    11
(1 row)</pre><p>
  </p><p>行コンストラクタは、複合型のテーブル列に格納する複合型の値を構築するため、あるいは複合型のパラメータを受け付ける関数に渡すために使用することができます。
また、以下の例のように、2つの行値を比較することも、<code class="literal">IS NULL</code>もしくは<code class="literal">IS NOT NULL</code>で行を検査することも可能です。
</p><pre class="programlisting">SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');

SELECT ROW(table.*) IS NULL FROM table;  -- すべてがNULLの行を検出します。</pre><p>
詳細は<a class="xref" href="functions-comparisons.html" title="9.23. 行と配列の比較">Section 9.23</a>を参照してください。
行コンストラクタは、<a class="xref" href="functions-subquery.html" title="9.22. 副問い合わせ式">Section 9.22</a>で説明するように、副問い合わせと一緒に使用することもできます。
  </p></div><div class="sect2" id="SYNTAX-EXPRESS-EVAL"><div class="titlepage"><div><div><h3 class="title">4.2.14. 式の評価規則</h3></div></div></div><a id="id-1.5.3.6.22.2" class="indexterm"></a><p>副式の評価の順序は定義されていません。
特に演算子や関数の入力は、必ずしも左から右などの決まった順序で評価されるわけではありません。
   </p><p>さらに、その式の一部を評価しただけで式の結果を決定できる場合には、他の副式がまったく評価されないこともあります。
例えば、
</p><pre class="programlisting">SELECT true OR somefunc();</pre><p>
では、（おそらく）<code class="literal">somefunc()</code>は呼び出されないでしょう。
以下の場合も同様です。
</p><pre class="programlisting">SELECT somefunc() OR true;</pre><p>
これは一部のプログラミング言語に見られる、ブーリアン演算子での左から右への<span class="quote">“<span class="quote">短絡評価</span>”</span>とは異なることに注意してください。
   </p><p>そのため、副次作用がある関数を複雑な式の一部として使用することは推奨されません。
特に、<code class="literal">WHERE</code>句および<code class="literal">HAVING</code>句で副次作用や評価順に依存するのは危険です。
これらの句は、実行計画を作成する過程で頻繁に再処理されるからです。
これらの句のブール式（<code class="literal">AND</code>/<code class="literal">OR</code>/<code class="literal">NOT</code>の組み合わせ）は、ブール代数の規則で許されるあらゆる方式で再編成される可能性があります。
   </p><p>評価の順序を強制することが重要であれば、<code class="literal">CASE</code>構文（<a class="xref" href="functions-conditional.html" title="9.17. 条件式">Section 9.17</a>を参照）を使用できます。
例えば、次の式は<code class="literal">WHERE</code>句で0除算を避ける方法としては信頼性の低いものです。
</p><pre class="programlisting">SELECT ... WHERE x &gt; 0 AND y/x &gt; 1.5;</pre><p>
しかし、次のようにすれば安全です。
</p><pre class="programlisting">SELECT ... WHERE CASE WHEN x &gt; 0 THEN y/x &gt; 1.5 ELSE false END;</pre><p>
このような方法で使用される<code class="literal">CASE</code>構文は最適化を妨げるものなので、必要な場合にのみ使用してください。
（特に、この例では、<code class="literal">y &gt; 1.5*x</code>と代わりに記述することが問題を回避するより優れた方法です。）
   </p><p>しかしながら、<code class="literal">CASE</code>はそのような問題に対する万能薬ではありません。
上で示したような方法の限界の1つは、定数副式が早く評価されるのを防げないことです。
<a class="xref" href="xfunc-volatility.html" title="37.6. 関数の変動性分類">Section 37.6</a>に記すように、<code class="literal">IMMUTABLE</code>と印をつけられた関数と演算子は、実行される時ではなく問い合わせが計画される時に評価されるかもしれません。
そのため、例えば
</p><pre class="programlisting">SELECT CASE WHEN x &gt; 0 THEN x ELSE 1/0 END FROM tab;</pre><p>
は、たとえテーブルのすべての行が<code class="literal">x &gt; 0</code>であり、実行時には<code class="literal">ELSE</code>節に決して入らないとしても、プランナが定数副式を単純化しようとするためにゼロによる除算での失敗という結果に終わるでしょう。
   </p><p>この特別な例は馬鹿げたものに見えるかもしれませんが、定数を含むことが明らかではない関連する場合が関数の中で実行される問い合わせで起こり得ます。関数の引数とローカル変数は計画する目的のために定数として問い合わせに入れられることがあるからです。
例えば、<span class="application">PL/pgSQL</span>関数の中では、<code class="literal">IF</code>-<code class="literal">THEN</code>-<code class="literal">ELSE</code>文を使って危険な計算を保護する方が<code class="literal">CASE</code>式の中で入れ子にするよりもずっと安全です。
   </p><p>同種の別の限界は、その中に含まれる集約式の評価を<code class="literal">CASE</code>が防げないことです。なぜなら、<code class="literal">SELECT</code>リストや<code class="literal">HAVING</code>句の別の式が考慮される前に、集約式が計算されるからです。
例えば、以下の問い合わせは対策を施しているように見えるにも関わらずゼロ除算エラーになり得ます。
</p><pre class="programlisting">SELECT CASE WHEN min(employees) &gt; 0
            THEN avg(expenses / employees)
       END
    FROM departments;</pre><p>
<code class="function">min()</code>と<code class="function">avg()</code>集約は入力行すべてに対して同時に計算されますので、もし<code class="structfield">employees</code>がゼロになる行があれば、<code class="function">min()</code>の結果が検査される機会の前にゼロ除算エラーが起こります。
代わりに、まずは問題のある入力行が集約関数に渡されないようにするために<code class="literal">WHERE</code>または<code class="literal">FILTER</code>句を使ってください。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-syntax-lexical.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-syntax.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-syntax-calling-funcs.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.1. 字句の構造 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.3. 関数呼び出し</td></tr></table></div></body></html>