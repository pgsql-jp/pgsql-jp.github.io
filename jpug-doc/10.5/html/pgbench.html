<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>pgbench</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="app-pgbasebackup.html" title="pg_basebackup" /><link rel="next" href="app-pgconfig.html" title="pg_config" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center"><span xmlns="http://www.w3.org/1999/xhtml" class="application">pgbench</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="app-pgbasebackup.html" title="pg_basebackup">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="reference-client.html" title="PostgreSQLクライアントアプリケーション">Up</a></td><th width="60%" align="center">PostgreSQLクライアントアプリケーション</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="app-pgconfig.html" title="pg_config">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="PGBENCH"><div class="titlepage"></div><a id="id-1.9.4.10.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle"><span class="application">pgbench</span></span></h2><p>pgbench — <span class="productname">PostgreSQL</span>に対してベンチマーク試験を行う</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><div class="cmdsynopsis"><p id="id-1.9.4.10.4.1"><code class="command">pgbench</code>  <code class="option">-i</code>  [<em class="replaceable"><code>option</code></em>...] [<em class="replaceable"><code>dbname</code></em>]</p></div><div class="cmdsynopsis"><p id="id-1.9.4.10.4.2"><code class="command">pgbench</code> [<em class="replaceable"><code>option</code></em>...] [<em class="replaceable"><code>dbname</code></em>]</p></div></div><div class="refsect1" id="id-1.9.4.10.5"><h2>説明</h2><p><span class="application">pgbench</span>は<span class="productname">PostgreSQL</span>上でベンチマーク試験を行う単純なプログラムです。
これは同一のSQLコマンドの並びを何度も実行します。複数の同時実行データベースセッションで実行することもできます。
そして、トランザクションの速度（1秒当たりのトランザクション数）の平均を計算します。
デフォルトで<span class="application">pgbench</span>は、1トランザクション当たり5つの<code class="command">SELECT</code>、<code class="command">UPDATE</code>、<code class="command">INSERT</code>コマンドを含むおおよそTPC-Bに基いたシナリオを試験します。
しかし、独自のトランザクションスクリプトファイルを作成することで他の試験ケースを簡単に実行することができます。
 </p><p>pgbenchの典型的な出力を以下に示します。

</p><pre class="screen">transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)</pre><p>

最初の6行はいくつかの最重要パラメータの設定を表示しています。
次行が完了トランザクション数と予定トランザクション数です（後者は単なるクライアント数とクライアント毎のトランザクション数の積算結果です。）
実行が完了する前に失敗しない限りこれは等しくなります。
(<code class="option">-T</code>モードでは、トランザクションの実際の数が表示されます)
最後の2行は、データベースセッションを開始するための時間を含める場合と含めない場合の1秒当たりのトランザクション数を示します。
 </p><p>デフォルトのTPC-Bと似たトランザクション試験では、あらかじめ設定する特定のテーブルが必要です。
これらのテーブルを作成し、データを投入するためには、<code class="option">-i</code>(初期化)オプションを付けて<span class="application">pgbench</span>を呼び出さなければなりません。
(独自スクリプトを試験する場合、この手順は必要ありません。
しかし代わりに試験に必要な何らかの設定を行わなければならないでしょう。)
初期化は以下のようになります。

</p><pre class="programlisting">pgbench -i [<span class="optional"> <em class="replaceable"><code>other-options</code></em> </span>] <em class="replaceable"><code>dbname</code></em></pre><p>

ここで<em class="replaceable"><code>dbname</code></em>は試験用に前もって作成されたデータベースの名前です。
（またデータベースサーバの接続方法を指定するために、<code class="option">-h</code>、<code class="option">-p</code>、<code class="option">-U</code>が必要になるかもしれません。）
  </p><div class="caution"><h3 class="title">Caution</h3><p><code class="literal">pgbench -i</code>は4つのテーブル<code class="structname">pgbench_accounts</code>、<code class="structname">pgbench_branches</code>、<code class="structname">pgbench_history</code>、<code class="structname">pgbench_tellers</code>を作成します。
もしあればこうした名前のテーブルは破壊されます。
もし同じ名前のテーブルが存在する場合にはよく注意してください。
   </p></div><p>デフォルトの<span class="quote">“<span class="quote">倍数</span>”</span>の1では、テーブルは初期状態で以下の行数を含みます。
</p><pre class="screen">table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0</pre><p>
<code class="option">-s</code>（倍数）オプションを使用して行数を増加させることができます（また、ほとんどの目的ではおそらく増加させるべきです）。
また、<code class="option">-F</code> （フィルファクタ）オプションをここで使用しても構いません。
  </p><p>一度この必要な設定を行った後、以下のように<code class="option">-i</code>を持たないコマンドでベンチマークを行うことができます。

</p><pre class="programlisting">pgbench [<span class="optional"> <em class="replaceable"><code>options</code></em> </span>] <em class="replaceable"><code>dbname</code></em></pre><p>

ほとんどすべての場合、有用な試験とするためにいくつかのオプションが必要になります。
最重要オプションは<code class="option">-c</code>（クライアント数）、<code class="option">-t</code>（トランザクション数）、<code class="option">-T</code> (制限時間)、<code class="option">-f</code>（独自スクリプトファイルの指定）です。
以下の全一覧を参照してください。
  </p></div><div class="refsect1" id="id-1.9.4.10.6"><h2>オプション</h2><p>以下では、データベース初期化時に使用されるオプション、ベンチマーク実行時に使用されるオプション、どちらの場合でも使われるオプションの３つに分けて説明します。
  </p><div class="refsect2" id="PGBENCH-INIT-OPTIONS"><h3>初期化用のオプション</h3><p><span class="application">pgbench</span>は以下の初期化用のコマンドライン引数を受け付けます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-i</code><br /></span><span class="term"><code class="option">--initialize</code></span></dt><dd><p>初期化モードを呼び出すために必要です。
       </p></dd><dt><span class="term"><code class="option">-F</code> <em class="replaceable"><code>fillfactor</code></em><br /></span><span class="term"><code class="option">--fillfactor=</code><em class="replaceable"><code>fillfactor</code></em></span></dt><dd><p>指定したフィルファクタで<code class="structname">pgbench_accounts</code>、<code class="structname">pgbench_tellers</code>、<code class="structname">pgbench_branches</code>テーブルを作成します。
デフォルトは100です。
       </p></dd><dt><span class="term"><code class="option">-n</code><br /></span><span class="term"><code class="option">--no-vacuum</code></span></dt><dd><p>初期化の後にバキューム処理を行いません。
       </p></dd><dt><span class="term"><code class="option">-q</code><br /></span><span class="term"><code class="option">--quiet</code></span></dt><dd><p>ログ処理を、5秒に１つの進行メッセージのみを生成する静寂モードに切り替えます。
デフォルトのログ処理では、10000行毎にメッセージを１つ出力し、（特に優れたハードウェアでは）1秒当たりに多くのメッセージを出力します。
       </p></dd><dt><span class="term"><code class="option">-s</code> <em class="replaceable"><code>scale_factor</code></em><br /></span><span class="term"><code class="option">--scale=</code><em class="replaceable"><code>scale_factor</code></em></span></dt><dd><p>この倍率で生成される行数を積算します。
例えば、<code class="literal">-s 100</code>は <code class="structname">pgbench_accounts</code>テーブルに10,000,000行を生成することを意味します。
デフォルトは1です。
この倍率が20000以上になると、アカウント識別子の範囲を保持できる程度に大きくなるように、アカウント識別子を保持するために使用される列（<code class="structfield">aid</code>列）はより大きな整数（<code class="type">bigint</code>）を使用するように切り替わります。

       </p></dd><dt><span class="term"><code class="option">--foreign-keys</code></span></dt><dd><p>標準テーブル間で外部キー制約を作成します。
       </p></dd><dt><span class="term"><code class="option">--index-tablespace=<em class="replaceable"><code>index_tablespace</code></em></code></span></dt><dd><p>デフォルトのテーブル空間ではなく、指定したテーブル空間の中にインデックスを作成します。
       </p></dd><dt><span class="term"><code class="option">--tablespace=<em class="replaceable"><code>tablespace</code></em></code></span></dt><dd><p>デフォルトのテーブル空間ではなく、指定したテーブル空間の中にテーブルを作成します。
       </p></dd><dt><span class="term"><code class="option">--unlogged-tables</code></span></dt><dd><p>永続テーブルではなくログを取らないテーブルとしてテーブルを作成します。
       </p></dd></dl></div><p>
   </p></div><div class="refsect2" id="PGBENCH-RUN-OPTIONS"><h3>ベンチマーク用オプション</h3><p><span class="application">pgbench</span>は以下のベンチマーク用コマンドライン引数を受け付けます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-b</code> <em class="replaceable"><code>scriptname[@weight]</code></em><br /></span><span class="term"><code class="option">--builtin</code>=<em class="replaceable"><code>scriptname[@weight]</code></em></span></dt><dd><p>指定の組み込みスクリプトを実行されたスクリプトのリストに追加します。
オプションで<code class="literal">@</code>の後に整数のweight（重み）をつけることで、そのスクリプトが選ばれる確率を調整することができます。
指定しなかった場合は1に設定されます。
利用可能な組み込みのスクリプトは、<code class="literal">tpcb-like</code>、<code class="literal">simple-update</code>、<code class="literal">select-only</code>です。
組み込みの名前の曖昧な接頭辞も受け付けられます。
特別な名前<code class="literal">list</code>を使うと、組み込みスクリプトのリストを表示して、即座に終了します。
       </p></dd><dt><span class="term"><code class="option">-c</code> <em class="replaceable"><code>clients</code></em><br /></span><span class="term"><code class="option">--client=</code><em class="replaceable"><code>clients</code></em></span></dt><dd><p>模擬するクライアント数、つまり、同時に実行されるデータベースセッション数です。
デフォルトは1です。
       </p></dd><dt><span class="term"><code class="option">-C</code><br /></span><span class="term"><code class="option">--connect</code></span></dt><dd><p>各クライアントセッションが一度だけ接続を確立するのではなく、各トランザクションが新しい接続を確立します。
これは接続オーバーヘッドを測定する場合に有用です。
       </p></dd><dt><span class="term"><code class="option">-d</code><br /></span><span class="term"><code class="option">--debug</code></span></dt><dd><p>デバッグ用出力を表示します。
       </p></dd><dt><span class="term"><code class="option">-D</code> <em class="replaceable"><code>varname</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em><br /></span><span class="term"><code class="option">--define=</code><em class="replaceable"><code>varname</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em></span></dt><dd><p>独自スクリプト（後述）で使用される変数を定義します。
複数の<code class="option">-D</code>オプションを使用することができます。
       </p></dd><dt><span class="term"><code class="option">-f</code> <em class="replaceable"><code>filename[@weight]</code></em><br /></span><span class="term"><code class="option">--file=</code><em class="replaceable"><code>filename[@weight]</code></em></span></dt><dd><p><em class="replaceable"><code>filename</code></em>から読み取ったトランザクションスクリプトを実行されたスクリプトのリストに追加します。
オプションで<code class="literal">@</code>の後に整数のweight（重み）をつけることで、そのテストが選ばれる確率を調整することができます。
詳細は後で説明します。
       </p></dd><dt><span class="term"><code class="option">-j</code> <em class="replaceable"><code>threads</code></em><br /></span><span class="term"><code class="option">--jobs=</code><em class="replaceable"><code>threads</code></em></span></dt><dd><p><span class="application">pgbench</span>内のワーカスレッド数です。
複数のスレッドを使用することはマルチCPUマシンで有用になります。
クライアントは利用可能なスレッドの間でできる限り均等に分散されます。
デフォルトは1です。
       </p></dd><dt><span class="term"><code class="option">-l</code><br /></span><span class="term"><code class="option">--log</code></span></dt><dd><p>各トランザクションに関する情報をログファイルに書き出します。
後で詳細を説明します。
       </p></dd><dt><span class="term"><code class="option">-L</code> <em class="replaceable"><code>limit</code></em><br /></span><span class="term"><code class="option">--latency-limit=</code><em class="replaceable"><code>limit</code></em></span></dt><dd><p><em class="replaceable"><code>limit</code></em>ミリ秒以上続くトランザクションが計数され、別途<em class="firstterm">遅いトランザクション</em>として報告されます。
       </p><p>制限が使用されると(<code class="option">--rate=...</code>)、<em class="replaceable"><code>limit</code></em>ミリ秒以上遅延がスケジュールされたトランザクションは遅延制限を満たす可能性がないため、サーバに送信されることは決してありません。
これらのトランザクションは計数され、別途<em class="firstterm">スキップされた</em>として報告されます。
       </p></dd><dt><span class="term"><code class="option">-M</code> <em class="replaceable"><code>querymode</code></em><br /></span><span class="term"><code class="option">--protocol=</code><em class="replaceable"><code>querymode</code></em></span></dt><dd><p>サーバへ問い合わせを送信するために使用するプロトコルです。
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">simple</code>: 簡易問い合わせプロトコルを使用します。</p></li><li class="listitem"><p><code class="literal">extended</code>: 拡張問い合わせプロトコルを使用します。</p></li><li class="listitem"><p><code class="literal">prepared</code>: プリペアドステートメントを伴う拡張問い合わせプロトコルを使用します。</p></li></ul></div><p>
デフォルトは簡易問い合わせプロトコルです。
（詳しい情報は<a class="xref" href="protocol.html" title="Chapter 52. フロントエンド/バックエンドプロトコル">Chapter 52</a>を参照してください）
       </p></dd><dt><span class="term"><code class="option">-n</code><br /></span><span class="term"><code class="option">--no-vacuum</code></span></dt><dd><p>試験を実行する前にバキュームを行いません。
<code class="structname">pgbench_accounts</code>、<code class="structname">pgbench_branches</code>、<code class="structname">pgbench_history</code>、
<code class="structname">pgbench_tellers</code>標準テーブルを含まない独自試験シナリオを実行する場合、このオプションは<span class="emphasis"><em>必要</em></span>です。
       </p></dd><dt><span class="term"><code class="option">-N</code><br /></span><span class="term"><code class="option">--skip-some-updates</code></span></dt><dd><p>組み込みのsimple-update（単純な更新）のスクリプトを実行します。
<code class="option">-b simple-update</code>の短縮形です。
       </p></dd><dt><span class="term"><code class="option">-P</code> <em class="replaceable"><code>sec</code></em><br /></span><span class="term"><code class="option">--progress=</code><em class="replaceable"><code>sec</code></em></span></dt><dd><p><em class="replaceable"><code>sec</code></em>秒毎の進捗レポートを表示します。
レポートには起動からの経過時間、前回レポート時からのtps、前回レポート時からのトランザクションの平均待ち時間、標準偏差を含んでいます。
(<code class="option">-R</code>)オプションによる制限下では、待ち時間はトランザクションの実開始時間ではなく、予定開始時間で算出されていますので、平均予定遅延時間が含まれています。
       </p></dd><dt><span class="term"><code class="option">-r</code><br /></span><span class="term"><code class="option">--report-latencies</code></span></dt><dd><p>ベンチマーク完了後の各コマンドにおけるステートメント毎の平均レイテンシ(クライアントから見た実行時間)を報告します。詳しくは下を参照してください。
       </p></dd><dt><span class="term"><code class="option">-R</code> <em class="replaceable"><code>rate</code></em><br /></span><span class="term"><code class="option">--rate=</code><em class="replaceable"><code>rate</code></em></span></dt><dd><p>トランザクションを可能な限り高速（デフォルト）で実行するのではなく、指定された目標レートで実行します。
レートは1秒あたりのトランザクション数で与えられます。目標レートが実施可能な最大レートを越えている場合、レート制限は結果に影響を与えません。
       </p><p>レートはトランザクションの開始予定タイムラインがポアソン分布に沿う事を目標としています。
期待される開始時刻の予定は、前トランザクションの終了時ではなくクライアントの初期起動時に基づいて動かします。
このアプローチはトランザクションがオリジナルの終了予定時刻を過ぎた場合でも、後でまた追い付けることを意味します。
       </p><p>制限がアクティブになると、実行終了時に報告されるトランザクション待ち時間は、予定開始時刻から計算されるので、
各トランザクションが前トランザクションの終了を待たねばならなかった時間を含んでいます。
この待ち時間はスケジュールラグタイムと呼ばれ、平均と最大値も別々に報告されます。
実トランザクション開始時刻についてのトランザクション待ち時間、つまりデータベース内でトランザクションの実行に要した時間は、報告された待ち時間からスケジュールラグタイムを減算することで算出することができます。
       </p><p><code class="option">--latency-limit</code>が<code class="option">--rate</code>と一緒に指定された場合、トランザクションは、先行するトランザクションが終了した際にすでに遅延制限を超えていて、非常に遅れてしまうことがあり得ます。
そのようなトランザクションはサーバに送信さることなくスキップされ、別途カウントされます。
       </p><p>スケジュールラグタイムの高い値は、システムが選択されたクライアント数とスレッド数で、指定されたレートでトランザクションを処理できなかったことを示しています。
トランザクションの平均実行時間が各トランザクション間で予定されていた間隔より長い場合、各逐次トランザクションは更に遅くなり、
スケジュールラグタイムはテスト実行がより長く増加し続けます。
これが起こる場合、指定トランザクションレートを減らす必要があります。
       </p></dd><dt><span class="term"><code class="option">-s</code> <em class="replaceable"><code>scale_factor</code></em><br /></span><span class="term"><code class="option">--scale=</code><em class="replaceable"><code>scale_factor</code></em></span></dt><dd><p><span class="application">pgbench</span>の出力で指定した倍率を報告します。
これは組み込みの試験では必要ありません。
正確な倍率が<code class="structname">pgbench_branches</code>テーブルの行数を数えることで検出されます。
しかし、独自ベンチマーク（<code class="option">-f</code>オプション）のみを試験している場合、このオプションを使用しない限り、倍率は1として報告されます。
       </p></dd><dt><span class="term"><code class="option">-S</code><br /></span><span class="term"><code class="option">--select-only</code></span></dt><dd><p>組み込みのselect-only（SELECTのみ）のスクリプトを実行します。
<code class="option">-b select-only</code>の短縮形です。
       </p></dd><dt><span class="term"><code class="option">-t</code> <em class="replaceable"><code>transactions</code></em><br /></span><span class="term"><code class="option">--transactions=</code><em class="replaceable"><code>transactions</code></em></span></dt><dd><p>各クライアントが実行するトランザクション数です。
デフォルトは10です。
       </p></dd><dt><span class="term"><code class="option">-T</code> <em class="replaceable"><code>seconds</code></em><br /></span><span class="term"><code class="option">--time=</code><em class="replaceable"><code>seconds</code></em></span></dt><dd><p>クライアントあたりのトランザクション数を固定で指定するよりも長くテストを実行したい場合、ここに指定した秒数でテストを実行します。
<code class="option">-t</code>と<code class="option">-T</code>は互いに排他的です。
       </p></dd><dt><span class="term"><code class="option">-v</code><br /></span><span class="term"><code class="option">--vacuum-all</code></span></dt><dd><p>試験前に4つの標準テーブルすべてをバキュームします。
<code class="option">-n</code>も<code class="option">-v</code>もなければ、pgbenchは<code class="structname">pgbench_tellers</code>と<code class="structname">pgbench_branches</code>テーブルをバキュームし、<code class="structname">pgbench_history</code>内のデータをすべて消去します。
       </p></dd><dt><span class="term"><code class="option">--aggregate-interval=<em class="replaceable"><code>seconds</code></em></code></span></dt><dd><p>集約間隔の長さ（秒単位）です。
これは<span class="application">-l</span>と一緒でのみ使用できます。
このオプションを付けると、ログには以下で説明するような指定間隔単位の要約が含まれます。
       </p></dd><dt><span class="term"><code class="option">--log-prefix=<em class="replaceable"><code>prefix</code></em></code></span></dt><dd><p><code class="option">--log</code>により作成されるログファイルのファイル名の先頭につける文字列を設定します。
デフォルトは<code class="literal">pgbench_log</code>です。
       </p></dd><dt><span class="term"><code class="option">--progress-timestamp</code></span></dt><dd><p>進捗を表示（<code class="option">-P</code>オプション）しているとき、実行開始以後の経過秒数の代わりにタイムスタンプ（Unixエポック時刻）を使用します。
単位は秒で、ドットの後にミリ秒の精度が付きます。
これは様々なツールで生成されたログを比較するのに役立つでしょう。
       </p></dd><dt><span class="term"><code class="option">--sampling-rate=<em class="replaceable"><code>rate</code></em></code></span></dt><dd><p>データをログに書き出す際に使用される、生成されるログの量を減少するためのサンプリング割合です。
このオプションが指定された場合、指定された割合のトランザクションがログに残ります。
1.0はすべてのトランザクションが、0.05はトランザクションの5%のみがログに残ることを意味します。
       </p><p>ログファイルを処理する際にはこのサンプリング割合を考慮することを忘れないでください。
例えば、tps値を計算する際には、比例した数を掛け合わせなければなりません（例：サンプリング割合が0.01の場合実際のtpsの1/100を得るだけです。）
       </p></dd></dl></div><p>
   </p></div><div class="refsect2" id="PGBENCH-COMMON-OPTIONS"><h3>共通オプション</h3><p><span class="application">pgbench</span>は以下の共通コマンドライン引数を受け付けます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-h</code> <em class="replaceable"><code>hostname</code></em><br /></span><span class="term"><code class="option">--host=</code><em class="replaceable"><code>hostname</code></em></span></dt><dd><p>      データベースサーバのホスト名
       </p></dd><dt><span class="term"><code class="option">-p</code> <em class="replaceable"><code>port</code></em><br /></span><span class="term"><code class="option">--port=</code><em class="replaceable"><code>port</code></em></span></dt><dd><p>データベースサーバのポート番号
       </p></dd><dt><span class="term"><code class="option">-U</code> <em class="replaceable"><code>login</code></em><br /></span><span class="term"><code class="option">--username=</code><em class="replaceable"><code>login</code></em></span></dt><dd><p>      接続ユーザ名
       </p></dd><dt><span class="term"><code class="option">-V</code><br /></span><span class="term"><code class="option">--version</code></span></dt><dd><p><span class="application">pgbench</span>のバージョンを表示し、終了します。
       </p></dd><dt><span class="term"><code class="option">-?</code><br /></span><span class="term"><code class="option">--help</code></span></dt><dd><p><span class="application">pgbench</span>のコマンドライン引数の説明を表示し、終了します。
       </p></dd></dl></div><p>
   </p></div></div><div class="refsect1" id="id-1.9.4.10.7"><h2>注釈</h2><div class="refsect2" id="id-1.9.4.10.7.2"><h3><span class="application">pgbench</span>で実際に実行される<span class="quote">“<span class="quote">トランザクション</span>”</span>は何か?</h3><p><span class="application">pgbench</span>は指定したリストからランダムに選択したテストスクリプトを実行します。
これには<code class="option">-b</code>の組み込みスクリプトと<code class="option">-f</code>のユーザ定義カスタムスクリプトが含まれます。
各スクリプトには<code class="literal">@</code>の後に指定される相対的な重みを与えることができ、それが選ばれる確率を変更することができます。
デフォルトの重みは<code class="literal">1</code>です。
重みが<code class="literal">0</code>のスクリプトは無視されます。
 </p><p>デフォルトの組み込みトランザクションスクリプト（<code class="option">-b tpcb-like</code>とすることでも実行されます）は、<code class="literal">aid</code>、<code class="literal">tid</code>、<code class="literal">bid</code>、<code class="literal">balance</code>からランダムに選択され、トランザクション毎に7つのコマンドを発行します。
このシナリオはTPC-Bベンチマークに示唆を受けたものですが、実際にはTPC-Bではないので、この名前になっています。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="literal">BEGIN;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</code></p></li><li class="listitem"><p><code class="literal">SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</code></p></li><li class="listitem"><p><code class="literal">UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</code></p></li><li class="listitem"><p><code class="literal">INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</code></p></li><li class="listitem"><p><code class="literal">END;</code></p></li></ol></div><p><code class="literal">simple-update</code>の組み込みを選択した（あるいは<code class="option">-N</code>を指定した）場合、第4ステップと第5ステップはトランザクションに含まれません。
これにより、これらのテーブルに対する更新の競合を避けられますが、テストケースはさらにTPC-Bらしくなくなります。
  </p><p><code class="literal">select-only</code>の組み込みを選択した（あるいは<code class="option">-S</code>を指定した）場合、<code class="command">SELECT</code>のみが発行されます。
  </p></div><div class="refsect2" id="id-1.9.4.10.7.3"><h3>独自スクリプト</h3><p><span class="application">pgbench</span>は、ファイルから読み込んだトランザクションスクリプト（<code class="option">-f</code>オプション）でデフォルトのトランザクションスクリプト（上述）を置き換えて独自のベンチマークシナリオを実行する機能をサポートします。
この場合、<span class="quote">“<span class="quote">トランザクション</span>”</span>はスクリプトファイルの1回の実行として数えられます。
  </p><p>スクリプトファイルにはセミコロンで終了するSQLコマンドが1つ以上含まれます。
空行および<code class="literal">--</code>から始まる行は無視されます。
スクリプトファイルの行には、<span class="application">pgbench</span>自身が解釈する<span class="quote">“<span class="quote">メタコマンド</span>”</span>（後述）も記述することができます。
  </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>の9.6より前では、スクリプトファイル内のSQLコマンドは改行で終了しており、そのため行をまたがって継続することができませんでした。
これからは連続するSQLコマンドを区切るためにセミコロンが<span class="emphasis"><em>必要</em></span>です（ただし、SQLコマンドの後にメタコマンドが続く場合は、セミコロンは必要ありません）。
<span class="application">pgbench</span>の古いバージョンと新しいバージョンの両方で動作するスクリプトを作る必要があるなら、各SQLコマンドを1行で書き、終わりにセミコロンを付けるようにしてください。
   </p></div><p>スクリプトファイル向けの簡単な変数置換機能があります。
上で説明したように変数を<code class="option">-D</code>コマンドラインオプションで設定することができます。
また、後で説明するようにメタコマンドで設定することもできます。
<code class="option">-D</code>コマンドラインオプションで設定された変数の他に、<a class="xref" href="pgbench.html#PGBENCH-AUTOMATIC-VARIABLES" title="Table 241. 自動変数">Table 241</a>に記載されているように、自動的に設定される変数がいくつかあります。
<code class="option">-D</code> を使ってこれらの変数に設定された値は、自動設定の値より優先されます。
一度設定すると、変数の値は、<code class="literal">:</code><em class="replaceable"><code>variablename</code></em>と書かれてSQLコマンドに挿入されます。
1つ以上のクライアントセッションが実行される場合、セッション毎に独自の変数群を持ちます。
  </p><div class="table" id="PGBENCH-AUTOMATIC-VARIABLES"><p class="title"><strong>Table 241. 自動変数</strong></p><div class="table-contents"><table class="table" summary="自動変数" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>変数</th><th>説明</th></tr></thead><tbody><tr><td> <code class="literal">scale</code> </td><td>現在のスケールファクタ</td></tr><tr><td> <code class="literal">client_id</code> </td><td>クライアントセッションを識別する一意の数値（ゼロから始まる）</td></tr></tbody></table></div></div><br class="table-break" /><p>スクリプトファイルのメタコマンドはバックスラッシュ（<code class="literal">\</code>）から始まり、通常は行末まで続きますが、バックスラッシュと改行を書くことで、追加の行に続けることができます。
メタコマンドへの引数は空白文字で区切られます。
以下のメタコマンドがサポートされています。
  </p><div class="variablelist"><dl class="variablelist"><dt id="PGBENCH-METACOMMAND-SET"><span class="term">     <code class="literal">\set <em class="replaceable"><code>varname</code></em> <em class="replaceable"><code>expression</code></em></code>
    </span></dt><dd><p><em class="replaceable"><code>varname</code></em>変数を<em class="replaceable"><code>expression</code></em>から計算された値に設定します。
expression(式)には、<code class="literal">5432</code>のような整数の定数、<code class="literal">3.14159</code>のような倍精度実数の定数、変数を参照する <code class="literal">:</code><em class="replaceable"><code>variablename</code></em>、通常の優先順位と結合規則に従う単項演算子（<code class="literal">+</code>、<code class="literal">-</code>）と2項演算子（<code class="literal">+</code>、<code class="literal">-</code>、<code class="literal">*</code>、<code class="literal">/</code>、<code class="literal">%</code>）、<a class="link" href="pgbench.html#PGBENCH-BUILTIN-FUNCTIONS" title="組み込み関数">関数呼び出し</a>、括弧を含むことができます。
     </p><p>例
</p><pre class="programlisting">\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % \
           (100000 * :scale) + 1</pre></dd><dt><span class="term">     <code class="literal">\sleep <em class="replaceable"><code>number</code></em> [ us | ms | s ]</code>
    </span></dt><dd><p>スクリプトの実行をマイクロ秒（<code class="literal">us</code>）、ミリ秒（<code class="literal">ms</code>）、秒（<code class="literal">s</code>）単位で指定した間待機させます。
単位を省略した場合、デフォルトは秒です。
<em class="replaceable"><code>number</code></em>は整数定数か整数値を持つ変数への<code class="literal">:</code><em class="replaceable"><code>variablename</code></em>参照のいずれかです。
     </p><p>例
</p><pre class="programlisting">\sleep 10 ms</pre></dd><dt><span class="term">     <code class="literal">\setshell <em class="replaceable"><code>varname</code></em> <em class="replaceable"><code>command</code></em> [ <em class="replaceable"><code>argument</code></em> ... ]</code>
    </span></dt><dd><p><em class="replaceable"><code>command</code></em>シェルコマンドを指定の<em class="replaceable"><code>argument</code></em>で実行した結果を<em class="replaceable"><code>varname</code></em>変数に設定します。
このコマンドは標準出力を通して整数値を返さなければなりません。
     </p><p><em class="replaceable"><code>command</code></em>および各<em class="replaceable"><code>argument</code></em>は、テキスト定数または変数を参照する<code class="literal">:</code><em class="replaceable"><code>variablename</code></em>とすることができます。
コロンから始まる<em class="replaceable"><code>argument</code></em>を使用したい場合、<em class="replaceable"><code>argument</code></em>の先頭にさらにコロンを付けなければなりません。
     </p><p>例:
</p><pre class="programlisting">\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon</pre></dd><dt><span class="term">     <code class="literal">\shell <em class="replaceable"><code>command</code></em> [ <em class="replaceable"><code>argument</code></em> ... ]</code>
    </span></dt><dd><p><code class="literal">\setshell</code>と同じですが、コマンドの結果は廃棄されます。
     </p><p>例:
</p><pre class="programlisting">\shell command literal_argument :variable ::literal_starting_with_colon</pre></dd></dl></div></div><div class="refsect2" id="PGBENCH-BUILTIN-FUNCTIONS"><h3>組み込み関数</h3><p><a class="xref" href="pgbench.html#PGBENCH-FUNCTIONS" title="Table 242. pgbenchの関数">Table 242</a>に示す関数は<span class="application">pgbench</span>に組み込まれており、<a class="link" href="pgbench.html#PGBENCH-METACOMMAND-SET"><code class="literal">\set</code></a>に現れる式の中で使うことができます。
  </p><div class="table" id="PGBENCH-FUNCTIONS"><p class="title"><strong>Table 242. pgbenchの関数</strong></p><div class="table-contents"><table class="table" summary="pgbenchの関数" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>戻り型</th><th>説明</th><th>例</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">abs(<em class="replaceable"><code>a</code></em>)</code></code></td><td><em class="replaceable"><code>a</code></em>と同じ</td><td>絶対値</td><td><code class="literal">abs(-17)</code></td><td><code class="literal">17</code></td></tr><tr><td><code class="literal"><code class="function">debug(<em class="replaceable"><code>a</code></em>)</code></code></td><td><em class="replaceable"><code>a</code></em>と同じ</td><td><em class="replaceable"><code>a</code></em>を<span class="systemitem">stderr</span>に出力し、<em class="replaceable"><code>a</code></em>を返す</td><td><code class="literal">debug(5432.1)</code></td><td><code class="literal">5432.1</code></td></tr><tr><td><code class="literal"><code class="function">double(<em class="replaceable"><code>i</code></em>)</code></code></td><td>double</td><td>倍精度実数にキャストする</td><td><code class="literal">double(5432)</code></td><td><code class="literal">5432.0</code></td></tr><tr><td><code class="literal"><code class="function">greatest(<em class="replaceable"><code>a</code></em> [, <em class="replaceable"><code>...</code></em> ] )</code></code></td><td><em class="replaceable"><code>a</code></em>のどれかがdoubleならdouble、そうでなければinteger</td><td>引数の中で最大の値</td><td><code class="literal">greatest(5, 4, 3, 2)</code></td><td><code class="literal">5</code></td></tr><tr><td><code class="literal"><code class="function">int(<em class="replaceable"><code>x</code></em>)</code></code></td><td>integer</td><td>整数にキャストする</td><td><code class="literal">int(5.4 + 3.8)</code></td><td><code class="literal">9</code></td></tr><tr><td><code class="literal"><code class="function">least(<em class="replaceable"><code>a</code></em> [, <em class="replaceable"><code>...</code></em> ] )</code></code></td><td><em class="replaceable"><code>a</code></em>のどれかがdoubleならdouble、そうでなければinteger</td><td>引数の中で最小の値</td><td><code class="literal">least(5, 4, 3, 2.1)</code></td><td><code class="literal">2.1</code></td></tr><tr><td><code class="literal"><code class="function">pi()</code></code></td><td>double</td><td>定数PI（円周率）の値</td><td><code class="literal">pi()</code></td><td><code class="literal">3.14159265358979323846</code></td></tr><tr><td><code class="literal"><code class="function">random(<em class="replaceable"><code>lb</code></em>, <em class="replaceable"><code>ub</code></em>)</code></code></td><td>integer</td><td><code class="literal">[lb, ub]</code>内の一様分布の整数の乱数</td><td><code class="literal">random(1, 10)</code></td><td><code class="literal">1</code>と<code class="literal">10</code>の間の整数</td></tr><tr><td><code class="literal"><code class="function">random_exponential(<em class="replaceable"><code>lb</code></em>, <em class="replaceable"><code>ub</code></em>, <em class="replaceable"><code>parameter</code></em>)</code></code></td><td>integer</td><td><code class="literal">[lb, ub]</code>内の指数分布の整数の乱数、後述</td><td><code class="literal">random_exponential(1, 10, 3.0)</code></td><td><code class="literal">1</code>と<code class="literal">10</code>の間の整数</td></tr><tr><td><code class="literal"><code class="function">random_gaussian(<em class="replaceable"><code>lb</code></em>, <em class="replaceable"><code>ub</code></em>, <em class="replaceable"><code>parameter</code></em>)</code></code></td><td>integer</td><td><code class="literal">[lb, ub]</code>内のガウス分布の整数の乱数、後述</td><td><code class="literal">random_gaussian(1, 10, 2.5)</code></td><td><code class="literal">1</code>と<code class="literal">10</code>の間の整数</td></tr><tr><td><code class="literal"><code class="function">sqrt(<em class="replaceable"><code>x</code></em>)</code></code></td><td>double</td><td>平方根</td><td><code class="literal">sqrt(2.0)</code></td><td><code class="literal">1.414213562</code></td></tr></tbody></table></div></div><br class="table-break" /><p><code class="literal">random</code>関数は一様分布を使って値を生成します。
つまり、すべての値は指定された範囲内で同じ確率で発生します。
<code class="literal">random_exponential</code>関数と<code class="literal">random_gaussian</code>関数は、追加の倍精度実数のパラメータを必要とし、それによって分布の正確な形が決まります。
   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>指数分布では、<em class="replaceable"><code>parameter</code></em>が分布を制御します。
急速に減少する指数分布を<em class="replaceable"><code>parameter</code></em>で切り捨て、境界範囲内の整数に射影します。
正確には、以下の式に従います。
</p><div class="literallayout"><p>f(x) = exp(-parameter * (x - min) / (max - min + 1)) / (1 - exp(-parameter))</p></div><p>
これにより、<em class="replaceable"><code>min</code></em>と<em class="replaceable"><code>max</code></em>の間（両端を含む）の間の値<em class="replaceable"><code>i</code></em>が<code class="literal">f(i) - f(i + 1)</code>の確率で生成されます。
     </p><p>直感的には、<em class="replaceable"><code>parameter</code></em>が大きければ、<em class="replaceable"><code>min</code></em>に近い値が発生する確率が高くなり、<em class="replaceable"><code>max</code></em>に近い値が発生する確率が低くなります。
<em class="replaceable"><code>parameter</code></em>が0に近ければ、発生の分布はより平ら（より一様）になります。
大雑把に分布を近似すると、<em class="replaceable"><code>min</code></em>に近い最頻の1%の範囲の値は、<em class="replaceable"><code>parameter</code></em>%の割合で発生します。
<em class="replaceable"><code>parameter</code></em>の値は厳密に正でなければなりません。
     </p></li><li class="listitem"><p>ガウス分布では、標準的な正規分布（古典的なベルの形をしたガウス曲線）で、左に<code class="literal">-parameter</code>、右に<code class="literal">+parameter</code>のところで切り捨てられたものに間隔が射影されます。
間隔の中間の値が発生する確率が最も高くなります。
正確に言うと、<code class="literal">PHI(x)</code>は標準正規分布の累積分布関数、平均値<code class="literal">mu</code>を<code class="literal">(max + min) / 2.0</code>と定義し、さらに
</p><div class="literallayout"><p>f(x) = PHI(2.0 * parameter * (x - mu) / (max - min + 1)) /<br />
       (2.0 * PHI(parameter) - 1)</p></div><p>
とすると、<em class="replaceable"><code>min</code></em>と<em class="replaceable"><code>max</code></em>の間（両端を含む）の値<em class="replaceable"><code>i</code></em>が発生する確率は<code class="literal">f(i + 0.5) - f(i - 0.5)</code>になります。
直感的には、<em class="replaceable"><code>parameter</code></em>が大きくなれば、間隔の中間に近い値になる確率が高く、また、<em class="replaceable"><code>min</code></em>と<em class="replaceable"><code>max</code></em>の境界に近い値になる確率は低くなります。
約67%の値は、中間の<code class="literal">1.0 / parameter</code>の範囲、つまり平均値から<code class="literal">0.5 / parameter</code>の範囲から、また95%は中間の<code class="literal">2.0 / parameter</code>の範囲、つまり平均値から<code class="literal">1.0 / parameter</code>の範囲に発生します。
例えば<em class="replaceable"><code>parameter</code></em>が4.0なら、67%の値は間隔の中間の4分の1(1.0/4.0)から（つまり<code class="literal">3.0 / 8.0</code>から<code class="literal">5.0 / 8.0</code>まで）、95%は間隔の中間の半分（<code class="literal">2.0 / 4.0</code>）から（2番目と3番目の四分位）から発生します。
ボックス＝ミュラーの変換のパフォーマンスのため、最小の<em class="replaceable"><code>parameter</code></em>は2.0です。
     </p></li></ul></div><p>例えば、組み込みのTPC-Bのようなトランザクションの完全な定義を示します。

</p><pre class="programlisting">\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;</pre><p>

 このスクリプトにより、トランザクションを繰り返す度に異なる、ランダムに選ばれた行を参照することができます。
 （この例はまた、各クライアントセッションがなぜ独自の変数を持つことが重要なのかも表しています。
 これがないと、異なる行を独立して参照することができないのです。）
  </p></div><div class="refsect2" id="id-1.9.4.10.7.5"><h3>トランザクション毎のログ処理</h3><p>（<code class="option">--aggregate-interval</code>オプションなしで）<code class="option">-l</code>オプションを使用すると、<span class="application">pgbench</span>は各トランザクションに関する情報をログファイルに書き出します。
ログファイルの名前は<code class="filename"><em class="replaceable"><code>prefix</code></em>.<em class="replaceable"><code>nnn</code></em></code>で、<em class="replaceable"><code>prefix</code></em>のデフォルトは<code class="literal">pgbench_log</code>、<em class="replaceable"><code>nnn</code></em>は<span class="application">pgbench</span>プロセスのPIDです。
ファイル名の先頭の文字列は<code class="option">--log-prefix</code>オプションを使って変更することができます。
<code class="option">-j</code>オプションが2以上で複数のワーカスレッドがある場合、それぞれが独自のログファイルを持つことになります。
最初のワーカは標準的な単一ワーカの場合と同じ名前を持つログファイルを使用します。
他のワーカ用の追加のログファイルは<code class="filename"><em class="replaceable"><code>prefix</code></em>.<em class="replaceable"><code>nnn</code></em>.<em class="replaceable"><code>mmm</code></em></code>と命名され、ここで<em class="replaceable"><code>mmm</code></em>は1から始まる各ワーカの連番です。
  </p><p>ログの書式は以下の通りです。

</p><pre class="synopsis"><em class="replaceable"><code>client_id</code></em> <em class="replaceable"><code>transaction_no</code></em> <em class="replaceable"><code>time</code></em> <em class="replaceable"><code>script_no</code></em> <em class="replaceable"><code>time_epoch</code></em> <em class="replaceable"><code>time_us</code></em> [<span class="optional"> <em class="replaceable"><code>schedule_lag</code></em> </span>]</pre><p>

<em class="replaceable"><code>client_id</code></em>はどのクライアントセッションがそのトランザクションを実行したかを示します。
<em class="replaceable"><code>transaction_no</code></em>はそのセッションで何個のトランザクションが実行されたかを示します。
<em class="replaceable"><code>time</code></em>はトランザクションの合計消費時間をミリ秒単位で示します。
<em class="replaceable"><code>script_no</code></em>はどのスクリプトファイルが使用されたかを識別するものです（<code class="option">-f</code>または<code class="option">-b</code>で複数のスクリプトが指定された場合に有用です）。
<em class="replaceable"><code>time_epoch</code></em>/<em class="replaceable"><code>time_us</code></em>はトランザクション完了時のUnixエポック時間とマイクロ秒単位のオフセットです（小数秒付きのISO 8601タイムスタンプの作成に適します）。
<em class="replaceable"><code>schedule_lag</code></em>フィールドは、マイクロ秒単位のトランザクションの予定開始時刻と実開始時刻の差です。
これは<code class="option">--rate</code>オプションを使用した時だけ表示されます。
<code class="option">--rate</code>と<code class="option">--latency-limit</code>の両方のオプションを使用した時は、スキップされたトランザクションの<em class="replaceable"><code>time</code></em>が<code class="literal">skipped</code>として表示されます。
  </p><p>単一クライアントでの実行で生成されたログファイルの一部を示します。
</p><pre class="screen">0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663</pre><p>

<code class="literal">--rate=100</code>と<code class="literal">--latency-limit=5</code>を指定した例を示します。(<em class="replaceable"><code>schedule_lag</code></em>列が追加されていることに注意)
</p><pre class="screen">0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740</pre><p>
この例では、トランザクション82は遅延(6.173ミリ秒)が5ミリ秒を越えており、遅れています。
次の2つのトランザクションは、開始する前にすでに遅れてしまっているため、スキップされています。
  </p><p>大量のトランザクションを処理することができるハードウェアで長時間試験を実行する場合、ログファイルは非常に大きくなる可能性があります。
<code class="option">--sampling-rate</code>オプションを使用して、トランザクションのランダムなサンプルだけをログに記録することができます。
  </p></div><div class="refsect2" id="id-1.9.4.10.7.6"><h3>ログ処理の集約</h3><p><code class="option">--aggregate-interval</code>オプションを付ける場合、以下のようにログの書式が異なります。

</p><pre class="synopsis"><em class="replaceable"><code>interval_start</code></em> <em class="replaceable"><code>num_transactions</code></em> <em class="replaceable"><code>sum_latency</code></em> <em class="replaceable"><code>sum_latency_2</code></em> <em class="replaceable"><code>min_latency</code></em> <em class="replaceable"><code>max_latency</code></em> [<span class="optional"> <em class="replaceable"><code>sum_lag</code></em> <em class="replaceable"><code>sum_lag_2</code></em> <em class="replaceable"><code>min_lag</code></em> <em class="replaceable"><code>max_lag</code></em> [<span class="optional"> <em class="replaceable"><code>skipped</code></em> </span>] </span>]</pre><p>

<em class="replaceable"><code>interval_start</code></em>はインターバルの開始時刻（Unixエポック時間）です。
<em class="replaceable"><code>num_of_transactions</code></em>はインターバル内のトランザクション数です。
<em class="replaceable"><code>latency_sum</code></em>はインターバル内のトランザクションレイテンシの総和です。
<em class="replaceable"><code>sum_latency_2</code></em>はインターバル内のトランザクションレイテンシの2乗の総和です。
<em class="replaceable"><code>min_latency</code></em>はインターバル内の最小レイテンシです。
<em class="replaceable"><code>max_latency</code></em>はインターバル内の最大レイテンシです。
これに続くフィールド<em class="replaceable"><code>sum_lag</code></em>、<em class="replaceable"><code>sum_lag_2</code></em>、<em class="replaceable"><code>min_lag</code></em>、<em class="replaceable"><code>max_lag</code></em>は<code class="option">--rate</code>オプションが指定された場合にのみ表示されます。
これらは、各トランザクションが直前のトランザクションの終了を待機しなければならなかった時間、つまりトランザクションの予定開始時刻と実際の開始時刻の差に関する統計を提供します。
一番最後のフィールド<em class="replaceable"><code>skipped</code></em>は<code class="option">--latency-limit</code>オプションも使用されたときにのみ表示されます。
これは開始時刻が遅くなったためにスキップされたトランザクションの数を数えます。
各トランザクションはインターバル内でコミットされた時に数えられます。
  </p><p>いくつか出力例を示します。
</p><pre class="screen">1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411</pre><p>通常の（集約されていない）ログファイルは、各トランザクションについてどのスクリプトファイルが使用されたかを示しますが、集約されたログにはそれがないことに注意してください。
このためスクリプト単位のデータが必要な場合は、自身でデータを集約する必要があります。
  </p></div><div class="refsect2" id="id-1.9.4.10.7.7"><h3>ステートメント毎のレイテンシ</h3><p><code class="option">-r</code>オプションを付けると、<span class="application">pgbench</span>は各クライアントにより実行されたトランザクションのステートメント毎の経過時間を収集します。
ベンチマークが終了した後、各値の平均値(各ステートメントのレイテンシと呼びます)が報告されます。
  </p><p>標準スクリプトでは、次のような出力になります。
</p><pre class="screen">starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;</pre><p>
  </p><p>複数のスクリプトファイルが定義された場合、平均値はそれぞれのスクリプトファイル毎に分けて報告されます。
  </p><p>ステートメント毎のレイテンシを計算するために必要となる、追加のタイミング情報を収集することは、オーバーヘッドが加わることに注意してください。
これは平均実行速度を遅くし、計測TPSを小さくするでしょう。
低下量はプラットフォームとハードウェアに依存して著しく変わります。
レイテンシの報告を有効にする、有効にしないで平均TPS値を比較することは、タイミング・オーバーヘッドが顕著かどうかを測定するには良い方法です。
  </p></div><div class="refsect2" id="id-1.9.4.10.7.8"><h3>優れた実践</h3><p>まったく無意味な数値を生み出すように<span class="application">pgbench</span>を使用することは非常に簡単です。
以下に有意な結果を生み出す手助けとなるガイドラインをいくつか示します。
  </p><p>まず第一に、数秒で終わる試験を<span class="emphasis"><em>決して</em></span>信用しないでください。
<code class="option">-t</code>または<code class="option">-T</code>オプションを使って、雑音を取り除くために、少なくとも数分試験にかかるようにしてください。
再現可能な数値を得るために数時間必要になる場合もあります。
数回試験を繰り返し、数値が再現できるかどうか確認することを勧めます。
  </p><p>デフォルトのTPC-Bのような試験シナリオでは、初期倍率（<code class="option">-s</code>）を試験予定のクライアント数（<code class="option">-c</code>）の最大値と同程度にしなければなりません。
<code class="structname">pgbench_branches</code>テーブルには<code class="option">-s</code>行しかありません。
また、全トランザクションはその内の1つを更新しようとします。
ですので、<code class="option">-c</code>値を<code class="option">-s</code>より大きくすると、他のトランザクションを待機するためにブロックされるトランザクションが多くなることは間違いありません。
  </p><p>デフォルトの試験シナリオはまた、テーブルを初期化してからの経過時間に非常に敏感です。
テーブル内の不要行や不要空間の累積により結果が変わります。
結果を理解するためには、更新された行数とバキューム時期を把握する必要があります。
自動バキュームが有効な場合、性能を測定する上で結果は予測できないほど変わる可能性があります。
  </p><p><span class="application">pgbench</span>の制限は、多くのクライアントセッションを試験しようとする際に<span class="application">pgbench</span>自身がボトルネックになる可能性があることです。
これは、データベースサーバとは別のマシンで<span class="application">pgbench</span>を実行することで緩和させることが可能です。
しかし、多少のネットワーク遅延が重要です。
同一データベースサーバに対し複数のクライアントマシンから複数の<span class="application">pgbench</span>インスタンスを同時に実行することが有用かもしれません。
  </p></div><div class="refsect2" id="id-1.9.4.10.7.9"><h3>セキュリティ</h3><p><a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">安全なスキーマの利用パターン</a>を適用していないデータベースに信頼できないユーザがアクセス可能な場合、そのデータベースで<span class="application">pgbench</span>を実行しないでください。
<span class="application">pgbench</span>は修飾していない名前を使っており、またサーチパスを操作していません。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="app-pgbasebackup.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="reference-client.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="app-pgconfig.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">pg_basebackup </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> pg_config</td></tr></table></div></body></html>