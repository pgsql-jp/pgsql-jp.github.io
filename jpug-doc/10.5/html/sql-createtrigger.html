<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TRIGGER</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createtransform.html" title="CREATE TRANSFORM" /><link rel="next" href="sql-createtype.html" title="CREATE TYPE" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE TRIGGER</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createtransform.html" title="CREATE TRANSFORM">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createtype.html" title="CREATE TYPE">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATETRIGGER"><div class="titlepage"></div><a id="id-1.9.3.89.1" class="indexterm"></a><a id="id-1.9.3.89.2" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TRIGGER</span></h2><p>CREATE TRIGGER — 新しいトリガを定義する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE [ CONSTRAINT ] TRIGGER <em class="replaceable"><code>name</code></em> { BEFORE | AFTER | INSTEAD OF } { <em class="replaceable"><code>event</code></em> [ OR ... ] }
    ON <em class="replaceable"><code>table_name</code></em>
    [ FROM <em class="replaceable"><code>referenced_table_name</code></em> ]
    [ NOT DEFERRABLE | [ DEFERRABLE ] [ INITIALLY IMMEDIATE | INITIALLY DEFERRED ] ]
    [ REFERENCING { { OLD | NEW } TABLE [ AS ] <em class="replaceable"><code>transition_relation_name</code></em> } [ ... ] ]
    [ FOR [ EACH ] { ROW | STATEMENT } ]
    [ WHEN ( <em class="replaceable"><code>condition</code></em> ) ]
    EXECUTE PROCEDURE <em class="replaceable"><code>function_name</code></em> ( <em class="replaceable"><code>arguments</code></em> )

<span class="phrase">ここで<em class="replaceable"><code>event</code></em>は以下のいずれかを取ることができます。</span>

    INSERT
    UPDATE [ OF <em class="replaceable"><code>column_name</code></em> [, ... ] ]
    DELETE
    TRUNCATE</pre></div><div class="refsect1" id="id-1.9.3.89.6"><h2>説明</h2><p><code class="command">CREATE TRIGGER</code>は新しいトリガを作成します。
作成したトリガは指定したテーブル、ビューまたは外部テーブルと関連付けられ、そのテーブルに特定の操作が行われた時に指定した関数<em class="replaceable"><code>function_name</code></em>を実行します。
  </p><p>トリガでは、起動のタイミングとして、行への操作が開始される前（制約条件のチェックと<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>が行われる前）、操作が完了した後（制約条件がチェックされ、<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>が完了した後）、操作の代わり（ビューにおける挿入、更新、削除の場合）のいずれかを指定することができます。
イベントの前または代わりにトリガが起動する場合、そのトリガは対象行に対する操作を省略したり、（<code class="command">INSERT</code>と<code class="command">UPDATE</code>の操作時のみ）挿入する行を変更したりすることができます。
イベントの後にトリガが起動する場合、他のトリガの影響を含む全ての変更が、トリガに対して<span class="quote">“<span class="quote">可視</span>”</span>状態となります。
  </p><p><code class="literal">FOR EACH ROW</code>付きのトリガは、その操作によって変更される行ごとに1回ずつ呼び出されます。
例えば、10行に影響を与える<code class="command">DELETE</code>操作は、対象リレーション上のすべての<code class="literal">ON DELETE</code>トリガを、削除される各行について1回ずつ、個別に10回呼び出すことになります。
反対に、<code class="literal">FOR EACH STATEMENT</code>付きのトリガは、その操作によって何行変更されたかにかかわらず、任意の操作ごとに1回のみ実行されます
（変更対象が0行となる操作でも、適用できるすべての<code class="literal">FOR EACH STATEMENT</code>トリガが実行されます）。
  </p><p>トリガイベントの<code class="literal">INSTEAD OF</code>として発行されるように指定されたトリガは<code class="literal">FOR EACH ROW</code>印を付けなければなりません。
またビュー上にのみ定義することができます。
ビューに対する<code class="literal">BEFORE</code>および<code class="literal">AFTER</code>トリガは<code class="literal">FOR EACH STATEMENT</code>印を付けなければなりません。
  </p><p>さらに、<code class="literal">FOR EACH STATEMENT</code>のみですが、トリガを<code class="command">TRUNCATE</code>に対して発行するように定義することができます。
  </p><p>以下の表にどの種類のトリガがテーブル、ビュー、外部テーブルに対して使用できるかをまとめます。
  </p><div class="informaltable" id="SUPPORTED-TRIGGER-TYPES"><table class="informaltable" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>いつ</th><th>イベント</th><th>行レベル</th><th>文レベル</th></tr></thead><tbody><tr><td rowspan="2" align="center"><code class="literal">BEFORE</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">テーブル、および外部テーブル</td><td align="center">テーブル、ビューおよび外部テーブル</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">テーブル</td></tr><tr><td rowspan="2" align="center"><code class="literal">AFTER</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">テーブルおよび外部テーブル</td><td align="center">テーブル、ビューおよび外部テーブル</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">テーブル</td></tr><tr><td rowspan="2" align="center"><code class="literal">INSTEAD OF</code></td><td align="center"><code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code></td><td align="center">ビュー</td><td align="center">—</td></tr><tr><td align="center"><code class="command">TRUNCATE</code></td><td align="center">—</td><td align="center">—</td></tr></tbody></table></div><p>またトリガ定義では、論理値の<code class="literal">WHEN</code>条件を指定することができ、これによってトリガを発行すべきかどうかが判定されます。
行レベルのトリガでは、<code class="literal">WHEN</code>条件は行の列の古い値、新しい値、またはその両方で検証することができます。
文レベルのトリガでも<code class="literal">WHEN</code>条件を持たせることができますが、条件としてテーブル内のどの値も参照することができませんので、この機能はあまり有用ではありません
  </p><p>同一イベントに同じ種類の複数のトリガが定義された場合、名前のアルファベット順で実行されます。
  </p><p><code class="literal">CONSTRAINT</code>オプションが指定された場合、このコマンドは<em class="firstterm">制約トリガ</em>を作成します。
これは、<a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a>を使用してトリガを発行するタイミングを調整することができるという点を除き、通常のトリガと同じです。
制約トリガは（外部テーブルではない）普通のテーブルの<code class="literal">AFTER ROW</code>トリガでなければなりません。
トリガイベントを引き起こした文の最後、またはそれを含むトランザクションの最後のいずれかで発行することができます。
後者の場合、<em class="firstterm">遅延</em>と呼ばれます。
<code class="command">SET CONSTRAINTS</code>を使用することで、強制的に待機中の遅延トリガの発行を即座に行わせることができます。
制約トリガは、実装する制約に違反した時に例外を発生するものと想定されています。
  </p><p><code class="literal">REFERENCING</code>オプションは<em class="firstterm">遷移リレーション</em>の収集を有効にします。
遷移リレーションとは現在のSQL文によって挿入、削除または修正されたすべての行を含む行集合です。
この機能により、トリガはSQL文によって行われたことを、一度に1行ずつだけではなく、全体のビューとして参照することができます。
このオプションは、制約トリガではない<code class="literal">AFTER</code>トリガについてのみ使うことができます。
また、トリガが<code class="literal">UPDATE</code>トリガの場合、<em class="replaceable"><code>column_name</code></em>のリストを指定してはいけません。
<code class="literal">OLD TABLE</code>は一度だけ指定することができ、<code class="literal">UPDATE</code>または<code class="literal">DELETE</code>のときに実行されるトリガにのみ指定できます。
これは文によって更新または削除されるすべての行の<em class="firstterm">更新前イメージ</em>を含む遷移リレーションを作成します。
同様に、<code class="literal">NEW TABLE</code>は一度だけ指定することができ、<code class="literal">UPDATE</code>または<code class="literal">INSERT</code>のときに実行されるトリガにのみ指定できます。
これは、文によって更新または挿入されるすべての行の<em class="firstterm">更新後イメージ</em>を含む遷移リレーションを作成します。
  </p><p><code class="command">SELECT</code>はまったく行を変更しないため、<code class="command">SELECT</code>トリガを作成することはできません。
<code class="command">SELECT</code>トリガが必要に見える問題には、ルールやビューが現実的な解決策を提供できるでしょう。
  </p><p>トリガに関するより詳細については、<a class="xref" href="triggers.html" title="Chapter 38. トリガ">Chapter 38</a>を参照してください。
  </p></div><div class="refsect1" id="id-1.9.3.89.7"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>新しいトリガに付与する名前です。
同じテーブルの他のトリガと異なる名前にする必要があります。
名前をスキーマ修飾することはできません。
トリガはそのテーブルのスキーマを引き継ぎます。
制約トリガの場合、この名前が<code class="command">SET CONSTRAINTS</code>を使用してトリガの動作を変更する時に使用されます。
     </p></dd><dt><span class="term"><code class="literal">BEFORE</code><br /></span><span class="term"><code class="literal">AFTER</code><br /></span><span class="term"><code class="literal">INSTEAD OF</code></span></dt><dd><p>関数の呼び出しをイベントの前に行うか後に行うか、それとも代替として行うかを決定します。
制約トリガでは<code class="literal">AFTER</code>としてしか指定することができません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>event</code></em></span></dt><dd><p><code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE</code>のいずれかが入ります。
このパラメータは、トリガを起動するイベントを指定します。
遷移リレーションが要求される場合を除き、<code class="literal">OR</code>を使用して、複数のイベントを指定することができます。
     </p><p><code class="literal">UPDATE</code>イベントでは、以下の構文を使用して列リストを指定することができます。
</p><pre class="synopsis">UPDATE OF <em class="replaceable"><code>column_name1</code></em> [, <em class="replaceable"><code>column_name2</code></em> ... ]</pre><p>
このトリガは<code class="command">UPDATE</code>コマンドの対象として列挙された列のいずれか少なくとも1つの列が指定された場合に発行されます。
     </p><p><code class="literal">INSTEAD OF UPDATE</code>イベントでは列リストを使用できません。
遷移リレーションを要求する場合も列リストを指定することはできません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>トリガを作成するテーブル、ビューまたは外部テーブルの名前です（スキーマ修飾名も可）。
     </p></dd><dt><span class="term"><em class="replaceable"><code>referenced_table_name</code></em></span></dt><dd><p>制約で参照される他のテーブルの名前（スキーマ修飾可）です。
このオプションは外部キー制約で使用されるものであり、一般利用を推奨しません。
これは制約トリガでのみ指定することができます。
     </p></dd><dt><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code><br /></span><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span></dt><dd><p>トリガのデフォルトのタイミングです。
これらの制約オプションについては<a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>文書を参照してください。
これは制約トリガでのみ指定することができます。
     </p></dd><dt><span class="term"><code class="literal">REFERENCING</code></span></dt><dd><p>このキーワードは、トリガの文の遷移リレーションへのアクセスを提供する1つまたは2つのリレーション名の宣言の直前に起きます。
     </p></dd><dt><span class="term"><code class="literal">OLD TABLE</code><br /></span><span class="term"><code class="literal">NEW TABLE</code></span></dt><dd><p>この句は、それに続くリレーション名が更新前イメージの遷移リレーションなのか、更新後イメージの遷移リレーションなのかを示します。
     </p></dd><dt><span class="term"><em class="replaceable"><code>transition_relation_name</code></em></span></dt><dd><p>この遷移リレーションについて、トリガ内で使用される（修飾されていない）名前です。
     </p></dd><dt><span class="term"><code class="literal">FOR EACH ROW</code><br /></span><span class="term"><code class="literal">FOR EACH STATEMENT</code></span></dt><dd><p>このパラメータは、トリガプロシージャを、トリガイベントによって影響を受ける行ごとに1回起動するか、SQL文ごとに1回のみ起動するかを指定します。
どちらも指定されない場合は、<code class="literal">FOR EACH STATEMENT</code>がデフォルトです。
制約トリガは<code class="literal">FOR EACH ROW</code>のみ指定することができます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>condition</code></em></span></dt><dd><p>トリガ関数を実際に実行するか否かを決定する論理式です。
<code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>condition</code></em>が<code class="literal">true</code>を返す場合のみ関数が呼び出されます。
<code class="literal">FOR EACH ROW</code>トリガでは、<code class="literal">WHEN</code>条件で、それぞれ<code class="literal">OLD.<em class="replaceable"><code>column_name</code></em></code>、<code class="literal">NEW.<em class="replaceable"><code>column_name</code></em></code>と記述することで、古い行の値、新しい行の値、またはその両方の列を参照することができます。
当然ながら<code class="literal">INSERT</code>トリガでは<code class="literal">OLD</code>を参照することはできませんし、<code class="literal">DELETE</code>トリガでは<code class="literal">NEW</code>を参照することはできません。
     </p><p><code class="literal">INSTEAD OF</code>トリガは<code class="literal">WHEN</code>条件をサポートしません。
     </p><p>現時点では<code class="literal">WHEN</code>条件に副問い合わせを含めることはできません。
     </p><p>制約トリガでは、<code class="literal">WHEN</code>条件の評価は遅延されず、行の更新操作が行われた直後に発生することに注意してください。
この条件が真と評価されなかった場合、トリガは遅延実行用のキューに入りません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>function_name</code></em></span></dt><dd><p>ユーザが提供する関数です。この関数は、引数を取らず<code class="literal">trigger</code>型を返すよう定義されます。トリガが起動した時に実行されます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>arguments</code></em></span></dt><dd><p>トリガ実行時に関数に渡される引数をカンマで区切ったリストで、省略可能です。
引数として指定するのは、リテラル文字列定数です。
単純な名前および数値定数を記述できますが、全て文字列に変換されます。
関数内でこれらの引数にアクセスする方法について調べるためには、トリガ関数を実装した言語の説明を参照してください。
通常の関数引数とは異なる場合があります。
     </p></dd></dl></div></div><div class="refsect1" id="SQL-CREATETRIGGER-NOTES"><h2>注釈</h2><p>テーブルにトリガを作成するには、ユーザがそのテーブルに対し<code class="literal">TRIGGER</code>権限を持っている必要があります。
またユーザはトリガ関数に対し<code class="literal">EXECUTE</code>権限を持たなければなりません。
  </p><p>トリガを削除するためには<a class="xref" href="sql-droptrigger.html" title="DROP TRIGGER"><span class="refentrytitle">DROP TRIGGER</span></a>を使用してください。
  </p><p>列指定のトリガ（<code class="literal">UPDATE OF <em class="replaceable"><code>column_name</code></em></code>構文で定義されたトリガ）は、列挙された列のいずれかが<code class="command">UPDATE</code>コマンドの<code class="literal">SET</code>リスト内に対象として指定された場合に発行されます。
<code class="literal">BEFORE UPDATE</code>トリガにより行の内容になされた変更は考慮されないため、トリガが発行されない場合であっても、列の値が変更されることはあります。
反対に、<code class="literal">UPDATE ... SET x = x ...</code>のようなコマンドは、列の値が変更されませんが、<code class="literal">x</code>列に対するトリガが発行されます。
  </p><p><code class="literal">BEFORE</code>トリガにおいて<code class="literal">WHEN</code>条件は関数が実行される、またはされそうな直前に評価されます。
このため<code class="literal">WHEN</code>の使用はトリガ関数の先頭で同一の条件を試験することと実質的に違いはありません。
この条件で確認できる<code class="literal">NEW</code>行が現在の値であり、それまでのトリガで変更されている可能性があることに、特に注意して下さい。
また<code class="literal">BEFORE</code>トリガの<code class="literal">WHEN</code>条件では、<code class="literal">NEW</code>行のシステム列(<code class="literal">oid</code>など)はまだ設定されていないので、検査することができません。
  </p><p><code class="literal">AFTER</code>トリガにおいて、<code class="literal">WHEN</code>条件は行の更新を行った直後に評価され、文の最後でトリガを発行するためにイベントを保持すべきかどうかを決定します。
このため<code class="literal">AFTER</code>トリガの<code class="literal">WHEN</code>条件は真を返さない場合、イベントを保持する必要もありませんし、文の最後の行を再度取り出す必要もありません。
これにより、トリガをわずかな行のみに対して発行する必要がある場合、多くの行を変更する文を非常に高速にすることができます。
  </p><p>場合によっては1つのSQLコマンドが2種類以上のトリガを発行することがあります。
例えば、<code class="literal">ON CONFLICT DO UPDATE</code>句のある<code class="command">INSERT</code>では、挿入と更新の両方の操作が発生するかもしれないので、必要に応じて両方の種類のトリガを発行します。
トリガに提供される遷移リレーションはトリガのイベント種類毎に個別のものです。
従って、<code class="command">INSERT</code>トリガには挿入された行だけが見え、一方で<code class="command">UPDATE</code>トリガには更新された行だけが見えます。
  </p><p><code class="literal">ON UPDATE CASCADE</code>や<code class="literal">ON DELETE SET NULL</code>など外部キーを強制する動作によって起こる行の更新や削除は、それを起こしたSQLコマンドの一部であるとみなされます（このような動作は決して遅延実行されないことに注意してください）。
影響を受けたテーブルの関連するトリガが発行されるため、これはSQLコマンドの種類と直接には一致しないトリガが発行される別のケースとなります。
単純な場合、遷移リレーションを要求するトリガは、元となる1つのSQLコマンドによって起こされたテーブルへのすべての変更を、一つの遷移リレーションとして見ることになります。
しかし、遷移リレーションを要求する<code class="literal">AFTER ROW</code>トリガの存在により、一つのSQLコマンドによって発生する外部キーを強制する動作が複数のステップに分割され、各ステップがそれぞれの遷移リレーションを持つという場合もあります。
そのような場合、すべての文レベルのトリガは1つの遷移リレーションの集合の作成に対して1度ずつ呼び出され、それによりトリガが遷移リレーション内の変更された行をちょうど一度だけ見ることを確実にしています。
  </p><p>ビューに付けられている文レベルのトリガは、ビューに対する操作が行レベルの<code class="literal">INSTEAD OF</code>トリガによって取り扱われた時にのみ発行されます。
ビューに対する操作が<code class="literal">INSTEAD OF</code>ルールによって取り扱われる場合は、ビューを指定した元の文の代わりに、そのルールが出力した文が実行されます。
それにより、発行されるトリガは、置き換えられた文によって指定されたテーブルに付けられたトリガとなります。
同様に、ビューが自動更新可能ならば、操作は、ビューの基底テーブル上の操作に自動的に書き換えられる文によって取り扱われます。
その結果、発行されるのは基底テーブルの文レベルのトリガとなります。
  </p><p>パーティションテーブルや継承した子テーブルがあるテーブルを変更したとき、明示的に指定されたテーブルに付けられている文レベルのトリガが発行されますが、パーティションや子テーブルに付けられている文レベルのトリガは発行されません。
対照的に、問合せ中で明示的に指定されていなくても、行レベルのトリガはすべての変更されたパーティションや子テーブルに対して発行されます。
<code class="literal">REFERENCING</code>句で指定された遷移リレーションのある文レベルのトリガが定義されている場合、行の変更前イメージおよび変更ごイメージは、変更されたすべてのパーティションおよび子テーブルから見ることができます。
継承された子テーブルの場合、行イメージはトリガが付けられたテーブルに存在する列だけしか含みません。
現在のところ、遷移リレーションのある行レベルトリガは、パーティションや継承した子テーブルには定義できません。
  </p><p>
<span class="productname">PostgreSQL</span> 7.3より前のバージョンでは、トリガ関数の戻り値の型を、<code class="type">trigger</code>型ではなくプレースホルダである<code class="type">opaque</code>型として宣言する必要がありました。
古いダンプファイルのロードをサポートするため、<code class="command">CREATE TRIGGER</code>では<code class="type">opaque</code>型を返すよう宣言された関数を受け入れます。
しかし、注意を促すメッセージを表示し、宣言された関数の戻り値型を<code class="type">trigger</code>に変換します。
  </p></div><div class="refsect1" id="SQL-CREATETRIGGER-EXAMPLES"><h2>例</h2><p>テーブル<code class="literal">accounts</code>の行が更新される直前に関数<code class="function">check_account_update</code>を実行します。

</p><pre class="programlisting">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();</pre><p>

上と同じです。
しかし、列<code class="literal">balance</code>が<code class="command">UPDATE</code>コマンドの対象として指定された場合のみ実行されます。

</p><pre class="programlisting">CREATE TRIGGER check_update
    BEFORE UPDATE OF balance ON accounts
    FOR EACH ROW
    EXECUTE PROCEDURE check_account_update();</pre><p>

以下の構文では、列<code class="literal">balance</code>が実際に変更された場合のみ関数が実行されます。

</p><pre class="programlisting">CREATE TRIGGER check_update
    BEFORE UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)
    EXECUTE PROCEDURE check_account_update();</pre><p>

何か変更された場合のみに<code class="literal">accounts</code>の更新のログを取る関数を呼び出します。

</p><pre class="programlisting">CREATE TRIGGER log_update
    AFTER UPDATE ON accounts
    FOR EACH ROW
    WHEN (OLD.* IS DISTINCT FROM NEW.*)
    EXECUTE PROCEDURE log_account_update();</pre><p>

ビューの背後にあるテーブルに行を挿入するために、各行に対して関数<code class="function">view_insert_row</code>を実行します。

</p><pre class="programlisting">CREATE TRIGGER view_insert
    INSTEAD OF INSERT ON my_view
    FOR EACH ROW
    EXECUTE PROCEDURE view_insert_row();</pre><p>

各文に対して関数<code class="function">check_transfer_balances_to_zero</code>を実行して、<code class="literal">transfer</code>の行が相殺してゼロになることを確認します。

</p><pre class="programlisting">CREATE TRIGGER transfer_insert
    AFTER INSERT ON transfer
    REFERENCING NEW TABLE AS inserted
    FOR EACH STATEMENT
    EXECUTE PROCEDURE check_transfer_balances_to_zero();</pre><p>

各行に対して関数<code class="function">check_matching_pairs</code>を実行して、対応する組み合わせに対して同じ時に（同じ文により）変更されていることを確認します。

</p><pre class="programlisting">CREATE TRIGGER paired_items_update
    AFTER UPDATE ON paired_items
    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab
    FOR EACH ROW
    EXECUTE PROCEDURE check_matching_pairs();</pre><p>
  </p><p><a class="xref" href="trigger-example.html" title="38.4. 完全なトリガの例">Section 38.4</a>には、C言語で作成されたトリガ関数の完全な例があります。
  </p></div><div class="refsect1" id="SQL-CREATETRIGGER-COMPATIBILITY"><h2>互換性</h2><p><span class="productname">PostgreSQL</span>における<code class="command">CREATE TRIGGER</code>文は標準<acronym class="acronym">SQL</acronym>のサブセットを実装したものです
現在は、<span class="productname">PostgreSQL</span>には、次の機能がありません。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">AFTER</code>トリガの遷移テーブル名は<code class="literal">REFERENCING</code>句を使って標準SQLの方法で指定できますが、<code class="literal">FOR EACH ROW</code>トリガで使用される行変数は<code class="literal">REFERENCING</code>句で指定することができません。
それはトリガ関数が書かれる言語に依存する方法で利用できますが、各言語によって決まった方法になります。
一部の言語は、<code class="literal">REFERENCING</code>句が<code class="literal">OLD ROW AS OLD NEW ROW AS NEW</code>となっているかのように動作します。
     </p></li><li class="listitem"><p>標準SQLでは列を指定した<code class="literal">UPDATE</code>トリガでも遷移テーブルを使うことができますが、その場合遷移テーブルで見ることができる行の集合はトリガの列リストに依存します。
これは現在のところ<span class="productname">PostgreSQL</span>では実装されていません。
     </p></li><li class="listitem"><p><span class="productname">PostgreSQL</span>では、トリガ動作として、ユーザ定義関数の実行しか認めていません。
標準では、多数の他のSQLコマンドを実行させることができます。
例えば、トリガ動作として<code class="command">CREATE TABLE</code>を実行させることも可能です。
この制限を回避する方法は簡単です。必要なコマンドを実行するユーザ定義関数を作成すればよいのです。
     </p></li></ul></div><p>
  </p><p>SQLでは、複数のトリガは、作成時刻順に起動すべきであると規定しています。
<span class="productname">PostgreSQL</span>では名前順です。この方が便利だと考えられるからです。
  </p><p>SQLでは、数珠繋ぎの削除に対する<code class="literal">BEFORE DELETE</code>は、数珠繋ぎの<code class="literal">DELETE</code>が完了した<span class="emphasis"><em>後に</em></span>発行するものと規定しています。
<span class="productname">PostgreSQL</span>では、<code class="literal">BEFORE DELETE</code>は常に削除操作よりも前に、それも起点となる削除よりも前に行われます。
この方がより一貫性があると考えられいます。
また、参照整合性に関する動作により引き起こされる更新を実行している間に、<code class="literal">BEFORE</code>トリガが行を更新し、更新を妨げるような場合の動作も標準に従わないものがあります。
これは、制約違反となるかもしれませんし、参照整合性制約に合わないデータを格納してしまうかもしれません。
  </p><p><code class="literal">OR</code>を使用して単一トリガに複数の動作を指定する機能は、標準SQLに対する<span class="productname">PostgreSQL</span>の拡張です。
  </p><p><code class="command">TRUNCATE</code>でのトリガ発行機能、および、ビューに対する文レベルのトリガの定義機能は標準SQLに対する<span class="productname">PostgreSQL</span>の拡張です。
  </p><p><code class="command">CREATE CONSTRAINT TRIGGER</code>は標準<acronym class="acronym">SQL</acronym>に対する<span class="productname">PostgreSQL</span>の拡張です。
  </p></div><div class="refsect1" id="id-1.9.3.89.11"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-altertrigger.html" title="ALTER TRIGGER"><span class="refentrytitle">ALTER TRIGGER</span></a>, <a class="xref" href="sql-droptrigger.html" title="DROP TRIGGER"><span class="refentrytitle">DROP TRIGGER</span></a>, <a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>, <a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createtransform.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtype.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE TRANSFORM </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE TYPE</td></tr></table></div></body></html>