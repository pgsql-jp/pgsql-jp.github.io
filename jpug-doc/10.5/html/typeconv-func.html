<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.3. 関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="typeconv-oper.html" title="10.2. 演算子" /><link rel="next" href="typeconv-query.html" title="10.4. 値の格納" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.3. 関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-oper.html" title="10.2. 演算子">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Chapter 10. 型変換">Up</a></td><th width="60%" align="center">Chapter 10. 型変換</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-query.html" title="10.4. 値の格納">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TYPECONV-FUNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.3. 関数</h2></div></div></div><a id="id-1.5.9.8.2" class="indexterm"></a><p>関数呼び出しによって参照される特定の関数は、以下の手順に従って解決されます。
  </p><div class="procedure" id="id-1.5.9.8.4"><p class="title"><strong>関数における型の解決</strong></p><ol class="procedure" type="1"><li class="step"><p><code class="classname">pg_proc</code>システムカタログから、調査の対象とする関数を選択します。
スキーマ修飾がされていない関数名が使用される場合、現行の検索パスで可視になっていて、同一の名前と引数の数を持つ関数が調査対象であるとみなされます
（<a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATH" title="5.8.3. スキーマ検索パス">Section 5.8.3</a>を参照してください）。
修飾された関数名が与えられている場合、指定されたスキーマの関数のみが調査対象とみなされます。</p><ol type="a" class="substeps"><li class="step"><p>検索パスで、引数のデータ型が同じである複数の関数を検出した場合、そのパスで最初に検出された関数のみを調査対象とみなします。
引数のデータ型が異なる関数は、検索パス内の位置に関係なく、同じように調べられます。</p></li><li class="step"><p>もし関数が<code class="literal">VARIADIC</code>型の配列パラメータを伴って定義されており、そして<code class="literal">VARIADIC</code>キーワードを用いずに呼ばれた場合は、呼び出しに適合するよう、一つかそれ以上の要素の型に配列のパラメータを置き換えた形で扱われます。
このような拡張後は、その関数は実際の引数の型を持つので、他の非可変長の引数を持つ関数と同一になるかもしれません。この場合、検索パスで先に見つかった関数が使われます。また、同じスキーマに2つの関数が見つかった場合は非可変長の関数が優先されます。</p><p>This creates a security hazard when calling, via qualified name
  <a href="#ftn.FUNC-QUALIFIED-SECURITY" class="footnote"><sup class="footnote" id="FUNC-QUALIFIED-SECURITY">[9]</sup></a>,
a variadic function found in a schema that permits untrusted users to create
objects.  A malicious user can take control and execute arbitrary SQL
functions as though you executed them.  Substitute a call bearing
the <code class="literal">VARIADIC</code> keyword, which bypasses this hazard.  Calls
populating <code class="literal">VARIADIC "any"</code> parameters often have no
equivalent formulation containing the <code class="literal">VARIADIC</code> keyword.  To
issue those calls safely, the function's schema must permit only trusted users
to create objects.</p></li><li class="step"><p>パラメータにデフォルト値を持つ関数は、デフォルト指定可能なパラメータ位置のうち、0以上が省略されたどのような呼び出しに対しても適合すると見なされます。
もし呼び出し時にこのような関数が2つ以上適合した場合、検索パスで先に見つかったものが使用されます。
もし、デフォルト指定のない位置に同じパラメータ型を持つ関数(もしそれらが異なるデフォルト指定のあるパラメータのセットを持っていればあり得ます)が同じスキーマに2つ以上あった時は、システムはどの関数を使うべきか決定できず、呼出しにより適合するものが見つからなければ<span class="quote">“<span class="quote">ambiguous function call</span>”</span>エラーが結果として返るでしょう。</p><p>This creates an availability hazard when calling, via qualified
name<a href="typeconv-func.html#ftn.FUNC-QUALIFIED-SECURITY" class="footnoteref"><sup class="footnoteref">[9]</sup></a>, any function found in a
schema that permits untrusted users to create objects.  A malicious user can
create a function with the name of an existing function, replicating that
function's parameters and appending novel parameters having default values.
This precludes new calls to the original function.  To forestall this hazard,
place functions in schemas that permit only trusted users to create objects.</p></li></ol></li><li class="step"><p>正確に入力引数型を受け付ける関数があるかどうか検査します。
該当する関数があれば（調査される関数の集合内で正確に一致するものは1つしかあり得ません）、それを使用します
（<code class="type">unknown</code>を含む場合は、この段階で一致するものは決して見つかりません）。</p></li><li class="step"><p>正確に一致するものが存在しなかった場合、その関数呼び出しが特別な型変換要求であるかどうかを確認します。
これは、関数呼び出しがただ1つの引数を取り、関数名が何らかのデータ型の（内部的な）名前と同一である場合に発生します。
さらに、その関数の引数は、unknown型のリテラルか指定されたデータ型へのバイナリ変換可能な型か、型の入出力関数を適用することで指定された型に変換可能な型（つまり、変換が標準文字列型との間の変換である）であるかのいずれかでなければなりません。
これらの条件に合う場合、関数呼び出しは<code class="literal">CAST</code>仕様の形式と同様に扱われます。
  <a href="#ftn.id-1.5.9.8.4.4.1.2" class="footnote"><sup class="footnote" id="id-1.5.9.8.4.4.1.2">[10]</sup></a></p></li><li class="step"><p>最適なものを検索します。</p><ol type="a" class="substeps"><li class="step"><p>関数の候補のうち、入力値のデータ型が一致せず、また、（暗黙的な変換を使用して）一致するように変換できないものを破棄します。
<code class="type">unknown</code>リテラルは、上記の目的で何にでも変換可能とみなされます。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>入力引数のいずれかがドメイン型であれば、以降の段階すべてでドメインの基本型であるかのように扱います。
これにより、曖昧な関数を解決するのを目的としてその基本型であるかのようにドメインが振る舞うことが確実になります。</p></li><li class="step"><p>全ての候補を検索し、入力型に最も正確に合うものを残します。
正確に合うものが何もなければ全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>全ての候補を検索し、型変換が必要とされるところで（入力データ型カテゴリの）優先される型を受け付けるものを残します。
優先される型を受け付けるものが何もなければ全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>入力引数で<code class="type">unknown</code>のものがあった場合、それらの残った候補に引数位置で受け入れられる型カテゴリを検査します。
各位置で候補が<code class="type">string</code>カテゴリを受け付ける場合は、そのカテゴリを選択します
（unknown 型のリテラルは文字列のようなものですので、この文字列への重み付けは適切です）。
そうでなければ、もし残った全ての候補が同じ型カテゴリを受け入れる場合はそのカテゴリを選択します。
そうでもなければ、さらに手掛かりがなければ正しい選択が演繹されることができませんので、失敗となります。
ここで、選択された型カテゴリを受け付けない演算子候補は破棄されます。
さらに、このカテゴリ内の優先される型を受け付ける候補が1つでもある場合、その引数の優先されない型を受け付ける候補は破棄されます。
これらの検査をどれも通らなかったら全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>もし<code class="type">unknown</code>と既知の型の引数の両方があり、そして全ての既知の型の引数が同じ型を持っていた場合、<code class="type">unknown</code>引数も同じ型であると仮定し、
どの候補が<code class="type">unknown</code>引数の位置にある型を受け付けることができるかを検査します。
正確に1つの候補がこの検査を通過した場合、それを使います。それ以外は失敗します。</p></li></ol></li></ol></div><p>この<span class="quote">“<span class="quote">最善一致</span>”</span>規則は演算子と関数の型解決で同一であることに注意してください。
以下に例を示します。</p><div class="example" id="id-1.5.9.8.6"><p class="title"><strong>Example 10.6. 丸め関数引数の型解決</strong></p><div class="example-contents"><p>2つの引数を取る<code class="function">round</code>関数は1つしかありません
第1引数として<code class="type">numeric</code>型、第2引数として<code class="type">integer</code>型を取ります。
ですから、以下の問い合わせは自動的に、<code class="type">integer</code>型の第1引数を<code class="type">numeric</code>に変換します。
</p><pre class="screen">SELECT round(4, 4);

 round
--------
 4.0000
(1 row)</pre><p>

問い合わせはパーサによって実質以下のように変形されます。
</p><pre class="screen">SELECT round(CAST (4 AS numeric), 4);</pre><p>小数点を持つ数値定数はまず<code class="type">numeric</code>に割り当てられますので、以下の問い合わせでは型変換が不要です。そのためかなり効率的になる可能性があります。
</p><pre class="screen">SELECT round(4.0, 4);</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.8.7"><p class="title"><strong>Example 10.7. Variadic Function Resolution</strong></p><div class="example-contents"><pre class="screen">CREATE FUNCTION public.variadic_example(VARIADIC numeric[]) RETURNS int
  LANGUAGE sql AS 'SELECT 1';
CREATE FUNCTION</pre><p>

This function accepts, but does not require, the VARIADIC keyword.  It
tolerates both integer and numeric arguments:

</p><pre class="screen">SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                1 |                1 |                1
(1 row)</pre><p>

However, the first and second calls will prefer more-specific functions, if
available:

</p><pre class="screen">CREATE FUNCTION public.variadic_example(numeric) RETURNS int
  LANGUAGE sql AS 'SELECT 2';
CREATE FUNCTION

CREATE FUNCTION public.variadic_example(int) RETURNS int
  LANGUAGE sql AS 'SELECT 3';
CREATE FUNCTION

SELECT public.variadic_example(0),
       public.variadic_example(0.0),
       public.variadic_example(VARIADIC array[0.0]);
 variadic_example | variadic_example | variadic_example
------------------+------------------+------------------
                3 |                2 |                1
(1 row)</pre><p>

Given the default configuration and only the first function existing, the
first and second calls are insecure.  Any user could intercept them by
creating the second or third function.  By matching the argument type exactly
and using the <code class="literal">VARIADIC</code> keyword, the third call is secure.</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.8.8"><p class="title"><strong>Example 10.8. 部分文字列関数の型解決</strong></p><div class="example-contents"><p><code class="function">substr</code>関数は複数存在します。
その1つは<code class="type">text</code>と<code class="type">integer</code>型を取ります。
型の指定がない文字列定数で呼び出した場合、システムは優先されるカテゴリ<code class="literal">string</code>（すなわち<code class="type">text</code>型）の引数を受け付ける候補関数を選択します。

</p><pre class="screen">SELECT substr('1234', 3);

 substr
--------
     34
(1 row)</pre><p>文字列が<code class="type">varchar</code>型と宣言された場合、これはテーブルから取り出した場合が考えられますが、パーサはそれを<code class="type">text</code>になるように変換しようと試みます。
</p><pre class="screen">SELECT substr(varchar '1234', 3);

 substr
--------
     34
(1 row)</pre><p>

これは以下になるようにパーサによって変換されます。
</p><pre class="screen">SELECT substr(CAST (varchar '1234' AS text), 3);</pre><div class="note"><h3 class="title">Note</h3><p>パーサは<code class="structname">pg_cast</code>カタログから<code class="type">text</code>と<code class="type">varchar</code>がバイナリ互換、つまり、何らかの物理的な変換を行うことなく片方を受け付ける関数にもう片方を渡すことができることを知ります。
したがって、この場合実際に挿入される型変換呼び出しはありません。</p></div><p>また、<code class="type">integer</code>型の引数でこの関数が呼び出された場合、パーサはそれを<code class="type">text</code>に変換しようと試みます。
</p><pre class="screen">SELECT substr(1234, 3);
ERROR:  function substr(integer, integer) does not exist
HINT:  No function matches the given name and argument types. You might need
to add explicit type casts.</pre><p>

<code class="type">integer</code>は<code class="type">text</code>への暗黙的なキャストを持たないため、これは失敗します。
成功させるには、以下のように明示的なキャストを行います。
</p><pre class="screen">SELECT substr(CAST (1234 AS text), 3);

 substr
--------
     34
(1 row)</pre></div></div><br class="example-break" /><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.FUNC-QUALIFIED-SECURITY" class="footnote"><p><a href="#FUNC-QUALIFIED-SECURITY" class="para"><sup class="para">[9] </sup></a>    The hazard does not arise with a non-schema-qualified name, because a
    search path containing schemas that permit untrusted users to create
    objects is not a <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">secure schema usage
    pattern</a>.
   </p></div><div id="ftn.id-1.5.9.8.4.4.1.2" class="footnote"><p><a href="#id-1.5.9.8.4.4.1.2" class="para"><sup class="para">[10] </sup></a>この処理の理由は、実際にはキャスト関数が存在しない状況において、関数形態のキャスト仕様をサポートすることです。
キャスト関数が存在する場合、慣習的に出力型に因んで名付けられます。
ですので、特殊な状況を持つ必要はありません。
詳細な解説については<a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>を参照してください。
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-oper.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-query.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">10.2. 演算子 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 10.4. 値の格納</td></tr></table></div></body></html>