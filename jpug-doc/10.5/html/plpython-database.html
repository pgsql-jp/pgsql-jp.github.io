<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>45.7. データベースアクセス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpython-trigger.html" title="45.6. トリガ関数" /><link rel="next" href="plpython-subtransaction.html" title="45.8. 明示的サブトランザクション" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">45.7. データベースアクセス</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpython-trigger.html" title="45.6. トリガ関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpython.html" title="Chapter 45. PL/Python - Python手続き言語">Up</a></td><th width="60%" align="center">Chapter 45. PL/Python - Python手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpython-subtransaction.html" title="45.8. 明示的サブトランザクション">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPYTHON-DATABASE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">45.7. データベースアクセス</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpython-database.html#id-1.8.11.15.3">45.7.1. データベースアクセス関数</a></span></dt><dt><span class="sect2"><a href="plpython-database.html#PLPYTHON-TRAPPING">45.7.2. エラーの捕捉</a></span></dt></dl></div><p>PL/Python言語モジュールは自動的に<code class="literal">plpy</code>というPythonモジュールをインポートします。
このモジュールの関数と定数は、<code class="literal">plpy.<em class="replaceable"><code>foo</code></em></code>のように作成したPythonコードから使用することができます。
  </p><div class="sect2" id="id-1.8.11.15.3"><div class="titlepage"><div><div><h3 class="title">45.7.1. データベースアクセス関数</h3></div></div></div><p><code class="literal">plpy</code>モジュールはデータベースコマンドを実行するために数個の関数を用意しています。
  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">plpy.<code class="function">execute</code>(<em class="replaceable"><code>query</code></em> [, <em class="replaceable"><code>max-rows</code></em>])</code></span></dt><dd><p><code class="function">plpy.execute</code>を、問い合わせ文字列および省略可能な行数制限引数を付けて呼び出すと、問い合わせが実行され、結果オブジェクトとして問い合わせ結果が返ります。
     </p><p>結果オブジェクトはリストもしくは辞書オブジェクトをエミュレートします。
結果オブジェクトは、行番号や列名によってアクセスすることができます。
例を示します。
</p><pre class="programlisting">rv = plpy.execute("SELECT * FROM my_table", 5)</pre><p>
これは、<code class="literal">my_table</code>から5行までを返します。
<code class="literal">my_table</code>に<code class="literal">my_column</code>列が存在する場合、その列には以下のようにアクセスできます。
</p><pre class="programlisting">foo = rv[i]["my_column"]</pre><p>
戻った行数はビルトイン<code class="function">len</code>関数を使用して取得できます。
     </p><p>結果オブジェクトには以下のメソッドが追加されています。
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal"><code class="function">nrows</code>()</code></span></dt><dd><p>コマンドによる処理の行数を返します。
戻った行数と同じとは限らないことに注意してください。
例えば、<code class="command">UPDATE</code>コマンドではゼロでない値を返しますが、行を戻すことはありません（<code class="literal">RETURNING</code>を使用したときは別です）。
         </p></dd><dt><span class="term"><code class="literal"><code class="function">status</code>()</code></span></dt><dd><p><code class="function">SPI_execute()</code>関数の戻り値を返します。
         </p></dd><dt><span class="term"><code class="literal"><code class="function">colnames</code>()</code><br /></span><span class="term"><code class="literal"><code class="function">coltypes</code>()</code><br /></span><span class="term"><code class="literal"><code class="function">coltypmods</code>()</code></span></dt><dd><p>各々、列名のリスト、列の型OIDのリスト、列に関する型独自の型修飾子のリストを返します。
         </p><p><code class="literal">RETURNING</code>を持たない<code class="command">UPDATE</code>や<code class="command">DROP TABLE</code>など、結果セットを生成しないコマンドによる結果オブジェクトに対して呼び出された場合、これらのメソッドは例外を発生します。
しかし、ゼロ行の結果セットに対してこれらのメソッドを使用することには問題ありません。
         </p></dd><dt><span class="term"><code class="literal"><code class="function">__str__</code>()</code></span></dt><dd><p>標準の<code class="literal">__str__</code>メソッドが定義されていますので、例えば問い合わせの実行結果を<code class="literal">plpy.debug(rv)</code>を使ってデバッグできます。
         </p></dd></dl></div><p>
     </p><p>結果オブジェクトは変更できます。
     </p><p><code class="literal">plpy.execute</code>を呼び出すことにより、結果セット全体がメモリ内に読み込まれることに注意してください。
結果セットが比較的小さいことが確実な場合だけ、この関数を使用してください。
大規模な結果を取り込む場合の過度のメモリ使用に関する危険を回避したい場合は、<code class="literal">plpy.execute</code>ではなく<code class="literal">plpy.cursor</code>を使用してください。
     </p></dd><dt><span class="term"><code class="literal">plpy.<code class="function">prepare</code>(<em class="replaceable"><code>query</code></em> [, <em class="replaceable"><code>argtypes</code></em>])</code><br /></span><span class="term"><code class="literal">plpy.<code class="function">execute</code>(<em class="replaceable"><code>plan</code></em> [, <em class="replaceable"><code>arguments</code></em> [, <em class="replaceable"><code>max-rows</code></em>]])</code></span></dt><dd><p><a id="id-1.8.11.15.3.3.2.3.1.1" class="indexterm"></a>
<code class="function">plpy.prepare</code>は問い合わせの実行計画を準備します。
問い合わせ内にパラメータ参照がある場合、問い合わせ文字列および引数型のリストとともに呼び出されます。
例を示します。
</p><pre class="programlisting">plan = plpy.prepare("SELECT last_name FROM my_users WHERE first_name = $1", ["text"])</pre><p>
<code class="literal">text</code>は<code class="literal">$1</code>として渡される変数の型です。
問い合わせにパラメータを渡さない場合、2番目の引数は省略可能です。
     </p><p>文を準備した後、それを実行するために関数<code class="function">plpy.execute</code>の亜種を使用します。
</p><pre class="programlisting">rv = plpy.execute(plan, ["name"], 5)</pre><p>
実行計画を（問い合わせ文字列ではなく）最初の引数として渡してください。
問い合わせに代入する値のリストを、2番目の引数として渡してください。
問い合わせにパラメータがない場合、2番目の引数は省略可能です。
3番目の引数は、前に述べた省略可能な行数制限引数です。
     </p><p>代わりに、計画オブジェクトの<code class="function">execute</code>メソッドを呼び出すことができます。
</p><pre class="programlisting">rv = plan.execute(["name"], 5)</pre><p>
     </p><p>問い合わせパラメータおよび結果行のフィールドは<a class="xref" href="plpython-data.html" title="45.3. データ値">Section 45.3</a>で示した通り、PostgreSQLとPythonのデータ型の間で変換されます。
     </p><p>PL/Pythonモジュールを使用して準備した計画は自動的に保存されます。
これが何を意味するのかについてはSPIの文書（<a class="xref" href="spi.html" title="Chapter 46. サーバプログラミングインタフェース">Chapter 46</a>）を参照してください。
これを複数呼び出しにおいて効果的に使用するためには、永続的な格納用辞書である<code class="literal">SD</code>または<code class="literal">GD</code>（<a class="xref" href="plpython-sharing.html" title="45.4. データの共有">Section 45.4</a>を参照）のいずれかを使用する必要があります。
例を示します。
</p><pre class="programlisting">CREATE FUNCTION usesavedplan() RETURNS trigger AS $$
    if "plan" in SD:
        plan = SD["plan"]
    else:
        plan = plpy.prepare("SELECT 1")
        SD["plan"] = plan
    # rest of function
$$ LANGUAGE plpythonu;</pre><p>
     </p></dd><dt><span class="term"><code class="literal">plpy.<code class="function">cursor</code>(<em class="replaceable"><code>query</code></em>)</code><br /></span><span class="term"><code class="literal">plpy.<code class="function">cursor</code>(<em class="replaceable"><code>plan</code></em> [, <em class="replaceable"><code>arguments</code></em>])</code></span></dt><dd><p><code class="literal">plpy.cursor</code>関数は<code class="literal">plpy.execute</code>と同じ引数を受け取り（行数制限引数を除いた）カーソルオブジェクトとして返します。
これにより大規模な結果セットをより小さな塊の中で処理することができます。
<code class="literal">plpy.execute</code>の場合と同様、問い合わせ文字列または引数リスト付きの計画オブジェクトを使用できますし、計画オブジェクトのメソッドとして<code class="function">cursor</code>関数を呼ぶことができます。
     </p><p>カーソルオブジェクトは、整数パラメータを受付け、結果オブジェクトを返す<code class="literal">fetch</code>メソッドを提供します。
<code class="literal">fetch</code>を呼び出す度に、返されるオブジェクトには次の一群の行が含まれます。
この行数はパラメータ値より多くなることはありません。
全ての行が出し尽くされると、<code class="literal">fetch</code>は空の結果オブジェクトを返すようになります。
カーソルオブジェクトはまた、すべての行を出し尽くすまで一度に１行を生成する<a class="ulink" href="http://docs.python.org/library/stdtypes.html#iterator-types" target="_top">イテレータインタフェース</a>を提供します。
この方法で取り出されたデータは結果オブジェクトとしては返されず、１つの辞書が単一の結果行に対応する辞書群として返されます。
     </p><p>大きなテーブルのデータを処理する、2つの方法の例を示します。
</p><pre class="programlisting">CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$
odd = 0
for row in plpy.cursor("select num from largetable"):
    if row['num'] % 2:
         odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$
odd = 0
cursor = plpy.cursor("select num from largetable")
while True:
    rows = cursor.fetch(batch_size)
    if not rows:
        break
    for row in rows:
        if row['num'] % 2:
            odd += 1
return odd
$$ LANGUAGE plpythonu;

CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$
odd = 0
plan = plpy.prepare("select num from largetable where num % $1 &lt;&gt; 0", ["integer"])
rows = list(plpy.cursor(plan, [2]))  # または = list(plan.cursor([2]))

return len(rows)
$$ LANGUAGE plpythonu;</pre><p>
     </p><p>カーソルは自動的に処分されます。
しかし、カーソルが保有していた資源を明示的に開放したい場合は、<code class="literal">close</code>メソッドを使用してください。
閉じた後、カーソルからこれ以上取り込むことはできません。
     </p><div class="tip"><h3 class="title">Tip</h3><p><code class="literal">plpy.cursor</code>によって作成されたオブジェクトと、<a class="ulink" href="http://www.python.org/dev/peps/pep-0249/" target="_top">PythonデータベースAPI仕様</a>において定義されたDB-APIカーソルとを混同しないでください。
名称以外の共通点はありません。
      </p></div></dd></dl></div></div><div class="sect2" id="PLPYTHON-TRAPPING"><div class="titlepage"><div><div><h3 class="title">45.7.2. エラーの捕捉</h3></div></div></div><p>データベースにアクセスする関数はエラーに遭遇し、エラーが関数をアボートして例外を発生させる原因となります。
<code class="function">plpy.execute</code>および<code class="function">plpy.prepare</code>は、デフォルトでは関数を終了させる<code class="literal">plpy.SPIError</code>のサブクラスのインスタンスを発生させることができます。
このエラーは、<code class="literal">try/except</code>構文を使用して、Pythonの他の例外と同様に処理できます。
例を示します。
</p><pre class="programlisting">CREATE FUNCTION try_adding_joe() RETURNS text AS $$
    try:
        plpy.execute("INSERT INTO users(username) VALUES ('joe')")
    except plpy.SPIError:
        "うまくいかなかった" を返す
    else:
        "Joeが追加された" を返す
$$ LANGUAGE plpythonu;</pre><p>
   </p><p>発生される例外の実クラスはエラーを引き起こした特定の条件と対応します。
<a class="xref" href="errcodes-appendix.html#ERRCODES-TABLE" title="Table A.1. PostgreSQLエラーコード">Table A.1</a>にあり得る条件のリストがありますので参照してください。
<code class="literal">plpy.spiexceptions</code>モジュールは<span class="productname">PostgreSQL</span>の条件それぞれに対して、その条件名に因んだ名前の例外クラスを定義しています。
例えば<code class="literal">division_by_zero</code>は<code class="literal">DivisionByZero</code>、<code class="literal">unique_violation</code>は<code class="literal">UniqueViolation</code>に、<code class="literal">fdw_error</code>は<code class="literal">FdwError</code>などのようになります。
これらの例外クラスはそれぞれ<code class="literal">SPIError</code>を継承したものです。
このように分離することで特定のエラーをより簡単に扱うことができるようになります。
以下に例を示します。
</p><pre class="programlisting">CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$
from plpy import spiexceptions
try:
    plan = plpy.prepare("INSERT INTO fractions (frac) VALUES ($1 / $2)", ["int", "int"])
    plpy.execute(plan, [numerator, denominator])
except spiexceptions.DivisionByZero:
    return "denominator cannot equal zero"
except spiexceptions.UniqueViolation:
    return "already have that fraction"
except plpy.SPIError, e:
    return "other error, SQLSTATE %s" % e.sqlstate
else:
    return "fraction inserted"
$$ LANGUAGE plpythonu;</pre><p>
<code class="literal">plpy.spiexceptions</code>モジュールからの全ての例外は<code class="literal">SPIError</code>を継承するため、例外を処理する<code class="literal">except</code>句は全てのデータベースアクセスエラーを捕捉することに注意してください。
   </p><p>異なったエラー条件を処理する代りの方法として、<code class="literal">SPIError</code>例外を捕捉して、例外オブジェクトの<code class="literal">sqlstate</code>属性を調べることにより、<code class="literal">except</code>ブロック内部の明細なエラー条件を決定できます。
この属性は<span class="quote">“<span class="quote">SQLSTATE</span>”</span>エラーコードを含む文字列値です。
この方法は、ほぼ同じ機能を提供します。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpython-trigger.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpython.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpython-subtransaction.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">45.6. トリガ関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 45.8. 明示的サブトランザクション</td></tr></table></div></body></html>