<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SELECT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-security-label.html" title="SECURITY LABEL" /><link rel="next" href="sql-selectinto.html" title="SELECT INTO" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">SELECT</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-security-label.html" title="SECURITY LABEL">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-selectinto.html" title="SELECT INTO">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-SELECT"><div class="titlepage"></div><a id="id-1.9.3.165.1" class="indexterm"></a><a id="id-1.9.3.165.2" class="indexterm"></a><a id="id-1.9.3.165.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">SELECT</span></h2><p>SELECT, TABLE, WITH — テーブルもしくはビューから行を検索する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">[ WITH [ RECURSIVE ] <em class="replaceable"><code>with_query</code></em> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <em class="replaceable"><code>expression</code></em> [, ...] ) ] ]
    [ * | <em class="replaceable"><code>expression</code></em> [ [ AS ] <em class="replaceable"><code>output_name</code></em> ] [, ...] ]
    [ FROM <em class="replaceable"><code>from_item</code></em> [, ...] ]
    [ WHERE <em class="replaceable"><code>condition</code></em> ]
    [ GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...] ]
    [ HAVING <em class="replaceable"><code>condition</code></em> [, ...] ]
    [ WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <em class="replaceable"><code>select</code></em> ]
    [ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <em class="replaceable"><code>count</code></em> | ALL } ]
    [ OFFSET <em class="replaceable"><code>start</code></em> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<span class="phrase">ここで<em class="replaceable"><code>from_item</code></em>は以下のいずれかです。</span>

    [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
                [ TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ] ]
    [ LATERAL ] ( <em class="replaceable"><code>select</code></em> ) [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ]
    <em class="replaceable"><code>with_query_name</code></em> [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ] <em class="replaceable"><code>alias</code></em> ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] ROWS FROM( <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    <em class="replaceable"><code>from_item</code></em> [ NATURAL ] <em class="replaceable"><code>join_type</code></em> <em class="replaceable"><code>from_item</code></em> [ ON <em class="replaceable"><code>join_condition</code></em> | USING ( <em class="replaceable"><code>join_column</code></em> [, ...] ) ]

<span class="phrase">また<em class="replaceable"><code>grouping_element</code></em>は以下のいずれかです。</span>

    ( )
    <em class="replaceable"><code>expression</code></em>
    ( <em class="replaceable"><code>expression</code></em> [, ...] )
    ROLLUP ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    CUBE ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    GROUPING SETS ( <em class="replaceable"><code>grouping_element</code></em> [, ...] )

<span class="phrase">また<em class="replaceable"><code>with_query</code></em>は以下の通りです。</span>

    <em class="replaceable"><code>with_query_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ] AS ( <em class="replaceable"><code>select</code></em> | <em class="replaceable"><code>values</code></em> | <em class="replaceable"><code>insert</code></em> | <em class="replaceable"><code>update</code></em> | <em class="replaceable"><code>delete</code></em> )

TABLE [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ]</pre></div><div class="refsect1" id="id-1.9.3.165.7"><h2>説明</h2><p><code class="command">SELECT</code>は0個以上のテーブルから行を返します。
<code class="command">SELECT</code>の一般的な処理は以下の通りです。

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><code class="literal">WITH</code>リスト内のすべての問い合わせが計算されます。
これらは実質的には、<code class="literal">FROM</code>リスト内から参照可能な一時テーブルとして提供されます。
<code class="literal">FROM</code>内で2回以上参照される<code class="literal">WITH</code>問い合わせは一度のみ計算されます。
（後述の<a class="xref" href="sql-select.html#SQL-WITH" title="WITH句"><code class="literal">WITH</code>句</a>を参照してください。）
     </p></li><li class="listitem"><p><code class="literal">FROM</code>リストにある全要素が計算されます
（<code class="literal">FROM</code>リストの要素は実テーブルか仮想テーブルのいずれかです）。
<code class="literal">FROM</code>リストに複数の要素が指定された場合、それらはクロス結合されます
（後述の<a class="xref" href="sql-select.html#SQL-FROM" title="FROM句"><code class="literal">FROM</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">WHERE</code>句が指定された場合、条件を満たさない行は全て出力から取り除かれます
（後述の<a class="xref" href="sql-select.html#SQL-WHERE" title="WHERE句"><code class="literal">WHERE</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">GROUP BY</code>句が指定された場合、および集約関数の呼び出しがある場合は、1つまたは複数の値が条件に合う行ごとにグループに組み合わせて出力され、また集約関数の結果が計算されます。
<code class="literal">HAVING</code>句が指定された場合、指定した条件を満たさないグループは取り除かれます
（後述の<a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>と<a class="xref" href="sql-select.html#SQL-HAVING" title="HAVING句"><code class="literal">HAVING</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p>実際には、選択された各行または行グループに対して、<code class="command">SELECT</code>の出力式を使用して計算した結果の行が出力されます
（後述の<a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECTリスト"><code class="command">SELECT</code>リスト</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">SELECT DISTINCT</code>は結果から重複行を取り除きます。
<code class="literal">SELECT DISTINCT ON</code>は指定した全ての式に一致する行を取り除きます。
<code class="literal">SELECT ALL</code>では、重複行も含め、全ての候補行を返します（これがデフォルトです。
詳しくは、後述の<a class="xref" href="sql-select.html#SQL-DISTINCT" title="DISTINCT句"><code class="literal">DISTINCT</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>演算子を使用すると、複数の<code class="command">SELECT</code>文の出力を1つの結果集合にまとめることができます。
<code class="literal">UNION</code>演算子は、両方の結果集合に存在する行と、片方の結果集合に存在する行を全て返します。
<code class="literal">INTERSECT</code>演算子は、両方の結果集合に存在する行を返します。
<code class="literal">EXCEPT</code>演算子は、最初の結果集合にあり、2番目の結果集合にない行を返します。
<code class="literal">ALL</code>が指定されない限り、いずれの場合も、重複する行は取り除かれます。
無意味な<code class="literal">DISTINCT</code>という単語を付けて、明示的に重複行を除去することを指定することができます。
<code class="command">SELECT</code>自体は<code class="literal">ALL</code>がデフォルトですが、この場合は<code class="literal">DISTINCT</code>がデフォルトの動作であることに注意してください。
（後述の<a class="xref" href="sql-select.html#SQL-UNION" title="UNION句"><code class="literal">UNION</code>句</a>、<a class="xref" href="sql-select.html#SQL-INTERSECT" title="INTERSECT句"><code class="literal">INTERSECT</code>句</a>、<a class="xref" href="sql-select.html#SQL-EXCEPT" title="EXCEPT句"><code class="literal">EXCEPT</code>句</a>を参照してください。）
     </p></li><li class="listitem"><p><code class="literal">ORDER BY</code>句が指定された場合、返される行は指定した順番でソートされます。
<code class="literal">ORDER BY</code>が指定されない場合は、システムが計算過程で見つけた順番で行が返されます
（後述の<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">LIMIT</code>（または<code class="literal">FETCH FIRST</code>）あるいは<code class="literal">OFFSET</code>句が指定された場合、<code class="command">SELECT</code>文は結果行の一部分のみを返します
（詳しくは、後述の<a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT句"><code class="literal">LIMIT</code>句</a>を参照してください）。
     </p></li><li class="listitem"><p><code class="literal">FOR UPDATE</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>句を指定すると、<code class="command">SELECT</code>文は引き続き行われる更新に備えて選択行をロックします
（詳しくは、後述の<a class="xref" href="sql-select.html#SQL-FOR-UPDATE-SHARE" title="ロック処理句">ロック処理句</a>を参照してください）。
     </p></li></ol></div><p>
  </p><p><code class="command">SELECT</code>コマンド内で使われる列それぞれに対する<code class="literal">SELECT</code>権限が必要です。
<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を使用するためには、さらに、（選択された各テーブルで少なくとも1列に対する）<code class="literal">UPDATE</code>権限が必要です。

  </p></div><div class="refsect1" id="id-1.9.3.165.8"><h2>パラメータ</h2><div class="refsect2" id="SQL-WITH"><h3><code class="literal">WITH</code>句</h3><p><code class="literal">WITH</code>句により主問い合わせ内で名前により参照可能な、1つ以上の副問い合わせを指定することができます。
副問い合わせは実質的に主問い合わせの間の一時的なテーブルかビューのように動作します。
各副問い合わせは<code class="command">SELECT</code>、<code class="command">TABLE</code>、<code class="command">VALUES</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>にすることができます。
<code class="literal">WITH</code>内でデータ変更文（<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>）を記述する場合は、<code class="literal">RETURNING</code>句を含めるのが普通です。
主問い合わせで読み取られる一時テーブルを形成するのは、<code class="literal">RETURNING</code>の出力であり、文が変更する背後のテーブルでは<span class="emphasis"><em>ありません</em></span>。
<code class="literal">RETURNING</code>を省いても文は実行されますが、出力を生成しませんので、主問い合わせでテーブルとして参照することができません。
   </p><p>（スキーマ修飾がない）名前を各<code class="literal">WITH</code>問い合わせで指定しなければなりません。
列名のリストをオプションで指定することもできます。
これを省略すると、列名は副問い合わせから推定されます。
   </p><p><code class="literal">RECURSIVE</code>が指定されると、<code class="command">SELECT</code>副問い合わせは自身で名前により参照することができます。
こうした副問い合わせは以下のような形式でなければなりません。
</p><pre class="synopsis"><em class="replaceable"><code>non_recursive_term</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>recursive_term</code></em></pre><p>
ここで再帰的な自己参照は<code class="literal">UNION</code>の右辺に現れなければなりません。
問い合わせ当たり1つの再帰的な自己参照のみが許されます。
再帰的なデータ変更文はサポートされていませんが、データ変更文で再帰的な<code class="command">SELECT</code>の結果を使用することができます。
例は<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">Section 7.8</a>を参照してください。
   </p><p><code class="literal">RECURSIVE</code>には他にも、<code class="literal">WITH</code>問い合わせが順序通りでなくても構わないという効果があります。
つまり、問い合わせはリストの後にある別のものを参照することができます。
（しかし巡回する参照や相互的な参照は実装されていません。）
<code class="literal">RECURSIVE</code>がないと、<code class="literal">WITH</code>問い合わせは主問い合わせが共通する<code class="literal">WITH</code>問い合わせのうち、<code class="literal">WITH</code>リストの前方にあるもののみを参照することができます。
   </p><p><code class="literal">WITH</code>問い合わせの重要な特性は、これらを主問い合わせが複数回参照していたとしても、主問い合わせの実行当たり一度のみ評価される点です。
特にデータ変更文は、主問い合わせがその出力のすべてまたは一部を読み取るかに関係なく、本当に一度のみ実行されることが保証されています。
   </p><p>主問い合わせと<code class="literal">WITH</code>問い合わせは（理論上）同時にすべて実行されます。
<code class="literal">WITH</code>内のデータ変更文によりなされた影響は、<code class="literal">RETURNING</code>出力を読み取る以外、問い合わせの他の部分では参照できないことを意味します。
こうしたデータ変更文が２つあり、同じ行を変更しようとした場合、その結果は不定です。
   </p><p>追加情報については<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">Section 7.8</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-FROM"><h3><code class="literal">FROM</code>句</h3><p><code class="literal">FROM</code>句には<code class="command">SELECT</code>の対象となるソーステーブルを1つ以上指定します。
複数のソースが指定された場合、結果は全てのソースの直積（クロス結合）となります。
しかし、通常は（<code class="literal">WHERE</code>を介して）制約条件を付けて、直積のごく一部を返すように結果行を限定します。
   </p><p><code class="literal">FROM</code>句には以下の要素を指定できます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>既存のテーブルもしくはビューの名前です（スキーマ修飾名も可）。
テーブル名の前に<code class="literal">ONLY</code>が指定された場合、そのテーブルのみがスキャンされます。
<code class="literal">ONLY</code>が指定されない場合、テーブルと（もしあれば）それを継承する全てのテーブルがスキャンされます。
省略することもできますが、テーブル名の後に<code class="literal">*</code>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>alias</code></em></span></dt><dd><p>別名を含む<code class="literal">FROM</code>項目の代替名です。
別名は、指定を簡潔にするため、もしくは、自己結合（同じテーブルを複数回スキャンする結合）の曖昧さをなくすために使われます。
別名が指定されている場合は、その別名によって実際のテーブル名または関数名が完全に隠されます。
例えば、<code class="literal">FROM foo AS f</code>と指定されている場合、<code class="command">SELECT</code>文の以降の部分ではこの<code class="literal">FROM</code>項目を<code class="literal">foo</code>ではなく<code class="literal">f</code>として参照する必要があります。
テーブルの別名があれば、そのテーブルの複数の列の名前を置き換える列の別名リストを記述することができます。
       </p></dd><dt><span class="term"><code class="literal">TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ]</code></span></dt><dd><p><em class="replaceable"><code>table_name</code></em>の後の<code class="literal">TABLESAMPLE</code>句は、そのテーブルの行の部分集合を取り出すときに、指定した<em class="replaceable"><code>sampling_method</code></em>を使うべきであることを示唆します。
このサンプリングは<code class="literal">WHERE</code>など他のすべてのフィルタの適用に先立って行われます。
<span class="productname">PostgreSQL</span>の標準ディストリビューションには、<code class="literal">BERNOULLI</code>と<code class="literal">SYSTEM</code>の2つのサンプリングメソッドが含まれています。
他のサンプリングメソッドも拡張(extension)によりデータベースにインストールすることができます。
       </p><p>サンプリングメソッド<code class="literal">BERNOULLI</code>と<code class="literal">SYSTEM</code>はいずれも1つだけ<em class="replaceable"><code>argument</code></em>を取り、これはテーブルからサンプリングする割合で0から100までのパーセントで表現されます。
この引数は<code class="type">real</code>型の値を取る任意の式にできます。
（他のサンプリングメソッドは、複数の、あるいは異なる引数を受け取るかもしれません。）
これら2つの方法はいずれも、テーブルのうち指定された割合に近い行数を含む、ランダムに選択されたサンプルテーブルを返します。
<code class="literal">BERNOULLI</code>では、テーブル全体を走査し、個々の行を別々に、指定された確率に従って、選択あるいは無視します。
<code class="literal">SYSTEM</code>ではブロックレベルのサンプリングを行います。
各ブロックは指定された確率で選択され、選択されたブロック内のすべての行が返されます。
サンプリングに小さな割合が指定された場合、<code class="literal">SYSTEM</code>は<code class="literal">BERNOULLI</code>よりもかなり高速ですが、クラスタリング効果により、<code class="literal">BERNOULLI</code>に比べてランダムでないサンプルを返すかもしれません。
       </p><p>オプションの<code class="literal">REPEATABLE</code>句では、サンプリングメソッドで乱数を生成するための<em class="replaceable"><code>seed</code></em>の数あるいは式を指定します。
シード値はNULL以外の任意の浮動点小数値とすることができます。
シードと<em class="replaceable"><code>argument</code></em>の値が同じ2つの問い合わせは、その間にテーブルに変更がなければ、同じサンプルテーブルを返します。
しかし、シードの値が異なれば、通常は異なるサンプルが生成されます。
<code class="literal">REPEATABLE</code>が指定されていなければ、システムが生成したシードに基づいて、問い合わせ毎に新しくランダムなサンプルが生成されます。
一部のアドオンのサンプリングメソッドでは<code class="literal">REPEATABLE</code>が利用できず、使用の度に常に新しいサンプルを生成することに注意してください。
       </p></dd><dt><span class="term"><em class="replaceable"><code>select</code></em></span></dt><dd><p><code class="literal">FROM</code>句では、副<code class="command">SELECT</code>を使うことができます。
<code class="command">SELECT</code>コマンドの実行中、副<code class="command">SELECT</code>の出力は一時テーブルであるかのように動作します。
副<code class="command">SELECT</code>は括弧で囲まれなければなりません。また、<span class="emphasis"><em>必ず</em></span>別名を与えなければなりません。
<a class="xref" href="sql-values.html" title="VALUES"><span class="refentrytitle">VALUES</span></a>コマンドをここで使用することもできます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>with_query_name</code></em></span></dt><dd><p><code class="literal">WITH</code>問い合わせは、問い合わせの名前があたかもテーブル名であるかのように、名前を記述することで参照されます。
（実際には<code class="literal">WITH</code>問い合わせは主問い合わせの対象とするテーブルと同じ名前の実テーブルを隠蔽します。
必要ならばテーブル名をスキーマ修飾することで同じ名前の実テーブルを参照することができます。）
テーブルと同様の方法で別名を提供することができます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>function_name</code></em></span></dt><dd><p><code class="literal">FROM</code>句では、関数呼び出しを使用することができます
（これは特に関数が結果セットを返す場合に有用ですが、任意の関数を使用することもできます）。
<code class="command">SELECT</code>コマンドの実行中は、この関数の結果は一時テーブルであるかのように動作します。
関数呼び出しに<code class="command">WITH ORDINALITY</code>句を追加した時は、すべての関数の出力列の後に各行の番号の列が追加されます。
       </p><p>テーブルに対するのと同じように、別名を使用することができます。
別名が記述されていれば、列の別名リストを記述して、関数の複合型の戻り値の１つ以上の、<code class="literal">ORDINALITY</code>がある場合はそれが追加する列を含め、属性に対する代替名を提供することもできます。
       </p><p>複数の関数呼び出しを<code class="literal">ROWS FROM( ... )</code>で括ることにより、1つの<code class="literal">FROM</code>句の項目にまとめることができます。
このような項目の出力は各関数の最初の行を結合した項目、次いで各関数の2番目の行、といった具合になります。
一部の関数が他の関数より少ない行数を出力した場合は、存在しないデータについてNULL値が代用され、戻される行数はいつでも最大の行数を返した関数と同じになります。
       </p><p>関数が<code class="type">record</code>データ型を返すと定義されている場合は、別名すなわち<code class="literal">AS</code>キーワードと、それに続く<code class="literal">（<em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> [<span class="optional">, ... </span>]）</code>という形式の列定義リストが必要です。
列定義リストは、関数によって返される実際の列の数およびデータ型に一致していなければなりません。
       </p><p><code class="literal">ROWS FROM( ... )</code>の構文を使う時、関数の1つが列定義のリストを必要としている場合は、<code class="literal">ROWS FROM( ... )</code>内の関数呼び出しの後に列定義のリストを置くのが望ましいです。
関数が1つだけで、<code class="literal">WITH ORDINALITY</code>句がない場合に限り、列定義のリストを<code class="literal">ROWS FROM( ... )</code>の後に置くことができます。
       </p><p><code class="literal">ORDINALITY</code>を列定義のリストと一緒に使うには、<code class="literal">ROWS FROM( ... )</code>構文を使い、列定義のリストを<code class="literal">ROWS FROM( ... )</code>の内側に置かなければなりません。
       </p></dd><dt><span class="term"><em class="replaceable"><code>join_type</code></em></span></dt><dd><p>        以下のいずれかです。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">[ INNER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">LEFT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">RIGHT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">FULL [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">CROSS JOIN</code></p></li></ul></div><p>

<code class="literal">INNER</code>および<code class="literal">OUTER</code>結合型では、結合条件、すなわち、<code class="literal">NATURAL</code>, <code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code>、<code class="literal">USING (<em class="replaceable"><code>join_column</code></em> [, ...])</code>のいずれか1つのみを指定する必要があります。
それぞれの意味は後述します。
<code class="literal">CROSS JOIN</code>では、これらの句を記述しなくても構いません。
       </p><p><code class="literal">JOIN</code>句は、2つの<code class="literal">FROM</code>項目を結び付けます。
便宜上<span class="quote">“<span class="quote">テーブル</span>”</span>と呼びますが、実際には任意の種類の<code class="literal">FROM</code>項目とすることができます。
入れ子の順番を決めるために、必要ならば括弧を使用してください。
括弧がないと、<code class="literal">JOIN</code>は左から右へ入れ子にします。
どのような場合でも<code class="literal">JOIN</code>は、カンマで分けられた<code class="literal">FROM</code>項目よりも強い結び付きを持ちます。
       </p><p><code class="literal">CROSS JOIN</code>と<code class="literal">INNER JOIN</code>は直積を1つ生成します。これは、<code class="literal">FROM</code>の最上位で2つのテーブルを結合した結果と同一です。
しかし、（指定すれば）結合条件によって制限をかけることができます。
<code class="literal">CROSS JOIN</code>は<code class="literal">INNER JOIN ON (TRUE)</code>と等価であり、条件によって削除される行はありません。
これらの結合型は記述上の便宜のためだけに用意されています。
なぜなら、通常の<code class="literal">FROM</code>と<code class="literal">WHERE</code>でできないことは何もしないからです。
       </p><p><code class="literal">LEFT OUTER JOIN</code>は、条件に合う直積の全ての行（つまり、その結合条件を満たす全ての組み合わせ）に加え、左側テーブルの中で、右側テーブルには結合条件を満たす行が存在しなかった行のコピーも返します。
この左側テーブルの行を結合結果のテーブルの幅に拡張するために、右側テーブルが入る列にはNULL値が挿入されます。
マッチする行を決める時は、<code class="literal">JOIN</code>句自身の条件のみが考慮されることに注意してください。
外部結合条件は後で適用されます。
       </p><p>逆に、<code class="literal">RIGHT OUTER JOIN</code>は、全ての結合行と、左側テーブルに当てはまるものがなかった右側の行（左側はNULLで拡張されています）の1行ずつを返します。
左右のテーブルを入れ替えれば<code class="literal">LEFT OUTER JOIN</code>に変換できるので、<code class="literal">RIGHT OUTER JOIN</code>は記述上の便宜を図るため用意されているに過ぎません。
       </p><p><code class="literal">FULL OUTER JOIN</code>は、全ての結合行に加え、一致しなかった左側の行（右側はNULLで拡張）、一致しなかった右側の行（左側はNULLで拡張）を全て返します。
       </p></dd><dt><span class="term"><code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code></span></dt><dd><p><em class="replaceable"><code>join_condition</code></em>は、結合においてどの行が一致するかを指定する、<code class="type">boolean</code>型の値を返す式です（<code class="literal">WHERE</code>句に類似しています）。
       </p></dd><dt><span class="term"><code class="literal">USING ( <em class="replaceable"><code>join_column</code></em> [, ...] )</code></span></dt><dd><p><code class="literal">USING ( a, b, ... )</code>という形式の句は<code class="literal">ON left_table.a = right_table.a AND left_table.b = right_table.b ...</code>の省略形です。
また<code class="literal">USING</code>は等価な列の両方ではなく片方のみが結合の出力に含まれることを意味します。
       </p></dd><dt><span class="term"><code class="literal">NATURAL</code></span></dt><dd><p><code class="literal">NATURAL</code>は、2つのテーブル内の同じ名前を持つ列を全て指定した<code class="literal">USING</code>リストの省略形です。
共通の列名がない場合、<code class="literal">NATURAL</code>は<code class="literal">ON TRUE</code>と同等になります。
       </p></dd><dt><span class="term"><code class="literal">LATERAL</code></span></dt><dd><p><code class="literal">LATERAL</code>キーワードを副<code class="command">SELECT</code>の<code class="literal">FROM</code>項目の前に付けることができます。
これにより、副<code class="command">SELECT</code>が<code class="literal">FROM</code>リストの中で前に現れる<code class="literal">FROM</code>項目の列を参照することができます。
（<code class="literal">LATERAL</code>がないと、副<code class="command">SELECT</code>それぞれが個別に評価され、他の<code class="literal">FROM</code>項目とのクロス参照を行うことができません。）
       </p><p><code class="literal">LATERAL</code>を関数を呼び出す<code class="literal">FROM</code>の前に付けることもできます。
しかしこの場合、無意味な単語になります。
関数式はどのような場合でもより前の<code class="literal">FROM</code>項目を参照することができるからです。
       </p><p><code class="literal">LATERAL</code>項目は<code class="literal">FROM</code>の最上位レベルや<code class="literal">JOIN</code>ツリー内に記述することができます。
後者の場合、<code class="literal">JOIN</code>の右辺にあれば、左辺にある任意の項目を参照することができます。
       </p><p><code class="literal">FROM</code>項目が<code class="literal">LATERAL</code>クロス参照を含む場合、評価は次のように行われます。
クロス参照される列を提供する<code class="literal">FROM</code>項目の各行、または、その列を提供する複数の<code class="literal">FROM</code>項目の行集合に対して、
<code class="literal">LATERAL</code>項目は列の行または行集合を使用して評価されます。
結果となる行は、計算された行と通常通り結合されます。
これが各行または列ソーステーブルからの行集合に対して繰り返されます。
       </p><p>列ソーステーブルは<code class="literal">LATERAL</code>項目と<code class="literal">INNER</code>または<code class="literal">LEFT</code>結合されていなければなりません。
さもないと、
<code class="literal">LATERAL</code>項目において各行集合を計算するための行集合が完全に定義することができません。
したがって<code class="literal"><em class="replaceable"><code>X</code></em> RIGHT JOIN LATERAL <em class="replaceable"><code>Y</code></em></code>という式は構文としては有効ですが、実際には<em class="replaceable"><code>Y</code></em>では<em class="replaceable"><code>X</code></em>を参照することができません。
       </p></dd></dl></div><p>
   </p></div><div class="refsect2" id="SQL-WHERE"><h3><code class="literal">WHERE</code>句</h3><p><code class="literal">WHERE</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">WHERE <em class="replaceable"><code>condition</code></em></pre><p>
<em class="replaceable"><code>condition</code></em>は、評価の結果として<code class="type">boolean</code>型を返す任意の式です。
この条件を満たさない行は全て出力から取り除かれます。
全ての変数に実際の行の値を代入して、式が真を返す場合、その行は条件を満たすとみなされます。
   </p></div><div class="refsect2" id="SQL-GROUPBY"><h3><code class="literal">GROUP BY</code>句</h3><p><code class="literal">GROUP BY</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...]</pre><p>
   </p><p><code class="literal">GROUP BY</code>は、グループ化のために与えられた式を評価し、結果が同じ値になった行を1つの行にまとめる機能を持ちます。
<em class="replaceable"><code>grouping_element</code></em>の内側で使われる<em class="replaceable"><code>expression</code></em>には、入力列の名前、出力列（<code class="command">SELECT</code>リスト項目）の名前/序数、あるいは入力列の値から計算される任意の式を取ることができます。
判断がつかない時は、<code class="literal">GROUP BY</code>の名前は出力列名ではなく入力列名として解釈されます。
   </p><p>グループ化の要素として<code class="literal">GROUPING SETS</code>、<code class="literal">ROLLUP</code>、<code class="literal">CUBE</code>のいずれかが指定されている場合、<code class="literal">GROUP BY</code>句は全体でいくつかの独立した<em class="firstterm">グループ化セット</em>を定義します。
この効果は、個々のグループ化セットを<code class="literal">GROUP BY</code>句で定義する副問い合わせを<code class="literal">UNION ALL</code>するのと同等です。
グループ化セットの処理の詳細については、<a class="xref" href="queries-table-expressions.html#QUERIES-GROUPING-SETS" title="7.2.4. GROUPING SETS、CUBE、ROLLUP">Section 7.2.4</a>を参照してください。
   </p><p>集約関数が使用された場合、各グループ内の全ての行を対象に計算が行われ、グループごとに別々の値が生成されます
（集約関数が使われていて<code class="literal">GROUP BY</code>がない場合、その問い合わせは選択された全ての行からなる1つのグループを持つものとして扱われます）。
集約関数の入力となる行の集合は、集約関数の呼び出しに<code class="literal">FILTER</code>句を付けることで、さらに絞り込むことができます。
詳しくは<a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 集約式">Section 4.2.7</a>を参照してください。
<code class="literal">FILTER</code>句があると、その条件に適合する行だけが集約関数の入力行に取り込まれます。
   </p><p><code class="literal">GROUP BY</code>が存在する場合、あるいは集約関数が存在する場合、集約関数内部以外で、グループ化されていない列を参照する、あるいはグループ化されていない列がグループ化された列に関数依存する<code class="command">SELECT</code>リストの式は無効になります。
こうしないとグループ化されていない列について返される値は複数の値になってしまう可能性があるからです。
グループ化された列(またはその部分集合)がグループ化されていない列を含むテーブルの主キーである場合、関数従属性が存在します。
   </p><p>すべての集約関数は、<code class="literal">HAVING</code>句や<code class="literal">SELECT</code>リストのどの<span class="quote">“<span class="quote">スカラー</span>”</span>式よりも先に評価されることに注意してください。
これは例えば、<code class="literal">CASE</code>式を集約関数の評価をスキップするために使うことはできない、ということを意味します。
<a class="xref" href="sql-expressions.html#SYNTAX-EXPRESS-EVAL" title="4.2.14. 式の評価規則">Section 4.2.14</a>を参照してください。
   </p><p>現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">GROUP BY</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-HAVING"><h3><code class="literal">HAVING</code>句</h3><p><code class="literal">HAVING</code>句の一般的な構文は以下の通りです（この句は省略可能です）。
</p><pre class="synopsis">HAVING <em class="replaceable"><code>condition</code></em></pre><p>
<em class="replaceable"><code>condition</code></em>は<code class="literal">WHERE</code>句で指定するものと同じです。
   </p><p><code class="literal">HAVING</code>は、グループ化された行の中で、条件を満たさない行を取り除く機能を持ちます。
<code class="literal">HAVING</code>と<code class="literal">WHERE</code>は次の点が異なります。
<code class="literal">WHERE</code>が、<code class="literal">GROUP BY</code>の適用前に個々の行に対してフィルタを掛けるのに対し、<code class="literal">HAVING</code>は、<code class="literal">GROUP BY</code>の適用後に生成されたグループ化された行に対してフィルタをかけます。
<em class="replaceable"><code>condition</code></em>内で使用する列は、集約関数内で使用される場合とグループ化されない列がグループ化される列に関数依存する場合を除き、グループ化された列を一意に参照するものでなければなりません。
   </p><p><code class="literal">HAVING</code>句があると、<code class="literal">GROUP BY</code>句がなかったとしても問い合わせはグループ化された問い合わせになります。
<code class="literal">GROUP BY</code>句を持たない問い合わせが集約関数を含む場合と同様です。
選択された行はすべて、1つのグループを形成するものとみなされます。また、<code class="command">SELECT</code>リストと<code class="literal">HAVING</code>句では、集約関数が出力するテーブル列しか参照することができません。
こうした問い合わせでは、<code class="literal">HAVING</code>が真の場合には単一の行を、真以外の場合は0行を出力します。
   </p><p>現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">HAVING</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-WINDOW"><h3><code class="literal">WINDOW</code>句</h3><p><code class="literal">WINDOW</code>句(省略可能)の一般的な構文は以下の通りです。
</p><pre class="synopsis">WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...]</pre><p>
ここで<em class="replaceable"><code>window_name</code></em>は、<code class="literal">OVER</code>句やこの後のウィンドウ定義で参照することができる名前です。
また、<em class="replaceable"><code>window_definition</code></em>は以下の通りです。
</p><pre class="synopsis">[ <em class="replaceable"><code>existing_window_name</code></em> ]
[ PARTITION BY <em class="replaceable"><code>expression</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>frame_clause</code></em> ]</pre><p>
   </p><p><em class="replaceable"><code>existing_window_name</code></em>を指定する場合、それは<code class="literal">WINDOW</code>リスト内のそれより前にある項目を参照しなければなりません。
新しいウィンドウはその<code class="literal">PARTITION BY</code>句をその項目からコピーします。
<code class="literal">ORDER BY</code>句があった場合も同様です。
この場合、新しいウィンドウでは独自の<code class="literal">PARTITION BY</code>句を指定することはできません。
また、コピーされたウィンドウが<code class="literal">ORDER BY</code>を持たない場合のみ<code class="literal">ORDER BY</code>を指定することができます。
新しいウィンドウは常に独自のフレーム句を使用します。
コピーされたウィンドウはフレーム句を指定してはなりません。
   </p><p><code class="literal">PARTITION BY</code>リストの要素は<a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>の要素とほとんど同じように解釈されます。
ただし、こちらは常に単純な式であり、出力列の名前や番号ではないことが異なります。
他にも違いがあり、これらの式は、通常の<code class="literal">GROUP BY</code>句では許されない、集約関数を含めることができるという点です。
グループ化および集約処理の後にウィンドウ処理が動作するため、これらでは許されています。
   </p><p>同様に、<code class="literal">ORDER BY</code>リストの要素は<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>の要素とほとんど同じように解釈されます。
ただし、この式は常に単純な式であり、出力列の名前や番号ではないことが異なります。
   </p><p><em class="replaceable"><code>frame_clause</code></em>を指定すると、（すべてではありませんが）フレームに依存するウィンドウ関数用の<em class="firstterm">ウィンドウフレーム</em>を定義できます。
ウィンドウフレームは、問い合わせの各行(<em class="firstterm">現在の行</em>と呼ばれます)に関連する行の集合です。
<em class="replaceable"><code>frame_clause</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">{ RANGE | ROWS } <em class="replaceable"><code>frame_start</code></em>
{ RANGE | ROWS } BETWEEN <em class="replaceable"><code>frame_start</code></em> AND <em class="replaceable"><code>frame_end</code></em></pre><p>

ここで<em class="replaceable"><code>frame_start</code></em>と<em class="replaceable"><code>frame_end</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">UNBOUNDED PRECEDING
<em class="replaceable"><code>value</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>value</code></em> FOLLOWING
UNBOUNDED FOLLOWING</pre><p>

<em class="replaceable"><code>frame_end</code></em>が省略された場合デフォルトで<code class="literal">CURRENT ROW</code>となります。
<em class="replaceable"><code>frame_start</code></em>は<code class="literal">UNBOUNDED FOLLOWING</code>とすることができない、<em class="replaceable"><code>frame_end</code></em>は<code class="literal">UNBOUNDED PRECEDING</code>とすることができない、および、上のリストで<em class="replaceable"><code>frame_end</code></em>の選択を<em class="replaceable"><code>frame_start</code></em>の選択より前に置くことができないという制限があります。
例えば<code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>value</code></em> PRECEDING</code>は許されません。
   </p><p>デフォルトのフレーム化オプションは<code class="literal">RANGE UNBOUNDED PRECEDING</code>です。
これは<code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</code>と同じで、
パーティションの先頭から<code class="literal">ORDER BY</code>順序における現在の行の最後のピア(<code class="literal">ORDER BY</code>が現在の行の同等であるとみなす行、あるいは<code class="literal">ORDER BY</code>がなければすべての行)までのすべての行をフレームとします。
一般的に<code class="literal">UNBOUNDED PRECEDING</code>はフレームがパーティションの先頭から始まることを意味し、同様に<code class="literal">UNBOUNDED FOLLOWING</code>はフレームがパーティションの最終行で終わることを意味します(<code class="literal">RANGE</code>モードか<code class="literal">ROWS</code>かは関係ありません)。
<code class="literal">ROWS</code>モードでは、<code class="literal">CURRENT ROW</code>はフレームが現在の行で始まる、または終わることを意味しますが、<code class="literal">RANGE</code>モードでは、フレームが現在の行の<code class="literal">ORDER BY</code>順序における最初のピアまたは最後のピアで始まる、または終わることを意味します。
現時点では<em class="replaceable"><code>value</code></em> <code class="literal">PRECEDING</code>および<em class="replaceable"><code>value</code></em> <code class="literal">FOLLOWING</code>という場合わけは<code class="literal">ROWS</code>モードだけで許されます。
これらは、現在の行の何行前または何行後にフレームが始まるまたは終わることを示します。
<em class="replaceable"><code>value</code></em>は整数式でなければならず、変数、集約関数、ウィンドウ関数を含めることはできません。
この値はNULLまたは負を取ることはできません。
しかし、現在の行自身を選択するゼロを取ることができます。
   </p><p><code class="literal">ORDER BY</code>順序によりその行を一意に順序付けできない場合、<code class="literal">ROWS</code>が予期できない結果をもたらす可能性があることに注意して下さい。
<code class="literal">RANGE</code>は、<code class="literal">ORDER BY</code>順序におけるピアとなる行が同等に扱われる、つまりすべてのピアは同じフレーム内に両方とも存在することが確実になるように設計されています。
   </p><p><code class="literal">WINDOW</code>句の目的は、問い合わせの<a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECTリスト"><code class="command">SELECT</code>リスト</a>または<a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY句"><code class="literal">ORDER BY</code>句</a>に記載される<em class="firstterm">ウィンドウ関数</em>の動作を規定することです。
これらの関数はその<code class="literal">OVER</code>句において名前で<code class="literal">WINDOW</code>句の項目を参照することができます。
しかし<code class="literal">WINDOW</code>句の項目は他で参照される必要はありません。
問い合わせ内で使用されなかったものは、単に無視されます。
ウィンドウ関数呼び出しは<code class="literal">OVER</code>句でウィンドウ定義を直接規定することができますので、<code class="literal">WINDOW</code>句を全く使わずにウィンドウ関数を使用することができます。
しかし<code class="literal">WINDOW</code>句は、同じウィンドウ定義が複数のウィンドウ関数で必要とされる場合に入力量を省くことができます。
   </p><p>現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">WINDOW</code>と合わせて使うことはできません。
   </p><p>ウィンドウ関数に関する詳細については<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">Section 3.5</a>、<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. ウィンドウ関数呼び出し">Section 4.2.8</a>、<a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. ウィンドウ関数処理">Section 7.2.5</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-SELECT-LIST"><h3><code class="command">SELECT</code>リスト</h3><p><code class="command">SELECT</code>リスト（<code class="literal">SELECT</code>キーワードと<code class="literal">FROM</code>キーワードの間にあるもの）は、<code class="command">SELECT</code>文の出力行を形成する式を指定するものです。
この式では、<code class="literal">FROM</code>句で処理後の列を参照することができます（通常は実際に参照します）。
   </p><p>テーブルの場合と同様に、<code class="command">SELECT</code>の出力列はすべて名前を持ちます。
簡単な<code class="command">SELECT</code>では、この名前は列に表示用のラベルを付けるために使用されるだけです。
しかし<code class="command">SELECT</code>が大規模な問い合わせの副問い合わせである場合、大規模な問い合わせ側で副問い合わせで生成された仮想のテーブルの列名としてこの名前が参照されます。
出力列として使用するための名前を指定するためには、列式の後に<code class="literal">AS</code> <em class="replaceable"><code>output_name</code></em>と記述してください。
（希望する列名が<span class="productname">PostgreSQL</span>のキーワード（<a class="xref" href="sql-keywords-appendix.html" title="Appendix C. SQLキーワード">Appendix C</a>を参照）に一致しない場合にのみ<code class="literal">AS</code>を省略することができます。
将来あり得るキーワードの追加に備えるために、常に<code class="literal">AS</code>を記述する、あるいは、出力名を二重引用符で括ることを推奨します。）
列名を指定しない場合、名前は<span class="productname">PostgreSQL</span>により自動的に付けられます。
列式が単純な列参照であれば、つけられる名前はその列の名前と同じものです。
より複雑な場合では、関数名または型名が使用されるかもしれません。さもなければ<code class="literal">?column?</code>のように生成される名前になるかもしれません。
   </p><p><code class="literal">ORDER BY</code>句と<code class="literal">GROUP BY</code>句内で列の値を参照する時も、出力列名を使用できます。
しかし、<code class="literal">WHERE</code>や<code class="literal">HAVING</code>句では使用できません。これらでは式を書かなければなりません。
   </p><p>リストには、選択された行の全ての列を表す省略形として、式ではなく<code class="literal">*</code>と書くことができます。
また、そのテーブルに由来する列のみを表す省略形として、<code class="literal"><em class="replaceable"><code>table_name</code></em>.*</code>と書くこともできます。
このような場合、<code class="literal">AS</code>により新しい名前を指定することはできません。
出力列名はテーブルの列名と同一になります。
   </p><p>標準SQLによれば、出力リスト内の式は、<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>を適用する前に計算することになっています。
<code class="literal">DISTINCT</code>を使う場合は、これは明らかに必要です。
なぜなら、そうしなければどの値がDISTINCTであるかわからないからです。
しかし、多くの場合、<code class="literal">ORDER BY</code>や<code class="literal">LIMIT</code>の後で出力式を計算する方が便利です。
特に出力式が揮発性(volatile)あるいは高価な式を含んでいる場合はそうです。
この動作により、関数の評価順序はより直感的になり、出力に現れない行については評価されなくなります。
<span class="productname">PostgreSQL</span>では、式が<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>、<code class="literal">GROUP BY</code>の中で参照されていない限り、ソートと制限(limit)の後にそれらの式を実際に評価します。
（この反例として、<code class="literal">SELECT f(x) FROM tab ORDER BY 1</code> では明らかに<code class="function">f(x)</code>をソートの前に評価しなければなりません。）
集合を返す関数を含む出力式は、ソートの後、制限の前に実際の評価が行われ、これにより<code class="literal">LIMIT</code>が集合を返す関数の出力を制限することになります。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>のバージョン9.6より前では、出力式がソートや制限に対して評価されるタイミングについて何の保証もしていませんでした。
それは選択された問い合わせの計画の形式に依存します。
    </p></div></div><div class="refsect2" id="SQL-DISTINCT"><h3><code class="literal">DISTINCT</code>句</h3><p><code class="literal">SELECT DISTINCT</code>が指定されると、重複する行は全て結果セットから削除されます
（重複するグループの中で1行が保持されます）。
<code class="literal">SELECT ALL</code>はこの反対で、全ての行が保持されます。
デフォルトはこちらです。
   </p><p><code class="literal">SELECT DISTINCT ON ( <em class="replaceable"><code>expression</code></em> [, ...] )</code>は指定した式が等しいと評価した各行集合の中で、最初の行のみを保持します。
<code class="literal">DISTINCT ON</code>式は、<code class="literal">ORDER BY</code>（上述）と同じ規則で扱われます。
各集合の<span class="quote">“<span class="quote">最初の行</span>”</span>は、<code class="literal">ORDER BY</code>を使用して目的の行が確実に最初に現れるようにしない限り予測することはできないことに注意してください。
例えば、次の例は各地点の最新の気象情報を取り出します。
</p><pre class="programlisting">SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;</pre><p>
しかし<code class="literal">ORDER BY</code>を使用して各地点を時間によって降順にソートしなければ、各地点について得られる情報がいつのものかはわかりません。
   </p><p><code class="literal">DISTINCT ON</code>に指定する式は<code class="literal">ORDER BY</code>の最も左側の式と一致しなければなりません。
<code class="literal">ORDER BY</code>句は、通常、各<code class="literal">DISTINCT ON</code>グループの中での行の優先順位を決定する追加的な式を含みます。
   </p><p>現在は、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を<code class="literal">DISTINCT</code>と合わせて使うことはできません。
   </p></div><div class="refsect2" id="SQL-UNION"><h3><code class="literal">UNION</code>句</h3><p><code class="literal">UNION</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis"><em class="replaceable"><code>select_statement</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em></pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない任意の<code class="command">SELECT</code>文が入ります
（<code class="literal">ORDER BY</code>と<code class="literal">LIMIT</code>は、括弧で囲めば副式として付与することができます。
括弧がない場合、これらの句は右側に置かれた入力式ではなく、<code class="literal">UNION</code>の結果に対して適用されてしまいます）。
   </p><p><code class="literal">UNION</code>演算子は、2つの<code class="command">SELECT</code>文が返す行の和集合を作成します。
この和集合には、2つの<code class="command">SELECT</code>文の結果集合のいずれか（または両方）に存在する行が全て含まれています。
<code class="literal">UNION</code>の直接のオペランドとなる2つの<code class="command">SELECT</code>文が返す列数は、同じでなければなりません。また、対応する列のデータ型には互換性が存在する必要があります。
   </p><p><code class="literal">ALL</code>オプションが指定されていない限り、<code class="literal">UNION</code>の結果には重複行は含まれません。
<code class="literal">ALL</code>を指定するとこのような重複除去が行われません
（したがって、通常<code class="literal">UNION ALL</code>は<code class="literal">UNION</code>よりかなり高速です。
できれば<code class="literal">ALL</code>を使用してください）。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>1つの<code class="command">SELECT</code>文に複数の<code class="literal">UNION</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
   </p><p>現時点では、<code class="literal">UNION</code>の結果や<code class="literal">UNION</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-INTERSECT"><h3><code class="literal">INTERSECT</code>句</h3><p><code class="literal">INTERSECT</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis"><em class="replaceable"><code>select_statement</code></em> INTERSECT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em></pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない、任意の<code class="command">SELECT</code>文が入ります。
   </p><p><code class="literal">INTERSECT</code>は、2つの<code class="command">SELECT</code>文が返す行の積集合を計算します。
この積集合に含まれるのは、2つの<code class="command">SELECT</code>文の結果集合の両方に存在する行です。
   </p><p><code class="literal">ALL</code>オプションを指定しない限り、<code class="literal">INTERSECT</code>の結果に重複行は含まれません。
<code class="literal">ALL</code>が指定された場合、左側テーブルに<em class="replaceable"><code>m</code></em>個、右側テーブルに<em class="replaceable"><code>n</code></em>個の重複がある行は、結果集合ではmin(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>1つの<code class="command">SELECT</code>文に複数の<code class="literal">INTERSECT</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<code class="literal">INTERSECT</code>は<code class="literal">UNION</code>よりも強い結び付きを持ちます。
つまり、<code class="literal">A UNION B INTERSECT C</code> は<code class="literal">A UNION (B INTERSECT C)</code>と解釈されます。
   </p><p>現時点では、<code class="literal">INTERSECT</code>の結果や<code class="literal">INTERSECT</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-EXCEPT"><h3><code class="literal">EXCEPT</code>句</h3><p><code class="literal">EXCEPT</code>句の一般的な構文は以下の通りです。
</p><pre class="synopsis"><em class="replaceable"><code>select_statement</code></em> EXCEPT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em></pre><p><em class="replaceable"><code>select_statement</code></em>には、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>句を持たない、任意の<code class="command">SELECT</code>文が入ります。
   </p><p><code class="literal">EXCEPT</code>は、左側の<code class="command">SELECT</code>文の結果には存在し、右側の<code class="command">SELECT</code>文の結果には存在しない行の集合を生成します。
   </p><p><code class="literal">ALL</code>オプションが指定されていない限り、<code class="literal">EXCEPT</code>の結果には重複行は含まれません。
<code class="literal">ALL</code>がある場合、左側テーブルに<em class="replaceable"><code>m</code></em>個、右側テーブルに<em class="replaceable"><code>n</code></em>個の重複がある行は、結果集合ではmax(<em class="replaceable"><code>m</code></em>-<em class="replaceable"><code>n</code></em>,0)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<code class="literal">DISTINCT</code>を記述することができます。
   </p><p>1つの<code class="command">SELECT</code>文に複数の<code class="literal">EXCEPT</code>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<code class="literal">EXCEPT</code>の結び付きの強さは<code class="literal">UNION</code>と同じです。
   </p><p>現時点では、<code class="literal">EXCEPT</code>の結果や<code class="literal">EXCEPT</code>に対する入力に、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>または<code class="literal">FOR KEY SHARE</code>を指定することはできません。
   </p></div><div class="refsect2" id="SQL-ORDERBY"><h3><code class="literal">ORDER BY</code>句</h3><p><code class="literal">ORDER BY</code>句の一般的な構文は以下の通りです（この句は省略可能です）。

</p><pre class="synopsis">ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...]</pre><p>
<code class="literal">ORDER BY</code>句を使うと、結果行を指定した式（複数可）に従ってソートすることができます。
最も左側の式を使って比較した結果、2つの行が等しいと判断された場合は、1つ右側の式を使って比較します。その結果も等しければ、さらに次の式に進みます。
指定した全ての式で等しいと判断された場合は、実装に依存した順番で返されます。
   </p><p><em class="replaceable"><code>expression</code></em>には、出力列（<code class="command">SELECT</code>リスト項目）の名前または序数、あるいは入力列値から形成される任意の式を取ることができます。
   </p><p>序数は、出力列の位置（左から右に割り当てられます）を示します。
これを使うと、一意な名前を持たない列の順序を定義することができます。
<code class="literal">AS</code>句を使用すれば出力列に名前を割り当てることができるので、これはどうしても必要な機能というわけではありません。
   </p><p>また、<code class="literal">ORDER BY</code>句には、<code class="command">SELECT</code>出力リストに出現しない列を含む、任意の式を使用できます。
したがって、以下の文は有効です。
</p><pre class="programlisting">SELECT name FROM distributors ORDER BY code;</pre><p>
ただし、<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>の結果に<code class="literal">ORDER BY</code>を適用する場合は、式は使用できず、出力列の名前か序数のみを指定できるという制限があります。
   </p><p><code class="literal">ORDER BY</code>の式として出力列名と入力列名の両方に一致する単なる名前が与えられた場合、<code class="literal">ORDER BY</code>はそれを出力列名として扱います。
これは、同じ状況における<code class="literal">GROUP BY</code>の選択とは反対です。
この不整合は、標準SQLとの互換性を保持するために発生しています。
   </p><p><code class="literal">ORDER BY</code>中の任意の式の後に、キーワード<code class="literal">ASC</code>（昇順）、<code class="literal">DESC</code>（降順）を付加することができます(省略可能)。
指定がなければ、デフォルトで<code class="literal">ASC</code>があるものとして扱われます。
その他、順序を指定する演算子名を<code class="literal">USING</code>句に指定する方法もあります。
順序指定演算子は何らかのB-Tree演算子族の小なりまたは大なり演算子でなければなりません。
通常、<code class="literal">ASC</code>は<code class="literal">USING &lt;</code>と、<code class="literal">DESC</code>は<code class="literal">USING &gt;</code>と同じです
（ただし、ユーザ定義データ型の作成時には、デフォルトのソート順を定義することができます。また、異なる名前の演算子と対応付けすることもできます）。
   </p><p><code class="literal">NULLS LAST</code>が指定されると、NULL値はすべての非NULL値の後にソートされます。
<code class="literal">NULLS FIRST</code>が指定されると、NULL値はすべての非NULL値の前にソートされます。
どちらも指定されない場合のデフォルト動作は、明示的あるいは暗黙的な<code class="literal">ASC</code>の場合は<code class="literal">NULLS LAST</code>、<code class="literal">DESC</code>が指定された場合は<code class="literal">NULLS FIRST</code>です。
（したがって、デフォルトでは、NULLが非NULLよりも大きい値であるかのように動作します。）
<code class="literal">USING</code>が指定されると、デフォルトのNULLの順序は、演算子が小なり演算子か大なり演算子によって変わります。
   </p><p>順序付けオプションは直前の演算子にのみ適用されます。
たとえば、<code class="literal">ORDER BY x, y DESC</code>は<code class="literal">ORDER BY x DESC, y DESC</code>と同一の意味ではありません。
   </p><p>文字型データでは、格納する列に適用された照合順序に従ってソートされます。
これは必要に応じて<em class="replaceable"><code>expression</code></em>内に<code class="literal">COLLATE</code>句を含めることで上書きできます。
例えば<code class="literal">ORDER BY mycolumn COLLATE "en_US"</code>です。
より詳細については<a class="xref" href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS" title="4.2.10. 照合順序式">Section 4.2.10</a>および<a class="xref" href="collation.html" title="23.2. 照合順序サポート">Section 23.2</a>を参照してください。
   </p></div><div class="refsect2" id="SQL-LIMIT"><h3><code class="literal">LIMIT</code>句</h3><p><code class="literal">LIMIT</code>句は2つの独立した副句から構成されます。
</p><pre class="synopsis">LIMIT { <em class="replaceable"><code>count</code></em> | ALL }
OFFSET <em class="replaceable"><code>start</code></em></pre><p>
<em class="replaceable"><code>count</code></em>には返される行の最大数を、一方、<em class="replaceable"><code>start</code></em>には行を返し始める前に飛ばす行数を指定します。
両方とも指定された場合、<em class="replaceable"><code>start</code></em>行分が飛ばされ、そこから数えて<em class="replaceable"><code>count</code></em>行が返されます。
   </p><p><em class="replaceable"><code>count</code></em>式がNULLと評価された場合、<code class="literal">LIMIT ALL</code>として、つまり制限無しとして扱われます。
<em class="replaceable"><code>start</code></em>がNULLと評価された場合、<code class="literal">OFFSET 0</code>と同様に扱われます。
   </p><p>SQL:2008では同じ結果を実現する異なる構文が導入されました。
<span class="productname">PostgreSQL</span>でもサポートしています。
以下の構文です。
</p><pre class="synopsis">OFFSET <em class="replaceable"><code>start</code></em> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY</pre><p>
この構文において、<em class="replaceable"><code>start</code></em>または<em class="replaceable"><code>count</code></em>に単一整数定数以外を記述するためには、括弧でくくって記述しなければなりません。
<em class="replaceable"><code>count</code></em>を<code class="literal">FETCH</code>句で省略した場合、そのデフォルトは１です。
<code class="literal">ROW</code>および<code class="literal">ROWS</code>、そして<code class="literal">FIRST</code>および<code class="literal">NEXT</code>は意味がない単語で、この句に影響を与えることはありません。
標準に従うと<code class="literal">OFFSET</code>句は、<code class="literal">FETCH</code>句と同時に使用する場合、これより前に存在しなければなりません。
しかし<span class="productname">PostgreSQL</span>は厳密ではなく、どちらが先でも許されます。
   </p><p><code class="literal">LIMIT</code>を使う時は、結果行を一意な順番に強制する<code class="literal">ORDER BY</code>句を使うとよいでしょう。
そうしないと、問い合わせ結果のどの部分が返されるのかがわかりません。
10〜20行目までを出力するとしても、どの順番で並べた時の10〜20行目なのでしょうか。
<code class="literal">ORDER BY</code>を指定しない限り、行が返される順番は不明です。
   </p><p>問い合わせプランナは問い合わせ計画を作成する時に<code class="literal">LIMIT</code>を考慮するので、<code class="literal">LIMIT</code>と<code class="literal">OFFSET</code>の指定によって異なった計画を得ることになるでしょう。計画が異なれば、異なる順番で行が返ります。
したがって、<code class="literal">LIMIT</code>/<code class="literal">OFFSET</code>値の変更によって異なる結果行を選択しようとすると、<code class="literal">ORDER BY</code>で順序を並び替えない限り、<span class="emphasis"><em>矛盾した結果を返すことになります</em></span>。
これはバグではありません。
「SQLは、<code class="literal">ORDER BY</code>で順序を制御されない限り、問い合わせ結果が返す順序を約束しない」という事実の当然の帰結なのです。
   </p><p>厳密的に部分集合の選択を強制する<code class="literal">ORDER BY</code>がなければ、同じ<code class="literal">LIMIT</code>問い合わせを繰り返し実行してもテーブル行から異なる部分集合が取り出される可能性すらあります。
繰り返しますが、これは不具合ではありません。
こうした場合に確定した結果は単に保証されていないのです。
   </p></div><div class="refsect2" id="SQL-FOR-UPDATE-SHARE"><h3>ロック処理句</h3><p><code class="literal">FOR UPDATE</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>および<code class="literal">FOR KEY SHARE</code>は<em class="firstterm">ロック処理句</em>です。
これらはテーブルから行を入手する時にどのように<code class="literal">SELECT</code>がその行をロックするかに影響します。
   </p><p>ロック処理句の一般的な構文は以下の通りです。

</p><pre class="synopsis">FOR <em class="replaceable"><code>lock_strength</code></em> [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ]</pre><p>

ここで<em class="replaceable"><code>lock_strength</code></em>は以下のいずれかを取ることができます。

</p><pre class="synopsis">UPDATE
NO KEY UPDATE
SHARE
KEY SHARE</pre><p>
   </p><p>それぞれの行レベルロックモードについての詳しい説明は<a class="xref" href="explicit-locking.html#LOCKING-ROWS" title="13.3.2. 行レベルロック">Section 13.3.2</a>を参照してください。
   </p><p>他のトランザクションのコミットを待機することなく操作を進めるには、<code class="literal">NOWAIT</code>あるいは<code class="literal">SKIP LOCKED</code>オプションを使用してください。
<code class="literal">NOWAIT</code>では、選択行のロックを即座に獲得できない時、文は待機せずに、エラーを報告します。
<code class="literal">SKIP LOCKED</code>では、即座にロックできない行はすべてスキップされます。
行のロックをスキップすると、一貫性のないデータが見えることになるので、一般的な目的の作業のためには適しませんが、複数の消費者がキューのようなテーブルにアクセスするときのロック競合の回避などに利用できます。
<code class="literal">NOWAIT</code>および<code class="literal">SKIP LOCKED</code>は行レベルロックにのみに適用される点に注意してください。
つまり、必要な<code class="literal">ROW SHARE</code>テーブルレベルロックは通常通りの方法（ <a class="xref" href="mvcc.html" title="Chapter 13. 同時実行制御">Chapter 13</a>を参照）で獲得されます。
もし、テーブルレベルのロックを待機せずに獲得しなければならないのであれば、最初に<a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>の<code class="literal">NOWAIT</code>オプションを使用してください。
   </p><p>ロック処理句内に特定のテーブルが指定されている場合は、そのテーブルの行のみがロックされます。
<code class="command">SELECT</code>内の他のテーブルは通常通りに読み込まれます。
テーブルリストを持たないロック処理句は、その文で使用されるすべてのテーブルに影響を与えます。
ロック処理句がビューまたは副問い合わせで使用された場合、そのビューや副問い合わせで使用されるすべてのテーブルに影響を与えます。
しかしこれらの句は主問い合わせで参照される<code class="literal">WITH</code>問い合わせには適用されません。
<code class="literal">WITH</code>問い合わせ内での行ロックを行いたい場合は、<code class="literal">WITH</code>問い合わせ内でロック処理句を指定してください。
   </p><p>異なるロック方式を異なるテーブルに指定する必要があれば、複数のロック処理句を記述することができます。
複数のロック処理句で同一のテーブルを記述した（または暗黙的に影響が与えられた）場合、最も強いものだけが指定されたかのように処理されます。
同様に、あるテーブルに影響を与える句のいずれかで<code class="literal">NOWAIT</code>が指定された場合、そのテーブルは<code class="literal">NOWAIT</code>として処理されます。
それ以外の場合、あるテーブルに影響を与える句のいずれかで<code class="literal">SKIP LOCKED</code>が指定されていれば、そのテーブルは<code class="literal">SKIP LOCKED</code>として処理されます。
   </p><p>ロック処理句は、返される行がテーブルのどの行に対応するのかが明確に識別できない場合には使用することができません。
例えば、集約には使用できません。
   </p><p>ロック処理句が<code class="command">SELECT</code>問い合わせの最上位レベルに存在する場合、ロック対象行は問い合わせが返す行に正確に一致します。
結合問い合わせ内の場合、ロック対象行は返される結合行に関連する行となります。
さらに、スナップショットを更新した後に問い合わせ条件を満たさなくなった場合は返されなくなりますが、問い合わせのスナップショット時点で問い合わせ条件を満たす行もロックされます。
<code class="literal">LIMIT</code>が使用された場合、制限を満たす行が返されるとロック処理は止まります。
（しかし、<code class="literal">OFFSET</code>により飛ばされた行はロックされることに注意してください。）
同様に、ロック処理句がカーソル問い合わせで使用された場合、カーソルにより実際に取り込んだ行または通り過ぎた行のみがロックされます。
   </p><p>ロック処理句が副<code class="command">SELECT</code>に存在する場合、ロック対象行は副問い合わせの外側の問い合わせに返される行となります。
外側の問い合わせからの条件が副問い合わせ実行の最適化に使用される可能性がありますので、これには副問い合わせ自体の検査が提示する行より少なくなるかもしれません。
例えば、
</p><pre class="programlisting">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;</pre><p>
は、副問い合わせ内では文字として条件が記載されていなくても、<code class="literal">col1 = 5</code>を持つ行のみがロックされます。
   </p><p>以前のリリースでは、セーブポイント以降に更新されるロックの保持は失敗しました。
例えば以下のコードです。
</p><pre class="programlisting">BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;</pre><p>
<code class="command">ROLLBACK TO</code>後の<code class="literal">FOR UPDATE</code>ロックの保持に失敗します。
これはリリース9.3で修正されました。
  </p><div class="caution"><h3 class="title">Caution</h3><p><code class="literal">ORDER BY</code>句とロック処理句を使用した、<code class="literal">READ COMMITTED</code>トランザクション隔離レベルで実行する<code class="command">SELECT</code>コマンドでは、順序通りにならない行を返す可能性があります。
<code class="literal">ORDER BY</code>が最初に適用されるためです。
このコマンドは結果をソートしますが、その後、1行または複数の行のロック獲得がブロックされる可能性があります。
この<code class="literal">SELECT</code>のブロックが解除された時点で、順序付け対象の列値の一部が変更されているかもしれません。
これによりこうした行が（元の列値という観点では順序通りではありますが、）順序通りに現れません。
必要に応じて、これは以下のように副問い合わせ内に<code class="literal">FOR UPDATE/SHARE</code>句を記述することで、回避することができます。
</p><pre class="programlisting">SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;</pre><p>
最上位レベルにおける<code class="literal">FOR UPDATE</code>は実際に返される行のみをロックするのに対して、これは結果として<code class="structname">mytable</code>のすべての行をロックすることに注意してください。
これは、特に<code class="literal">ORDER BY</code>が<code class="literal">LIMIT</code>やその他の制限と組み合わせている場合、性能上大きな違いを生み出す可能性があります。
このため、この技法は、順序付け対象の列に対する同時実行の更新が想定され、かつ、厳密にソートされた結果が要求される場合にのみ推奨されます。
   </p><p><code class="literal">REPEATABLE READ</code>または<code class="literal">SERIALIZABLE</code>トランザクション隔離レベルでは、（<code class="literal">'40001'</code>という<code class="literal">SQLSTATE</code>を持つ）シリアライゼーション失敗が発生します。
このためこれらの隔離レベルでは順序通りでない行を受け取る可能性はありません。
   </p></div></div><div class="refsect2" id="SQL-TABLE"><h3><code class="literal">TABLE</code>コマンド</h3><pre class="programlisting">TABLE <em class="replaceable"><code>name</code></em></pre><p>
というコマンドは以下と同じです。
</p><pre class="programlisting">SELECT * FROM <em class="replaceable"><code>name</code></em></pre><p>
これは、最上位のコマンドとして、あるいは複雑な問い合わせの一部として、入力を省略する構文の一種としても使用することができます。
<code class="literal">WITH</code>、<code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>、<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">OFFSET</code>、<code class="literal">FETCH</code>、<code class="literal">FOR</code>のロック句だけを<code class="command">TABLE</code>と一緒に使うことができます。
<code class="literal">WHERE</code>句およびいかなる形式の集約も使うことはできません。
   </p></div></div><div class="refsect1" id="id-1.9.3.165.9"><h2>例</h2><p><code class="literal">films</code>テーブルを<code class="literal">distributors</code>テーブルと結合します。

</p><pre class="programlisting">SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...</pre><p>
  </p><p>全ての映画の<code class="literal">len</code>列を合計し<code class="literal">kind</code>列によって結果をグループ化します。

</p><pre class="programlisting">SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38</pre><p>
  </p><p>全ての映画の<code class="literal">len</code>列を合計し<code class="literal">kind</code>列によって結果をグループ化し、合計が5時間より少ないグループの合計を表示します。

</p><pre class="programlisting">SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38</pre><p>
  </p><p>次に、結果を2番目の列（<code class="literal">name</code>）の内容に基づいてソートする方法を2つ例示します。

</p><pre class="programlisting">SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward</pre><p>
  </p><p>次の例は、<code class="literal">distributors</code>テーブルと<code class="literal">actors</code>テーブルの和集合を取得する方法を示しています。さらに、両方のテーブルで結果をWという文字で始まる行のみに限定しています。
重複しない行のみが必要なので、<code class="literal">ALL</code>キーワードは省略されています。

</p><pre class="programlisting">distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen</pre><p>
  </p><p>次に、<code class="literal">FROM</code>句内での関数の使用方法について、列定義リストがある場合とない場合の両方の例を示します。

</p><pre class="programlisting">CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney</pre><p>
  </p><p>以下は序数列が追加された関数の例です。

</p><pre class="programlisting">SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)</pre><p>
  </p><p>以下の例では簡単な<code class="literal">WITH</code>句の使用方法を示します。

</p><pre class="programlisting">WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422</pre><p>

<code class="literal">WITH</code>問い合わせが一度だけ評価されることに注意してください。
このため3つのランダムな値の同じ集合2組を得ることになります。
  </p><p>以下の例では<code class="literal">WITH RECURSIVE</code>を使用して、直接の部下しか表示しないテーブルから、従業員Maryの（直接または間接的な）部下とその間接度を見つけ出します。

</p><pre class="programlisting">WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;</pre><p>

初期条件、続いて<code class="literal">UNION</code>、さらに問い合わせの再帰部分という再帰問い合わせの典型的な構文に注意してください。
問い合わせの再帰部分は最終的にはタプルを返さないことを確実にしてください。
さもないと問い合わせは無限にループします。
（より多くの例については<a class="xref" href="queries-with.html" title="7.8. WITH問い合わせ（共通テーブル式）">Section 7.8</a>を参照してください。）
  </p><p>以下の例では、<code class="structname">manufacturers</code>テーブルの各行に対して集合を返す<code class="function">get_product_names()</code>関数を適用するために<code class="literal">LATERAL</code>を使用します。

</p><pre class="programlisting">SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;</pre><p>

これは内部結合ですので、現時点で製品をまったく持たないメーカは結果に現れません。
こうしたメーカの名前も結果に含めたければ以下のようにします。

</p><pre class="programlisting">SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;</pre></div><div class="refsect1" id="id-1.9.3.165.10"><h2>互換性</h2><p>当然ながら、<code class="command">SELECT</code>文は標準SQLと互換性があります。
しかし、拡張機能や実現されていない機能もいくつかあります。
  </p><div class="refsect2" id="id-1.9.3.165.10.3"><h3><code class="literal">FROM</code>句の省略</h3><p><span class="productname">PostgreSQL</span>では、<code class="literal">FROM</code>句を省略することができます。
これによって、以下のように単純な式を計算させることができます。
</p><pre class="programlisting">SELECT 2+2;

 ?column?
----------
        4</pre><p>
他の<acronym class="acronym">SQL</acronym>データベースでは、このような<code class="command">SELECT</code>を行うためにはダミーの1行テーブルを使わなければならないものもあります。
   </p><p><code class="literal">FROM</code>句の指定がない場合、問い合わせではデータベーステーブルを参照することができません。
例えば、以下の問い合わせは無効です。
</p><pre class="programlisting">SELECT distributors.* WHERE distributors.name = 'Westward';</pre><p>
<span class="productname">PostgreSQL</span>リリース8.1より前まででは、こうした形の問い合わせを受け付け、問い合わせで参照する各テーブルに対する暗黙的な項目を問い合わせの<code class="literal">FROM</code>句に追加していました。
これは許されなくなりました。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.4"><h3>空の<code class="literal">SELECT</code>リスト</h3><p><code class="literal">SELECT</code>の後の出力式のリストは空でも良く、このとき列数がゼロの結果テーブルが生成されます。
これは標準SQLでは有効な構文ではありませんが、<span class="productname">PostgreSQL</span>は列数がゼロのテーブルを許すので、それと整合性を保つために許しています。
しかし、<code class="literal">DISTINCT</code>を使う時は、空のリストを使うことはできません。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.5"><h3><code class="literal">AS</code>キーワードの省略</h3><p>標準SQLでは、キーワード<code class="literal">AS</code>(省略可能)は、新しい列名が有効な列名（つまり予約済みのどのキーワードとも異なるもの）である場合は常に、出力列名の前から省くことができます。
<span class="productname">PostgreSQL</span>には多少より強い制限があります。
新しい列名が予約済みか否かに関わらず何らかのキーワードに一致する場合は<code class="literal">AS</code>が必要です。
推奨する実践方法は、今後のキーワードの追加と競合する可能性に備え、<code class="literal">AS</code>を使用する、または出力列名を二重引用符で括ることです。
   </p><p><code class="literal">FROM</code>項目において標準および<span class="productname">PostgreSQL</span>では、未予約のキーワードである別名の前の<code class="literal">AS</code>を省略することができます。
しかし、構文があいまいになるため、出力名では実践的ではありません。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.6"><h3><code class="literal">ONLY</code>と継承関係</h3><p>標準SQLでは、<code class="literal">SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</code>のように、<code class="literal">ONLY</code>を記述する時にテーブル名の前後を括弧でくくることを要求します。
<span class="productname">PostgreSQL</span>ではこの括弧を省略可能であるとみなしています。
   </p><p><span class="productname">PostgreSQL</span>では最後に<code class="literal">*</code>を付けることで
明示的に子テーブルを含めるという<code class="literal">ONLY</code>ではない動作を指定することができます。
標準ではこれを許していません。
   </p><p>（これらの点は<code class="literal">ONLY</code>オプションをサポートするすべてのSQLコマンドで同様に適用されます。）
   </p></div><div class="refsect2" id="id-1.9.3.165.10.7"><h3><code class="literal">TABLESAMPLE</code>句の制限</h3><p>現在のところ、<code class="literal">TABLESAMPLE</code>句は通常のテーブルとマテリアライズドビューでのみ受け付けられます。
SQL標準では、<code class="literal">FROM</code>句の任意の要素について適用可能であるべきとされています。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.8"><h3><code class="literal">FROM</code>内の関数呼び出し</h3><p><span class="productname">PostgreSQL</span>では、<code class="literal">FROM</code>リストのメンバとして直接関数呼び出しを記述することができます。
標準SQLではこうした関数呼び出しを副<code class="command">SELECT</code>内に囲む必要があります。
つまり<code class="literal">FROM <em class="replaceable"><code>func</code></em>(...) <em class="replaceable"><code>alias</code></em></code>はおおよそ<code class="literal">FROM LATERAL (SELECT <em class="replaceable"><code>func</code></em>(...)) <em class="replaceable"><code>alias</code></em></code>と同じです。
暗黙的に<code class="literal">LATERAL</code>であるとみなされることに注意してください。
標準では<code class="literal">FROM</code>内の<code class="literal">UNNEST()</code>項目には<code class="literal">LATERAL</code>構文を必要とするためです。
<span class="productname">PostgreSQL</span>では<code class="literal">UNNEST()</code>を他の集合を返す関数と同じものとして扱います。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.9"><h3><code class="literal">GROUP BY</code>と<code class="literal">ORDER BY</code>における利用可能な名前空間</h3><p>標準SQL-92では、<code class="literal">ORDER BY</code>句で使用できるのは、出力列名か序数のみであり、<code class="literal">GROUP BY</code>句で使用できるのは、入力列名からなる式のみです。
<span class="productname">PostgreSQL</span>は、これらの句で両方が指定できるように拡張されています
（ただし、不明瞭さがある場合は標準の解釈が使用されます）。
さらに、<span class="productname">PostgreSQL</span>ではどちらの句にも任意の式を指定できます。
式で使われる名前は、常に出力列名ではなく入力列の名前とみなされることに注意してください。
   </p><p>SQL:1999以降では、SQL-92と完全には上位互換でない、多少異なる定義が採用されています。
しかし、ほとんどの場合、<span class="productname">PostgreSQL</span>はSQL:1999と同じ方法で<code class="literal">ORDER BY</code>や<code class="literal">GROUP BY</code>を解釈します。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.10"><h3>関数従属性</h3><p>テーブルの主キーが<code class="literal">GROUP BY</code>リストに含まれる場合に限り、<span class="productname">PostgreSQL</span>は（<code class="literal">GROUP BY</code>で列を省くことができる）関数従属性を認識します。
標準SQLでは、認識しなければならない追加の条件を規定しています。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.11"><h3><code class="literal">WINDOW</code>句の制限</h3><p>標準SQLではウィンドウ用の<em class="replaceable"><code>frame_clause</code></em>に追加のオプションを提供します。
現在の<span class="productname">PostgreSQL</span>では上述のオプションのみをサポートします。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.12"><h3><code class="literal">LIMIT</code>および<code class="literal">OFFSET</code></h3><p><code class="literal">LIMIT</code>および<code class="literal">OFFSET</code>句は<span class="productname">PostgreSQL</span>独自の構文ですが、<span class="productname">MySQL</span>でも使用されています。
<a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT句"><code class="literal">LIMIT</code>句</a>で説明したように、標準SQL:2008にて同じ機能の<code class="literal">OFFSET ... FETCH {FIRST|NEXT} ...</code>が導入されました。
この構文は<span class="productname">IBM DB2</span>でも使用されています。
（<span class="productname">Oracle</span>用に開発されたアプリケーションでは、これらの句の機能を実装するために自動生成される<code class="literal">rownum</code>列を含めるという回避策を使用することが多いですが、PostgreSQLでは利用できません。）
   </p></div><div class="refsect2" id="id-1.9.3.165.10.13"><h3><code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code></h3><p><code class="literal">FOR UPDATE</code>は標準SQLに存在しますが、標準では、<code class="command">DECLARE CURSOR</code>のオプションとしてしか許されていません。
<span class="productname">PostgreSQL</span>では、副<code class="command">SELECT</code>など任意の<code class="command">SELECT</code>で許されます。
これは拡張です。
<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code>の亜種、および<code class="literal">NOWAIT</code>と<code class="literal">SKIP LOCKED</code>オプションは標準にはありません。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.14"><h3><code class="literal">WITH</code>内のデータ変更文</h3><p><span class="productname">PostgreSQL</span>では<code class="literal">WITH</code>問い合わせとして<code class="command">INSERT</code>、<code class="command">UPDATE</code>および<code class="command">DELETE</code>を使用することができます。
これは標準SQLにはありません。
   </p></div><div class="refsect2" id="id-1.9.3.165.10.15"><h3>非標準句</h3><p><code class="literal">DISTINCT ON ( ... )</code>は標準SQLの拡張です。
   </p><p><code class="literal">ROWS FROM( ... )</code>は標準SQLの拡張です。
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-security-label.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-selectinto.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">SECURITY LABEL </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> SELECT INTO</td></tr></table></div></body></html>