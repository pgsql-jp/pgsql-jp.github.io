<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE POLICY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createopfamily.html" title="CREATE OPERATOR FAMILY" /><link rel="next" href="sql-createpublication.html" title="CREATE PUBLICATION" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE POLICY</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createopfamily.html" title="CREATE OPERATOR FAMILY">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createpublication.html" title="CREATE PUBLICATION">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATEPOLICY"><div class="titlepage"></div><a id="id-1.9.3.72.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE POLICY</span></h2><p>CREATE POLICY — テーブルに新しい行単位のセキュリティポリシーを定義する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE POLICY <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table_name</code></em>
    [ AS { PERMISSIVE | RESTRICTIVE } ]
    [ FOR { ALL | SELECT | INSERT | UPDATE | DELETE } ]
    [ TO { <em class="replaceable"><code>role_name</code></em> | PUBLIC | CURRENT_USER | SESSION_USER } [, ...] ]
    [ USING ( <em class="replaceable"><code>using_expression</code></em> ) ]
    [ WITH CHECK ( <em class="replaceable"><code>check_expression</code></em> ) ]</pre></div><div class="refsect1" id="id-1.9.3.72.5"><h2>説明</h2><p><code class="command">CREATE POLICY</code>はテーブルに新しい行単位のセキュリティポリシーを定義します。
作成したポリシーを適用するには、（<code class="command">ALTER TABLE ... ENABLE ROW LEVEL SECURITY</code>を使って）テーブルの行単位セキュリティを有効にしなければならないことに注意して下さい。
  </p><p>ポリシーは、それを定義する式にマッチした行をselect/insert/update/deleteする権限を与えます。
テーブルの既存の行は<code class="literal">USING</code>で指定した式によって検査されます。
<code class="literal">INSERT</code>または<code class="literal">UPDATE</code>によって作成される新しい行は<code class="literal">WITH CHECK</code>で指定した式によって検査されます。
ある行について<code class="literal">USING</code>式がtrueを返した場合、その行はユーザに可視となりますが、falseまたはnullを返した場合は不可視となります。
行に対して<code class="literal">WITH CHECK</code>式がtrueを返した場合、その行は挿入または更新されますが、falseまたはnullを返した場合はエラーが発生します。
  </p><p><code class="command">INSERT</code>文および<code class="command">UPDATE</code>文では、<code class="literal">BEFORE</code>トリガーが実行された後で、かつ、実際のデータ更新が行われるより前に<code class="literal">WITH CHECK</code>式が実行されます。
従って、<code class="literal">BEFORE ROW</code>トリガーは挿入されるデータを変更する場合があり、これはセキュリティポリシーの検査の結果に影響を与えます。
<code class="literal">WITH CHECK</code>式は他のいかなる制約よりも前に実行されます。
  </p><p>ポリシー名はテーブル毎につけられます。
従って、1つのポリシー名を多くの異なるテーブルに使うことができます。
また、その定義は各テーブル毎に異なった、適切な内容にできます。
  </p><p>ポリシーは特定のコマンドまたは特定のロールに対して適用することができます。
新しく作成するポリシーのデフォルトは、特に指定しなければ、すべてのコマンドとロールに適用、となっています。
複数のポリシーを単一のコマンドに適用できます。
更なる詳細は以下を参照ください。
<a class="xref" href="sql-createpolicy.html#SQL-CREATEPOLICY-SUMMARY" title="Table 240. コマンドタイプにより適用されるポリシー">Table 240</a>に、どのようにして、特定のコマンドに異なるタイプのポリシーが適用されるかがまとめられています。
  </p><p><code class="literal">USING</code>式と<code class="literal">WITH CHECK</code>式の両方を持つことができるポリシー（<code class="literal">ALL</code>と<code class="literal">UPDATE</code>）について<code class="literal">WITH CHECK</code>式が定義されていない場合、どの行が可視であるかの決定（通常の<code class="literal">USING</code>の対象）と新しい行のどれが追加可能であるかの決定（<code class="literal">WITH CHECK</code>の対象）の両方で<code class="literal">USING</code>式が使用されます。
  </p><p>テーブルの行単位セキュリティが有効で、適用可能なポリシーが存在しない場合、<span class="quote">“<span class="quote">デフォルト拒否</span>”</span>のポリシーが適用され、すべての行が不可視で更新不能になります。
  </p></div><div class="refsect1" id="id-1.9.3.72.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>作成するポリシーの名前です。
同じテーブルの他のポリシーとは異なる名前でなければなりません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>ポリシーが適用されるテーブルの名前（スキーマ修飾可）です。
     </p></dd><dt><span class="term"><code class="literal">PERMISSIVE</code></span></dt><dd><p>作成するポリシーが許容(permissive)ポリシーであることを指定します。
問い合わせに適用可能なすべての許容ポリシーは論理演算子<span class="quote">“<span class="quote">OR</span>”</span>を使って結合されます。
許容ポリシーを作成することで、管理者はアクセス可能なレコード集合を追加することができます。
デフォルトではポリシーは許容ポリシーです。
     </p></dd><dt><span class="term"><code class="literal">RESTRICTIVE</code></span></dt><dd><p>作成するポリシーが制限(restrictive)ポリシーであることを指定します。
問い合わせに適用可能なすべての制限ポリシーは論理演算子<span class="quote">“<span class="quote">AND</span>”</span>と使って結合されます。
各行についてすべての制限ポリシーを満たさなければならなくなるため、制限ポリシーを作成することで、管理者はアクセス可能なレコード集合を減らすことができます。
     </p><p>制限ポリシーを有効に使ってアクセスを制限できるようにする前に、レコードへのアクセスを許可する許容ポリシーが少なくとも1つ必要であることに注意してください。
制限ポリシーだけしか存在しない場合、レコードにアクセスすることはできません。
許容ポリシーと制限ポリシーが混在している場合、少なくとも1つの許容ポリシーを満たし、さらに、すべての制限ポリシーを満たしている場合のみレコードにアクセスできます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>command</code></em></span></dt><dd><p>ポリシーが適用されるコマンドです。
有効なオプションは<code class="command">ALL</code>、<code class="command">SELECT</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>です。
デフォルトは<code class="command">ALL</code>です。
これらがどのように適用されるかの詳細は以下を参照して下さい。
     </p></dd><dt><span class="term"><em class="replaceable"><code>role_name</code></em></span></dt><dd><p>ポリシーが適用されるロールです。
デフォルトは<code class="literal">PUBLIC</code>で、すべてのロールに対してポリシーが適用されます。
     </p></dd><dt><span class="term"><em class="replaceable"><code>using_expression</code></em></span></dt><dd><p>任意の<acronym class="acronym">SQL</acronym>条件式（戻り値は<code class="type">boolean</code>）です。
条件式に集約関数やウィンドウ関数を含めることはできません。
行単位セキュリティが有効なときは、テーブルへの問い合わせにこの式が追加されます。
この式がtrueを返す行が可視となります。
この式がfalseまたはnullを返す行は、ユーザには（<code class="command">SELECT</code>において）不可視となり、また（<code class="command">UPDATE</code>あるいは<code class="command">DELETE</code>では）更新の対象ではなくなります。
そのような行は静かに無視され、エラーは報告されません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>check_expression</code></em></span></dt><dd><p>任意の<acronym class="acronym">SQL</acronym>条件式（戻り値は<code class="type">boolean</code>）です。
条件式に集約関数やウィンドウ関数を含めることはできません。
この式は、そのテーブルに対する<code class="command">INSERT</code>および<code class="command">UPDATE</code>の問い合わせで使用され、この式の評価がtrueになる行のみが許されます。
挿入されるレコード、あるいは更新の結果のレコードでこの式の評価がfalseまたはnullになるものについては、エラーが発生します。
<em class="replaceable"><code>check_expression</code></em>は元の内容ではなく、予定される更新の後の新しい内容に対して評価されることに注意してください。
     </p></dd></dl></div><div class="refsect2" id="id-1.9.3.72.6.3"><h3>コマンド毎のポリシー</h3><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATEPOLICY-ALL"><span class="term"><code class="literal">ALL</code></span></dt><dd><p>ポリシーに<code class="literal">ALL</code>を使うのは、そのポリシーはコマンドの種類に関係なく、すべてのコマンドに適用されるという意味になります。
<code class="literal">ALL</code>のポリシーと特定のコマンドに対するポリシーの両方が存在する場合、<code class="literal">ALL</code>のポリシーと特定のコマンドに対するポリシーの両方が適用されます。
さらに<code class="literal">ALL</code>のポリシーは、問い合わせの選択側と更新側の両方で適用されます。
このとき、<code class="literal">USING</code>式だけが定義されていたら、両方の場合について<code class="literal">USING</code>式を使用します。
       </p><p>例えば<code class="literal">UPDATE</code>が実行されるとき、<code class="literal">ALL</code>のポリシーは、<code class="literal">UPDATE</code>が更新対象の行として選択できる行（<code class="literal">USING</code>式が適用されます）と、<code class="literal">UPDATE</code>文の結果としてできる行がテーブルに追加できるかどうかの検証（<code class="literal">WITH CHECK</code>が定義されていれば、それが適用され、なければ<code class="literal">USING</code>式が適用されます）の両方で適用可能です。
<code class="command">INSERT</code>または<code class="command">UPDATE</code>コマンドが<code class="literal">ALL</code>の<code class="literal">WITH CHECK</code>式に反する行をテーブルに追加しようとした場合、コマンド全体が中止されます。
       </p></dd><dt id="SQL-CREATEPOLICY-SELECT"><span class="term"><code class="literal">SELECT</code></span></dt><dd><p>ポリシーに<code class="literal">SELECT</code>を使うのは、そのポリシーは<code class="literal">SELECT</code>の問い合わせの他に、そのポリシーが定義されているリレーションに対して<code class="literal">SELECT</code>権限が必要な時は常に適用されるという意味になります。
その結果、<code class="literal">SELECT</code>問い合わせでは、<code class="literal">SELECT</code>ポリシーに適うレコードだけが返されます。
また、<code class="literal">UPDATE</code>など<code class="literal">SELECT</code>権限が必要な問い合わせでも、<code class="literal">SELECT</code>ポリシーによって許可されるレコードだけが見えます。
<code class="literal">SELECT</code>ポリシーはリレーションからレコードを取り出す場合にしか適用されないので、<code class="literal">WITH CHECK</code>式を持つことはできません。
       </p></dd><dt id="SQL-CREATEPOLICY-INSERT"><span class="term"><code class="literal">INSERT</code></span></dt><dd><p>ポリシーに<code class="literal">INSERT</code>を使うのは、そのポリシーは<code class="literal">INSERT</code>コマンドに適用されるという意味になります。
このポリシーに反する行を挿入しようとすると、ポリシー違反エラーを起こし、<code class="literal">INSERT</code>コマンド全体が中止されます。
<code class="literal">INSERT</code>ポリシーはリレーションにレコードを追加する場合にしか適用されないため、<code class="literal">USING</code>式を持つことはできません。
       </p><p><code class="literal">ON CONFLICT DO UPDATE</code>のある<code class="literal">INSERT</code>では、<code class="literal">INSERT</code>ポリシーの<code class="literal">WITH CHECK</code>式について、<code class="literal">INSERT</code>の部分でリレーションに追加されるすべての行についてのみ確認することに注意してください。
       </p></dd><dt id="SQL-CREATEPOLICY-UPDATE"><span class="term"><code class="literal">UPDATE</code></span></dt><dd><p>ポリシーに<code class="literal">UPDATE</code>を使うのは、そのポリシーは<code class="literal">UPDATE</code>コマンド、<code class="literal">SELECT FOR UPDATE</code>コマンド、<code class="literal">SELECT FOR SHARE</code>コマンド、および補助的に<code class="literal">INSERT</code>コマンドの<code class="literal">ON CONFLICT DO UPDATE</code>句で適用されるという意味になります。
<code class="literal">UPDATE</code>は既存のレコードを取り出すことと、レコードを新しい修正されたレコードで置換することが含まれるので、<code class="literal">UPDATE</code>ポリシーは<code class="literal">USING</code>式と<code class="literal">WITH CHECK</code>式の両方を受け付けます。
<code class="literal">USING</code>式は<code class="literal">UPDATE</code>コマンドが操作の対象としてどのレコードを見ることができるかを決めるのに使われます。
一方で<code class="literal">WITH CHECK</code>はどの修正した行をリレーションに戻すことができるかを定義します。
       </p><p>更新後の値が<code class="literal">WITH CHECK</code>式に反する行があればエラーを起こし、コマンド全体が中止されます。
<code class="literal">USING</code>句だけが指定されていた場合は、それが<code class="literal">USING</code>と<code class="literal">WITH CHECK</code>の両方に対して使用されます。
       </p><p>通常は、<code class="literal">UPDATE</code>コマンドは更新対象のリレーションの列からデータを読む必要もあります（例えば、<code class="literal">WHERE</code>句の中、<code class="literal">RETURNING</code>句、あるいは<code class="literal">SET</code>句の右辺の式の中）。
この場合、更新対象のリレーションの<code class="literal">SELECT</code>権限も必要となり、<code class="literal">UPDATE</code>ポリシーに加えて、適切な<code class="literal">SELECT</code>または<code class="literal">ALL</code>ポリシーも適用されます。
従って、ユーザは<code class="literal">UPDATE</code>または<code class="literal">ALL</code>ポリシーによって、行を更新する権限を付与されているのに加えて、<code class="literal">SELECT</code>または<code class="literal">ALL</code>ポリシーによって、更新対象の行にアクセスできなければなりません。
       </p><p><code class="literal">INSERT</code>コマンドに補助的な<code class="literal">ON CONFLICT DO UPDATE</code>句があり、<code class="literal">UPDATE</code>の部分が使われるとき、更新対象の行についてまず、すべての<code class="literal">UPDATE</code>ポリシーの<code class="literal">USING</code>式が検査され、次いで、更新された新しい行が<code class="literal">WITH CHECK</code>式が検査されます。
しかし、単独の<code class="literal">UPDATE</code>コマンドとは異なり、既存の行が<code class="literal">USING</code>式を満たさないときは、エラーが発生します（<code class="literal">UPDATE</code>の部分が警告なしに回避されることは<span class="emphasis"><em>決して</em></span>ありません）。
       </p></dd><dt id="SQL-CREATEPOLICY-DELETE"><span class="term"><code class="literal">DELETE</code></span></dt><dd><p>ポリシーに<code class="literal">DELETE</code>を使うのは、そのポリシーは<code class="literal">DELETE</code>コマンドに適用されるという意味になります。
ポリシーを満たす行だけが<code class="literal">DELETE</code>コマンドから見えます。
<code class="literal">SELECT</code>では見えるけれど、削除の対象ではない、という行もあり得ます。
それらの行が<code class="literal">DELETE</code>ポリシーの<code class="literal">USING</code>式を満たさない場合です。
       </p><p>ほとんどの場合、<code class="literal">DELETE</code>コマンドは削除対象のリレーションの列からデータを読む必要もあります（例えば、<code class="literal">WHERE</code>句の中や<code class="literal">RETURNING</code>句）。
この場合、リレーション上の<code class="literal">SELECT</code>権限も必要となり、<code class="literal">DELETE</code>ポリシーに加えて、適切な<code class="literal">SELECT</code>ポリシーまたは<code class="literal">ALL</code>ポリシーも適用されます。
従って、ユーザは<code class="literal">DELETE</code>または<code class="literal">ALL</code>ポリシーによって、行を削除する権限を付与されているのに加えて、<code class="literal">SELECT</code>または<code class="literal">ALL</code>ポリシーによって、削除対象の行にアクセスできなければなりません。
       </p><p><code class="literal">DELETE</code>ポリシーはリレーションからレコードが削除される場合にしか適用されず、確認すべき新しい行はないので、<code class="literal">WITH CHECK</code>式を持つことはできません。
       </p></dd></dl></div><div class="table" id="SQL-CREATEPOLICY-SUMMARY"><p class="title"><strong>Table 240. コマンドタイプにより適用されるポリシー</strong></p><div class="table-contents"><table class="table" summary="コマンドタイプにより適用されるポリシー" border="1"><colgroup><col /><col /><col /><col class="update-using" /><col class="update-check" /><col /></colgroup><thead><tr><th rowspan="2">コマンド</th><th><code class="literal">SELECT/ALLポリシー</code></th><th><code class="literal">INSERT/ALLポリシー</code></th><th colspan="2"><code class="literal">UPDATE/ALLポリシー</code></th><th><code class="literal">DELETE/ALLポリシー</code></th></tr><tr><th><code class="literal">USING式</code></th><th><code class="literal">WITH CHECK式</code></th><th><code class="literal">USING式</code></th><th><code class="literal">WITH CHECK式</code></th><th><code class="literal">USING式</code></th></tr></thead><tbody><tr><td><code class="command">SELECT</code></td><td>既存の行</td><td>—</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">SELECT FOR UPDATE/SHARE</code></td><td>既存の行</td><td>—</td><td>既存の行</td><td>—</td><td>—</td></tr><tr><td><code class="command">INSERT</code></td><td>—</td><td>新しい行</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">INSERT ... RETURNING</code></td><td>新しい行 <a href="#ftn.RLS-SELECT-PRIV" class="footnote"><sup class="footnote" id="RLS-SELECT-PRIV">[a]</sup></a>
       </td><td>新しい行</td><td>—</td><td>—</td><td>—</td></tr><tr><td><code class="command">UPDATE</code></td><td>既存の行と新しい行 <a href="sql-createpolicy.html#ftn.RLS-SELECT-PRIV" class="footnoteref"><sup class="footnoteref">[a]</sup></a>
       </td><td>—</td><td>既存の行</td><td>新しい行</td><td>—</td></tr><tr><td><code class="command">DELETE</code></td><td>既存の行 <a href="sql-createpolicy.html#ftn.RLS-SELECT-PRIV" class="footnoteref"><sup class="footnoteref">[a]</sup></a>
       </td><td>—</td><td>—</td><td>—</td><td>既存の行</td></tr><tr><td><code class="command">ON CONFLICT DO UPDATE</code></td><td>既存の行と新しい行</td><td>—</td><td>既存の行</td><td>新しい行</td><td>—</td></tr></tbody><tbody class="footnotes"><tr><td colspan="6"><div id="ftn.RLS-SELECT-PRIV" class="footnote"><p><a href="#RLS-SELECT-PRIV" class="para"><sup class="para">[a] </sup></a>読み出しアクセスが既存の、あるいは新しい行（たとえば、リレーションのカラムを参照する<code class="literal">WHERE</code>あるいは<code class="literal">RETURNING</code>句）に要求された場合
         </p></div></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="refsect2" id="id-1.9.3.72.6.4"><h3>複数のポリシーの適用</h3><p>同じコマンドに対して、異なるコマンド種別の複数のポリシーを適用する場合（例えば、<code class="literal">UPDATE</code>コマンドに対しては<code class="literal">SELECT</code>と<code class="literal">UPDATE</code>のポリシーが適用されます）、ユーザは両方の種別の権限（例えば、リレーションから行を検索する権限と、それを更新する権限）を持っている必要があります。
従って、ある種別のポリシーの式は、別の種別のポリシーの式と<code class="literal">AND</code>演算子を使って結合されます。
   </p><p>同じコマンドに対して同じコマンド種別の複数のポリシーが適用される場合、リレーションのアクセスを許可する少なくとも1つの<code class="literal">PERMISSIVE</code>ポリシーがなければならず、さらにすべての<code class="literal">RESTRICTIVE</code>ポリシーを満たす必要があります。
従って、すべての<code class="literal">PERMISSIVE</code>ポリシー式が<code class="literal">OR</code>を使って結合され、すべての<code class="literal">RESTRICTIVE</code>ポリシー式が<code class="literal">AND</code>を使って結合され、その結果が<code class="literal">AND</code>を使って結合されます。
<code class="literal">PERMISSIVE</code>ポリシーがなければアクセスは拒絶されます。
   </p><p>複数のポリシーを結合するという目的において、<code class="literal">ALL</code>のポリシーは適用対象となっている他のすべてのポリシーと同じ種別であるとして扱われることに注意してください。
   </p><p>例えば、<code class="literal">SELECT</code>と<code class="literal">UPDATE</code>の両方の権限を必要とする<code class="literal">UPDATE</code>コマンドにおいて、それぞれの種別の適用可能な複数のポリシーがある場合、以下のように結合されます。

</p><pre class="programlisting"><em class="replaceable"><code>expression</code></em> from RESTRICTIVE SELECT/ALL policy 1
AND
<em class="replaceable"><code>expression</code></em> from RESTRICTIVE SELECT/ALL policy 2
AND
...
AND
(
  <em class="replaceable"><code>expression</code></em> from PERMISSIVE SELECT/ALL policy 1
  OR
  <em class="replaceable"><code>expression</code></em> from PERMISSIVE SELECT/ALL policy 2
  OR
  ...
)
AND
<em class="replaceable"><code>expression</code></em> from RESTRICTIVE UPDATE/ALL policy 1
AND
<em class="replaceable"><code>expression</code></em> from RESTRICTIVE UPDATE/ALL policy 2
AND
...
AND
(
  <em class="replaceable"><code>expression</code></em> from PERMISSIVE UPDATE/ALL policy 1
  OR
  <em class="replaceable"><code>expression</code></em> from PERMISSIVE UPDATE/ALL policy 2
  OR
  ...
)</pre><p>
   </p></div></div><div class="refsect1" id="id-1.9.3.72.7"><h2>注釈</h2><p>ポリシーを作成あるいは変更するには、テーブルの所有者でなければなりません。
  </p><p>ポリシーは、データベース内のテーブルに対する明示的な問い合わせには適用されますが、システムが内部的な参照整合性のチェックや制約の検証をしている時には適用されません。
この意味するところは、ある値が存在するかどうかを判定する間接的な方法がある、ということです。
その例の1つは、主キーあるいは一意制約のある列に重複する値を挿入しようとすることです。
挿入に失敗すれば、その値が既に存在すると推定することができます。
（この例では、ユーザが見ることができないレコードを挿入することがポリシーにより許されていると仮定しています。）
別の例は、あるテーブルへの挿入は許されているが、そのテーブルが別の隠されているテーブルを参照している、という場合です。
参照元のテーブルに値を挿入することで、値の存在が判断できます。
この場合、挿入の成功はその値が参照先のテーブルに存在することを示唆します。
これらの問題は、見ることができない値を示唆するかもしれないようなレコードの挿入、削除、更新が全くできないように注意深くポリシーを設計するか、あるいは外部的な意味を持つキーの代わりに生成された値（例：代理キー）を使うことで解決できます。
  </p><p>一般に、システムは問い合わせに記述される制限より前に、セキュリティポリシーを使ったフィルター条件を実行します。
これは守られるべきデータが信頼できないかもしれないユーザ定義関数に偶然に意図せずに渡されることを防ぐためです。
しかし、システム（またはシステム管理者）によって<code class="literal">LEAKPROOF</code>であるとされた関数や演算子については、信頼できるとみなして良いので、ポリシー式より先に評価される場合があります。
  </p><p>ポリシーの式はユーザの問い合わせに直接追加されるため、式は問い合わせ全体を実行しているユーザの権限によって実行されます。
そのため、あるポリシーを使用するユーザは、その式が参照しているすべてのテーブルおよび関数にアクセスできる必要があります。
そうでなければ、行単位セキュリティが有効になっているテーブルに問い合わせをしようとしたときに、単に権限なしのエラーを受け取ります。
しかし、これによってビューの動作が変わることはありません。
通常の問い合わせおよびビューと同じく、ビューによって参照されるテーブルに対する権限の確認とポリシーは、ビューの所有者の権限およびビューの所有者に適用されるポリシーを利用します。
  </p><p>更なる詳細と実践的な例については<a class="xref" href="ddl-rowsecurity.html" title="5.7. 行セキュリティポリシー">Section 5.7</a>に記述されています。
  </p></div><div class="refsect1" id="id-1.9.3.72.8"><h2>互換性</h2><p><code class="command">CREATE POLICY</code>は<span class="productname">PostgreSQL</span>の拡張です。
  </p></div><div class="refsect1" id="id-1.9.3.72.9"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-alterpolicy.html" title="ALTER POLICY"><span class="refentrytitle">ALTER POLICY</span></a>, <a class="xref" href="sql-droppolicy.html" title="DROP POLICY"><span class="refentrytitle">DROP POLICY</span></a>, <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createopfamily.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createpublication.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE OPERATOR FAMILY </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE PUBLICATION</td></tr></table></div></body></html>