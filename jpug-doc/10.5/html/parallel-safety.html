<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.4. パラレル安全</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="parallel-plans.html" title="15.3. パラレルプラン" /><link rel="next" href="admin.html" title="Part III. サーバの管理" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.4. パラレル安全</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="parallel-plans.html" title="15.3. パラレルプラン">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="Chapter 15. パラレルクエリ">Up</a></td><th width="60%" align="center">Chapter 15. パラレルクエリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="admin.html" title="Part III. サーバの管理">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PARALLEL-SAFETY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.4. パラレル安全</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="parallel-safety.html#PARALLEL-LABELING">15.4.1. 関数と集約のためのパラレルラベル付け</a></span></dt></dl></div><p>プランナは、クエリ中に実行される操作を<em class="firstterm">パラレル安全（parallel safe）</em>、<em class="firstterm">パラレル制限（parallel restricted）</em>、<em class="firstterm">パラレル非安全（parallel unsafe）</em>に分類します。
パラレル安全操作は、パラレルクエリとコンフリクトしない操作です。
パラレル制限操作は、パラレルクエリを利用中に、パラレルワーカー中では実行できないが、リーダーによって実行できる操作です。
したがって、パラレル制限操作は、<code class="literal">Gather</code>あるいは<code class="literal">Gather Merge</code>ノードより下では決して実行されませんが、<code class="literal">Gather</code>ノードを含むプランの別の場所では実行されるかもしれません。
パラレル非安全操作は、パラレルクエリ利用中に、リーダも含めて実行できない操作です。
クエリがパラレル非安全なものを含む場合は、クエリ中でのパラレルクエリの利用は全くできなくなります。
  </p><p>次の操作は常にパラレル制限です。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>共通テーブル式（CTE）のスキャン
      </p></li><li class="listitem"><p>一時テーブルのスキャン
      </p></li><li class="listitem"><p>外部テーブルのスキャン。
外部データラッパが<code class="literal">IsForeignScanParallelSafe</code>APIを持ち、パラレル安全を返す場合を除く。
      </p></li><li class="listitem"><p><code class="literal">InitPlan</code>あるいは関連する<code class="literal">SubPlan</code>へのアクセス。
      </p></li></ul></div><div class="sect2" id="PARALLEL-LABELING"><div class="titlepage"><div><div><h3 class="title">15.4.1. 関数と集約のためのパラレルラベル付け</h3></div></div></div><p>プランナは、自動的にはユーザ定義関数や集約がパラレル安全か、パラレル制限か、あるいはパラレル非安全かを決定することはできません。
この関数が潜在的に実行する可能性のあるすべての操作を予測することが、このために要求されるからです。
一般的には、これは停止性問題と同等で、それ故に不可能です。
思いつく限りにおいては、終了すると思われる単純な関数においてさえ、私達は予測をしようとは思いません。
なぜなら、そうした予測は高価でエラーを起こしやすいからです。
その代わりに、そうではないとマークされない限り、すべてのユーザ定義関数は、パラレル非安全と見なされます。
<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>あるいは<a class="xref" href="sql-alterfunction.html" title="ALTER FUNCTION"><span class="refentrytitle">ALTER FUNCTION</span></a>を使用するときは、
適当な<code class="literal">PARALLEL SAFE</code>、<code class="literal">PARALLEL RESTRICTED</code>、<code class="literal">PARALLEL UNSAFE</code>を指定することによってマーキングを行うことができます。
<a class="xref" href="sql-createaggregate.html" title="CREATE AGGREGATE"><span class="refentrytitle">CREATE AGGREGATE</span></a>を利用するときは、対応する値にしたがって、<code class="literal">SAFE</code>、<code class="literal">RESTRICTED</code>、<code class="literal">UNSAFE</code>のどれかを<code class="literal">PARALLEL</code>オプションに指定します。
  </p><p>データベースに書き込むか、シーケンスにアクセスするか、あるいはトランザクションの状態を一時的にであっても変更する（たとえばエラーを捕捉するために<code class="literal">EXCEPTION</code>ブロック確立するPL/pgSQL関数）、恒久的な設定変更を行う関数あるいは集約は、<code class="literal">PARALLEL UNSAFE</code>とマークされなければなりません。
同様に、一時テーブル、クライアントの接続状態、カーソル、準備された文、システムがワーカーの間で同期できないその他のバックエンドローカルな状態にアクセスする関数あるいは集約は、<code class="literal">PARALLEL RESTRICTED</code>とマークされなければなりません。
たとえば、<code class="literal">setseed</code>と<code class="literal">random</code>は、最後の理由により、パラレル制限です。
  </p><p>一般的に制限あるいは非安全な関数が安全とラベル付されたり、実際には非安全なのに制限付きとラベル付されると、パラレルクエリの中で使用される際に、エラーを生じたり、間違った結果を生成するかもしれません。
誤ったラベル付をされると、C言語関数は理論的にはまったく未定義の振る舞いを示すことがあります。
システムは任意のCコードから身を守るすべがないからです。
しかしもっとも起こりえる可能性としては、他の関数のよりも悪いということはなさそうです。
もし自信がないなら、たぶんその関数を<code class="literal">UNSAFE</code>とラベル付するのが最善でしょう。
  </p><p>パラレルワーカーの中で実行される関数がリーダーが獲得していないロックを獲得する場合、たとえばクエリ中で参照されていないテーブルに対して問い合わせを実行する場合などは、これらのロックはトランザクションが終了した時点ではなく、ワーカーが終了する際に解放されます。
もしあなたがこれを行う関数を作成し、こうした振る舞いの違いがあなたにとって重要ならば、関数がリーダーの中だけで実行されることを保証するために、関数を<code class="literal">PARALLEL RESTRICTED</code>とマーク付けしてください。
  </p><p>より良いプランを得るために、プランナがクエリの中で実行されるパラレル制限な関数や集約の評価の遅延を考慮することはないことに注意してください。
したがって、たとえばあるテーブルに適用される<code class="literal">WHERE</code>句がパラレル制限であるときに、クエリプランナはプランの並列実行部分中のテーブルに対してスキャンを実行をすることを考慮しません。
ある場合においては、クエリ中のパラレル部分におけるテーブルのスキャンを含むようにして、<code class="literal">WHERE</code>句の評価を遅らせ、<code class="literal">Gather</code>ノード上で実行されるようにすることも可能でしょう（そしてその方が効率が良いことさえあります）。
しかし、プランナはそうしたことは行いません。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="parallel-plans.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="admin.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">15.3. パラレルプラン </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Part III. サーバの管理</td></tr></table></div></body></html>