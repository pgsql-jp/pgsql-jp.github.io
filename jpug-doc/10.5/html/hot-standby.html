<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>26.5. ホットスタンバイ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="log-shipping-alternative.html" title="26.4. この他のログシッピングの方法" /><link rel="next" href="recovery-config.html" title="Chapter 27. リカバリの設定" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">26.5. ホットスタンバイ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="log-shipping-alternative.html" title="26.4. この他のログシッピングの方法">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="high-availability.html" title="Chapter 26. 高可用性、負荷分散およびレプリケーション">Up</a></td><th width="60%" align="center">Chapter 26. 高可用性、負荷分散およびレプリケーション</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="recovery-config.html" title="Chapter 27. リカバリの設定">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="HOT-STANDBY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">26.5. ホットスタンバイ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-USERS">26.5.1. ユーザのための概説</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-CONFLICT">26.5.2. 問い合わせコンフリクトの処理</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-ADMIN">26.5.3. 管理者のための概説</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-PARAMETERS">26.5.4. ホットスタンバイパラメータリファレンス</a></span></dt><dt><span class="sect2"><a href="hot-standby.html#HOT-STANDBY-CAVEATS">26.5.5. 警告</a></span></dt></dl></div><a id="id-1.6.13.19.2" class="indexterm"></a><p>ホットスタンバイという単語は、サーバがアーカイブリカバリを実行している最中にサーバに接続し読み取り専用の問い合わせを実行することができる機能を説明するために使われます。
これは、レプリケーションという目的およびバックアップからのリストアの両方で高い精度で好ましい状態にするために有用です。
ホットスタンバイという単語はまた、ユーザが問い合わせを実行しながら、または、開いている接続を維持しながら、またはその両方で、サーバをリカバリ状態から通常の動作に移すことができる機能も示すものです。
   </p><p>ホットスタンバイモードにおける問い合わせは、通常の問い合わせに類似していますが、利用上および管理上の差異が多少あり、以下に説明します。
   </p><div class="sect2" id="HOT-STANDBY-USERS"><div class="titlepage"><div><div><h3 class="title">26.5.1. ユーザのための概説</h3></div></div></div><p>スタンバイサーバで<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>パラメータが真に設定されている場合、リカバリによりシステムが一貫性を持つようになった後接続を受け付け始めます。
こうした接続はすべて読み取り専用に限定されます。
一時テーブルであっても書き込むことはできません。
   </p><p>スタンバイ上のデータはプライマリサーバから届くまでに多少の時間がかかります。
このため、プライマリとスタンバイの間にはある程度の遅延があります。
したがって、同じ問い合わせをほとんど同時にプライマリとスタンバイに対して実行すると、異なる結果が返る可能性があります。
スタンバイ上のデータはプライマリに対して<em class="firstterm">最後には一貫性を持つ</em>といいます。
あるトランザクションのコミットレコードがスタンバイ上で再生されると、そのトランザクションでなされた変更はスタンバイで獲得されるすべての新規スナップショットで可視になります。
現在のトランザクション隔離レベルに応じて、スナップショットは各問い合わせの開始時または各トランザクションの開始時に獲得されます。
詳細については<a class="xref" href="transaction-iso.html" title="13.2. トランザクションの分離">Section 13.2</a>を参照してください。
   </p><p>ホットスタンバイ中に開始されたトランザクションは以下のコマンドを発行することができます。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>問い合わせによるアクセス - <code class="command">SELECT</code>および<code class="command">COPY TO</code>
      </p></li><li class="listitem"><p>カーソルコマンド - <code class="command">DECLARE</code>と<code class="command">FETCH</code>と<code class="command">CLOSE</code>
      </p></li><li class="listitem"><p>パラメータの操作 - <code class="command">SHOW</code>と<code class="command">SET</code>と<code class="command">RESET</code>
      </p></li><li class="listitem"><p>トランザクション管理コマンド
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="command">BEGIN</code>と<code class="command">END</code>と<code class="command">ABORT</code>と<code class="command">START TRANSACTION</code>
          </p></li><li class="listitem"><p><code class="command">SAVEPOINT</code>と<code class="command">RELEASE</code>と<code class="command">ROLLBACK TO SAVEPOINT</code>
          </p></li><li class="listitem"><p><code class="command">EXCEPTION</code>ブロックおよびこの他の内部サブトランザクション
          </p></li></ul></div><p>
      </p></li><li class="listitem"><p><code class="command">LOCK TABLE</code>。
なお、以下のモードが明示された場合に限ります。
<code class="literal">ACCESS SHARE</code>または<code class="literal">ROW SHARE</code>または<code class="literal">ROW EXCLUSIVE</code>
      </p></li><li class="listitem"><p>計画と資源 - <code class="command">PREPARE</code>と<code class="command">EXECUTE</code>と<code class="command">DEALLOCATE</code>と<code class="command">DISCARD</code>
      </p></li><li class="listitem"><p>プラグインと拡張 - <code class="command">LOAD</code>
      </p></li></ul></div><p>
   </p><p>ホットスタンバイ中に開始したトランザクションではトランザクションIDを割り当てられません。
また、システムのログ先行書き込みに書き出すことができません。
このため、以下の動作はエラーメッセージを生成します。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>データ操作言語（DML）。
<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">COPY FROM</code>および<code class="command">TRUNCATE</code>。
リカバリ中にトリガ内で実行されてしまう場合でも許されていない動作であることに注意してください。
現在のホットスタンバイ環境では行うことができないトランザクションIDの割り当てを行うことなく、テーブル行の読み書きを行うことができませんので、この制限は一時テーブルであっても適用されます。
      </p></li><li class="listitem"><p>データ定義言語（DDL）。
<code class="command">CREATE</code>、<code class="command">DROP</code>、<code class="command">ALTER</code>および<code class="command">COMMENT</code>。
この制約は一時テーブルに対しても適用されます。
これらの操作の実行がシステムカタログテーブルの更新を必要とするためです。
      </p></li><li class="listitem"><p><code class="command">SELECT ... FOR SHARE | UPDATE</code>。
背後のデータファイルを更新することなく行ロックを獲得することはできないためです。
      </p></li><li class="listitem"><p>データ操作言語のコマンドを生成する<code class="command">SELECT</code>文のルール
      </p></li><li class="listitem"><p><code class="literal">ROW EXCLUSIVE MODE</code>より高いモードを明示的に要求する<code class="command">LOCK</code>
      </p></li><li class="listitem"><p>短いデフォルト構文の<code class="command">LOCK</code>。
これは<code class="literal">ACCESS EXCLUSIVE MODE</code>を要求するためです。
      </p></li><li class="listitem"><p>読み取り専用でない状態を明示的に設定するトランザクション処理コマンド
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><code class="command">BEGIN READ WRITE</code>と<code class="command">START TRANSACTION READ WRITE</code>
          </p></li><li class="listitem"><p><code class="command">SET TRANSACTION READ WRITE</code>と<code class="command">SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE</code>
          </p></li><li class="listitem"><p><code class="command">SET transaction_read_only = off</code>
          </p></li></ul></div><p>
      </p></li><li class="listitem"><p>二相コミットコマンド - <code class="command">PREPARE TRANSACTION</code>、<code class="command">COMMIT PREPARED</code>および<code class="command">ROLLBACK PREPARED</code>。
読み取り専用トランザクションでも、プリペア相（二相コミットの第1相）においてWALの書き込みが必要だからです。
      </p></li><li class="listitem"><p>シーケンス更新の関数 - <code class="function">nextval()</code>と<code class="function">setval()</code>
      </p></li><li class="listitem"><p><code class="command">LISTEN</code>、<code class="command">UNLISTEN</code>および<code class="command">NOTIFY</code>
      </p></li></ul></div><p>
   </p><p>通常の操作では、<span class="quote">“<span class="quote">読み取り専用</span>”</span>トランザクションには<code class="command">LISTEN</code>と<code class="command">UNLISTEN</code>と<code class="command">NOTIFY</code>の使用が許可されています。
ホットスタンバイセッションの操作では、通常の読み取り専用セッションよりも少し厳しい制約を受けます。
将来のリリースではこの制約の一部が緩和されるかもしれません。
   </p><p>ホットスタンバイ中は、<code class="varname">transaction_read_only</code>パラメータは常に真であり、変更することはできません。
しかし、データベースを変更するような試行がない限り、ホットスタンバイ中の接続は他のデータベース接続とほとんど同じように動作します。
もし、フェールオーバまたはスイッチオーバが発生すると、データベースは通常処理モードに切り替わります。
サーバのモードが変わってもセッションは接続を保持します。
ホットスタンバイが完了すると、読み書き可能なトランザクションを（ホットスタンバイ中に始まったセッションからであっても）始められるようになります。
   </p><p>ユーザは<code class="command">SHOW transaction_read_only</code>を発行することで、そのセッションが読み取り専用かどうかを調べることができます。
さらに、ユーザがスタンバイサーバに関する情報にアクセスできる関数群(<a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="Table 9.80. リカバリ情報関数">Table 9.80</a>)があります。
これらによりデータベースの現状認識を行うプログラムを作成することができます。
これらを使用して、リカバリの進行状況を監視するために使用したり、データベースを特定の状態にリストアする複雑なプログラムを作成したりすることができます。
   </p></div><div class="sect2" id="HOT-STANDBY-CONFLICT"><div class="titlepage"><div><div><h3 class="title">26.5.2. 問い合わせコンフリクトの処理</h3></div></div></div><p>プライマリサーバとスタンバイサーバは、多方面でゆるく結合しています。
プライマリサーバの動作はスタンバイサーバに影響します。
その結果、負の相互作用またはコンフリクトの可能性があります。
最も分かりやすいコンフリクトは性能です。
プライマリサーバで巨大なデータがロードされた場合、スタンバイサーバにおいて同様に巨大なWALレコードが生成されるので、スタンバイサーバにおける問い合わせは互いにI/Oなどのシステム資源を奪い合います。
   </p><p>ホットスタンバイで発生する可能性があるコンフリクトの種類には他にもあります。
これらのコンフリクトは、問い合わせをキャンセルしなければならない可能性があり、解消させるためにはセッションの接続を閉ざすことになる場合もあるため、<span class="emphasis"><em>致命的なコンフリクト</em></span>です。
ユーザにはこうしたコンフリクトを扱うための複数の方法が提供されます。
コンフリクトする状況には以下があります。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>プライマリサーバで獲得されたアクセス排他ロックは、スタンバイの問い合わせにおけるテーブルアクセスとコンフリクトします。
明示的な<code class="command">LOCK</code>コマンドおよび各種<acronym class="acronym">DDL</acronym>操作を含みます。
        </p></li><li class="listitem"><p>プライマリでテーブル空間を削除することは、一時作業ファイル用にそのテーブル空間を使用するスタンバイ側の問い合わせとコンフリクトします。
        </p></li><li class="listitem"><p>プライマリでデータベースを削除することは、スタンバイ側でそのデータベースに接続するセッションとコンフリクトします。
        </p></li><li class="listitem"><p>WALからのバキュームクリーンアップレコードの適用は、その適用により削除される行のどれか1つでも<span class="quote">“<span class="quote">見る</span>”</span>ことができるスナップショットを持つスタンバイでのトランザクションとコンフリクトします。
        </p></li><li class="listitem"><p>WALからのバキュームクリーンアップレコードは、消去されるデータが可視か否かに関係なく、スタンバイで対象ページにアクセスする問い合わせとコンフリクトします。
        </p></li></ul></div><p>
   </p><p>プライマリサーバでは、こうした状況は単に待たされるだけです。
ユーザはコンフリクトする操作をキャンセルすることを選ぶことができます。
しかし、スタンバイ側には選択肢がありません。
WALに記録された操作はすでにプライマリで発生したものですので、スタンバイではその適用に失敗してはなりません。
さらに、適用したいWALを無制限に待機させることを許すことは、まったく望まない結果になってしまうかもしれません。
なぜなら、スタンバイの状態がプライマリの状態とだんだんとかけ離れてしまうからです。
したがって適用すべきWALレコードとコンフリクトするスタンバイの問い合わせを強制的に取り消す仕組みが用意されています。
   </p><p>この問題の例として、スタンバイサーバで現在問い合わせ対象となっているテーブルをプライマリサーバで<code class="command">DROP TABLE</code>を行う管理者を考えてみます。
スタンバイで<code class="command">DROP TABLE</code>が適用されたら問い合わせを継続できないことは明確です。
プライマリ上でこうした状況が発生した場合は、他の問い合わせが終わるまで<code class="command">DROP TABLE</code>は待機させられます。
しかし、<code class="command">DROP TABLE</code>がプライマリで実行された時、プライマリ側でスタンバイで稼動する問い合わせに関する情報がありませんので、スタンバイ側のこうした問い合わせを待機させることはできません。
スタンバイ側で問い合わせが実行している時にWALの変更レコードがスタンバイに届けば、コンフリクトが発生します。
スタンバイサーバはWALレコードの適用を遅延させる（およびその後の適用すべても遅延させる）か、<code class="command">DROP TABLE</code>を適用できるようにコンフリクトする問い合わせを取り消すかのいずれかを行わなければなりません。
   </p><p>コンフリクトする問い合わせが短ければ、適用したいWALを多少遅延させることで、問い合わせを完了させることが通常望まれます。
しかし、WALの適用が長く遅延することはたいていは望まれません。
したがって、取り消し機能は<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>というパラメータを持ちます。
これらはWAL適用に許される遅延を定義するものです。
コンフリクトする問い合わせは、何らかの新しく受信したWALデータを適用するための各種遅延設定を超えたら取り消されます。
アーカイブからWALデータを読み取る場合（つまりベースバックアップからの初期リカバリや大きく遅延したスタンバイサーバの<span class="quote">“<span class="quote">追従</span>”</span>）とストリーミングレプリケーションとで異なる遅延値を指定することができるように2つのパラメータが存在します。
   </p><p>主に高可用性のために存在するスタンバイサーバでは、スタンバイ側の問い合わせによって発生する遅延のためにプライマリと大きく遅延が発生することがないように、遅延パラメータを相対的に短く設定することが最善です。
しかし、スタンバイサーバが長時間かかる問い合わせを実行するためのものであれば、長い遅延もしくは制限を設けないことが好まれるかもしれません。
しかし、長時間かかる問い合わせがWALレコードの適用を遅延させてしまう場合、スタンバイサーバ上の他のセッションがプライマリにおける最近の変更を参照することができなくなることは覚えておいてください。
   </p><p><code class="varname">max_standby_archive_delay</code>または<code class="varname">max_standby_streaming_delay</code>で指定した遅延を超えると、コンフリクトする問い合わせは取り消されます。
通常これは単なる取り消しエラーという結果となりますが、<code class="command">DROP DATABASE</code>を再生する場合では、コンフリクトするセッション全体が終了します。
また、コンフリクトが待機中のトランザクションで保持されるロックについてのものであれば、そのコンフリクトするセッションが終了します（この動作は将来変更されるかもしれません）。
   </p><p>ユーザは取り消された問い合わせをすぐに再試行するかもしれません（もちろん新規のトランザクション開始後に）。
問い合わせの取り消しは、再生されるWALレコードの性質に依存するので、取り消された問い合わせが再度実行された場合には正常に動作するかもしれません。
   </p><p>遅延パラメータはスタンバイサーバでWALデータを受信してからの経過時間と比べられることに注意してください。
したがって、スタンバイ上で任意の問い合わせに許される猶予期間は、この遅延パラメータよりも大きくなることは決してありません。
これまでの問い合わせを完了させるために待機した結果、あるいは、大量の更新負荷に追従することができなくなった結果、スタンバイがすでに遅延している場合は相当小さくなります。
   </p><p>スタンバイ側の問い合わせとWAL再生の間でもっともよくあるコンフリクト理由は<span class="quote">“<span class="quote">早すぎる消去</span>”</span>です。
通常<span class="productname">PostgreSQL</span>はMVCC規則にしたがって正確なデータの可視性を確実にするために、古い行バージョンを参照するトランザクションが存在しない場合それらを消去することが許されています。
しかし、この規則はマスタ上で実行するトランザクションのみに適用させることができます。
したがって、スタンバイ上のトランザクションでまだ可視である行バージョンを、マスタ上の消去処理が削除してしまう可能性があります。
   </p><p>熟練したユーザは、行バージョンの消去と行バージョンの凍結の両方ともスタンバイ側の問い合わせとコンフリクトする可能性があることに気づくはずです。
手作業での<code class="command">VACUUM FREEZE</code>は、更新または削除された行がないテーブルであったとしてもコンフリクトを発生し易いものです。
   </p><p>プライマリサーバにおいて規則的かつ頻繁に更新されるテーブルは、スタンバイサーバにおける問い合わせの取り消しの原因になりやすいことを利用者は理解するべきです。
そのような場合、<code class="varname">max_standby_archive_delay</code>または<code class="varname">max_standby_streaming_delay</code>の設定値は<code class="varname">statement_timeout</code>の設定と同様に考えることができます。
   </p><p>スタンバイのクエリが中断される受け入れがたいほど多い場合、この問題を解決する方法が用意されています。
１つ目の選択肢は、<code class="varname">hot_standby_feedback</code>パラメータを設定することです。
これは<code class="command">VACUUM</code>による最近不要になった行の削除を防止しますので、消去によるコンフリクトが発生しません。
これを行う場合、プライマリで不要になった行の消去が遅延することに注意が必要です。望まないテーブルの膨張が発生してしまうかもしれません。
しかし、スタンバイ側で行うべき問い合わせをプライマリサーバ上で直接実行することと比べ、こうした消去に関する問題を優先する価値はありません。
また、スタンバイに実行負荷を分散できるという利点があります。
スタンバイサーバが接続、切断を頻繁に繰り返す場合、<code class="varname">hot_standby_feedback</code>によるフィードバックが提供されていなければ、その値を調整したいと思うでしょう。
例えば、<code class="varname">max_standby_archive_delay</code>が増大し、切断している期間WALアーカイブのコンフリクト発生による問い合わせの中断が速やかに行われないことを考えてみてください。また、再接続後に速やかに問い合わせが中断されることを避けるために<code class="varname">max_standby_streaming_delay</code>を大きくすることを考えてみてください。
   </p><p>他の選択肢は、不要になった行が通常よりも早く消去されないようにプライマリサーバで<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>を増やすことです。
これにより、<code class="varname">max_standby_streaming_delay</code>を長くすることなく、スタンバイでキャンセルが起こるようになる前により多くの時間、問い合わせを実行することができます。
しかし、<code class="varname">vacuum_defer_cleanup_age</code>はプライマリサーバ上で実行されたトランザクションを単位に測定されますので、この方法では特定の実行期間を保証することは困難です。
   </p><p>問い合わせキャンセルの個数とその原因はスタンバイサーバ上の<code class="structname">pg_stat_database_conflicts</code>システムビューを用いて参照することができます。
また<code class="structname">pg_stat_database</code>システムビューには要約された情報が含まれます。
   </p></div><div class="sect2" id="HOT-STANDBY-ADMIN"><div class="titlepage"><div><div><h3 class="title">26.5.3. 管理者のための概説</h3></div></div></div><p><code class="filename">postgresql.conf</code>において<code class="varname">hot_standby</code>が<code class="literal">on</code>で（これはデフォルトです）、かつ<code class="filename">recovery.conf</code>が存在すれば、サーバはホットスタンバイモードで稼動します。
しかし、サーバはまず問い合わせが実行できる程度の一貫性を持つ状態を提供するために十分なリカバリを完了させなければなりませんので、ホットスタンバイでの接続が有効になるまでに多少の時間がかかるかもしれません。
サーバの準備ができたことを確認するために、アプリケーションで接続試行を繰り返すか、サーバログに以下のメッセージがあるかどうかを確認します。

</p><pre class="programlisting">LOG:  entering standby mode

... 多少時間が経過して ...

LOG:  consistent recovery state reached
LOG:  database system is ready to accept read only connections</pre><p>

一貫性に関する情報はプライマリでチェックポイント毎に一回記録されます。
プライマリで<code class="varname">wal_level</code>が<code class="literal">replica</code>もしくは<code class="literal">logical</code>に設定されていなかった期間に書き込まれたWALを読み取っている間は、ホットスタンバイを有効にすることはできません。
また、一貫性のある状態への到達は、以下の両方が存在する間遅延することがあります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>サブトランザクション数が64を超える書き込みトランザクション
        </p></li><li class="listitem"><p>非常に長く実行される書き込みトランザクション
        </p></li></ul></div><p>

ファイルベースのログシッピング(「ウォームスタンバイ」)を実行しているのであれば、次のWALファイルが届く、長くともプライマリの<code class="varname">archive_timeout</code>設定まで待機しなければなりません。
   </p><p>プライマリサーバにおける設定値が変更した場合、スタンバイサーバにおいて数個のパラメータの再設定が必要です。
スタンバイサーバにおける設定値は、プライマリサーバにおける設定値以上でなければなりません。
所定値未満の設定の場合、スタンバイは起動を取りやめます。
所定値以上の設定により、スタンバイサーバは再起動してリカバリが再び開始されます。
このパラメータは以下です。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>         <code class="varname">max_connections</code>
        </p></li><li class="listitem"><p>         <code class="varname">max_prepared_transactions</code>
        </p></li><li class="listitem"><p>         <code class="varname">max_locks_per_transaction</code>
        </p></li><li class="listitem"><p>         <code class="varname">max_worker_processes</code>
        </p></li></ul></div><p>
   </p><p><a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>および<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>の値が適切であるように管理者が選択することが重要です。
最善の選択は業務上の優先順位によって変化します。
例えば、サーバが主に高可用性を目的としたサーバとして作業するものであれば、短い遅延を設定したいでしょう。
非常に積極的な設定ですが、ゼロにしたいかもしれません。
スタンバイサーバが意思決定支援のための問い合わせ用の追加サーバとして作業するものであれば、数時間程度の最大の遅延値の設定、あるいは問い合わせの完了を永遠に待つことを意味する-1という設定でさえ、許容範囲であるかもしれません。
   </p><p>プライマリ側で「ヒントビット」として書き出されたトランザクション状態はWALに記録されません。
このためスタンバイ側のデータはスタンバイ側でヒントを再度書き出すことになります。
ユーザは大規模なソート用の一時ファイルを書き出し、relcache情報ファイルを再作成します。
したがって、ホットスタンバイモードではデータベースのすべてが本当に読み取り専用ではありません。
また、ローカルでは読み取り専用のトランザクションであっても<span class="application">dblink</span>モジュールを使用したリモートデータベースへの書き出しや、その他のPL関数を使用したデータベース外部への操作が可能であることに注意してください。
   </p><p>リカバリモードの間、下記の管理者用コマンドは受理されません。

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>データ定義言語、例えば<code class="command">CREATE INDEX</code>
        </p></li><li class="listitem"><p>権限および所有権 - <code class="command">GRANT</code>と<code class="command">REVOKE</code>と<code class="command">REASSIGN</code>
        </p></li><li class="listitem"><p>保守コマンド - <code class="command">ANALYZE</code>と<code class="command">VACUUM</code>と<code class="command">CLUSTER</code>と<code class="command">REINDEX</code>
        </p></li></ul></div><p>
   </p><p>繰り返しますが、これらのコマンドの一部は、プライマリサーバにおける「読み取り専用」モードのトランザクションで実際に許可されていることに注意してください。
   </p><p>その結果、スタンバイ側にのみ存在する追加のインデックスやスタンバイ側にのみ存在する統計情報を作成することはできません。
これらの管理者用コマンドが必要な場合、プライマリ側で実行しなければなりません。
最終的にこの変更はスタンバイ側に伝播します。
   </p><p><code class="function">pg_cancel_backend()</code>と<code class="function">pg_terminate_backend()</code>は利用者のバックエンドでは実行できますが、リカバリを実行する起動プロセスでは実行できません。
<code class="structname">pg_stat_activity</code>はリカバリ中のトランザクションをアクティブとして表示しません。
その結果、リカバリの間<code class="structname">pg_prepared_xacts</code>は常に空となります。
調査が必要な準備されたトランザクションがある場合は、プライマリサーバにおいて<code class="literal">pg_prepared_xacts</code>を表示し、その場でトランザクションを解決するか、リカバリが終わるのを待ってからトランザクションを解決します。
   </p><p><code class="structname">pg_locks</code>は通常通りバックエンドで保持されるロックを示します。
<code class="structname">pg_locks</code>はまた、リカバリによって再生されているトランザクションで保持される<code class="literal">AccessExclusiveLocks</code>のすべてを所有する、起動プロセスで管理される仮想トランザクションも表示します。
起動プロセスはデータベースの変更を行うためのロックを獲得しません。
このため起動プロセスにおいて<code class="literal">AccessExclusiveLocks</code>以外のロックは<code class="structname">pg_locks</code>では表示されません。
これらは存在することを想定されているだけです。
   </p><p>存在を検知する情報が単純なので、<span class="productname">Nagios</span>プラグインは稼動します。
一部の報告値が異なった、混乱を招く結果となりますが、<span class="productname">check_postgres</span>の監視スクリプトも動作します。
それでも、プライマリで行われるバキュームはその変更をスタンバイに送信します。
   </p><p>リカバリの間WALの制御コマンドは稼動しません。
例えば、<code class="function">pg_start_backup</code>や<code class="function">pg_switch_wal</code>などです。
   </p><p><code class="structname">pg_stat_statements</code>も含み、動的に読み込み可能なモジュールは稼動します。
   </p><p>デッドロック検出を含むアドバイザリロックは、通常リカバリにおいて稼動します。
アドバイザリロックはWALに決して記録されないので、プライマリサーバでもスタンバイサーバでもWALの再実行においてコンフリクトが起こらないことに注意してください。
プライマリサーバでアドバイザリロックを取得して、スタンバイサーバで同様のアドバイザリロックを掛けることはできません。
アドバイザリロックは取得したサーバだけに関係するものです。
   </p><p><span class="productname">Slony</span>や<span class="productname">Londiste</span>や<span class="productname">Bucardo</span>のようにトリガに基づいたレプリケーションシステムは、スタンバイサーバで全く稼動しません。
しかし、それによる変更がスタンバイサーバに送られるまでは、プライマリサーバにおいて問題なく稼動します。
WALの再実行はトリガに基づいたものではありません。
したがって、データベースへの付加的な書き込みを必要とするか、トリガの使用に依存するものを、スタンバイサーバを中継して他のシステムへ送ることはできません。
   </p><p>一部の<acronym class="acronym">UUID</acronym>ジェネレータは、データベースに新しい状態を書き出すことに依存していない限り動作可能ですが、新しいOIDを割り当てることはできません。
   </p><p>現時点では、読み取り専用のトランザクションでは一時テーブルの作成は許されません。
このため既存のスクリプトが正しく動作しない場合があります。
この制限は将来のリリースで緩和されるかもしれません。
これは、標準SQLとの互換性の問題でもあり、技術的な問題でもあります。
   </p><p>テーブル空間が空の場合だけ、<code class="command">DROP TABLESPACE</code>が成功します。
一部のスタンバイ側のユーザは<code class="varname">temp_tablespaces</code>パラメータを介してテーブル空間を活発に使用しているかもしれません。
テーブル空間に一時ファイルが存在する場合、一時ファイルを確実に削除するためすべての問い合わせが取り消されます。
このため、WAL再生を続けながらテーブル空間を削除することができます。
   </p><p>プライマリサーバにおける<code class="command">DROP DATABASE</code>または<code class="command">ALTER DATABASE ... SET TABLESPACE</code>の実行により、スタンバイサーバのデータベースに接続するすべてのユーザを強制的に接続を切断させることになるWALエントリを生成します。
これは<code class="varname">max_standby_streaming_delay</code>の設定にかかわらず、直ちに起こります。
<code class="command">ALTER DATABASE ... RENAME</code>はユーザを切断しないので大部分の場合は気がつきませんが、プログラムがデータベースの名称に依存するときは混乱の原因となることに注意してください。
   </p><p>通常の(リカバリ以外の)モードで、ログイン権限を持つロールが接続している間にそのロールに<code class="command">DROP USER</code>または<code class="command">DROP ROLE</code>を発行した場合、接続中のユーザには何も起こらず、接続し続けます。
しかし、そのユーザは再接続できません。
この振舞いはリカバリモードでも適用されます。
このためプライマリ側で<code class="command">DROP USER</code>されたとしても、スタンバイ側のユーザの接続は切断されません。
   </p><p>リカバリの間も統計情報は収集されます。
すべてのスキャン、読み取り、ブロック、インデックスの使用などは、スタンバイサーバにおいて正常に記録されます。
再実行によりプライマリサーバの結果が重複して収集されることはないので、行の挿入によりpg_stat_user_tablesの挿入列の値は増加しません。
リカバリの開始時点で統計情報ファイルが削除されるので、プライマリサーバとスタンバイサーバで統計情報は異なります。
これは将来どうするか検討中であり、バグではありません。
   </p><p>リカバリの間は自動バキュームは稼動しません。
リカバリが終わると正常に起動します。
   </p><p>リカバリの間バックグラウンドライタは稼動して（プライマリサーバにおけるチェックポイントに類似した）リスタートポイントを設定し、通常のブロック消去を行います。
これはスタンバイサーバに保存されるヒントビット情報の更新を含むことができます。
リカバリの間<code class="command">CHECKPOINT</code>コマンドは受理されますが、新規のチェックポイントではなくてリスタートポイントが設定されます。
   </p></div><div class="sect2" id="HOT-STANDBY-PARAMETERS"><div class="titlepage"><div><div><h3 class="title">26.5.4. ホットスタンバイパラメータリファレンス</h3></div></div></div><p>種々のパラメータが上記<a class="xref" href="hot-standby.html#HOT-STANDBY-CONFLICT" title="26.5.2. 問い合わせコンフリクトの処理">Section 26.5.2</a>および<a class="xref" href="hot-standby.html#HOT-STANDBY-ADMIN" title="26.5.3. 管理者のための概説">Section 26.5.3</a>で述べられています。
   </p><p>プライマリサーバでは、<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>および<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>のパラメータを使用できます。
プライマリサーバに<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>および<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>を設定しても無効です。
   </p><p>スタンバイサーバでは<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY">hot_standby</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-ARCHIVE-DELAY">max_standby_archive_delay</a>と<a class="xref" href="runtime-config-replication.html#GUC-MAX-STANDBY-STREAMING-DELAY">max_standby_streaming_delay</a>のパラメータを使用できます。
サーバがスタンバイモードの間<a class="xref" href="runtime-config-replication.html#GUC-VACUUM-DEFER-CLEANUP-AGE">vacuum_defer_cleanup_age</a>を設定しても無効です。
しかし、スタンバイサーバがプライマリサーバになった場合、意味を持つようになります。
   </p></div><div class="sect2" id="HOT-STANDBY-CAVEATS"><div class="titlepage"><div><div><h3 class="title">26.5.5. 警告</h3></div></div></div><p>ホットスタンバイには幾つかの制限があります。
将来のリリースでは改善されると思われます。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>スナップショットを取ることができるようになる前に、実行中のトランザクションについての完全な知識が要求されます。
(現時点では64を超える)多くのサブトランザクションを使用するトランザクションでは、実行中の最長の書き込みトランザクションが完了するまで、読み取り専用の接続の開始は遅延されます。
この状況が起こると、それを説明するメッセージがサーバログに記録されます。
    </p></li><li class="listitem"><p>スタンバイ問い合わせ用の有効な起動ポイントは、マスタにおけるチェックポイント毎に生成されます。
マスタが停止状態にある時にスタンバイが停止した場合、プライマリが起動し、さらに起動ポイントをWALログに生成するまで再度ホットスタンバイになることができないことがあります。
この状況は、通常考えられる状態では問題ではありません。
一般的に、プライマリが停止し利用できなくなった場合、それはスタンバイに対して新しいプライマリに切り替わることを要求するような深刻な失敗が原因であることが多いはずです。
また、プライマリを意図的に停止させるような状況では、それに伴いスタンバイが新しいプライマリになめらかに切り替わることも普通の手順です。
    </p></li><li class="listitem"><p>リカバリの終了において、準備されたトランザクションが保持する<code class="literal">AccessExclusiveLocks</code>には、通常の2倍のロックテーブルへのエントリ数が必要です。
通常<code class="literal">AccessExclusiveLocks</code>を取るプリペアドトランザクションを大量に同時実行させる、または、多くの<code class="literal">AccessExclusiveLocks</code>を取る大規模なトランザクションを1つ実行させることを考えている場合、<code class="varname">max_locks_per_transaction</code>の値を、おそらくプライマリサーバのパラメータ値の倍程度に大きくすることを勧めます。
<code class="varname">max_prepared_transactions</code>の設定が0ならば、これを検討する必要はまったくありません。
    </p></li><li class="listitem"><p>シリアライザブルトランザクション隔離レベルはまだホットスタンバイでは利用できません。
（<a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. シリアライザブル分離レベル">Section 13.2.3</a>および<a class="xref" href="applevel-consistency.html#SERIALIZABLE-CONSISTENCY" title="13.4.1. シリアライザブルトランザクションを用いた一貫性の強化">Section 13.4.1</a>参照）
ホットスタンバイにおいてトランザクションをシリアライザブルトランザクション隔離レベルに設定しようとすると、エラーになります。
    </p></li></ul></div><p>

   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="log-shipping-alternative.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="recovery-config.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">26.4. この他のログシッピングの方法 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 27. リカバリの設定</td></tr></table></div></body></html>