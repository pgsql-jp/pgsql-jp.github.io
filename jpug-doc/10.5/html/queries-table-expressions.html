<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7.2. テーブル式</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="queries-overview.html" title="7.1. 概要" /><link rel="next" href="queries-select-lists.html" title="7.3. 選択リスト" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">7.2. テーブル式</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="queries-overview.html" title="7.1. 概要">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="queries.html" title="Chapter 7. 問い合わせ">Up</a></td><th width="60%" align="center">Chapter 7. 問い合わせ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="queries-select-lists.html" title="7.3. 選択リスト">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="QUERIES-TABLE-EXPRESSIONS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7.2. テーブル式</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-FROM">7.2.1. <code class="literal">FROM</code>句</a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-WHERE">7.2.2. <code class="literal">WHERE</code>句</a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-GROUP">7.2.3. <code class="literal">GROUP BY</code>句と<code class="literal">HAVING</code>句</a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-GROUPING-SETS">7.2.4. <code class="literal">GROUPING SETS</code>、<code class="literal">CUBE</code>、<code class="literal">ROLLUP</code></a></span></dt><dt><span class="sect2"><a href="queries-table-expressions.html#QUERIES-WINDOW">7.2.5. ウィンドウ関数処理</a></span></dt></dl></div><a id="id-1.5.6.6.2" class="indexterm"></a><p><em class="firstterm">テーブル式</em>はテーブルを計算するためのものです。
テーブル式には<code class="literal">FROM</code>句が含まれており、その後ろにオプションとして<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、<code class="literal">HAVING</code>句を付けることができます。
単純なテーブル式は、単にディスク上のいわゆる基本テーブルと呼ばれるテーブルを参照するだけです。
しかし複雑な式では、様々な方法で基本テーブルを修正したり、結合させて使用することができます。
  </p><p>テーブル式のオプション<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、および<code class="literal">HAVING</code>句は、<code class="literal">FROM</code>句で派生したテーブル上に対して次々に変換を実行するパイプラインを指定します。
これらの変換によって仮想テーブルが1つ生成されます。
そしてこの仮想テーブルの行が選択リストに渡され、問い合わせの出力行が計算されます。
  </p><div class="sect2" id="QUERIES-FROM"><div class="titlepage"><div><div><h3 class="title">7.2.1. <code class="literal">FROM</code>句</h3></div></div></div><p><a class="xref" href="sql-select.html#SQL-FROM" title="FROM句"><code class="literal">FROM</code>句</a>は、カンマで分けられたテーブル参照リストで与えられる1つ以上のテーブルから、1つのテーブルを派生します。
</p><pre class="synopsis">FROM <em class="replaceable"><code>table_reference</code></em> [<span class="optional">, <em class="replaceable"><code>table_reference</code></em> [<span class="optional">, ...</span>]</span>]</pre><p>

テーブル参照は、テーブル名（スキーマで修飾することもできます）、あるいは、副問い合わせ、<code class="literal">JOIN</code>による結合、これらの複雑な組み合わせなどの派生テーブルとすることができます。
<code class="literal">FROM</code>句に複数のテーブル参照がある場合、クロス結合されます（テーブルの行のデカルト積が形成されます。下記を参照）。
<code class="literal">FROM</code>リストの結果は<code class="literal">WHERE</code>句、<code class="literal">GROUP BY</code>句、および<code class="literal">HAVING</code>句での変換対象となる中間的な仮想テーブルになり、最終的にはテーブル式全体の結果となります。
   </p><a id="id-1.5.6.6.5.3" class="indexterm"></a><p>テーブル参照で、テーブルの継承階層の親テーブルの名前を指定すると、テーブル名の前に<code class="literal">ONLY</code>キーワードがない場合は、テーブル参照はそのテーブルだけでなくその子テーブルに継承されたすべての行を生成します。
しかし、この参照は名前を指定したテーブルに現れる列のみを生成し、子テーブルで追加された列は無視されます。
   </p><p>テーブル名の前に<code class="literal">ONLY</code>を記述する代わりに、テーブル名の後に<code class="literal">*</code>を記述して、子テーブルが含まれることを明示的に指定することができます。
子テーブルを検索するのが今は常にデフォルトの振る舞いですので、この文法を使う本当の理由はもうありません。
しかし、古いリリースとの互換性のためにサポートされています。
   </p><div class="sect3" id="QUERIES-JOIN"><div class="titlepage"><div><div><h4 class="title">7.2.1.1. 結合テーブル</h4></div></div></div><a id="id-1.5.6.6.5.6.2" class="indexterm"></a><p>結合テーブルは、2つの（実または派生）テーブルから、指定した結合種類の規則に従って派生したテーブルです。
内部結合、外部結合、およびクロス結合が使用可能です。
テーブル結合の一般的な構文は次のとおりです
</p><pre class="synopsis"><em class="replaceable"><code>T1</code></em> <em class="replaceable"><code>join_type</code></em> <em class="replaceable"><code>T2</code></em> [<span class="optional"> <em class="replaceable"><code>join_condition</code></em> </span>]</pre><p>
すべての結合は、互いに結び付けたり、あるいは入れ子にしたりすることができます。
<em class="replaceable"><code>T1</code></em>と<em class="replaceable"><code>T2</code></em>のどちらか、あるいは両方が、結合テーブルになることがあります。
括弧で<code class="literal">JOIN</code>句を括ることで結合の順序を制御することができます。
括弧がない場合、<code class="literal">JOIN</code>句は左から右に入れ子にします。
    </p><div class="variablelist"><p class="title"><strong>結合の種類</strong></p><dl class="variablelist"><dt><span class="term">クロス結合
      <a id="id-1.5.6.6.5.6.4.2.1.1" class="indexterm"></a>

      <a id="id-1.5.6.6.5.6.4.2.1.2" class="indexterm"></a>
      </span></dt><dd><pre class="synopsis"><em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em></pre><p><em class="replaceable"><code>T1</code></em>および<em class="replaceable"><code>T2</code></em>からのすべての可能な行の組み合わせ（つまりデカルト積）に対し、結合されたテーブルは<em class="replaceable"><code>T1</code></em>のすべての列の後に<em class="replaceable"><code>T2</code></em>のすべての列が続く行を含みます。
テーブルがそれぞれN行とM行で構成されているとすると、結合されたテーブルの行数は N * M 行となります。
       </p><p><code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN <em class="replaceable"><code>T2</code></em></code> は <code class="literal">FROM <em class="replaceable"><code>T1</code></em> INNER JOIN <em class="replaceable"><code>T2</code></em> ON TRUE</code> と同じです（下記を参照）。
また <code class="literal">FROM <em class="replaceable"><code>T1</code></em>, <em class="replaceable"><code>T2</code></em></code> とも同じです。
        </p><div class="note"><h3 class="title">Note</h3><p>３つ以上のテーブルが現れた場合、この後者の等価性は厳密には保たれてはいません。
なぜなら、<code class="literal">JOIN</code>はカンマより強固に結合するためです。
例えば
<code class="literal">FROM <em class="replaceable"><code>T1</code></em> CROSS JOIN
<em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em>
ON <em class="replaceable"><code>condition</code></em></code>
は
<code class="literal">FROM <em class="replaceable"><code>T1</code></em>,
<em class="replaceable"><code>T2</code></em> INNER JOIN <em class="replaceable"><code>T3</code></em>
ON <em class="replaceable"><code>condition</code></em></code>
と同じではありません。
なぜなら最初のケースでは<em class="replaceable"><code>condition</code></em>が<em class="replaceable"><code>T1</code></em>を参照できますが、2番目ではできないからです。
        </p></div><p>
       </p></dd><dt><span class="term">限定的な結合
      <a id="id-1.5.6.6.5.6.4.3.1.1" class="indexterm"></a>

      <a id="id-1.5.6.6.5.6.4.3.1.2" class="indexterm"></a>
      </span></dt><dd><pre class="synopsis"><em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em> ON <em class="replaceable"><code>boolean_expression</code></em>
<em class="replaceable"><code>T1</code></em> { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em> USING ( <em class="replaceable"><code>join column list</code></em> )
<em class="replaceable"><code>T1</code></em> NATURAL { [<span class="optional">INNER</span>] | { LEFT | RIGHT | FULL } [<span class="optional">OUTER</span>] } JOIN <em class="replaceable"><code>T2</code></em></pre><p><code class="literal">INNER</code>や<code class="literal">OUTER</code>は省略可能です。
<code class="literal">INNER</code>がデフォルトとなります。
<code class="literal">LEFT</code>、<code class="literal">RIGHT</code>、<code class="literal">FULL</code>は外部結合を意味します。
       </p><p><em class="firstterm">結合条件</em>は、<code class="literal">ON</code>句か<code class="literal">USING</code>句で指定するか、または<code class="literal">NATURAL</code>記述で暗黙的に指定します。
結合条件は、以下で詳しく説明するように、2つの元となるテーブルのどの行が<span class="quote">“<span class="quote">一致するか</span>”</span>を決めます。
       </p><p>限定的な結合には次のものがあります。

       </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">INNER JOIN</code>（内部結合）</span></dt><dd><p>T1の各行R1に対して、T2において行R1との結合条件を満たしている各行が、結合されたテーブルに含まれます。
          </p></dd><dt><span class="term"><code class="literal">LEFT OUTER JOIN</code>（左外部結合）
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.2.1.3" class="indexterm"></a>
         </span></dt><dd><p>まず、内部結合が行われます。
その後、T2のどの行との結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
したがって、連結されたテーブルは常にT1の行それぞれに少なくとも1つの行があります。
          </p></dd><dt><span class="term"><code class="literal">RIGHT OUTER JOIN</code>（右外部結合）
         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.2" class="indexterm"></a>

         <a id="id-1.5.6.6.5.6.4.3.2.4.1.3.1.3" class="indexterm"></a>
         </span></dt><dd><p>まず、内部結合が行われます。
その後、T1のどの行の結合条件も満たさないT2の各行については、T1の列をNULL値として結合行が追加されます。
これは左結合の反対です。
結果のテーブルは、T2の行が常に入ります。
          </p></dd><dt><span class="term"><code class="literal">FULL OUTER JOIN</code>（完全外部結合）</span></dt><dd><p>まず、内部結合が行われます。
その後、T2のどの行の結合条件も満たさないT1の各行については、T2の列をNULL値として結合行が追加されます。
さらに、T1のどの行でも結合条件を満たさないT2の各行に対して、T1の列をNULL値として結合行が追加されます。
          </p></dd></dl></div><p>
       </p><p><code class="literal">ON</code>句は最も汎用的な結合条件であり、<code class="literal">WHERE</code>句で使われるものと同じ論理値評価式となります。
<code class="literal">ON</code>式の評価が真となる場合、<em class="replaceable"><code>T1</code></em>および<em class="replaceable"><code>T2</code></em>の対応する行が一致します。
       </p><p><code class="literal">USING</code>句は、結合の両側で結合列に同じ名前を使っているという特別な状況の利点を活かすことができる省略形です。
それは、結合テーブルが共通で持つ列名をカンマで区切ったリストから、それぞれの列の等価性を結合条件として生成します。
例えば, <em class="replaceable"><code>T1</code></em>と<em class="replaceable"><code>T2</code></em>を<code class="literal">USING (a, b)</code>を使用して結合する場合は、<code class="literal">ON <em class="replaceable"><code>T1</code></em>.a = <em class="replaceable"><code>T2</code></em>.a AND <em class="replaceable"><code>T1</code></em>.b = <em class="replaceable"><code>T2</code></em>.b</code>という結合条件を生成します。
       </p><p>さらに、<code class="literal">JOIN USING</code>の出力は、冗長列を抑制します。マッチした列は両方が同じ値を待つので両方を出力する必要がありません。
<code class="literal">JOIN ON</code> は <em class="replaceable"><code>T1</code></em> からのすべての列と、それに続く <em class="replaceable"><code>T2</code></em> からのすべての列を生成します。
<code class="literal">JOIN USING</code>は指定された列のペアのそれぞれについて１つの出力（結合リストでの指定順）、続いて<em class="replaceable"><code>T1</code></em>の残りの列、その後に<em class="replaceable"><code>T2</code></em>の残りの列を出力します。
       </p><p>        <a id="id-1.5.6.6.5.6.4.3.2.8.1" class="indexterm"></a>
        <a id="id-1.5.6.6.5.6.4.3.2.8.2" class="indexterm"></a>
最後に、<code class="literal">NATURAL</code>は<code class="literal">USING</code>の略記形式で、２つの入力テーブルの両方に含まれているすべての列名で構成される<code class="literal">USING</code>リストを形成します。
<code class="literal">USING</code>と同様、これらの列は出力テーブルに一度だけ現れます。
共通する列が存在しない場合、<code class="literal">NATURAL JOIN</code>は<code class="literal">JOIN ... ON TRUE</code>と同様に動作し、クロス積結合を生成します。
       </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">USING</code>は、リストされている列のみ結合するのでリレーションの列の変更から適度に安全です。
<code class="literal">NATURAL</code>は、<code class="literal">USING</code>よりもかなり危険です。
いずれかのリレーションのスキーマ変更により新しくマッチする列名が作られると、結合にその新しい列も使われるようになってしまうからです。
        </p></div></dd></dl></div><p>まとめとして、 以下のテーブル<code class="literal">t1</code>
</p><pre class="programlisting"> num | name
-----+------
   1 | a
   2 | b
   3 | c</pre><p>
および、テーブル<code class="literal">t2</code>
</p><pre class="programlisting"> num | value
-----+-------
   1 | xxx
   3 | yyy
   5 | zzz</pre><p>
を想定すると、以下のように様々な結合に関する結果が得られます。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 CROSS JOIN t2;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   1 | a    |   3 | yyy
   1 | a    |   5 | zzz
   2 | b    |   1 | xxx
   2 | b    |   3 | yyy
   2 | b    |   5 | zzz
   3 | c    |   1 | xxx
   3 | c    |   3 | yyy
   3 | c    |   5 | zzz
(9 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 INNER JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 NATURAL INNER JOIN t2;</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   3 | c    | yyy
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 USING (num);</code></strong>
 num | name | value
-----+------+-------
   1 | a    | xxx
   2 | b    |
   3 | c    | yyy
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 RIGHT JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   3 | c    |   3 | yyy
     |      |   5 | zzz
(3 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 FULL JOIN t2 ON t1.num = t2.num;</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |   3 | yyy
     |      |   5 | zzz
(4 rows)</pre><p>
    </p><p><code class="literal">ON</code>で指定される結合条件には、結合に直接関係しない条件も含めることができます。
これは一部の問い合わせにおいては便利ですが、使用の際には注意が必要です。
例を示します。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num AND t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
   2 | b    |     |
   3 | c    |     |
(3 rows)</pre><p>
<code class="literal">WHERE</code>句の中に制約を記述すると異なる結果になることに注意してください。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num WHERE t2.value = 'xxx';</code></strong>
 num | name | num | value
-----+------+-----+-------
   1 | a    |   1 | xxx
(1 row)</pre><p>
この理由は<code class="literal">ON</code>句の中の制約は結合の<span class="emphasis"><em>前</em></span>に処理され、一方<code class="literal">WHERE</code>句の中の制約は結合の<span class="emphasis"><em>後</em></span>に処理されることによります。
これは内部結合には影響がありませんが、外部結合には大きな影響があります。
    </p></div><div class="sect3" id="QUERIES-TABLE-ALIASES"><div class="titlepage"><div><div><h4 class="title">7.2.1.2. テーブルと列の別名</h4></div></div></div><a id="id-1.5.6.6.5.7.2" class="indexterm"></a><a id="id-1.5.6.6.5.7.3" class="indexterm"></a><p>テーブルや複雑なテーブル参照に一時的な名前を付与し、問い合わせの以降の部分では、その名前を使ってテーブルや複雑なテーブル参照を利用することができます。
これを<em class="firstterm">テーブルの別名</em>と呼びます。
    </p><p>テーブルの別名を作成するには以下のようにします。
</p><pre class="synopsis">FROM <em class="replaceable"><code>table_reference</code></em> AS <em class="replaceable"><code>alias</code></em></pre><p>
もしくは
</p><pre class="synopsis">FROM <em class="replaceable"><code>table_reference</code></em> <em class="replaceable"><code>alias</code></em></pre><p>
<code class="literal">AS</code>キーワードはなくても構わないノイズです。
<em class="replaceable"><code>alias</code></em>は任意の識別子になります。
    </p><p>テーブルの別名の一般的な適用法は、長いテーブル名に短縮した識別子を割り当てて結合句を読みやすくすることです。
例を示します。
</p><pre class="programlisting">SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;</pre><p>
    </p><p>現在の問い合わせに関しては、別名がテーブル参照をする時の新しい名前になります。
問い合わせの他の場所で元々の名前でテーブルを参照することはできなくなります。
よって、次の例は有効ではありません。
</p><pre class="programlisting">SELECT * FROM my_table AS m WHERE my_table.a &gt; 5;    -- 間違い</pre><p>
    </p><p>テーブルの別名は主に表記を簡単にするためにあります。
しかし次のように、1つのテーブルが自分自身と結合する場合は、必須となります。
</p><pre class="programlisting">SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;</pre><p>
さらに、テーブル参照が副問い合わせ（<a class="xref" href="queries-table-expressions.html#QUERIES-SUBQUERIES" title="7.2.1.3. 副問い合わせ">Section 7.2.1.3</a>を参照）の場合に別名が必要になります。
    </p><p>括弧は曖昧さをなくすために使われます。
次の例では、最初の文で2つ目の<code class="literal">my_table</code>のインスタンスに<code class="literal">b</code>という別名を付与し、一方、2つ目の文では結合結果に対して別名を付与しています。
</p><pre class="programlisting">SELECT * FROM my_table AS a CROSS JOIN my_table AS b ...
SELECT * FROM (my_table AS a CROSS JOIN my_table) AS b ...</pre><p>
    </p><p>次のような形式でテーブル別名を付けて、テーブル自身と同様にテーブルの列に一時的な名前を付けることができます。
</p><pre class="synopsis">FROM <em class="replaceable"><code>table_reference</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>alias</code></em> ( <em class="replaceable"><code>column1</code></em> [<span class="optional">, <em class="replaceable"><code>column2</code></em> [<span class="optional">, ...</span>]</span>] )</pre><p>
もし、実際のテーブルが持つ列よりも少ない数の列の別名が与えられる場合、残りの列は改名されません。
この構文は、自己結合あるいは副問い合わせで特に役立ちます。
    </p><p>別名が<code class="literal">JOIN</code>句の結果に適用される場合、別名は<code class="literal">JOIN</code>内で参照される元々の名を隠します。
以下に例を示します。
</p><pre class="programlisting">SELECT a.* FROM my_table AS a JOIN your_table AS b ON ...</pre><p>
は有効なSQLですが、
</p><pre class="programlisting">SELECT a.* FROM (my_table AS a JOIN your_table AS b ON ...) AS c</pre><p>
は有効ではありません。
テーブルの別名<code class="literal">a</code>は、別名<code class="literal">c</code>の外側では参照することができません。
    </p></div><div class="sect3" id="QUERIES-SUBQUERIES"><div class="titlepage"><div><div><h4 class="title">7.2.1.3. 副問い合わせ</h4></div></div></div><a id="id-1.5.6.6.5.8.2" class="indexterm"></a><p>派生テーブルを指定する副問い合わせは括弧で囲む必要があります。
また、（<a class="xref" href="queries-table-expressions.html#QUERIES-TABLE-ALIASES" title="7.2.1.2. テーブルと列の別名">Section 7.2.1.2</a>にあるように）<span class="emphasis"><em>必ず</em></span>テーブル別名が割り当てられている必要があります。
例を示します。
</p><pre class="programlisting">FROM (SELECT * FROM table1) AS alias_name</pre><p>
    </p><p>この例は<code class="literal">FROM table1 AS alias_name</code>と同じです。
副問い合わせがグループ化や集約を含んでいる場合は、単純結合にまとめることはできない、より重要な例が発生します。
    </p><p>また、副問い合わせを<code class="command">VALUES</code>リストとすることもできます。
</p><pre class="programlisting">FROM (VALUES ('anne', 'smith'), ('bob', 'jones'), ('joe', 'blow'))
     AS names(first, last)</pre><p>
繰り返しますが、テーブルの別名が必要です。
<code class="command">VALUES</code>リストの列に別名を付与することは省略することもできますが、付与することを勧めます。
<a class="xref" href="queries-values.html" title="7.7. VALUESリスト">Section 7.7</a>を参照してください。
    </p></div><div class="sect3" id="QUERIES-TABLEFUNCTIONS"><div class="titlepage"><div><div><h4 class="title">7.2.1.4. テーブル関数</h4></div></div></div><a id="id-1.5.6.6.5.9.2" class="indexterm"></a><a id="id-1.5.6.6.5.9.3" class="indexterm"></a><p>テーブル関数は、基本データ型（スカラ型）、もしくは複合データ型（テーブル行）からなる行の集合を生成する関数です。
これらは、問い合わせの<code class="literal">FROM</code>句内でテーブル、ビュー、副問い合わせのように使用されます。
テーブル関数から返される列は、テーブル、ビュー、副問い合わせの列と同様の手順で、<code class="literal">SELECT</code>、<code class="literal">JOIN</code>、<code class="literal">WHERE</code>の中に含めることができます。
    </p><p>テーブル関数は<code class="literal">ROWS FROM</code>構文を使用することで、それらの返却列を一緒に組み合わせることもできます。
このときの結果の行数は、行数が最大となる関数の結果と同じになり、少ない結果側は多い結果に合わせてnull値で埋められます。
    </p><pre class="synopsis"><em class="replaceable"><code>function_call</code></em> [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]
ROWS FROM( <em class="replaceable"><code>function_call</code></em> [<span class="optional">, ... </span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]</pre><p>WITH ORDINALITY句が指定されている場合、関数の結果の列に<code class="type">bigint</code>型の列が追加されます。
この列は関数の結果の行を1から数えます。
（これは標準SQLの構文<code class="literal">UNNEST ... WITH ORDINALITY</code>の一般化です。）
デフォルトでは、この序数(ordinal)の列は<code class="literal">ordinality</code>になります。しかし別の名前を<code class="literal">AS</code>句を使用して別名を割り当てることができます。
    </p><p>特別なテーブル関数<code class="literal">UNNEST</code>は、任意の数の配列パラメータで呼ぶことができます。
そしてそれは、対応する数の列を返し、あたかも<code class="literal">UNNEST</code>(<a class="xref" href="functions-array.html" title="9.18. 配列関数と演算子">Section 9.18</a>)が各パラメータ毎に<code class="literal">ROWS FROM</code>構文を使用して結合されているかのようになります。
    </p><pre class="synopsis">UNNEST( <em class="replaceable"><code>array_expression</code></em> [<span class="optional">, ... </span>] ) [<span class="optional">WITH ORDINALITY</span>] [<span class="optional">[<span class="optional">AS</span>] <em class="replaceable"><code>table_alias</code></em> [<span class="optional">(<em class="replaceable"><code>column_alias</code></em> [<span class="optional">, ... </span>])</span>]</span>]</pre><p><em class="replaceable"><code>table_alias</code></em>が指定されない場合、テーブル名として関数名が使用されます。
<code class="literal">ROWS FROM()</code>の場合は最初の関数名が使用されます。
    </p><p>列に別名が提供されない場合、基本データ型を返す関数に対しては、列名も関数名と同じになります。
複合型を返す関数の場合は、結果の列は型の個々の属性の名前を取得します。
    </p><p>以下に数例示します。
</p><pre class="programlisting">CREATE TABLE foo (fooid int, foosubid int, fooname text);

CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$
    SELECT * FROM foo WHERE fooid = $1;
$$ LANGUAGE SQL;

SELECT * FROM getfoo(1) AS t1;

SELECT * FROM foo
    WHERE foosubid IN (
                        SELECT foosubid
                        FROM getfoo(foo.fooid) z
                        WHERE z.fooid = foo.fooid
                      );

CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);

SELECT * FROM vw_getfoo;</pre><p>
    </p><p>呼び出し方法に応じて異なる列集合を返すテーブル関数を定義することが役に立つ場合があります。
これをサポートするために、テーブル関数を<code class="type">record</code>擬似型を返すものと宣言することができます。
こうした関数を問い合わせで使用する場合、システムがその問い合わせをどのように解析し計画を作成すればよいのかが判断できるように、想定した行構造を問い合わせ自身内に指定しなければなりません。
この構文は次のようになります。
    </p><pre class="synopsis"><em class="replaceable"><code>function_call</code></em> [<span class="optional">AS</span>] <em class="replaceable"><code>alias</code></em> (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>])
<em class="replaceable"><code>function_call</code></em> AS [<span class="optional"><em class="replaceable"><code>alias</code></em></span>] (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>])
ROWS FROM( ... <em class="replaceable"><code>function_call</code></em> AS (<em class="replaceable"><code>column_definition</code></em> [<span class="optional">, ... </span>]) [<span class="optional">, ... </span>] )</pre><p><code class="literal">ROWS FROM()</code>構文を使用しない場合は、<em class="replaceable"><code>column_definition</code></em>のリストが<code class="literal">FROM</code>項目に取り付けることができる列の別名の代わりとなります。
列の定義内の名前は、列の別名として機能します。
<code class="literal">ROWS FROM()</code>構文を使用する場合は、<em class="replaceable"><code>column_definition</code></em>リストを個別に各メンバー関数に添付することができます。
またはメンバ関数が1つだけしかなく、かつ<code class="literal">WITH ORDINALITY</code>句がない場合は、<em class="replaceable"><code>column_definition</code></em>リストを、<code class="literal">ROWS FROM()</code>の後ろの列別名のリストの場所に書くことができます。
    </p><p>以下の例を考えます。

</p><pre class="programlisting">SELECT *
    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')
      AS t1(proname name, prosrc text)
    WHERE proname LIKE 'bytea%';</pre><p>
<a class="xref" href="contrib-dblink-function.html" title="dblink"><span class="refentrytitle">dblink</span></a>関数（<a class="xref" href="dblink.html" title="F.11. dblink">dblink</a>モジュールの一部）は遠隔問い合わせを実行します。
これは任意の問い合わせで使用できるように、<code class="type">record</code>を返すものと宣言されています。
実際の列集合は、パーサが例えば<code class="literal">*</code>がどのように展開されるかを理解できるように、呼び出した問い合わせ内で指定されなければなりません。
    </p></div><div class="sect3" id="QUERIES-LATERAL"><div class="titlepage"><div><div><h4 class="title">7.2.1.5. <code class="literal">LATERAL</code> 副問い合わせ</h4></div></div></div><a id="id-1.5.6.6.5.10.2" class="indexterm"></a><p>    
<code class="literal">FROM</code>に現れる副問い合わせの前にキーワード<code class="literal">LATERAL</code>を置くことができます。
こうすると、副問い合わせは先行する<code class="literal">FROM</code>項目によって提供される列を参照できます。
（<code class="literal">LATERAL</code>がない場合、それぞれの副問い合わせは個別に評価され、従ってその他の<code class="literal">FROM</code>項目を相互参照できません。）
    </p><p>    
<code class="literal">FROM</code>に現れるテーブル関数の前にもキーワード<code class="literal">LATERAL</code>を置くことが可能ですが、関数に対してこのキーワードは省略可能です。
どんな場合であっても、関数の引数は先行する <code class="literal">FROM</code>項目により提供される列の参照を含むことができます。
    </p><p>    
<code class="literal">LATERAL</code>項目は<code class="literal">FROM</code>リストの最上層、または<code class="literal">JOIN</code>木の中で表示することができます。
後者の場合、右側にある<code class="literal">JOIN</code>の左側のすべての項目を参照することが可能です。
    </p><p>    
<code class="literal">FROM</code>項目が<code class="literal">LATERAL</code>相互参照を含む場合の評価は以下のようになります。
相互参照される列（複数可）を提供する<code class="literal">FROM</code>項目のそれぞれの行、もしくは列を提供する複数の<code class="literal">FROM</code>項目の行一式に対し、<code class="literal">LATERAL</code>項目は列の行または複数行の一式の値により評価されます。
結果行（複数可）は通常のように演算された行と結合されます。
元となるテーブル（複数可）の列からそれぞれの行、または行の一式に対し反復されます。
    </p><p>    
<code class="literal">LATERAL</code>の些細な例としては以下があげられます。
</p><pre class="programlisting">SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;</pre><p>
上記は以下のより伝統的なやり方と全く同じ結果をもたらしますので特別に有用ではありません。
</p><pre class="programlisting">SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;</pre><p>
<code class="literal">LATERAL</code>は、結合される行を計算するために相互参照する列を必須とする場合、第一義的に有用です。
一般的な利用方法は、集合を返す関数に対して引数の値を提供することです。
例えば、<code class="function">vertices(polygon)</code>が多角形の頂点の組みを返す関数だとして、以下のようにしてテーブルに格納されている多角形の互いに近接する頂点を特定できます。
</p><pre class="programlisting">SELECT p1.id, p2.id, v1, v2
FROM polygons p1, polygons p2,
     LATERAL vertices(p1.poly) v1,
     LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</pre><p>
この問い合わせは以下のようにも書くことができます。
</p><pre class="programlisting">SELECT p1.id, p2.id, v1, v2
FROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,
     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2
WHERE (v1 &lt;-&gt; v2) &lt; 10 AND p1.id != p2.id;</pre><p>
そのほか幾つかの同等の定式化が考えられます。
（既に言及したとおり、<code class="literal">LATERAL</code>キーワードはこの例に於いて必要ではありませんが、明確に示すために使用しました。）
    </p><p>    
<code class="literal">LATERAL</code>副問い合わせは<code class="literal">LEFT JOIN</code>の対象として、しばしば特に重宝します。
たとえ<code class="literal">LATERAL</code>副問い合わせがそこから行を生成しない場合に於いても元となった行が結果に現れるからです。
たとえば、<code class="function">get_product_names()</code>が製造者により生産された製品名を返すとして、テーブル内のいくつかの製造者が現在製品を製造していない場合、それらは何であるかを以下のようにして見つけることができます。
</p><pre class="programlisting">SELECT m.name
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true
WHERE pname IS NULL;</pre><p>
    </p></div></div><div class="sect2" id="QUERIES-WHERE"><div class="titlepage"><div><div><h3 class="title">7.2.2. <code class="literal">WHERE</code>句</h3></div></div></div><a id="id-1.5.6.6.6.2" class="indexterm"></a><p><a class="xref" href="sql-select.html#SQL-WHERE" title="WHERE句"><code class="literal">WHERE</code>句</a>の構文は以下の通りです。
</p><pre class="synopsis">WHERE <em class="replaceable"><code>search_condition</code></em></pre><p>
ここで、<em class="replaceable"><code>search_condition</code></em>には<code class="type">boolean</code>型を返すどのような評価式（<a class="xref" href="sql-expressions.html" title="4.2. 評価式">Section 4.2</a>を参照）も指定できます。
   </p><p><code class="literal">FROM</code>句の処理が終わった後、派生した仮想テーブルの各行は検索条件と照合されます。
条件の結果が真の場合、その行は出力されます。
そうでない（すなわち結果が偽またはNULLの）場合は、その行は捨てられます。
一般的に検索条件は、<code class="literal">FROM</code>句で生成されたテーブルの最低１列を参照します。
これは必須ではありませんが、そうしないと<code class="literal">WHERE</code>句はまったく意味がなくなります。
   </p><div class="note"><h3 class="title">Note</h3><p>内部結合の結合条件は、<code class="literal">WHERE</code>句でも<code class="literal">JOIN</code>句でも記述することができます。
例えば、以下のテーブル式は等価です。
</p><pre class="programlisting">FROM a, b WHERE a.id = b.id AND b.val &gt; 5</pre><p>
および
</p><pre class="programlisting">FROM a INNER JOIN b ON (a.id = b.id) WHERE b.val &gt; 5</pre><p>
また、以下でも同じです。
</p><pre class="programlisting">FROM a NATURAL JOIN b WHERE b.val &gt; 5</pre><p>
どれを使うかは、主にスタイルの問題です。
<code class="literal">FROM</code>句の<code class="literal">JOIN</code>構文はSQL標準であるにも関わらず、おそらく他のSQLデータベース管理システムへの移植性では劣るでしょう。
外部結合については、<code class="literal">FROM</code>句以外に選択の余地はありません。
外部結合の<code class="literal">ON</code>句または<code class="literal">USING</code>句は、<code class="literal">WHERE</code>条件とは等しく<span class="emphasis"><em>ありません</em></span>。
なぜなら、最終結果での行を除去すると同様に、（一致しない入力行に対する）行の追加となるからです。
    </p></div><p><code class="literal">WHERE</code>句の例を以下に示します。
</p><pre class="programlisting">SELECT ... FROM fdt WHERE c1 &gt; 5

SELECT ... FROM fdt WHERE c1 IN (1, 2, 3)

SELECT ... FROM fdt WHERE c1 IN (SELECT c1 FROM t2)

SELECT ... FROM fdt WHERE c1 IN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10)

SELECT ... FROM fdt WHERE c1 BETWEEN (SELECT c3 FROM t2 WHERE c2 = fdt.c1 + 10) AND 100

SELECT ... FROM fdt WHERE EXISTS (SELECT c1 FROM t2 WHERE c2 &gt; fdt.c1)</pre><p>
<code class="literal">fdt</code>は<code class="literal">FROM</code>句で派生されたテーブルです。
<code class="literal">WHERE</code>句の検索条件を満たさなかった行は、<code class="literal">fdt</code>から削除されます。
評価式としてのスカラ副問い合わせの使い方に注目してください。
他の問い合わせのように、副問い合わせは複雑なテーブル式を使うことができます。
副問い合わせの中でどのように<code class="literal">fdt</code>が参照されるかにも注意してください。
<code class="literal">c1</code>を<code class="literal">fdt.c1</code>のように修飾することは、<code class="literal">c1</code>が副問い合わせの入力テーブルから派生した列名でもある時にだけ必要です。
列名の修飾は、必須の場合ではなくても、明確にするために役立ちます。
この例は、外側の問い合わせの列名の有効範囲を、どのようにして内側の問い合わせまで拡張するかを示します。
   </p></div><div class="sect2" id="QUERIES-GROUP"><div class="titlepage"><div><div><h3 class="title">7.2.3. <code class="literal">GROUP BY</code>句と<code class="literal">HAVING</code>句</h3></div></div></div><a id="id-1.5.6.6.7.2" class="indexterm"></a><a id="id-1.5.6.6.7.3" class="indexterm"></a><p><code class="literal">WHERE</code>フィルタを通した後、派生された入力テーブルを<code class="literal">GROUP BY</code>句でグループ化し、また、<code class="literal">HAVING</code>句を使用して不要なグループを取り除くことができます。
   </p><pre class="synopsis">SELECT <em class="replaceable"><code>select_list</code></em>
    FROM ...
    [<span class="optional">WHERE ...</span>]
    GROUP BY <em class="replaceable"><code>grouping_column_reference</code></em> [<span class="optional">, <em class="replaceable"><code>grouping_column_reference</code></em></span>]...</pre><p><a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY句"><code class="literal">GROUP BY</code>句</a>は、GROUP BY句で列挙されたすべての列で同じ値を所有する行をまとめてグループ化するために使用されます。
列の列挙順は関係ありません。
これは共通する値を持つそれぞれの行の集合をグループ内のすべての行を代表する１つのグループ行にまとめるものです。
これは、出力の冗長度を排除したり、それぞれのグループに適用される集約計算を行うためのものです。
以下に例を示します。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM test1;</code></strong>
 x | y
---+---
 a | 3
 c | 2
 b | 5
 a | 1
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x FROM test1 GROUP BY x;</code></strong>
 x
---
 a
 b
 c
(3 rows)</pre><p>
   </p><p>2番目の問い合わせでは、<code class="literal">SELECT * FROM test1 GROUP BY x</code>と書くことはできません。
各グループに関連付けられる列<code class="literal">y</code>の単一の値がないからです。
<code class="literal">GROUP BY</code>で指定した列はグループごとに単一の値を持つので、選択リストで参照することができます。
   </p><p>一般的に、テーブルがグループ化されている場合、<code class="literal">GROUP BY</code>でリストされていない列は集約式を除いて参照することはできません。
集約式の例は以下の通りです。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
 c |   2
(3 rows)</pre><p>
上記で<code class="literal">sum()</code> は、グループ全体について単一の値を計算する集約関数です。
使用可能な集約関数の詳細については、<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">Section 9.20</a>を参照してください。
   </p><div class="tip"><h3 class="title">Tip</h3><p>集約式を使用しないグループ化は、列内の重複しない値の集合を効率良く計算します。
これは<code class="literal">DISTINCT</code>句（<a class="xref" href="queries-select-lists.html#QUERIES-DISTINCT" title="7.3.3. DISTINCT">Section 7.3.3</a>を参照）の使用で同じように達成することができます。
    </p></div><p>別の例を示します。
これは各製品の総売上を計算します
（全製品の総売上ではありません）。
</p><pre class="programlisting">SELECT product_id, p.name, (sum(s.units) * p.price) AS sales
    FROM products p LEFT JOIN sales s USING (product_id)
    GROUP BY product_id, p.name, p.price;</pre><p>
この例では、<code class="literal">product_id</code>列、<code class="literal">p.name</code>列、<code class="literal">p.price</code>列は必ず<code class="literal">GROUP BY</code>句で指定する必要があります。
なぜなら、これらは問い合わせ選択リストの中で使われているからです（ただし、以下を参照）。
<code class="literal">s.units</code>列は<code class="literal">GROUP BY</code>で指定する必要はありません。
これは、製品ごとの売上計算の集約式（<code class="function">sum(...)</code>）の中だけで使われるためです。
この問い合わせは、各製品に対して製品の全販売に関する合計行が返されます。
   </p><a id="id-1.5.6.6.7.11" class="indexterm"></a><p>productsテーブルが、例えば、<code class="literal">product_id</code>が主キーであるように設定されている場合、nameとprice列は製品ID（product_id）に<em class="firstterm">関数依存</em>しており、このため製品IDグループそれぞれに対してどのnameとpriceの値を返すかに関するあいまいさがありませんので、上の例では<code class="literal">product_id</code>でグループ化することで十分です。
   </p><p>厳密なSQLでは、<code class="literal">GROUP BY</code>は、元となるテーブルの列によってのみグループ化できますが、<span class="productname">PostgreSQL</span>では、選択リストの列によるグループ化もできるように拡張されています。
単純な列名の代わりに、評価式でグループ化することもできます。
   </p><a id="id-1.5.6.6.7.14" class="indexterm"></a><p><code class="literal">GROUP BY</code>を使ってグループ化されたテーブルで特定のグループのみ必要な場合、結果から不要なグループを除くのに、<code class="literal">WHERE</code>句のように<code class="literal">HAVING</code>句を使うことができます。
構文は以下の通りです。
</p><pre class="synopsis">SELECT <em class="replaceable"><code>select_list</code></em> FROM ... [<span class="optional">WHERE ...</span>] GROUP BY ... HAVING <em class="replaceable"><code>boolean_expression</code></em></pre><p>
<code class="literal">HAVING</code>句内の式は、グループ化された式とグループ化されてない式（この場合は集約関数が必要になります）の両方を参照することができます。
   </p><p>例を示します。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING sum(y) &gt; 3;</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT x, sum(y) FROM test1 GROUP BY x HAVING x &lt; 'c';</code></strong>
 x | sum
---+-----
 a |   4
 b |   5
(2 rows)</pre><p>
   </p><p>次に、より現実的な例を示します。
</p><pre class="programlisting">SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit
    FROM products p LEFT JOIN sales s USING (product_id)
    WHERE s.date &gt; CURRENT_DATE - INTERVAL '4 weeks'
    GROUP BY product_id, p.name, p.price, p.cost
    HAVING sum(p.price * s.units) &gt; 5000;</pre><p>
上の例で、<code class="literal">WHERE</code>句は、グループ化されていない列によって行を選択している（この式では最近の4週間の売上のみが真になります）のに対し、<code class="literal">HAVING</code>句は出力を売上高が5000を超えるグループに制限しています。
集約式が、問い合わせ内で常に同じである必要がないことに注意してください。
   </p><p>ある問い合わせが集約関数を含んでいるが<code class="literal">GROUP BY</code>句がない場合でも、グループ化は依然として行われます。
結果は単一グループ行（または<code class="literal">HAVING</code>で単一行が削除されれば、行が全くなくなるかもしれません）となります。
<code class="literal">HAVING</code>句を含んでいれば、集約関数呼び出しや<code class="literal">GROUP BY</code>句がまったく存在しなくても同じことが言えます。
   </p></div><div class="sect2" id="QUERIES-GROUPING-SETS"><div class="titlepage"><div><div><h3 class="title">7.2.4. <code class="literal">GROUPING SETS</code>、<code class="literal">CUBE</code>、<code class="literal">ROLLUP</code></h3></div></div></div><a id="id-1.5.6.6.8.2" class="indexterm"></a><a id="id-1.5.6.6.8.3" class="indexterm"></a><a id="id-1.5.6.6.8.4" class="indexterm"></a><p>上述のものよりも複雑なグループ化の操作は、<em class="firstterm">グループ化セット</em>の概念を用いることで可能です。
<code class="literal">FROM</code>句と<code class="literal">WHERE</code>句によって選択されたデータは、指定されたグループ化セットによってそれぞれグループ化され、単純な<code class="literal">GROUP BY</code>句と同じように集約計算され、その後結果が返されます。
例を示します。
</p><pre class="screen"><code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT * FROM items_sold;</code></strong>
 brand | size | sales
-------+------+-------
 Foo   | L    |  10
 Foo   | M    |  20
 Bar   | M    |  15
 Bar   | L    |  5
(4 rows)

<code class="prompt">=&gt;</code> <strong class="userinput"><code>SELECT brand, size, sum(sales) FROM items_sold GROUP BY GROUPING SETS ((brand), (size), ());</code></strong>
 brand | size | sum
-------+------+-----
 Foo   |      |  30
 Bar   |      |  20
       | L    |  15
       | M    |  35
       |      |  50
(5 rows)</pre><p>
   </p><p><code class="literal">GROUPING SETS</code>の各サブリストはゼロ個以上の列または式を指定することが出来ます。
そして、それが直接<code class="literal">GROUP BY</code>句で指定したのと同じように解釈されます。
空のグループ化セットは、全行が一つのグループにまで集約されることを意味します（何も入力行が存在しない場合でも出力されます）。
これは、上述した<code class="literal">GROUP BY</code>句がない集約関数の場合と同様です。
   </p><p>グループ化している列または式の参照は、その列が現われないグループ化セットの結果行ではNULL値に置き換えられます。
特定の出力行が、どのグループ化から生じたかを識別するには<a class="xref" href="functions-aggregate.html#FUNCTIONS-GROUPING-TABLE" title="Table 9.56. グループ化演算">Table 9.56</a>を参照して下さい。
   </p><p>グループ化セットの中で一般的な２種類については、略記法での指定方法が提供されています。
</p><pre class="programlisting">ROLLUP ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... )</pre><p>
上の句は、式の指定されたリストと空のリストを含めたリストのすべてのプレフィックスを表します。
したがって、以下と同等です。
</p><pre class="programlisting">GROUPING SETS (
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, <em class="replaceable"><code>e3</code></em>, ... ),
    ...
    ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em> ),
    ( <em class="replaceable"><code>e1</code></em> ),
    ( )
)</pre><p>
これは一般に、階層データに対する分析のために使用されます。例えば、部署、部門、全社合計による総給与を出します。
   </p><pre class="programlisting">CUBE ( <em class="replaceable"><code>e1</code></em>, <em class="replaceable"><code>e2</code></em>, ... )</pre><p>
上の句は、与えられたリストとその可能な部分集合（サブセット）のすべて（すなわち、べき集合）を表します。
したがって
</p><pre class="programlisting">CUBE ( a, b, c )</pre><p>
は以下と同等です。
</p><pre class="programlisting">GROUPING SETS (
    ( a, b, c ),
    ( a, b    ),
    ( a,    c ),
    ( a       ),
    (    b, c ),
    (    b    ),
    (       c ),
    (         )
)</pre><p>
   </p><p><code class="literal">CUBE</code>句や<code class="literal">ROLLUP</code>句の各要素は、個々の式、または括弧で囲まれた要素のサブリスト、どちらかに出来ます。
後者の場合には、サブリストは個々のグループ化セットを生成する目的において一つの単位として扱われます。
例えば
</p><pre class="programlisting">CUBE ( (a, b), (c, d) )</pre><p>
は以下と同等です。
</p><pre class="programlisting">GROUPING SETS (
    ( a, b, c, d ),
    ( a, b       ),
    (       c, d ),
    (            )
)</pre><p>
そして
</p><pre class="programlisting">ROLLUP ( a, (b, c), d )</pre><p>
は以下と同等です。
</p><pre class="programlisting">GROUPING SETS (
    ( a, b, c, d ),
    ( a, b, c    ),
    ( a          ),
    (            )
)</pre><p>
   </p><p><code class="literal">CUBE</code>と<code class="literal">ROLLUP</code>構文は、<code class="literal">GROUP BY</code>句の中で直接使用、または<code class="literal">GROUPING SETS</code>句の中で入れ子に出来ます。
<code class="literal">GROUPING SETS</code>句が別の内側に入れ子になっている場合、内側の句が外側の句に直接書かれている場合と効果は同じになります。
   </p><p>複数の集約項目が<code class="literal">GROUP BY</code>句一つで指定されている場合、グループ化セットの最終的なリストは、個々の項目の外積（クロス積）です。
例えば
</p><pre class="programlisting">GROUP BY a, CUBE (b, c), GROUPING SETS ((d), (e))</pre><p>
は以下と同等です。
</p><pre class="programlisting">GROUP BY GROUPING SETS (
    (a, b, c, d), (a, b, c, e),
    (a, b, d),    (a, b, e),
    (a, c, d),    (a, c, e),
    (a, d),       (a, e)
)</pre><p>
   </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">(a, b)</code>という構文は通常<a class="link" href="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS" title="4.2.13. 行コンストラクタ">行コンストラクタ</a>として式に認識されます。
<code class="literal">GROUP BY</code>句の中では、トップレベルの式の場合これは適用されず、<code class="literal">(a, b)</code>は上記のような式のリストとして解析されます。
何らかの理由で、グループ化式の中で行コンストラクタが<span class="emphasis"><em>必要</em></span>になった場合は、<code class="literal">ROW(a, b)</code>を使用して下さい。
   </p></div></div><div class="sect2" id="QUERIES-WINDOW"><div class="titlepage"><div><div><h3 class="title">7.2.5. ウィンドウ関数処理</h3></div></div></div><a id="id-1.5.6.6.9.2" class="indexterm"></a><p>問い合わせがウィンドウ関数（<a class="xref" href="tutorial-window.html" title="3.5. ウィンドウ関数">Section 3.5</a>、<a class="xref" href="functions-window.html" title="9.21. ウィンドウ関数">Section 9.21</a>と<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. ウィンドウ関数呼び出し">Section 4.2.8</a>を参照）を含んでいれば、これらの関数はグループ化、集約および<code class="literal">HAVING</code>条件検索が行われた後に評価されます。
つまり、問い合わせが何らかの集約、<code class="literal">GROUP BY</code>または<code class="literal">HAVING</code>を使用していれば、ウィンドウ関数により見える行は<code class="literal">FROM</code>/<code class="literal">WHERE</code>での本来のテーブル行ではなく、グループ行となります。
   </p><p>複数のウィンドウ関数が使用された場合、そのウィンドウ定義にある構文的に同等である<code class="literal">PARTITION BY</code>および<code class="literal">ORDER BY</code>句を持つすべてのウィンドウ関数は、データ全体に渡って単一の実行手順により評価されることが保証されています。
したがって、<code class="literal">ORDER BY</code>が一意に順序付けを決定しなくても同一の並べ替え順序付けを見ることができます。
しかし、異なる<code class="literal">PARTITION BY</code>または<code class="literal">ORDER BY</code>仕様を持つ関数の評価については保証されません。
（このような場合、並べ替え手順がウィンドウ関数評価の諸手順間で一般的に必要となり、<code class="literal">ORDER BY</code>が等価と判断する行の順序付けを保存するような並べ替えは保証されません。）
   </p><p>現時点では、ウィンドウ関数は常に事前に並べ替えられたデータを必要とするので、問い合わせ出力はウィンドウ関数の<code class="literal">PARTITION BY</code>/<code class="literal">ORDER BY</code>句のどれか１つに従って順序付けされます。
とはいえ、これに依存することは薦められません。
確実に結果が特定の方法で並べ替えられるようにしたいのであれば、明示的な最上階層の<code class="literal">ORDER BY</code>を使用します。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="queries-overview.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="queries.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="queries-select-lists.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.1. 概要 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.3. 選択リスト</td></tr></table></div></body></html>