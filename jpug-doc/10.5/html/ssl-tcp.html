<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.9. SSLによる安全なTCP/IP接続</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="encryption-options.html" title="18.8. 暗号化オプション" /><link rel="next" href="ssh-tunnels.html" title="18.10. SSHトンネルを使った安全なTCP/IP接続" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">18.9. SSLによる安全なTCP/IP接続</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="encryption-options.html" title="18.8. 暗号化オプション">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Chapter 18. サーバの準備と運用">Up</a></td><th width="60%" align="center">Chapter 18. サーバの準備と運用</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ssh-tunnels.html" title="18.10. SSHトンネルを使った安全なTCP/IP接続">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SSL-TCP"><div class="titlepage"><div><div><h2 class="title" style="clear: both">18.9. SSLによる安全なTCP/IP接続</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ssl-tcp.html#SSL-CLIENT-CERTIFICATES">18.9.1. クライアント証明書の使用</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-SERVER-FILES">18.9.2. サーバにおけるSSL関連ファイルの利用</a></span></dt><dt><span class="sect2"><a href="ssl-tcp.html#SSL-CERTIFICATE-CREATION">18.9.3. 証明書の作成</a></span></dt></dl></div><a id="id-1.6.5.11.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は標準で<acronym class="acronym">SSL</acronym>接続をサポートし、クライアント/サーバの通信がさらに安全になるよう暗号化します。
そのためには<span class="productname">OpenSSL</span>がクライアントとサーバシステムの両方にインストールされ、構築時に<span class="productname">PostgreSQL</span>におけるそのサポートが有効になっている必要があります（<a class="xref" href="installation.html" title="Chapter 16.  ソースコードからインストール">Chapter 16</a>を参照してください）。
  </p><p><acronym class="acronym">SSL</acronym>サポートを有効にしてコンパイルされた場合、<span class="productname">PostgreSQL</span>サーバは、<code class="filename">postgresql.conf</code>において<a class="xref" href="runtime-config-connection.html#GUC-SSL">ssl</a>パラメータを<code class="literal">on</code>にすることで、<acronym class="acronym">SSL</acronym>サポートを有効にして起動することができます。
サーバは同じTCPポートで通常の接続と<acronym class="acronym">SSL</acronym>接続の両方を待ち受け、クライアントとの接続に<acronym class="acronym">SSL</acronym>を使用するかどうかを調停します。
デフォルトでは、これはクライアント側の選択肢です。
一部またはすべての接続で<acronym class="acronym">SSL</acronym>の使用を必要とさせるためのサーバ側の設定方法に関しては<a class="xref" href="auth-pg-hba-conf.html" title="20.1. pg_hba.confファイル">Section 20.1</a>を参照してください。
  </p><p><span class="productname">PostgreSQL</span>は、システム全体用の<span class="productname">OpenSSL</span>設定ファイルを読み取ります。
デフォルトでは、このファイルの名前は<code class="filename">openssl.cnf</code>であり、<code class="literal">openssl version -d</code>で報告されるディレクトリに存在します。
このデフォルトは、環境変数<code class="envar">OPENSSL_CONF</code>を希望する設定ファイルの名前に設定することにより変更可能です。
  </p><p><span class="productname">OpenSSL</span>は、強度が異なる、多くの暗号化および認証用のアルゴリズムをサポートします。
暗号の一覧は<span class="productname">OpenSSL</span>設定ファイル内で指定することができますが、<code class="filename">postgresql.conf</code>内の<a class="xref" href="runtime-config-connection.html#GUC-SSL-CIPHERS">ssl_ciphers</a>を変更することで、データベースサーバで使用される暗号を指定することができます。
  </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">NULL-SHA</code>または<code class="literal">NULL-MD5</code>暗号を使用して暗号化のオーバーヘッドなしで認証を行うことが可能です。
しかし、中間者はクライアントサーバ間の通信を読み取り中継することができます。
また、暗号化のオーバーヘッドは認証のオーバーヘッドと比べると最小です。
こうした理由によりNULL暗号は推奨しません。
   </p></div><p><acronym class="acronym">SSL</acronym>モードで起動するには、サーバ証明書と秘密鍵を含むファイルが存在していなければなりません。
デフォルトでは、これらのファイルは<code class="filename">server.crt</code>および<code class="filename">server.key</code>という名前で、それぞれがサーバのデータディレクトリに存在していることが想定されていますが、設定パラメータの<a class="xref" href="runtime-config-connection.html#GUC-SSL-CERT-FILE">ssl_cert_file</a>と<a class="xref" href="runtime-config-connection.html#GUC-SSL-KEY-FILE">ssl_key_file</a>によって他の名前、他の場所を指定することもできます。
  </p><p>Unixシステムでは、<code class="filename">server.key</code>の権限は所有者以外からのアクセスを許可してはなりません。
これは<code class="command">chmod 0600 server.key</code>というコマンドで実現できます。
あるいは、このファイルの所有者をrootにして、グループに読み取りアクセス権を与える（つまり、パーミッションを<code class="literal">0640</code>にする）ということもできます。
この設定は、証明書と鍵ファイルがオペレーティングシステムによって管理されるインストレーションのためのものです。
<span class="productname">PostgreSQL</span>サーバを実行するユーザは、証明書と鍵ファイルにアクセス権のあるグループのメンバーにする必要があります。
  </p><p>秘密鍵がパスフレーズで保護されている場合、サーバはパスフレーズの入力を促し、入力されるまでは起動しません。
パスフレーズを使用すると、サーバを再起動せずにサーバのSSL設定を変更する機能も無効になります。
さらに、パスフレーズで保護された秘密鍵は、Windowsではまったく使用できません。
  </p><p><code class="filename">server.crt</code>の最初の証明書は、サーバ証明書になり、秘密鍵とマッチしなければなりません。
<span class="quote">“<span class="quote">中間</span>”</span>認証局の証明書をファイルに追加することもできます。
これにより、ルートと中間証明書が<code class="literal">v3_ca</code>拡張により作成されていることが前提になりますが、中間証明書をクライアントに保存する必要が無くなります。
これは、中間証明書の有効期限の扱いをより簡単にします。
  </p><p><code class="filename">server.crt</code>にルート証明書を追加する必要はありません。
代わりに、クライアントはサーバ証明書のチェーンを持つルート証明書を持っていなければなりません。
  </p><div class="sect2" id="SSL-CLIENT-CERTIFICATES"><div class="titlepage"><div><div><h3 class="title">18.9.1. クライアント証明書の使用</h3></div></div></div><p>信頼できる証明書をクライアントに要求するには、信頼するルート認証局（<acronym class="acronym">CA</acronym>）の証明書をデータディレクトリ内のファイルに置き、<code class="filename">postgresql.conf</code>の<a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a>パラメータを<code class="literal">root.crt</code>に設定し、認証オプション<code class="literal">clientcert=1</code>を<code class="filename">pg_hba.conf</code>の適切な<code class="literal">hostssl</code>行に追加します。
そうすると、SSL接続の開始時にクライアントへ証明書が要求されます。
（クライアント上での証明書の設定方法については<a class="xref" href="libpq-ssl.html" title="33.18. SSLサポート">Section 33.18</a>を参照してください。）
サーバは、クライアントの証明書が信頼する認証局のいずれかにより署名されていることを検証します。
  </p><p>   
既存のルート証明書に連鎖する中間証明書は、クライアントに保存することを避けたい場合に<code class="filename">root.crt</code>に含めることができます（ルート証明書と中間証明書が<code class="literal">v3_ca</code>拡張で作成されている場合）。
<a class="xref" href="runtime-config-connection.html#GUC-SSL-CRL-FILE">ssl_crl_file</a>パラメータが設定されている場合、証明書失効リスト（CRL）項目も検査されます。
（SSL証明書の使用方法を示す図については<a class="ulink" href="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04s02.html" target="_top">http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04s02.html</a>を参照してください。）
  </p><p>認証オプション<code class="literal">clientcert</code>はすべての認証方式について利用可能ですが、<code class="filename">pg_hba.conf</code>の<code class="literal">hostssl</code>として指定された行でのみ有効です。
<code class="literal">clientcert</code>が指定されていない、または0と設定されている場合でも、認証局のリストが設定されていれば、サーバはその認証局に対してクライアント証明書の検証を行いますが、クライアント証明書を提示することを要求しません。
  </p><p>クライアント証明書を設定している場合、接続の安全性を提供するとともに証明書でユーザ認証を制御できるように<code class="literal">cert</code>認証方式を使用したいと考えるかもしれません。
詳細については<a class="xref" href="auth-methods.html#AUTH-CERT" title="20.3.9. 証明書認証">Section 20.3.9</a>を参照してください。
（<code class="literal">cert</code>認証方式を使用している場合は、明示的に<code class="literal">clientcert=1</code>を指定する必要はありません。）
  </p></div><div class="sect2" id="SSL-SERVER-FILES"><div class="titlepage"><div><div><h3 class="title">18.9.2. サーバにおけるSSL関連ファイルの利用</h3></div></div></div><p><a class="xref" href="ssl-tcp.html#SSL-FILE-USAGE" title="Table 18.2. SSLサーバファイルの使用方法">Table 18.2</a>にて、サーバにおけるSSLの設定に関連するファイルをまとめます。
（表示されているファイル名はデフォルトまたは一般的な名前です。異なる名前を個別に設定することもできます。）
   </p><div class="table" id="SSL-FILE-USAGE"><p class="title"><strong>Table 18.2. SSLサーバファイルの使用方法</strong></p><div class="table-contents"><table class="table" summary="SSLサーバファイルの使用方法" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>ファイル</th><th>内容</th><th>影響</th></tr></thead><tbody><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CERT-FILE">ssl_cert_file</a> (<code class="filename">$PGDATA/server.crt</code>)</td><td>サーバ証明書</td><td>サーバの身元を示すためにクライアントに送信します</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-KEY-FILE">ssl_key_file</a> (<code class="filename">$PGDATA/server.key</code>)</td><td>サーバの秘密鍵</td><td>サーバ証明書が所有者によって送られたことを証明します。証明書所有者が信頼できることを意味しません。</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CA-FILE">ssl_ca_file</a> (<code class="filename">$PGDATA/root.crt</code>)</td><td>信頼できる認証局</td><td>信頼する認証局により署名されたクライアント証明書か検査します。</td></tr><tr><td><a class="xref" href="runtime-config-connection.html#GUC-SSL-CRL-FILE">ssl_crl_file</a> (<code class="filename">$PGDATA/root.crl</code>)</td><td>認証局により失効された証明書</td><td>クライアント証明書はこの一覧にあってはいけません。</td></tr></tbody></table></div></div><br class="table-break" /><p>サーバは、サーバ起動時及びサーバ設定がリロードされるたびに、これらのファイルを読み取ります。
<span class="systemitem">Windows</span>システム上では新しいクライアント接続のために新しいバックエンドプロセスが生成されるたびに再読み込みされます。
   </p><p>サーバ起動時にこれらのファイルのエラーが検出された場合、サーバは起動を拒否します。
ただし、設定のリロード中にエラーが検出された場合、ファイルは無視され、古いSSL設定が引き続き使用されます。
<span class="systemitem">Windows</span>システム上ではバックエンドの開始時にこれらのファイルのエラーが検出された場合、そのバックエンドはSSL接続を確立出来ません。
これらのすべてのケースでは、エラー状態がサーバログに記録されます。
   </p></div><div class="sect2" id="SSL-CERTIFICATE-CREATION"><div class="titlepage"><div><div><h3 class="title">18.9.3. 証明書の作成</h3></div></div></div><p>365日有効なサーバ用の自己署名証明書を簡単に作るためには下記の<span class="productname">OpenSSL</span>コマンドを実行してください（<em class="replaceable"><code>dbhost.yourdomain.com</code></em>をサーバのホスト名に置き換えてください）。
</p><pre class="programlisting">openssl req -new -x509 -days 365 -nodes -text -out server.crt \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"</pre><p>
続けて以下も実行します。
</p><pre class="programlisting">chmod og-rwx server.key</pre><p>
サーバの秘密鍵および証明書を作成するための詳しい方法については<span class="productname">OpenSSL</span>の文書を参照してください。
   </p><p>テストには自己署名証明書を使用できますが、運用時は認証局(<acronym class="acronym">CA</acronym>)（通常は事業全体の<acronym class="acronym">CA</acronym>）により署名された証明書を使用する必要があります。
   </p><p>クライアントが身元を検証できるサーバ証明書を作成するには、まず最初に証明書署名要求(<acronym class="acronym">CSR</acronym>) と公開／秘密鍵を作成します。
</p><pre class="programlisting">openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<em class="replaceable"><code>root.yourdomain.com</code></em>"
chmod og-rwx root.key</pre><p>
その後、鍵を使用して署名要求に署名しルート証明書を作成します（<span class="productname">Linux</span>上のデフォルトの<span class="productname">OpenSSL</span>設定ファイルの場所を使用）。
</p><pre class="programlisting">openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt</pre><p>
最後に、新しいルート証明書によって署名されるサーバ証明書を作成します。
</p><pre class="programlisting">openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"
chmod og-rwx server.key

openssl x509 -req -in server.csr -text -days 365 \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out server.crt</pre><p>
<code class="filename">server.crt</code>と<code class="filename">server.key</code>をサーバに格納し、<code class="filename">root.crt</code>をクライアントに格納します。
クライアントはサーバのリーフ証明書が信頼されたルート証明書によって署名されたことを確認できます。
<code class="filename">root.key</code>は将来の証明書の作成に使用するために、オフラインで保存する必要があります。
   </p><p>中間証明書が含まれる信頼の連鎖を作成することも可能です。
</p><pre class="programlisting"># root
openssl req -new -nodes -text -out root.csr \
  -keyout root.key -subj "/CN=<em class="replaceable"><code>root.yourdomain.com</code></em>"
chmod og-rwx root.key
openssl x509 -req -in root.csr -text -days 3650 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -signkey root.key -out root.crt

# intermediate
openssl req -new -nodes -text -out intermediate.csr \
  -keyout intermediate.key -subj "/CN=<em class="replaceable"><code>intermediate.yourdomain.com</code></em>"
chmod og-rwx intermediate.key
openssl x509 -req -in intermediate.csr -text -days 1825 \
  -extfile /etc/ssl/openssl.cnf -extensions v3_ca \
  -CA root.crt -CAkey root.key -CAcreateserial \
  -out intermediate.crt

# leaf
openssl req -new -nodes -text -out server.csr \
  -keyout server.key -subj "/CN=<em class="replaceable"><code>dbhost.yourdomain.com</code></em>"
chmod og-rwx server.key
openssl x509 -req -in server.csr -text -days 365 \
  -CA intermediate.crt -CAkey intermediate.key -CAcreateserial \
  -out server.crt</pre><p>
<code class="filename">server.crt</code>と<code class="filename">intermediate.crt</code>は証明書ファイルに束ねて連結し、サーバに格納する必要があります。
<code class="filename">server.key</code>もまたサーバーに格納される必要があります。
サーバのリーフ証明書が信頼されたルート証明書にリンクされた一連の証明書によって署名されていることをクライアントが確認できるように、<code class="filename">root.crt</code>をクライアントに格納する必要があります。
<code class="filename">root.key</code>と<code class="filename">intermediate.key</code>は将来の証明書を作成に使用するためにオフラインで格納する必要があります。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="encryption-options.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ssh-tunnels.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">18.8. 暗号化オプション </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 18.10. <span class="application">SSH</span>トンネルを使った安全なTCP/IP接続</td></tr></table></div></body></html>