<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>32.1. テストの実行</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="regress.html" title="Chapter 32. リグレッションテスト" /><link rel="next" href="regress-evaluation.html" title="32.2. テストの評価" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">32.1. テストの実行</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="regress.html" title="Chapter 32. リグレッションテスト">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="regress.html" title="Chapter 32. リグレッションテスト">Up</a></td><th width="60%" align="center">Chapter 32. リグレッションテスト</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="regress-evaluation.html" title="32.2. テストの評価">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="REGRESS-RUN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">32.1. テストの実行</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.3">32.1.1. 一時的なインストレーションに対するテストの実行</a></span></dt><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.4">32.1.2. 既存のインストレーションに対するテストの実行</a></span></dt><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.5">32.1.3. 追加のテストスイート</a></span></dt><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.6">32.1.4. ロケールと符号化方式</a></span></dt><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.7">32.1.5. 追加のテスト</a></span></dt><dt><span class="sect2"><a href="regress-run.html#id-1.6.19.5.8">32.1.6. ホットスタンバイのテスト</a></span></dt></dl></div><p>リグレッションテストは既にインストールされ稼働中のサーバや、ビルドツリー内の一時的なインストレーションに対して実行することができます。
さらに、テストの実行には<span class="quote">“<span class="quote">並行</span>”</span>と<span class="quote">“<span class="quote">連続</span>”</span>モードがあります。
連続モードでは個々のテストスクリプトを単独で実行し、並行モードでは複数のサーバプロセスを実行し、テストをグループ化して並行的に実行します。
並行テストではプロセス間通信とロック機能が正常に作動しているかをテストします。
  </p><div class="sect2" id="id-1.6.19.5.3"><div class="titlepage"><div><div><h3 class="title">32.1.1. 一時的なインストレーションに対するテストの実行</h3></div></div></div><p>構築後、インストール前に並行リグレッションテストを行う場合には、最上位のディレクトリで以下のように入力してください。
</p><pre class="screen">make check</pre><p>
（または、<code class="filename">src/test/regress</code>ディレクトリに移動して、そこで実行してください。）
終了したら以下のような表示がされるはずです。
</p><pre class="screen"><code class="computeroutput">=======================
 All 115 tests passed.
=======================</code></pre><p>
これが表示されなければ、テストは失敗したことになります。
<span class="quote">“<span class="quote">失敗</span>”</span>を深刻な問題であると推測する前に、以下の <a class="xref" href="regress-evaluation.html" title="32.2. テストの評価">Section 32.2</a> を参照してください。
  </p><p>この試験方法では、一時的にサーバを起動するので、rootユーザとして構築を行なった場合には動作しません。
サーバがrootでは起動しないからです。
rootで構築をしないこと、もしくはインストール完了後に試験を実施することをお薦めします。
   </p><p>古い<span class="productname">PostgreSQL</span>のインストレーションが既に存在している場所に<span class="productname">PostgreSQL</span>をインストールするように構築した場合、新しいバージョンをインストールする前に<code class="literal">make check</code>を行うと、新しいプログラムがインストール済みの共有ライブラリを使用しようとするために試験が失敗することになります。
（典型的な症状は、未定義シンボルに関するエラーメッセージです。）
古いインストレーションを上書きする前に試験を行いたいのであれば、<code class="literal">configure --disable-rpath</code>で構築する必要があります。
しかし、このオプションを最終的なインストレーションで使用することは推奨しません。
   </p><p>並行リグレッションテストは、実行したユーザのユーザIDを使用して相当数のプロセスを起動します。
現在、最大で20個の並行テストスクリプトが同時に実行されますが、これは合計40個のプロセスが実行されることを意味します。
各テストスクリプトに対して、1つのサーバプロセスと1つの<span class="application">psql</span>プロセスが存在するためです。
ですので、使用するシステムでユーザ当たりのプロセス数に制限を加えている場合は、その上限が少なくとも50程度であることを確認してください。
さもないと、並行テストにおいて、ランダムに発生しているように見える失敗が発生するかもしれません。
この上限を変更できない場合は、<code class="literal">MAX_CONNECTIONS</code>パラメータを編集して、並行度を減らすことができます。
例えば、以下は同時実行数を10以下で実行します。
</p><pre class="screen">make MAX_CONNECTIONS=10 check</pre><p>
   </p></div><div class="sect2" id="id-1.6.19.5.4"><div class="titlepage"><div><div><h3 class="title">32.1.2. 既存のインストレーションに対するテストの実行</h3></div></div></div><p>インストール（<a class="xref" href="installation.html" title="Chapter 16.  ソースコードからインストール">Chapter 16</a>を参照）後にテストを実行するには、<a class="xref" href="runtime.html" title="Chapter 18. サーバの準備と運用">Chapter 18</a>で説明したようにデータ領域を初期化し、サーバを起動し、そして以下を入力してください。
</p><pre class="screen">make installcheck</pre><p>
もしくは、並行テストの場合は以下を入力してください。
</p><pre class="screen">make installcheck-parallel</pre><p>
テストでは、<code class="envar">PGHOST</code>環境変数と<code class="envar">PGPORT</code>環境変数で指定がない限り、ローカルホストのサーバに接続し、デフォルトのポート番号を使用します。
テストは<code class="literal">regression</code>という名前のデータベースで行なわれます。
この名前の既存のデータベースはすべて削除されます。
  </p><p>テストは、ロールやテーブル空間のようなクラスタ全体にわたるオブジェクトも一時的に作成します。
このオブジェクトの名前は<code class="literal">regress_</code>で始まります。
実際のユーザーやテーブル空間がそのように名付けられたインストレーションで<code class="literal">installcheck</code>モードを使う場合には注意してください。
  </p></div><div class="sect2" id="id-1.6.19.5.5"><div class="titlepage"><div><div><h3 class="title">32.1.3. 追加のテストスイート</h3></div></div></div><p><code class="literal">make check</code>と<code class="literal">make installcheck</code>コマンドは<span class="quote">“<span class="quote">コア</span>”</span>リグレッションテストだけを実行します。
そのテストは<span class="productname">PostgreSQL</span>サーバに組み込まれている機能のみをテストします。
ソース配布には、オプションとなっている手続き言語のような追加機能とその多くが関係のある追加のテストスイートも含まれています。
  </p><p>コアテストを含む、構築するよう選択されたモジュールに適用できるテストスイートをすべて実行するにはビルドツリーの最上位で以下のコマンドの一つを入力して下さい。
</p><pre class="screen">make check-world
make installcheck-world</pre><p>
<code class="literal">make check</code>と<code class="literal">make installcheck</code>で以前述べたように、このコマンドは、それぞれ、一時的なサーバもしくは既にインストールされているサーバを使ってテストを行ないます。
それ以外に考慮すべきことはそれぞれのところで以前述べたことと同じです。
<code class="literal">make check-world</code>はテストするモジュール毎に別の一時的なインストールツリーを構築しますので、<code class="literal">make installcheck-world</code>よりもずっとより多くの時間とディスク容量が必要です。
  </p><p>代わりに、構築ツリーの適切なサブディレクトリで<code class="literal">make check</code>または<code class="literal">make installcheck</code>と入力することで個々のテストスイートを実行することもできます。
<code class="literal">make installcheck</code>はコアサーバだけでなく、関係のあるモジュールもインストール済みであると仮定することを覚えておいて下さい。
  </p><p>このように実行できる追加のテストには以下のものが含まれます。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>オプションとなっている手続き言語のリグレッションテスト（<span class="application">PL/pgSQL</span>を除きます。そちらはコアテストでテストされます）。
これは<code class="filename">src/pl</code>にあります。
    </p></li><li class="listitem"><p><code class="filename">contrib</code>の下にある<code class="filename">contrib</code>モジュールのリグレッションテスト。
すべての<code class="filename">contrib</code>モジュールにテストがあるわけではありません。
    </p></li><li class="listitem"><p>ECPGインタフェースライブラリのリグレッションテスト。
<code class="filename">src/interfaces/ecpg/test</code>にあります。
    </p></li><li class="listitem"><p>同時実行中のセッションの振舞いの負荷テスト。
<code class="filename">src/test/isolation</code>にあります。
    </p></li><li class="listitem"><p><code class="filename">src/bin</code>以下のクライアントプログラムのテスト。
<a class="xref" href="regress-tap.html" title="32.4. TAPテスト">Section 32.4</a>も参照してください。
    </p></li></ul></div><p><code class="literal">installcheck</code>モードを使う場合には、上記のテストは<code class="literal">regression</code>だけでなく<code class="literal">pl_regression</code>、<code class="literal">contrib_regression</code>、<code class="literal">isolation_regression</code>、<code class="literal">ecpg1_regression</code>、<code class="literal">ecpg2_regression</code>という名前の既存のデータベースも破壊します。
  </p><p>オプション<code class="option">--enable-tap-tests</code>を指定してPostgreSQLを構築した場合にのみ、TAPベースのテストが行なわれます。
これは開発にはお薦めですが、適切なPerlのインストレーションがない場合には省略できます。
  </p></div><div class="sect2" id="id-1.6.19.5.6"><div class="titlepage"><div><div><h3 class="title">32.1.4. ロケールと符号化方式</h3></div></div></div><p>デフォルトでは、一時的なインストレーションを使うテストは、現在の環境で定義されたロケールと<code class="command">initdb</code>で決定される対応するデータベース符号化方式を使用します。
異なるロケールを試験する際は、以下の例のように適切な環境変数を設定することが有用です。
</p><pre class="screen">make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8</pre><p>
実装上の理由のため、<code class="envar">LC_ALL</code>はこの目的には動作しません。
この他のロケール関連の環境変数は動作します。
   </p><p>既存のインストレーションに対するテストでは、ロケールは既存のデータベースクラスタによって決まり、テスト実行時に別の値に設定することができません。
   </p><p>また、以下の例のように<code class="envar">ENCODING</code>変数を設定することで明示的にデータベース符号化方式を選択することができます。
</p><pre class="screen">make check LANG=C ENCODING=EUC_JP</pre><p>
この方法でデータベース符号化方式を設定することは、通常ロケールがCだった場合にのみ意味があります。
この他の場合、ロケールから自動的に符号化方式が選択されます。
ロケールと一致しない符号化方式を指定してもエラーになるだけです。
   </p><p>データベース符号化方式は一時的なインストレーションに対するテストでも既存のインストレーションに対するテストでも設定することができます。
ただし、後者の場合にはインストレーションのロケールと互換性がなければなりません。
   </p></div><div class="sect2" id="id-1.6.19.5.7"><div class="titlepage"><div><div><h3 class="title">32.1.5. 追加のテスト</h3></div></div></div><p>プラットフォームに依存する、または非常に時間がかかる可能性があるという理由で、コアリグレッションテスト一式にはデフォルトでは動作しないテストがいくつか含まれています。
<code class="envar">EXTRA_TESTS</code>変数を設定することでこれらの追加テストやその他のテストを実行することができます。
例えば、<code class="literal">numeric_big</code>テストを以下のように実行します。
</p><pre class="screen">make check EXTRA_TESTS=numeric_big</pre><p>
以下のように照合順序テストを実行します。
</p><pre class="screen">make check EXTRA_TESTS='collate.icu.utf8 collate.linux.utf8' LANG=en_US.utf8</pre><p>
<code class="literal">collate.linux.utf8</code>テストは、Linux/glibcプラットフォームにおいてのみ動作します。
<code class="literal">collate.icu.utf8</code>テストは、ICUをサポートするよう構築した場合にのみ動作します。
どちらのテストも、UTF-8符号化方式を使用するデータベースで実行した場合にのみ成功するでしょう。
   </p></div><div class="sect2" id="id-1.6.19.5.8"><div class="titlepage"><div><div><h3 class="title">32.1.6. ホットスタンバイのテスト</h3></div></div></div><p>ソース配布は、ホットスタンバイの静的な挙動に対するリグレッションテストも含んでいます。
これらのテストは、稼働しているプライマリサーバと、（ファイルベースのログ転送、またはストリーミングレプリケーションによって）プライマリからの新規のWALの変更を受け付けられる稼働中のスタンバイサーバを必要とします。
これらのサーバは、自動的に作成されませんし、ここにはレプリケーション設定ドキュメントもありません。
必要なコマンドや関連する問題について記述されている、ドキュメントのさまざまなセクションを参照してください。
  </p><p>ホットスタンバイテストを実行するには、最初に"regression"という名前のデータベースをプライマリに作成します。
</p><pre class="screen">psql -h primary -c "CREATE DATABASE regression"</pre><p>
次に、準備のためのスクリプト<code class="filename">src/test/regress/sql/hs_primary_setup.sql</code>をプライマリのregressionデータベース上で以下のように実行します。
</p><pre class="screen">psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression</pre><p>
この変更がスタンバイに伝搬するようにします。
  </p><p>ここで、デフォルトデータベース接続がスタンバイサーバの試験環境になるように（例えば、<code class="envar">PGHOST</code>と<code class="envar">PGPORT</code>環境変数を設定することで）手配してください。
最後に、リグレッションテスト用のディレクトリから<code class="literal">make standbycheck</code>を実行してください。
</p><pre class="screen">cd src/test/regress
make standbycheck</pre><p>
  </p><p>いくつかの極端な挙動を、スタンバイのテストのための挙動を実現するスクリプト<code class="filename">src/test/regress/sql/hs_primary_extremes.sql</code>を用いることでプライマリサーバ上で生成することができます。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="regress.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="regress.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="regress-evaluation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 32. リグレッションテスト </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 32.2. テストの評価</td></tr></table></div></body></html>