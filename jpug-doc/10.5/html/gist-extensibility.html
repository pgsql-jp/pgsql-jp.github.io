<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>62.3. 拡張性</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="gist-builtin-opclasses.html" title="62.2. 組み込み演算子クラス" /><link rel="next" href="gist-implementation.html" title="62.4. 実装" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">62.3. 拡張性</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="gist-builtin-opclasses.html" title="62.2. 組み込み演算子クラス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="gist.html" title="Chapter 62. GiSTインデックス">Up</a></td><th width="60%" align="center">Chapter 62. GiSTインデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="gist-implementation.html" title="62.4. 実装">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="GIST-EXTENSIBILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">62.3. 拡張性</h2></div></div></div><p>伝統的に、新しいインデックスメソッドの実装は、非常に難しい作業を意味していました。
ロックマネージャやログ先行書き込みなどデータベースの内部動作を理解する必要がありました。
<acronym class="acronym">GiST</acronym>インタフェースは高度に抽象化されており、アクセスメソッドの実装者には、アクセスするデータ型のセマンティックスのみの実装を要求します。
<acronym class="acronym">GiST</acronym>層自身が同時実行性、ログ処理、ツリー構造の検索処理に関する注意を行います。
 </p><p>この拡張性と、他の、扱うことができるデータを対象とした標準検索ツリーの拡張性とを混同すべきではありません。
例えば、<span class="productname">PostgreSQL</span>は拡張可能なB-treeとハッシュインデックスをサポートしています。
これは、<span class="productname">PostgreSQL</span>を使用して、任意のデータ型に対するB-treeやハッシュを構築することができることを意味します。
しかし、B-treeは範囲述語（<code class="literal">&lt;</code>、<code class="literal">=</code>、<code class="literal">&gt;</code>）のみをサポートし、ハッシュインデックスは等価性問い合わせのみをサポートします。
 </p><p>ですから、<span class="productname">PostgreSQL</span>のB-treeで例えば画像群をインデックス付けする場合、<span class="quote">“<span class="quote">画像xは画像yと同じか</span>”</span>、<span class="quote">“<span class="quote">画像xは画像yより小さいか</span>”</span>、<span class="quote">“<span class="quote">画像xは画像yより大きいか</span>”</span>といった問い合わせのみ発行することができます。
この文脈でどのように<span class="quote">“<span class="quote">同じか</span>”</span>や<span class="quote">“<span class="quote">より小さいか</span>”</span>、<span class="quote">“<span class="quote">より大きいか</span>”</span>を定義するかに依存して、これが有意なこともあるでしょう。
しかし、<acronym class="acronym">GiST</acronym>を基にしたインデックスを使用すれば、問題分野に特化した、おそらくは、<span class="quote">“<span class="quote">馬の画像を全て見つけたい</span>”</span>、<span class="quote">“<span class="quote">露出オーバーの写真をすべて見つけたい</span>”</span>といった質問に答えられる手段を作成することができます。
 </p><p><acronym class="acronym">GiST</acronym>アクセスメソッドを有効にし、実行するために行なわなければならないことは、ツリーのキーの動作を定義する、複数のユーザ定義のメソッドを実装することです。
当然ながら、これらのメソッドは手の込んだ問い合わせをサポートするためかなり意匠を凝らす必要があります。
しかし、すべての標準的な問い合わせ（B-treeやR-treeなど）ではこれらは、相対的に見てごく簡単です。
まとめると、<acronym class="acronym">GiST</acronym>は汎用性、コード再利用、整理されたインタフェースと拡張性を兼ね備えたものです。
  </p><p><acronym class="acronym">GiST</acronym>用の演算子クラスが提供しなければならないメソッドが7つ、オプションで提供可能なメソッドが2つあります。
インデックスの正確性は、<code class="function">same</code>、<code class="function">consistent</code>、<code class="function">union</code>メソッドを適切に実装することで保証されます。
一方、インデックスの効率（容量と速度）は<code class="function">penalty</code>と<code class="function">picksplit</code>メソッドに依存します。
残る２つの基本メソッドは<code class="function">compress</code>と<code class="function">decompress</code>ですが、これによりインデックスはインデックス付けするデータと異なるデータ型のツリーデータを内部で持つことができるようになります。
リーフはインデックス付けするデータ型となりますが、他のツリーノードは何らかのC構造体を取ることができます。
（しかしここでも<span class="productname">PostgreSQL</span>のデータ型規約に従わなければなりません。
容量が可変のデータに関しては<code class="literal">varlena</code>を参照してください。）
ツリーの内部データ型がSQLレベルで存在する場合、<code class="command">CREATE OPERATOR CLASS</code>コマンドの<code class="literal">STORAGE</code>オプションを使用することができます。
オプションの８番目のメソッドは<code class="function">distance</code>です。
これは演算子クラスに順序付けスキャン（最近傍検索）をサポートさせたい場合に必要です。
オプションの9番目のメソッド<code class="function">fetch</code>は演算子クラスがインデックスオンリースキャンをサポートしたい場合に必要になります。
 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">consistent</code></span></dt><dd><p>インデックス項目<code class="literal">p</code>と問い合わせ値<code class="literal">q</code>が与えられると、この関数はインデックス項目が問い合わせと<span class="quote">“<span class="quote">一貫性</span>”</span>があるかどうか、つまり、述語<span class="quote">“<span class="quote"><em class="replaceable"><code>indexed_column</code></em><em class="replaceable"><code>indexable_operator</code></em> <code class="literal">q</code></span>”</span>が、インデックス項目で表現される行に対して真かどうかを決定します。
リーフインデックス項目では、これはインデックス付条件の試験と等価です。
一方で内部ツリーノードでは、これはツリーノードで表現されるインデックスの副ツリーを走査する必要があるかどうかを決定します。
結果が<code class="literal">true</code>ならば、<code class="literal">recheck</code>フラグも返されなければなりません。
これは、述語が確実に真なのか一部のみ真なのかを示します。
<code class="literal">recheck</code> = <code class="literal">false</code>ならば、インデックスは述語条件を正確に試験されたことを示し、<code class="literal">recheck</code>= <code class="literal">true</code>ならば行が単に一致候補であることを示します。
この場合、システムは自動的に<em class="replaceable"><code>indexable_operator</code></em>を実際の行値に対して評価し、本当に一致するかどうか確認します。
この規則により、<acronym class="acronym">GiST</acronym>はインデックス構造が非可逆な場合でも可逆な場合でもサポートすることができます。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_consistent);

Datum
my_consistent(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    bool       *recheck = (bool *) PG_GETARG_POINTER(4);
    data_type  *key = DatumGetDataType(entry-&gt;key);
    bool        retval;

    /*
     * strategy、keyおよびqueryの関数として戻り値を決定してください。
     *
     * インデックスツリー内のどこで呼びだされているかを知るためGIST_LEAF(entry)を使用してください。
     * それは、例えば = 演算子をサポートする場合重宝です
     *（非リーフノードにおける空でないunion()とリーフノードにおける等価性を検査することができます）。
     */

    *recheck = true;        /* もしくは検査が正確であれば偽 */

    PG_RETURN_BOOL(retval);
}</pre><p>

ここで、<code class="varname">key</code>はインデックス要素であり、<code class="varname">query</code>はインデックスに対して検索される値です。
<code class="literal">StrategyNumber</code>パラメータは、演算子クラスのどの演算子が適用されるかを示します。
これは<code class="command">CREATE OPERATOR CLASS</code>コマンドの演算子番号の1つに一致します。
      </p><p>演算子の右辺にはいかなる型も来ることがあり、それは左辺に現れるインデックス付けされたデータ型とは違うものかもしれませんので、このクラスにどの演算子を含めたかに依存して、<code class="varname">query</code>のデータ型は演算子に応じて変動することがあります。
(上のコードの骨格は型が1つだけ可能であることを仮定しています。
そうでなければ、<code class="varname">query</code>引数の値を取得するのは演算子に依存しないといけないでしょう。)
<code class="function">consistent</code>関数のSQL宣言では、実際の型は演算子に依存して何か他のものであるとしても、<code class="varname">query</code>引数の演算子クラスのインデックス付けされたデータ型を使うことをお勧めします。
      </p></dd><dt><span class="term"><code class="function">union</code></span></dt><dd><p>このメソッドはツリー内の情報を統合します。
項目の集合が与えられると、この関数は与えられた項目すべてを表現するインデックス項目を新しく生成します。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_union(internal, internal)
RETURNS storage_type
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_union);

Datum
my_union(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GISTENTRY  *ent = entryvec-&gt;vector;
    data_type  *out,
               *tmp,
               *old;
    int         numranges,
                i = 0;

    numranges = entryvec-&gt;n;
    tmp = DatumGetDataType(ent[0].key);
    out = tmp;

    if (numranges == 1)
    {
        out = data_type_deep_copy(tmp);

        PG_RETURN_DATA_TYPE_P(out);
    }

    for (i = 1; i &lt; numranges; i++)
    {
        old = out;
        tmp = DatumGetDataType(ent[i].key);
        out = my_union_implementation(out, tmp);
    }

    PG_RETURN_DATA_TYPE_P(out);
}</pre><p>
      </p><p>ご覧になったように、この骨格で<code class="literal">union(X, Y, Z) = union(union(X, Y), Z)</code>であるようなデータ型を処理しています。
この<acronym class="acronym">GiST</acronym>サポートメソッドに適切なunionアルゴリズムを実装することで、このような場合以外のデータ型をサポートすることは非常に容易です。
      </p><p><code class="function">union</code>関数の結果は、(インデックス付けされた列の型とは異なるかもしれないし、異ならないかもしれませんが)それが何であれインデックスの格納型の値でなければなりません。
<code class="function">union</code>関数は新たに<code class="function">palloc()</code>されたメモリへのポインタを返さなければなりません。
型の変更がなかったとしても、入力値をそのまま返すことはできません。
      </p><p>上に示したように、<code class="function">union</code>関数の1番目の<code class="type">internal</code>引数は実際は<code class="structname">GistEntryVector</code>のポインタです。
2番目の引数は整数の変数へのポインタであり、無視できます。
(<code class="function">union</code>関数がその結果値の大きさをその変数に保存するのに必要だったのですが、これはもはや必要ではありません。)
      </p></dd><dt><span class="term"><code class="function">compress</code></span></dt><dd><p>データ項目をインデックスページ内の物理的な格納に適した形式に変換します。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_compress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_compress);

Datum
my_compress(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *retval;

    if (entry-&gt;leafkey)
    {
        /* 圧縮バージョンで entry-&gt;key を差し替え */
        compressed_data_type *compressed_data = palloc(sizeof(compressed_data_type));

        /* entry-&gt;key ... から *compressed_data を補填 */

        retval = palloc(sizeof(GISTENTRY));
        gistentryinit(*retval, PointerGetDatum(compressed_data),
                      entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);
    }
    else
    {
        /* 通常非リーフ項目に対して行うことはない */
        retval = entry;
    }

    PG_RETURN_POINTER(retval);
}</pre><p>
      </p><p>当然ながら<em class="replaceable"><code>compressed_data_type</code></em>を、リーフノードを圧縮するために変換する特定の型に適合させなければなりません。
      </p></dd><dt><span class="term"><code class="function">decompress</code></span></dt><dd><p><code class="function">compress</code>メソッドの逆です。
データ項目のインデックス表現から、演算子クラスの他のGiSTメソッドで扱うことができる書式に変換します。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_decompress(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_decompress);

Datum
my_decompress(PG_FUNCTION_ARGS)
{
    PG_RETURN_POINTER(PG_GETARG_POINTER(0));
}</pre><p>

上記骨格は、伸長を必要としない場合に適したものです。
      </p></dd><dt><span class="term"><code class="function">penalty</code></span></dt><dd><p>新しい項目をツリーの特定の分岐点に挿入するための<span class="quote">“<span class="quote">コスト</span>”</span>を示す値を返します。
項目は、ツリー内で<code class="function">penalty</code>が最小の経路に挿入されます。
<code class="function">penalty</code>から返される値は非負でなければなりません。
負の値が返された場合、ゼロとして扱われます。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;  -- penalty関数は厳密である必要がない場合もあります</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_penalty);

Datum
my_penalty(PG_FUNCTION_ARGS)
{
    GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0);
    GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1);
    float      *penalty = (float *) PG_GETARG_POINTER(2);
    data_type  *orig = DatumGetDataType(origentry-&gt;key);
    data_type  *new = DatumGetDataType(newentry-&gt;key);

    *penalty = my_penalty_implementation(orig, new);
    PG_RETURN_POINTER(penalty);
}</pre><p>

歴史的な理由により、<code class="function">penalty</code>関数は単純に<code class="type">float</code>の結果を返しません。
その代わり、3番目の引数で指定された場所に値を格納しなければなりません。
その引数のアドレスを戻すのが慣例ですが、戻り値それ自体は無視されます。
      </p><p><code class="function">penalty</code>関数は優れた性能のインデックスではきわめて重要です。
これは、挿入の段階で新しい項目をツリーに追加する場所を決定する際にどの分岐に従うかを決定するために使用されます。
問い合わせの際、インデックスのバランスが良ければ、検索が速くなります。
      </p></dd><dt><span class="term"><code class="function">picksplit</code></span></dt><dd><p>インデックスページ分割が必要になった時、この関数は、ページ内のどの項目を古いページに残すか、および、どれを新しいページに移動するかを決定します。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_picksplit);

Datum
my_picksplit(PG_FUNCTION_ARGS)
{
    GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0);
    GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1);
    OffsetNumber maxoff = entryvec-&gt;n - 1;
    GISTENTRY  *ent = entryvec-&gt;vector;
    int         i,
                nbytes;
    OffsetNumber *left,
               *right;
    data_type  *tmp_union;
    data_type  *unionL;
    data_type  *unionR;
    GISTENTRY **raw_entryvec;

    maxoff = entryvec-&gt;n - 1;
    nbytes = (maxoff + 1) * sizeof(OffsetNumber);

    v-&gt;spl_left = (OffsetNumber *) palloc(nbytes);
    left = v-&gt;spl_left;
    v-&gt;spl_nleft = 0;

    v-&gt;spl_right = (OffsetNumber *) palloc(nbytes);
    right = v-&gt;spl_right;
    v-&gt;spl_nright = 0;

    unionL = NULL;
    unionR = NULL;

    /* 項目自体のベクタの初期化 */
    raw_entryvec = (GISTENTRY **) malloc(entryvec-&gt;n * sizeof(void *));
    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
        raw_entryvec[i] = &amp;(entryvec-&gt;vector[i]);

    for (i = FirstOffsetNumber; i &lt;= maxoff; i = OffsetNumberNext(i))
    {
        int         real_index = raw_entryvec[i] - entryvec-&gt;vector;

        tmp_union = DatumGetDataType(entryvec-&gt;vector[real_index].key);
        Assert(tmp_union != NULL);

        /*
         * インデックス項目の格納場所を決定し、それに合わせてunionLとunionRを更新
         * します。v_spl_left もしくは v_spl_right のどちらかに項目を追加します。
         * カウンタに留意してください。
         */

        if (my_choice_is_left(unionL, curl, unionR, curr))
        {
            if (unionL == NULL)
                unionL = tmp_union;
            else
                unionL = my_union_implementation(unionL, tmp_union);

            *left = real_index;
            ++left;
            ++(v-&gt;spl_nleft);
        }
        else
        {
            /*
             * 右と同じ
             */
        }
    }

    v-&gt;spl_ldatum = DataTypeGetDatum(unionL);
    v-&gt;spl_rdatum = DataTypeGetDatum(unionR);
    PG_RETURN_POINTER(v);
}</pre><p>

<code class="function">picksplit</code>関数の結果は渡された<code class="structname">v</code>構造体を修正することで返されることに注意してください。
<code class="structname">v</code>のアドレスを戻すのが慣例ですが、戻り値それ自体は無視されます。
      </p><p><code class="function">penalty</code>同様、<code class="function">picksplit</code>関数も優れた性能のインデックスのためにきわめて重要です。
<code class="function">penalty</code>と<code class="function">picksplit</code>の実装を適切に設計することが、性能が良い<acronym class="acronym">GiST</acronym>インデックスの実装を行うことにつながります。
      </p></dd><dt><span class="term"><code class="function">same</code></span></dt><dd><p>２つのインデックス項目が同一の場合に真、さもなくば偽を返します。
(<span class="quote">“<span class="quote">インデックス項目</span>”</span>はインデックスの格納型の値であり、必ずしも元のインデックス付けされた列の型という訳ではありません。)
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようになります。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

そして、Cモジュール内の対応するコードは以下のような骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_same);

Datum
my_same(PG_FUNCTION_ARGS)
{
    prefix_range *v1 = PG_GETARG_PREFIX_RANGE_P(0);
    prefix_range *v2 = PG_GETARG_PREFIX_RANGE_P(1);
    bool       *result = (bool *) PG_GETARG_POINTER(2);

    *result = my_eq(v1, v2);
    PG_RETURN_POINTER(result);
}</pre><p>

歴史的な理由により、<code class="function">same</code>関数は単純に論理値の結果を返しません。
その代わり、3番目の引数で指定された場所にフラグを格納しなければなりません。
その引数のアドレスを戻すのが慣例ですが、戻り値それ自体は無視されます。
      </p></dd><dt><span class="term"><code class="function">distance</code></span></dt><dd><p>インデックス項目<code class="literal">p</code>と問い合わせ値<code class="literal">q</code>を与えると、この関数は問い合わせ値からのインデックス項目の<span class="quote">“<span class="quote">距離</span>”</span>を決定します。
この関数は、演算子クラスが何らかの順序付け演算子を含む場合には提供しなければなりません。
順序付け演算子を使用する問い合わせは、まず最小の<span class="quote">“<span class="quote">距離</span>”</span>を持つインデックス項目を返すことで実装されます。
このためこの結果は演算子の意味と一貫性を持たなければなりません。
リーフインデックスノード項目では、結果は単にインデックス項目との距離を表します。
内部ツリーノードでは、結果はすべての子項目が持つ中から最も最小の距離でなければなりません。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようにならなければなりません。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)
RETURNS float8
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

Cモジュールにおける対応するコードは次の骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_distance);

Datum
my_distance(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    data_type  *query = PG_GETARG_DATA_TYPE_P(1);
    StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2);
    /* Oid subtype = PG_GETARG_OID(3); */
    /* bool *recheck = (bool *) PG_GETARG_POINTER(4); */
    data_type  *key = DatumGetDataType(entry-&gt;key);
    double      retval;

    /*
     * strategy、keyおよびqueryの関数として戻り値を決定してください。
     */

    PG_RETURN_FLOAT8(retval);
}</pre><p>

<code class="function">distance</code>関数の引数は<code class="function">consistent</code>関数の引数と同一です。
      </p><p>距離の決定において、その結果がエントリの実際の距離よりも大きくならない限り、多少の概算は許されます。
したがって、例えば、幾何学に関するアプリケーションでは、通常は外接矩形への距離で十分です。
内部ツリーノードについては、返される距離はどの子ノードへの距離よりも大きくなることは許されません。
返される距離が正確でない場合、関数は<code class="literal">*recheck</code>を真にセットする必要があります。
（内部ツリーノードについては、計算はいつでも不正確であると見なされるため、これは必要ありません。）
この場合、エグゼキュータはヒープからタプルを取得した後で正確な距離を計算し、必要ならタプルを並べ替えます。
      </p><p>距離関数がリーフノードについて<code class="literal">*recheck = true</code>を返す場合、元の順序づけ演算子の戻り型は<code class="type">float8</code>または<code class="type">float4</code>でなければならず、また距離関数の結果の値は元の順序づけ演算子の戻り型と比較可能でなければなりません。
なぜならエグゼキュータは距離関数の結果および再計算された順序づけ演算子の結果の両方を利用してソート処理を行うからです。
その他の場合は、結果値の相対的な順序が順序づけ演算子が返す順序と一致する限り、距離関数の戻り値は任意の有限の<code class="type">float8</code>の値とすることができます。
（無限大とマイナス無限大は内部的にNULLなどの場合を処理するために利用するので、<code class="function">distance</code>関数がこれらの値を戻すことは薦められません。）
      </p></dd><dt><span class="term"><code class="function">fetch</code></span></dt><dd><p>インデックスオンリースキャンで使用するため、データ項目の圧縮されたインデックス表現を元のデータ型に変換します。
返されたデータは元のインデックス値の正確で、何も失われていない複製でなければなりません。
      </p><p>この関数の<acronym class="acronym">SQL</acronym>宣言は以下のようにならなければなりません。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION my_fetch(internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE C STRICT;</pre><p>

引数は<code class="structname">GISTENTRY</code>構造体へのポインタです。
関数が呼び出された時点では、その<code class="structfield">key</code>フィールドには、NULLでないリーフデータが圧縮形式で入っています。
戻り値は別の<code class="structname">GISTENTRY</code>構造体で、その<code class="structfield">key</code>フィールドには、同じデータが元の非圧縮形式で入っています。
opclassの圧縮関数がリーフのエントリに対して何もしないなら、<code class="function">fetch</code>メソッドは引数をそのまま返すことができます。
       </p><p>Cモジュールにおける対応するコードは次の骨格に従うことになります。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(my_fetch);

Datum
my_fetch(PG_FUNCTION_ARGS)
{
    GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0);
    input_data_type *in = DatumGetP(entry-&gt;key);
    fetched_data_type *fetched_data;
    GISTENTRY  *retval;

    retval = palloc(sizeof(GISTENTRY));
    fetched_data = palloc(sizeof(fetched_data_type));

    /*
     * fetched_dataを元のデータ型のデータに変換する。
     */

    /* fetch_dataを使って*retvalに値を入れる。 */
    gistentryinit(*retval, PointerGetDatum(converted_datum),
                  entry-&gt;rel, entry-&gt;page, entry-&gt;offset, FALSE);

    PG_RETURN_POINTER(retval);
}</pre><p>
      </p><p>compressメソッドがリーフエントリに対してデータ損失がある場合、演算子クラスはインデックスオンリースキャンをサポートすることができず、<code class="function">fetch</code>関数を定義してはいけません。
      </p></dd></dl></div><p>すべてのGiSTサポートメソッドは通常短期間有効なメモリコンテキストで呼び出されます。
つまり<code class="varname">CurrentMemoryContext</code>は各タプルが処理された後にリセットされます。
そのためpallocしたすべてをpfreeすることに注意するのはあまり重要ではありません。
しかし、サポートメソッドで、繰り返される呼び出しを跨がってデータをキャッシュすることが有用な場合があります。
このためには、<code class="literal">fcinfo-&gt;flinfo-&gt;fn_mcxt</code>の中で長期間有効なデータを割り当て、そこへのポインタを<code class="literal">fcinfo-&gt;flinfo-&gt;fn_extra</code>の中に保持してください。
こうしたデータはインデックス操作（例えば１つのGiSTインデックススキャン、インデックス構築、インデックスタプルの挿入）の間有効です。
<code class="literal">fn_extra</code>値を置き換える時に以前の値をpfreeすることに注意してください。
さもないと操作の間リークが蓄積されます。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="gist-builtin-opclasses.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="gist.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="gist-implementation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">62.2. 組み込み演算子クラス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 62.4. 実装</td></tr></table></div></body></html>