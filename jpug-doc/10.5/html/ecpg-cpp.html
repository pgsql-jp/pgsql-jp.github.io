<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.13. C++アプリケーション</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ecpg-lo.html" title="35.12. ラージオブジェクト" /><link rel="next" href="ecpg-sql-commands.html" title="35.14. 埋め込みSQLコマンド" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.13. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">C++</acronym>アプリケーション</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-lo.html" title="35.12. ラージオブジェクト">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Chapter 35. ECPG - C言語による埋め込みSQL">Up</a></td><th width="60%" align="center">Chapter 35. <span xmlns="http://www.w3.org/1999/xhtml" class="application">ECPG</span> - C言語による埋め込み<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-sql-commands.html" title="35.14. 埋め込みSQLコマンド">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ECPG-CPP"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.13. <acronym class="acronym">C++</acronym>アプリケーション</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-cpp.html#ECPG-CPP-SCOPE">35.13.1. ホスト変数のスコープ</a></span></dt><dt><span class="sect2"><a href="ecpg-cpp.html#ECPG-CPP-AND-C">35.13.2. 外部のCモジュールを用いたC++アプリケーションの開発</a></span></dt></dl></div><p>ECPGはC++アプリケーションを多少の制限がありますがサポートします。
本節ではいくつかの注意を説明します。
  </p><p><code class="command">ecpg</code>プリプロセッサはC（またはCのようなもの）と埋め込みSQLコマンドで記述された入力ファイルを取り、埋め込みSQLコマンドをC言語の小塊に変換し、最終的に<code class="filename">.c</code>ファイルを作成します。
<code class="command">ecpg</code>が生成するC言語の小塊で使用されるライブラリ関数のヘッダファイル定義は、C++で使用される場合<code class="literal">extern "C" { ... }</code>で囲まれます。
このためC++でも継ぎ目なく動作するはずです。
  </p><p>しかし一般的には、<code class="command">ecpg</code>プリプロセッサはCのみを理解しています。
C++言語の特殊な構文や予約語を取り扱いません。
このため、C++に特化した複雑な機能を使用するC++アプリケーションコードの中に記述された埋め込みSQLコードの一部は、正しく前処理することに失敗する、または想定通りに動作しないかもしれません。
  </p><p>C++アプリケーションで埋め込みSQLコードを使用する安全な方法は、ECPGの呼び出しをCモジュール内に隠蔽し、残りのC++コードとまとめてリンクすることです。C++アプリケーションコードがデータベースにアクセスするためにはそのCモジュールを呼び出します。
<a class="xref" href="ecpg-cpp.html#ECPG-CPP-AND-C" title="35.13.2. 外部のCモジュールを用いたC++アプリケーションの開発">Section 35.13.2</a>を参照してください。
  </p><div class="sect2" id="ECPG-CPP-SCOPE"><div class="titlepage"><div><div><h3 class="title">35.13.1. ホスト変数のスコープ</h3></div></div></div><p><code class="command">ecpg</code>プリプロセッサはCにおける変数のスコープを理解しています。
C言語では、変数のスコープはコードブロックに基づきますので、どちらかといえば単純です。
しかしC++では
クラスメンバ変数は宣言場所とは異なるコードブロック内で参照されます。
このため<code class="command">ecpg</code>プリプロセッサはクラスメンバ変数のスコープを理解していません。
   </p><p>例えば、以下の場合、<code class="command">ecpg</code>プリプロセッサは<code class="literal">test</code>メソッド内の<code class="literal">dbname</code>変数の定義を見つけることができません。
このためエラーになります。

</p><pre class="programlisting">class TestCpp
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void Test::test()
{
    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

TestCpp::~TestCpp()
{
    EXEC SQL DISCONNECT ALL;
}</pre><p>

このコードは以下のようなエラーになります。
</p><pre class="screen"><strong class="userinput"><code>ecpg test_cpp.pgc</code></strong>
test_cpp.pgc:28: ERROR: variable "dbname" is not declared</pre><p>
   </p><p>このスコープ問題を回避するためには、<code class="literal">test</code>メソッドを中間格納領域としてローカル変数を使用するように変更することができます。
しかしこの手法は悪い回避策でしかありません。コードを醜くしますし性能も劣化させます。

</p><pre class="programlisting">void TestCpp::test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char tmp[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :tmp;
    strlcpy(dbname, tmp, sizeof(tmp));

    printf("current_database = %s\n", dbname);
}</pre><p>
   </p></div><div class="sect2" id="ECPG-CPP-AND-C"><div class="titlepage"><div><div><h3 class="title">35.13.2. 外部のCモジュールを用いたC++アプリケーションの開発</h3></div></div></div><p>C++における<code class="command">ecpg</code>の技術的な制限を理解しているのであれば、ECPG機能を使用するC++アプリケーションを実現するためには、リンク段階でCオブジェクトとC++オブジェクトをリンクする方が、C++コード内で埋め込みSQLコマンドを直接記述することより優れているという結論に至るでしょう。
本節では、簡単な例を用いて、C++アプリケーションコードから埋め込みSQLコマンドを分離する方法について説明します。
この例では、アプリケーションはC++で実装し、PostgreSQLサーバに接続するためにCおよびECPGを使用します。
   </p><p>Cファイル（<code class="filename">*.pgc</code>）、ヘッダファイル、C++ファイルという３種類のファイルを作成しなければなりません。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">test_mod.pgc</code></span></dt><dd><p>C内に埋め込まれたサブルーチンモジュールです。
プリプロセッサにより<code class="filename">test_mod.c</code>に変換されます。

</p><pre class="programlisting">#include "test_mod.h"
#include &lt;stdio.h&gt;

void
db_connect()
{
    EXEC SQL CONNECT TO testdb1;
    EXEC SQL SELECT pg_catalog.set_config('search_path', '', false); EXEC SQL COMMIT;
}

void
db_test()
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dbname[1024];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT current_database() INTO :dbname;
    printf("current_database = %s\n", dbname);
}

void
db_disconnect()
{
    EXEC SQL DISCONNECT ALL;
}</pre><p>
       </p></dd><dt><span class="term"><code class="filename">test_mod.h</code></span></dt><dd><p>Cモジュール（<code class="filename">test_mod.pgc</code>）内の関数宣言を持つヘッダファイルです。
<code class="filename">test_cpp.cpp</code>でインクルードされます。
このファイルは、C++モジュールからリンクされますので、宣言を囲む<code class="literal">extern "C"</code>ブロックを持たなければなりません。

</p><pre class="programlisting">#ifdef __cplusplus
extern "C" {
#endif

void db_connect();
void db_test();
void db_disconnect();

#ifdef __cplusplus
}
#endif</pre><p>
       </p></dd><dt><span class="term"><code class="filename">test_cpp.cpp</code></span></dt><dd><p><code class="function">main</code>ルーチンとこの例でのC++クラスを含む、アプリケーションの主要コードです。

</p><pre class="programlisting">#include "test_mod.h"

class TestCpp
{
  public:
    TestCpp();
    void test();
    ~TestCpp();
};

TestCpp::TestCpp()
{
    db_connect();
}

void
TestCpp::test()
{
    db_test();
}

TestCpp::~TestCpp()
{
    db_disconnect();
}

int
main(void)
{
    TestCpp *t = new TestCpp();

    t-&gt;test();
    return 0;
}</pre><p>
       </p></dd></dl></div><p>
   </p><p>アプリケーションを構築するためには、以下の処理を行います。
<code class="command">ecpg</code>を実行して<code class="filename">test_mod.pgc</code>を<code class="filename">test_mod.c</code>に変換します。
そしてCコンパイラを用いて<code class="filename">test_mod.c</code>をコンパイルし<code class="filename">test_mod.o</code>を生成します。
</p><pre class="programlisting">ecpg -o test_mod.c test_mod.pgc
cc -c test_mod.c -o test_mod.o</pre><p>
   </p><p>次にC++コンパイラを用いて<code class="filename">test_cpp.cpp</code>をコンパイルし<code class="filename">test_cpp.o</code>を生成します。
</p><pre class="programlisting">c++ -c test_cpp.cpp -o test_cpp.o</pre><p>
   </p><p>最後に、C++コンパイラドライバを用いて<code class="filename">test_cpp.o</code>および<code class="filename">test_mod.o</code>というオブジェクトファイルを実行形式ファイルにリンクします。
</p><pre class="programlisting">c++ test_cpp.o test_mod.o -lecpg -o test_cpp</pre><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-lo.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-sql-commands.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">35.12. ラージオブジェクト </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 35.14. 埋め込みSQLコマンド</td></tr></table></div></body></html>