<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.9. 継承</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ddl-schemas.html" title="5.8. スキーマ" /><link rel="next" href="ddl-partitioning.html" title="5.10. テーブルのパーティショニング" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.9. 継承</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl-schemas.html" title="5.8. スキーマ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Chapter 5. データ定義">Up</a></td><th width="60%" align="center">Chapter 5. データ定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-partitioning.html" title="5.10. テーブルのパーティショニング">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="DDL-INHERIT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.9. 継承</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ddl-inherit.html#DDL-INHERIT-CAVEATS">5.9.1. 警告</a></span></dt></dl></div><a id="id-1.5.4.11.2" class="indexterm"></a><a id="id-1.5.4.11.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は、データベース設計者にとって便利なテーブルの継承を実装しています。
（SQL:1999以降は型の継承を定義していますが、ここで述べられている継承とは多くの点で異なっています。）
  </p><p>まず例から始めましょう。
市（cities）のデータモデルを作成しようとしていると仮定してください。
それぞれの州にはたくさんの市がありますが、州都（capitals）は1つのみです。
どの州についても州都を素早く検索したいとします。
これは、2つのテーブルを作成することにより実現できます。
1つは州都のテーブルで、もう1つは州都ではない市のテーブルです。
しかし、州都であるか否かに関わらず、市に対するデータを問い合わせたいときには何が起こるでしょうか？
継承はこの問題を解決できます。
<code class="structname">cities</code>から継承される<code class="structname">capitals</code>テーブルを定義するのです。

</p><pre class="programlisting">CREATE TABLE cities (
    name            text,
    population      float,
    altitude        int     -- in feet
);

CREATE TABLE capitals (
    state           char(2)
) INHERITS (cities);</pre><p>

この場合、<code class="structname">capitals</code>テーブルは、その親テーブルである<code class="structname">cities</code>テーブルの列をすべて<em class="firstterm">継承</em>します。
州都は1つの追加の列<code class="structfield">state</code>を持ち、州を表現します。
  </p><p><span class="productname">PostgreSQL</span>では、1つのテーブルは、0以上のテーブルから継承することが可能です。
また、問い合わせはテーブルのすべての行、またはテーブルのすべての行と継承されたテーブルのすべての行のいずれかを参照できます。
後者がデフォルトの動作になります。
例えば次の問い合わせは、500フィートより上に位置しているすべての市の名前を、州都を含めて検索します。

</p><pre class="programlisting">SELECT name, altitude
    FROM cities
    WHERE altitude &gt; 500;</pre><p>

<span class="productname">PostgreSQL</span>チュートリアルからのサンプルデータ（<a class="xref" href="tutorial-sql-intro.html" title="2.1. 序文">Section 2.1</a>を参照してください）に対して、この問い合わせは、以下の結果を出力します。

</p><pre class="programlisting">   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953
 Madison   |      845</pre><p>
  </p><p>一方、次の問い合わせは、州都ではなく500フィートより上に位置しているすべての市を検索します。

</p><pre class="programlisting">SELECT name, altitude
    FROM ONLY cities
    WHERE altitude &gt; 500;

   name    | altitude
-----------+----------
 Las Vegas |     2174
 Mariposa  |     1953</pre><p>
  </p><p>ここで<code class="literal">ONLY</code>キーワードは、問い合わせが<code class="structname">cities</code>テーブルのみを対象にし<code class="structname">cities</code>以下の継承の階層にあるテーブルは対象としないことを意味します。
これまで議論したコマンドの多く—<code class="command">SELECT</code>、<code class="command">UPDATE</code>そして<code class="command">DELETE</code> —が<code class="literal">ONLY</code>キーワードをサポートしています。
  </p><p>また、明示的に子孫テーブルが含まれていることを示すために、テーブル名の後ろに<code class="literal">*</code>を書くこともできます:

</p><pre class="programlisting">SELECT name, altitude
    FROM cities*
    WHERE altitude &gt; 500;</pre><p>

<code class="literal">*</code>の指定は、その動作が常にデフォルトであるため、必要ありません。
しかし、この構文はデフォルトが変更可能であった古いリリースとの互換性のためにまだサポートされています。
  </p><p>ある特定の行がどのテーブルからきたものか知りたいという場合もあるでしょう。
それぞれのテーブルには<code class="structfield">tableoid</code>という、元になったテーブルを示すシステム列があります。

</p><pre class="programlisting">SELECT c.tableoid, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;</pre><p>

出力は以下の通りです。

</p><pre class="programlisting"> tableoid |   name    | altitude
----------+-----------+----------
   139793 | Las Vegas |     2174
   139793 | Mariposa  |     1953
   139798 | Madison   |      845</pre><p>

（この例をそのまま実行しても、おそらく異なる数値OIDが得られるでしょう。）
<code class="structname">pg_class</code>と結合することで、テーブルの実際の名前が分かります。

</p><pre class="programlisting">SELECT p.relname, c.name, c.altitude
FROM cities c, pg_class p
WHERE c.altitude &gt; 500 AND c.tableoid = p.oid;</pre><p>

出力は以下の通りです。

</p><pre class="programlisting"> relname  |   name    | altitude
----------+-----------+----------
 cities   | Las Vegas |     2174
 cities   | Mariposa  |     1953
 capitals | Madison   |      845</pre><p>
  </p><p>同じ効果を得る別の方法は、別名型<code class="type">regclass</code>を使うことで、これによりテーブルのOIDを記号的に表示します。

</p><pre class="programlisting">SELECT c.tableoid::regclass, c.name, c.altitude
FROM cities c
WHERE c.altitude &gt; 500;</pre><p>
  </p><p>継承は<code class="command">INSERT</code>または<code class="command">COPY</code>によるデータを、継承の階層にある他のテーブルに自動的に伝播しません。
この例では、次の<code class="command">INSERT</code>文は失敗します。
</p><pre class="programlisting">INSERT INTO cities (name, population, altitude, state)
VALUES ('Albany', NULL, NULL, 'NY');</pre><p>
データが、どうにかして<code class="structname">capitals</code>テーブルに入ることを期待するかもしれませんが、そのようにはなりません。
<code class="command">INSERT</code>は、いつも指定されたテーブルそれ自体に対してデータを挿入します。
ルール（詳細は<a class="xref" href="rules.html" title="Chapter 40. ルールシステム">Chapter 40</a>を参照してください）を使用して挿入を中継できる場合もあります。
しかし、ルールを使用しても上記のような場合は解決できません。
なぜなら、<code class="structname">cities</code>テーブルに<code class="structfield">state</code>列が含まれていないため、ルールが適用される前にコマンドが拒否されてしまうからです。
  </p><p>親テーブル上の検査制約と非NULL制約は、<code class="literal">NO INHERIT</code>句によって明示的に指定され無い限り、その子テーブルに自動的に継承されます。
他の種類の制約（一意性制約、主キー、外部キー制約）は継承されません。
  </p><p>テーブルは1つ以上の親テーブルから継承可能です。
この場合、テーブルは親テーブルで定義された列の和になります。
子テーブルで宣言された列は、これらの列に追加されることになります。
もし親テーブルに同じ名前の列がある場合、もしくは、親テーブルと子テーブルに同じ名前の列がある場合は、列が<span class="quote">“<span class="quote">統合</span>”</span>されて子テーブルではただ1つの列となります。
統合されるには列は同じデータ型を持っている必要があります。
異なるデータ型の場合にはエラーとなります。
継承可能な検査制約と非NULL制約は、同じようなやり方で統合されます。
つまり、例えば、列定義のいずれかが非NULL制約の印が付いているならば、統合された列に非NULLという印が付きます。
検査制約は、同じ名前を持っている場合に統合され、それらの条件が異なる場合は統合に失敗します。
  </p><p>テーブル継承は、通常、<a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>文の<code class="literal">INHERITS</code>句を使用して、子テーブルを作成する時に確立します。
他にも、互換性を持つ方法で定義済みのテーブルに新しく親子関係を付けることも可能です。
これには<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>の<code class="literal">INHERIT</code>形式を使用します。
このためには、新しい子テーブルは親テーブルと同じ名前の列を持ち、その列の型は同じデータ型でなければなりません。
また、親テーブルと同じ名前、同じ式の検査制約を持っていなければなりません。
<code class="command">ALTER TABLE</code>の<code class="literal">NO INHERIT</code>形式を使用して、同様に継承関係を子テーブルから取り除くことも可能です。
このような継承関係の動的追加、動的削除は、継承関係をテーブル分割（<a class="xref" href="ddl-partitioning.html" title="5.10. テーブルのパーティショニング">Section 5.10</a>を参照）に使用している場合に有用です。
  </p><p>後で子テーブルとする予定の、互換性を持つテーブルを簡単に作成する方法の1つは、<code class="command">CREATE TABLE</code>で<code class="literal">LIKE</code>句を使用することです。
これは、元としたテーブルと同じ列を持つテーブルを新しく作成します。
新しい子テーブルが必ず親テーブルと一致する制約を持ち、互換性があるものとみなされるように、元となるテーブルで<code class="literal">CHECK</code>制約が存在する場合は、<code class="literal">LIKE</code>に<code class="literal">INCLUDING CONSTRAINTS</code>オプションを指定すべきです。
  </p><p>子テーブルが存在する場合親テーブルを削除することはできません。
また、子テーブルでは、親テーブルから継承した列、または検査制約を削除することも変更することもできません。
テーブルとそのすべての子テーブルを削除したければ、<code class="literal">CASCADE</code>オプションを付けて親テーブルを削除することが簡単な方法です（<a class="xref" href="ddl-depend.html" title="5.13. 依存関係の追跡">Section 5.13</a>を参照）。
  </p><p><a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>は、列データ定義と検査制約の変更を継承の階層にあるテーブルに伝えます。
ここでも、他のテーブルに依存する列の削除は<code class="literal">CASCADE</code>オプションを使用したときのみ可能となります。
<code class="command">ALTER TABLE</code>は、重複列の統合と拒否について、<code class="command">CREATE TABLE</code>時に適用される規則に従います。
  </p><p>継承された問い合わせは、親テーブルのみアクセス権限を検査します。
つまり、例えば、<code class="literal">UPDATE</code>権限を<code class="structname">cities</code>テーブルに付与することは、<code class="structname">cities</code>テーブルを通じてアクセスする場合に、<code class="structname">capitals</code>テーブルにも行の更新権限を付与することを意味します。
これによりデータが親テーブルに（も）あるように見えることが保たれます。
しかし、<code class="structname">capitals</code>テーブルは、追加権限なしに直接更新することはできません。
同様に、親テーブルの行セキュリティポリシー（<a class="xref" href="ddl-rowsecurity.html" title="5.7. 行セキュリティポリシー">Section 5.7</a>を参照してください）が、継承された問い合わせの時に子テーブルの行に適用されます。
子テーブルのポリシー（あれば）は、問い合わせにて明示的に指定されたテーブルである時にのみ適用されます。
そしてこの場合、親テーブルに紐付けられたあらゆるポリシーは無視されます。
  </p><p>外部テーブル（<a class="xref" href="ddl-foreign-data.html" title="5.11. 外部データ">Section 5.11</a>参照）も通常のテーブルと同様、親テーブルあるいは子テーブルとして継承の階層の一部となりえます。
外部テーブルが継承の階層の一部となっている場合、外部テーブルがサポートしない操作は、その継承全体でもサポートされません。
  </p><div class="sect2" id="DDL-INHERIT-CAVEATS"><div class="titlepage"><div><div><h3 class="title">5.9.1. 警告</h3></div></div></div><p>すべてのSQLコマンドが継承階層に対して動作できるとは限らないことに注意してください。
データの検索、データの変更、スキーマの変更のために使用されるコマンド（例えば<code class="literal">SELECT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">ALTER TABLE</code>のほとんどの構文が該当しますが、<code class="literal">INSERT</code>や<code class="literal">ALTER TABLE ... RENAME</code>は含まれません）は通常、デフォルトで子テーブルを含み、また、それを除外するための<code class="literal">ONLY</code>記法をサポートします。
データベース保守およびチューニング（例えば<code class="literal">REINDEX</code>、<code class="literal">VACUUM</code>）を行うコマンドは通常、個々の物理テーブルに対してのみ動作し、継承階層に対する再帰をサポートしません。
個々のコマンドのそれぞれの動作はそのマニュアルページ（<a class="xref" href="sql-commands.html" title="SQLコマンド">SQLコマンド</a>）に記載されています。
  </p><p>継承機能の重大な制限として、インデックス（一意性制約を含む）、および外部キーは、そのテーブルのみに適用され、それを継承した子テーブルには適用されないことがあります。
これは外部キーの参照側、被参照側の両方について当てはまります。
したがって、上の例では

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>もし、<code class="structname">cities</code>.<code class="structfield">name</code>を<code class="literal">UNIQUE</code>または<code class="literal">PRIMARY KEY</code>と宣言しても、<code class="structname">cities</code>テーブルの行と重複した行を<code class="structname">capitals</code>テーブル内に持つことを禁止することにはなりません。
さらに、これらの重複した行はデフォルトで<code class="structname">cities</code>テーブルへの問い合わせで現れるでしょう。
事実として、<code class="structname">capitals</code>テーブルはデフォルトで一意性制約を持っていませんし、同一の名前の複数の行を持つことがあり得ます。
<code class="structname">capitals</code>テーブルに一意性制約を追加できますが、これは<code class="structname">cities</code>テーブルと比較して重複を禁止することにはなりません。
     </p></li><li class="listitem"><p>同じように、<code class="structname">cities</code>.<code class="structfield">name</code> <code class="literal">REFERENCES</code>で他のテーブルを参照するようにしても、この制約は自動的に<code class="structname">capitals</code>に引き継がれるわけではありません。
この場合は<code class="structname">capitals</code>テーブルに同一の<code class="literal">REFERENCES</code>制約を手動で追加すれば問題を回避できます。
     </p></li><li class="listitem"><p>他のテーブルの列に<code class="literal">REFERENCES cities(name)</code>を指定すると、他のテーブルが市の名前を持つことはできますが、州都の名前を持つことできません。
この場合は良い回避策がありません。
     </p></li></ul></div><p>

これらの機能の不足は、今後のリリースでおそらく改善されるでしょう。
しかし当面、継承がアプリケーションにとって有用であるかどうかを判断する際に十分注意してください。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl-schemas.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-partitioning.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.8. スキーマ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.10. テーブルのパーティショニング</td></tr></table></div></body></html>