<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.10. PL/pgSQLの秘訣</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-trigger.html" title="42.9. トリガプロシージャ" /><link rel="next" href="plpgsql-development-tips.html" title="42.11. PL/pgSQLによる開発向けのヒント" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.10. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span>の秘訣</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-trigger.html" title="42.9. トリガプロシージャ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-development-tips.html" title="42.11. PL/pgSQLによる開発向けのヒント">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-IMPLEMENTATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.10. <span class="application">PL/pgSQL</span>の秘訣</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-implementation.html#PLPGSQL-VAR-SUBST">42.10.1. 変数置換</a></span></dt><dt><span class="sect2"><a href="plpgsql-implementation.html#PLPGSQL-PLAN-CACHING">42.10.2. 計画のキャッシュ</a></span></dt></dl></div><p>本節では、<span class="application">PL/pgSQL</span>利用者の知識として重要な、実装の詳細を述べます。
   </p><div class="sect2" id="PLPGSQL-VAR-SUBST"><div class="titlepage"><div><div><h3 class="title">42.10.1. 変数置換</h3></div></div></div><p><span class="application">PL/pgSQL</span>関数内のSQL文および式は変数および関数のパラメータを参照することができます。
背後では、<span class="application">PL/pgSQL</span>はこうした参照を問い合わせパラメータに置き換えます。
パラメータまたは列参照が文法的に許されているところでのみパラメータは置換されます。
極端な場合として、以下のよろしくないプログラミングスタイルの例を考えてみましょう。
</p><pre class="programlisting">INSERT INTO foo (foo) VALUES (foo);</pre><p>
最初に現れる<code class="literal">foo</code>の場所は文法的にはテーブル名でなければなりません。
このため関数が<code class="literal">foo</code>という名前の変数を持っていたとしても、置換されません。
2番目の場所はテーブルの列名でなければなりません。
このためこれも置換されません。
3番目の場所のみが関数の変数参照の候補です。
   </p><div class="note"><h3 class="title">Note</h3><p>9.0より前の<span class="productname">PostgreSQL</span>では、3つの場合すべてにおいて変数を置換しようとし、構文エラーを引き起こしました。
    </p></div><p>変数名は文法的にはテーブル列名と違いがありませんので、テーブルを参照する文の中であいまいさが出る可能性があります。
与えられた名前はテーブル列を意味するのでしょうか、それとも変数なのでしょうか。
前の例を次のように変えてみましょう。
</p><pre class="programlisting">INSERT INTO dest (col) SELECT foo + bar FROM src;</pre><p>
ここでは、<code class="literal">dest</code>および<code class="literal">src</code>はテーブル名でなければなりません。
また、<code class="literal">col</code>は<code class="literal">dest</code>の列でなければなりませんが、<code class="literal">foo</code>および<code class="literal">bar</code>は理論上関数の変数かもしれませんし、<code class="literal">src</code>の列かもしれません。
   </p><p>デフォルトで<span class="application">PL/pgSQL</span>はSQL文における名前が変数かテーブル列のいずれかを参照可能な場合にエラーを報告します。
変数または列の名前を変更することやあいまいな参照を修飾すること、<span class="application">PL/pgSQL</span>にどちらを優先して解釈するかを通知することで、こうした問題を解消することができます。
   </p><p>最も簡単な解法は変数名または列名を変更することです。
一般的なコーディング法として、列の命名と<span class="application">PL/pgSQL</span>変数の命名とで規約を分ける方法があります。
例えば、一貫して関数の変数は<code class="literal">v_<em class="replaceable"><code>something</code></em></code>という名前とし、列名は<code class="literal">v_</code>で始まらないようにすれば、競合は起こりません。
   </p><p>その他、あいまいな参照を明確にするために修飾することができます。
上の例では、<code class="literal">src.foo</code>によりテーブル列への参照についてあいまいさが解消します。
あいまい性のない変数参照を行うためには、ラベル付けしたブロック内で変数を宣言し、そのブロックのラベルを使用します(<a class="xref" href="plpgsql-structure.html" title="42.2. PL/pgSQLの構造">Section 42.2</a>参照)。
以下に例を示します。
</p><pre class="programlisting">&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;</pre><p>
ここで<code class="literal">block.foo</code>は<code class="literal">src</code>に<code class="literal">foo</code>列があったとしても、変数を意味することになります。
<code class="literal">FOUND</code>などの特別な変数を含め、関数パラメータを関数名で修飾することができます。
これらは暗黙的に関数名をラベル名とした上位ブロック内で宣言されているためです。
   </p><p><span class="application">PL/pgSQL</span>の大規模な本体コードにおける、すべてのあいまいな参照を修正することが現実的ではない場合があります。
こうした場合、<span class="application">PL/pgSQL</span>にあいまいな参照を変数として解決すべき(この動作は<span class="productname">PostgreSQL</span> 9.0より前の<span class="application">PL/pgSQL</span>の動作と互換性を持ちます)、または、テーブル列参照として解決すべき(<span class="productname">Oracle</span>などの他のシステムと互換性を持ちます)と指定することができます。
   </p><a id="id-1.8.8.12.3.9" class="indexterm"></a><p>システム全体に対してこの動作を変更するためには<code class="literal">plpgsql.variable_conflict</code>設定パラメータを<code class="literal">error</code>、<code class="literal">use_variable</code>、<code class="literal">use_column</code>のいずれかに設定します(<code class="literal">error</code>が標準配布におけるデフォルトです)。
このパラメータは以降の<span class="application">PL/pgSQL</span>関数の文のコンパイルに影響しますが、現在のセッションでコンパイル済みの文には影響を与えません。
この設定を変更することで、<span class="application">PL/pgSQL</span>の動作において予期できない変化が発生することがありますので、これはスーパーユーザのみが変更することができます。
   </p><p>また、関数テキストの先頭に以下の特殊なコマンドの1つをいれることで、関数単位で動作を設定することもできます。
</p><pre class="programlisting">#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column</pre><p>
これらのコマンドを記述した関数に対してのみ、コマンドは影響を与え、<code class="literal">plpgsql.variable_conflict</code>の設定を上書きします。
以下に例を示します。
</p><pre class="programlisting">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;</pre><p>
<code class="literal">UPDATE</code>コマンドにおいて、<code class="literal">curtime</code>、<code class="literal">comment</code>および<code class="literal">id</code>は、<code class="literal">users</code>に同名の列があるか否かに関わらず、関数の変数またはパラメータを参照します。
テーブル列を参照させるために<code class="literal">WHERE</code>句において<code class="literal">users.id</code>と参照を修飾する必要があったことに注意して下さい。
しかし<code class="literal">UPDATE</code>リストの対象としての<code class="literal">comment</code>への参照は修飾させる必要がありませんでした。
これは文法的に<code class="literal">users</code>の列でなければならないためです。
以下のように<code class="literal">variable_conflict</code>の設定に依存せずに同じ関数を作成することもできます。
</p><pre class="programlisting">CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;</pre><p>
   </p><p>変数置換は<code class="command">EXECUTE</code>コマンドまたはその亜種におけるコマンド文字列の中では起こりません。
そのようなコマンドに可変値を挿入する時は、<a class="xref" href="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN" title="42.5.4. 動的コマンドの実行">Section 42.5.4</a>に述べたように、文字列の値を構成するものの一部とするか<code class="literal">USING</code>を使用してください。
   </p><p>今のところ変数置換は、<code class="command">SELECT</code>と<code class="command">INSERT</code>と<code class="command">UPDATE</code>と<code class="command">DELETE</code>コマンドの中だけで作動します。
メインSQLエンジンが問い合わせパラメータをこれらのコマンドでしか許可しないからです。
他の種類の文（通常ユーティリティ文といいます）において可変名または可変値を使用するには、文字列としてユーティリティ文を構成し<code class="command">EXECUTE</code>してください。
   </p></div><div class="sect2" id="PLPGSQL-PLAN-CACHING"><div class="titlepage"><div><div><h3 class="title">42.10.2. 計画のキャッシュ</h3></div></div></div><p><span class="application">PL/pgSQL</span>インタプリタは、初めてその関数が（各セッションで）呼び出された時に、関数のソーステキストを解析し、バイナリ形式の命令ツリーを内部で作成します。
この命令ツリーは完全に<span class="application">PL/pgSQL</span>文構造に変換されますが、関数内部の個々の<acronym class="acronym">SQL</acronym>式と<acronym class="acronym">SQL</acronym>コマンドは即座に変換されません。
   </p><p>    <a id="id-1.8.8.12.4.3.1" class="indexterm"></a>
各式や<acronym class="acronym">SQL</acronym>コマンドが初めてその関数で実行される時に、<span class="application">PL/pgSQL</span>インタプリタは<acronym class="acronym">SPI</acronym>マネージャの<code class="function">SPI_prepare</code>関数を使用して、プリペアドステートメントを作成するためにコマンドを解析します。
その後にその式やコマンドが行われる時には、そのプリペアドステートメントを再利用します。
こうして、めったに分岐されない条件付きコードパスを持つ関数では、現在のセッションで実行されないそれらのコマンドの解析によるオーバーヘッドを背負いこむことはありません。
欠点は特定の式や問い合わせのエラーが、関数の該当部分が実行されるまで検出されないことです。
（典型的な構文エラーは、最初の解釈において検出されますが、それより深いエラーは、実行の時まで検出されません）。
   </p><p><span class="application">PL/pgSQL</span>は（正確にはSPIマネージャは）さらに特定のプリペアドステートメントに関する実行計画のキャッシュを試行できます。
キャッシュした実行計画が使用されなかった場合、プリペアドステートメントが呼び出される度に新しい実行計画が作成され、選択した実行計画を最適にするために、最新のパラメータ値（すなわち<span class="application">PL/pgSQL</span>の変数値）が使用されます。
プリペアドステートメントがパラメータを持たないか何回も使用される場合、SPIマネージャは特定のパラメータ値に依存しない<em class="firstterm">一般的</em>な実行計画の作成を考え、再使用のためにキャッシュします。
典型的には、これは参照した<span class="application">PL/pgSQL</span>の変数値が、実行計画にさほど影響しない場合にだけ起こります。
それならば、毎回の実行計画の作成の方が優れています。
プリペアドステートメントに関する詳細は<a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>を参照してください。
   </p><p>このように<span class="application">PL/pgSQL</span>はプリペアドステートメントおよび時には実行計画を保存しますので、<span class="application">PL/pgSQL</span>関数内に直接現れるSQLコマンドは実行の度に同じテーブルとフィールドを参照しなければなりません。
つまり、SQLコマンドにて、テーブルやフィールドの名前としてパラメータを使用することができません。
実行の度に新しく実行計画を作成して解析する無駄を覚悟で、<span class="application">PL/pgSQL</span>の<code class="command">EXECUTE</code>文を使った動的問い合わせを構成することで、この制限を回避できます。
   </p><p>レコード変数の変わりやすいという性質はこの接続において別の問題となります。
レコード変数のフィールドが式や文の中で使用される場合、そのフィールドのデータ型を関数を呼び出す度に変更してはいけません。
それぞれの式が最初に実行された時のデータ型を使用して、その式が解析されているからです。
必要な場合<code class="command">EXECUTE</code>を使用してこの問題を回避することができます。
    </p><p>同一の関数が2つ以上のテーブルのトリガとして使用される場合、<span class="application">PL/pgSQL</span>はテーブルごとのプリペアドステートメントをキャッシュします。
すなわち、各々のトリガ関数とテーブルの組ごとにキャッシュするのであり、トリガ関数ごとではありません。
このため、データ型の変更に伴う問題の一部を軽減します。
例えば、別のテーブルにある異なったデータ型であっても、<code class="literal">key</code>と命名した列に対してトリガ関数は有効に作動します。
    </p><p>同様に、多様型の引数を持った関数は、実際に呼び出す引数の型の組み合わせごとに別々のプリペアドステートメントをキャッシュします。
そのため、データ型の差異が原因で予期しない失敗が起こることはありません。
    </p><p>プリペアドステートメントのキャッシュにより、時間に依存する値の解釈の結果に違いが現れることがあります。
例えば、以下の2つの関数の結果は異なります。

</p><pre class="programlisting">CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;</pre><p>

および

</p><pre class="programlisting">CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;</pre><p>
    </p><p><code class="function">logfunc1</code>の場合では、<span class="productname">PostgreSQL</span>のメインパーサは、<code class="command">INSERT</code>を解析する時に、<code class="classname">logtable</code>の対象列の型から<code class="literal">'now'</code>を<code class="type">timestamp</code>と解釈しなければならないことを把握しています。
こうして、パーサは<code class="command">INSERT</code>が解析された時点で<code class="literal">'now'</code>を<code class="type">timestamp</code>定数に変換し、その定数値をその後のセッションの有効期間における<code class="function">logfunc1</code>の全ての呼び出しで使用します。
言うまでもありませんが、これはプログラマが意図した動作ではありません。
<code class="literal">now()</code>または<code class="literal">current_timestamp</code>関数の使用が優れています。
    </p><p><code class="function">logfunc2</code>の場合では、<span class="productname">PostgreSQL</span>のメインパーサは<code class="literal">'now'</code>の型を決定することができません。
そのため、<code class="literal">now</code>という文字列を持つ<code class="type">text</code>型のデータ値を返します。
<code class="varname">curtime</code>ローカル変数に代入する時に、<span class="application">PL/pgSQL</span>インタプリタはこの文字列を<code class="function">text_out</code>と<code class="function">timestamp_in</code>関数を変換に使用して<code class="type">timestamp</code>型にキャストします。
ですから、演算されたタイムスタンプは、プログラマが意図した通り、実行の度に更新されます。
この方法でたまたま意図した通り動くけれど、それほど効率的ではありません。
ですから、<code class="literal">now()</code>関数の使用の方が優れています。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-trigger.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-development-tips.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.9. トリガプロシージャ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.11. <span class="application">PL/pgSQL</span>による開発向けのヒント</td></tr></table></div></body></html>