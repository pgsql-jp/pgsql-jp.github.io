<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.11. ユーザ定義の型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xaggr.html" title="37.10. ユーザ定義の集約" /><link rel="next" href="xoper.html" title="37.12. ユーザ定義の演算子" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.11. ユーザ定義の型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xaggr.html" title="37.10. ユーザ定義の集約">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="xoper.html" title="37.12. ユーザ定義の演算子">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="XTYPES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.11. ユーザ定義の型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xtypes.html#XTYPES-TOAST">37.11.1. TOASTの考慮</a></span></dt></dl></div><a id="id-1.8.3.14.2" class="indexterm"></a><p><a class="xref" href="extend-type-system.html" title="37.2. PostgreSQLの型システム">Section 37.2</a>に述べられているように、<span class="productname">PostgreSQL</span>は、新しい型をサポートするように拡張することができます。
本節では、<acronym class="acronym">SQL</acronym>言語以下のレベルで定義されるデータ型である基本型を新しく定義する方法について説明します。
新しい基本型の作成には、低レベル言語、通常Cで作成された型を操作する関数の実装が必要です。
  </p><p>本節で使用する例は、ソース配布物内の<code class="filename">src/tutorial</code>ディレクトリに<code class="filename">complex.sql</code>と<code class="filename">complex.c</code>という名前で置いてあります。
この例の実行方法についてはディレクトリ内の<code class="filename">README</code>を参照してください。
  </p><p>  <a id="id-1.8.3.14.5.1" class="indexterm"></a>
  <a id="id-1.8.3.14.5.2" class="indexterm"></a>
ユーザ定義データ型では必ず入力関数と出力関数が必要です。
これらの関数は、その型が（ユーザによる入力とユーザへの出力のための）文字列としてどのように表現されるかと、その型がメモリ中でどう構成されるかを決定します。
入力関数は引数としてヌル終端文字列を取り、その型の（メモリ中の）内部表現を返します。
出力関数は引数としてその型の内部表現を取り、ヌル終端文字列を返します。
単に格納するだけではなく、その型に操作を加えたいのであれば、その型に持たせたいすべての操作を実装した関数をさらに提供しなければなりません。
 </p><p>例えば、複素数を表現する<code class="type">complex</code>型を定義することを考えます。
おそらく、次のようなC構造体で複素数をメモリ中で表現することがごく自然な方法です。

</p><pre class="programlisting">typedef struct Complex {
    double      x;
    double      y;
} Complex;</pre><p>

単一の<code class="type">Datum</code>値で扱うには大き過ぎるので、これは参照渡し型にしなければなりません。
 </p><p>この型の外部文字列表現として<code class="literal">(x,y)</code>形式の文字列を使用することを選択します。
 </p><p>入出力関数、特に出力関数を作成することは困難ではありません。
しかし、この型の外部表現文字列を定義する時、その表現のための完全で堅牢なパーサを入力関数として作成しなければなりません。
以下に例を示します。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(complex_in);

Datum
complex_in(PG_FUNCTION_ARGS)
{
    char       *str = PG_GETARG_CSTRING(0);
    double      x,
                y;
    Complex    *result;

    if (sscanf(str, " ( %lf , %lf )", &amp;x, &amp;y) != 2)
        ereport(ERROR,
                (errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),
                 errmsg("invalid input syntax for complex: \"%s\"",
                        str)));

    result = (Complex *) palloc(sizeof(Complex));
    result-&gt;x = x;
    result-&gt;y = y;
    PG_RETURN_POINTER(result);
}</pre><p>

出力関数は以下のように簡単にできます。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(complex_out);

Datum
complex_out(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    char       *result;

    result = psprintf("(%g,%g)", complex-&gt;x, complex-&gt;y);
    PG_RETURN_CSTRING(result);
}</pre><p>
 </p><p>入出力関数は各々の逆関数になるように注意しなければなりません。
そうしないと、データをファイルにダンプし、それを読み戻そうとする際に、深刻な問題が発生するでしょう。
これは特に浮動小数点数が関係する際によく発生する問題です。
 </p><p>省略することができますが、ユーザ定義型はバイナリ入出力関数を提供することができます。
バイナリ入出力は通常テキスト入出力より高速ですが、テキスト入出力より移植性がありません。
テキスト入出力と同様に、外部バイナリ表現を正確に定義することは作成者の責任です。
ほとんどの組み込みデータ型は、マシンに依存しないバイナリ表現を提供しようとしています。
<code class="type">complex</code>型では<code class="type">float8</code>型のバイナリ入出力コンバータを元にします。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(complex_recv);

Datum
complex_recv(PG_FUNCTION_ARGS)
{
    StringInfo  buf = (StringInfo) PG_GETARG_POINTER(0);
    Complex    *result;

    result = (Complex *) palloc(sizeof(Complex));
    result-&gt;x = pq_getmsgfloat8(buf);
    result-&gt;y = pq_getmsgfloat8(buf);
    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(complex_send);

Datum
complex_send(PG_FUNCTION_ARGS)
{
    Complex    *complex = (Complex *) PG_GETARG_POINTER(0);
    StringInfoData buf;

    pq_begintypsend(&amp;buf);
    pq_sendfloat8(&amp;buf, complex-&gt;x);
    pq_sendfloat8(&amp;buf, complex-&gt;y);
    PG_RETURN_BYTEA_P(pq_endtypsend(&amp;buf));
}</pre><p>
 </p><p>入出力関数を作成し共有ライブラリ内にコンパイルすれば、SQLで<code class="type">complex</code>型を定義することができます。
まずシェル型として宣言します。

</p><pre class="programlisting">CREATE TYPE complex;</pre><p>

これは、入出力関数を定義する時にこの型を参照することができるプレースホルダとして動作します。
この後以下のように、入出力関数を定義することができます。

</p><pre class="programlisting">CREATE FUNCTION complex_in(cstring)
    RETURNS complex
    AS '<em class="replaceable"><code>filename</code></em>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_out(complex)
    RETURNS cstring
    AS '<em class="replaceable"><code>filename</code></em>'
    LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_recv(internal)
   RETURNS complex
   AS '<em class="replaceable"><code>filename</code></em>'
   LANGUAGE C IMMUTABLE STRICT;

CREATE FUNCTION complex_send(complex)
   RETURNS bytea
   AS '<em class="replaceable"><code>filename</code></em>'
   LANGUAGE C IMMUTABLE STRICT;</pre><p>
 </p><p>最後にデータ型の完全な定義を提供することができます。
</p><pre class="programlisting">CREATE TYPE complex (
   internallength = 16,
   input = complex_in,
   output = complex_out,
   receive = complex_recv,
   send = complex_send,
   alignment = double
);</pre><p>
 </p><p>  <a id="id-1.8.3.14.13.1" class="indexterm"></a>
新しい基本型を定義すると、<span class="productname">PostgreSQL</span>は自動的にその型の配列のサポートを提供します。
配列型は通常、基本型の名前の前にアンダースコア文字<code class="literal">_</code>が付いた名前になります。
 </p><p>データ型が存在するようになると、そのデータ型に対する有用な操作を提供する関数を宣言することができます。
そしてその関数を使用する演算子も定義できます。
また、必要に応じて、そのデータ型用のインデックスをサポートするための演算子クラスも作成することができます。
こうした追加層については後の節で説明します。
 </p><p>データ型の内部表現が可変長であるなら、内部表現は可変長データの標準配置に従わなければなりません。先頭の4バイトは<code class="type">char[4]</code>フィールドで、直接アクセスされることは決してありません（慣習的に<code class="structfield">vl_len_</code>と呼ばれます）。
<code class="function">SET_VARSIZE()</code>マクロを使用してデータの総量をこのフィールドに格納し、また、<code class="function">VARSIZE()</code>を使用して取り出さなければなりません。
(長さフィールドはプラットフォームに依存してエンコードされるかもしれませんので、このマクロが存在します。)
 </p><p>詳細については<a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>コマンドの説明を参照してください。
 </p><div class="sect2" id="XTYPES-TOAST"><div class="titlepage"><div><div><h3 class="title">37.11.1. TOASTの考慮</h3></div></div></div><a id="id-1.8.3.14.17.2" class="indexterm"></a><p>データ型の値により（内部形式で）容量が変動する場合、そのデータ型を<acronym class="acronym">TOAST</acronym>可能とすることが通常は望ましいです（<a class="xref" href="storage-toast.html" title="66.2. TOAST">Section 66.2</a>を参照してください）。
ヘッダのオーバーヘッドを減らすことで<acronym class="acronym">TOAST</acronym>は小さなデータに対しても容量を抑えることができますので、データが常に圧縮したり外部に格納したりするには小さ過ぎる場合でも、これを行なうことを推奨します。
 </p><p><acronym class="acronym">TOAST</acronym>格納をサポートするために、そのデータ型を扱うC関数は常に、<code class="function">PG_DETOAST_DATUM</code>を使用して、渡されたTOAST化値を注意深く展開しなければなりません。
（通常、こうした詳細は型独自の<code class="function">GETARG_DATATYPE_P</code>マクロを定義して隠蔽します。）
その後、<code class="command">CREATE TYPE</code>コマンドを実行する際に、内部長を<code class="literal">variable</code>と指定し、また、<code class="literal">plain</code>以外の適当な格納オプションを選択してください。
 </p><p>データの整列が（単なる特定の関数向けやデータ型が常にバイト単位の整列を規定しているため）重要でない場合、<code class="function">PG_DETOAST_DATUM</code>のオーバヘッドの一部を省くことができます。
代わりに<code class="function">PG_DETOAST_DATUM_PACKED</code>を使用してください（通常は<code class="function">GETARG_DATATYPE_PP</code>マクロを定義することで隠蔽されます）。
そして、<code class="function">VARSIZE_ANY_EXHDR</code>および<code class="function">VARDATA_ANY</code>マクロを使用して、圧縮されている可能性があるデータにアクセスしてください。
繰り返しますが、これらのマクロから返されるデータは、たとえデータ型定義で整列を規定していたとしても、整列されません。
整列が重要であれば、通常の<code class="function">PG_DETOAST_DATUM</code>インタフェースを介して実行してください。
 </p><div class="note"><h3 class="title">Note</h3><p>古めのコードではしばしば<code class="structfield">vl_len_</code>を<code class="type">char[4]</code>ではなく<code class="type">int32</code>として宣言しています。
この構造体定義が少なくとも<code class="type">int32</code>で整列されたフィールドを持っている限り、これは問題ありません。
しかし、整列されていない可能性があるデータを扱う場合に、こうした構造体定義を使用することは危険です。
データが実際に整列されていると仮定することをコンパイラの規則としているかもしれず、この場合、整列に厳密なアーキテクチャではコアダンプしてしまいます。
  </p></div><p><acronym class="acronym">TOAST</acronym>のサポートにより有効になるもう一つの機能は以下のような可能性です。ディスクに格納されたフォーマットよりも扱うのにより便利な<em class="firstterm">展開された</em>インメモリデータ表現を持てるかもしれません。
通常のもしくは<span class="quote">“<span class="quote">単純な</span>”</span>varlena格納フォーマットは結局のところ単なるバイトのblobです。例えば、メモリの別の場所にコピーされるかもしれませんのでポインタを含むことができません。
複雑なデータ型に対しては、単純なフォーマットは扱うのにかなり高価になるかもしれません。そこで、<span class="productname">PostgreSQL</span>は計算するのにより適した表現に単純なフォーマットを<span class="quote">“<span class="quote">展開する</span>”</span>方法を提供し、そのフォーマットをインメモリでそのデータ型の関数から関数へと渡します。
 </p><p>展開された格納を使うためには、データ型は<code class="filename">src/include/utils/expandeddatum.h</code>にある規則に従う展開されたフォーマットを定義し、単純なvarlenaの値を展開されたフォーマットに<span class="quote">“<span class="quote">展開する</span>”</span>関数や展開されたフォーマットを通常のvarlena表現に<span class="quote">“<span class="quote">戻す</span>”</span>関数を提供しなければなりません。
そのデータ型のC関数はすべてどちらの表現でも確実に受け付けられるようにしてください。おそらく、受け取ったらすぐに一方からもう一方に変換することによって実現することになるでしょう。
これはそのデータ型の既存の関数をすべて一度に修正することを要求するものでありません。なぜなら、<code class="function">PG_DETOAST_DATUM</code>マクロが展開された入力を通常の単純なフォーマットに変換するために定義されているからです。
そのため、単純なvarlenaフォーマットを扱う既存の関数は、わずかに非効率ではありますが、展開された入力も続けて扱えるでしょう。より良いパフォーマンスが重要になるまで、変更は必要ありません。
 </p><p>展開された表現の扱い方を知っているC関数は典型的には以下の2つに分類されます。展開されたフォーマットのみを扱えるものと、展開されたものも単純なvarlena入力も扱えるものです。
前者は書くのが簡単ですが、全般にあまり効率的ではないかもしれません。なぜなら、一つの関数による使用のために単純な入力を展開された形に変換することは、展開されたフォーマットで操作することで節約されることよりコストが掛かるかもしれないからです。
展開されたフォーマットのみ扱うことが必要であるなら、単純な入力の展開された形への変換は引数を取得するマクロの中に隠すことができます。それゆえ、関数は伝統的なvarlena入力を扱うものよりもより複雑に見えることはありません。
両方の型の入力を扱うためには、外部やショートヘッダや圧縮されたvarlenaの入力はトースト解除をするけれども展開された入力に対してはトースト解除をしないような、引数を取得する関数を書いてください。
そのような関数は、単純なvarlenaフォーマットと展開されたフォーマットの共用体へのポインタを返すよう定義できます。
呼び出し側はどちらのフォーマットを受け取ったのか確定するのに<code class="function">VARATT_IS_EXPANDED_HEADER()</code>マクロを使えます。
 </p><p><acronym class="acronym">TOAST</acronym>基盤により、通常のvarlenaの値を展開された値から区別できるようになるだけでなく、展開された値への<span class="quote">“<span class="quote">読み書き可能</span>”</span>なポインタと<span class="quote">“<span class="quote">読み取りのみ</span>”</span>のポインタを区別できるようになります。
展開された値を検査することが必要なだけのものや安全で意味論的に不可視の方法で変更するC関数は、受け取ったポインタがどちらの種類であるか気にする必要はありません。
入力値の修正されたバージョンを生成するC関数は、読み書き可能なポインタを受け取ったのであれば展開された入力値をその場で修正できますが、読み取りのみのポインタを受け取ったのであれば入力を変更してはなりません。その場合には、まず値をコピーして、修正するための新しい値を生成しなければなりません。
展開された値を新しく作成したC関数は、必ずそこへの読み書き可能なポインタを返すことを推奨します。
また、読み書き可能な展開された値をその場で修正するC関数は、途中で失敗した場合に気をつけて値を健全な状態のままにしておくことを推奨します。
 </p><p>展開された値を扱う例は、標準配列基盤、特に<code class="filename">src/backend/utils/adt/array_expanded.c</code>を見てください。
 </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xaggr.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="xoper.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.10. ユーザ定義の集約 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.12. ユーザ定義の演算子</td></tr></table></div></body></html>