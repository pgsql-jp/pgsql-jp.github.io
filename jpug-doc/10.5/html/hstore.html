<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.17. hstore</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fuzzystrmatch.html" title="F.16. fuzzystrmatch" /><link rel="next" href="intagg.html" title="F.18. intagg" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.17. hstore</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fuzzystrmatch.html" title="F.16. fuzzystrmatch">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Appendix F. 追加で提供されるモジュール">Up</a></td><th width="60%" align="center">Appendix F. 追加で提供されるモジュール</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="intagg.html" title="F.18. intagg">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="HSTORE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.17. hstore</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.4">F.17.1. <code class="type">hstore</code>の外部表現</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.5">F.17.2. <code class="type">hstore</code>の演算子と関数</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.6">F.17.3. インデックス</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.7">F.17.4. 例</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.8">F.17.5. 統計情報</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.9">F.17.6. 互換性</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.10">F.17.7. 変換</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.26.11">F.17.8. 作者</a></span></dt></dl></div><a id="id-1.11.7.26.2" class="indexterm"></a><p>本モジュールはキー、値の組み合わせの集合を単一の<span class="productname">PostgreSQL</span>値に格納するための<code class="type">hstore</code>データ型を実装します。
あまり厳密に検査されない属性を多く持つ行や半構造化データなど、多くの状況で有用になる可能性があります。
キーと値は単純なテキスト文字列です。
 </p><div class="sect2" id="id-1.11.7.26.4"><div class="titlepage"><div><div><h3 class="title">F.17.1. <code class="type">hstore</code>の外部表現</h3></div></div></div><p>
入力および出力で使用される<code class="type">hstore</code>値のテキスト表現はカンマで区切られた、ゼロ以上の<em class="replaceable"><code>key</code></em> <code class="literal">=&gt;</code> <em class="replaceable"><code>value</code></em>という組み合わせを含みます。
以下に例を示します。

</p><pre class="synopsis">k =&gt; v
foo =&gt; bar, baz =&gt; whatever
"1-a" =&gt; "anything at all"</pre><p>

組み合わせの順序は重要ではありません（出力時に再現されないこともあります）。
組み合わせ間や<code class="literal">=&gt;</code>記号の前後の空白文字は無視されます。
キーや値が空白文字、カンマ、<code class="literal">=</code>、<code class="literal">&gt;</code>を含む場合は二重引用符でくくります。
キーや値に二重引用符やバックスラッシュを含めるには、バックスラッシュでエスケープしてください。
  </p><p><code class="type">hstore</code>内の各キーは一意です。
重複するキーを持つ<code class="type">hstore</code>を宣言すると、<code class="type">hstore</code>には1つしか保存されません。
またどちらが残るかは保証されません。

</p><pre class="programlisting">SELECT 'a=&gt;1,a=&gt;2'::hstore;
  hstore
----------
 "a"=&gt;"1"</pre><p>
  </p><p>値はSQLの<code class="literal">NULL</code>を取ることができます（キーは不可）。
以下に例を示します。

</p><pre class="programlisting">key =&gt; NULL</pre><p>

<code class="literal">NULL</code>キーワードは大文字小文字の区別をしません。
<code class="literal">null</code>を普通の文字列<span class="quote">“<span class="quote">NULL</span>”</span>として扱うためには二重引用符でくくってください。
  </p><div class="note"><h3 class="title">Note</h3><p>入力として使用される場合<code class="type">hstore</code>テキスト書式は、<span class="emphasis"><em>前もって</em></span>必要な引用符付けやエスケープ処理を適用することに注意してください。
パラメータとして<code class="type">hstore</code>リテラルを渡す場合、追加処理は必要ありません。
しかし、引用符付けしたリテラル定数として渡す場合には、単一引用符および(<code class="varname">standard_conforming_strings</code>設定パラメータに依存しますが)バックスラッシュ文字をすべて正しくエスケープしなければなりません。
文字列定数の取り扱いについては<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 文字列定数">Section 4.1.2.1</a>を参照してください。
  </p></div><p>出力の場合、厳密に必要がない場合であっても、常にキーと値は二重引用符でくくられます。
  </p></div><div class="sect2" id="id-1.11.7.26.5"><div class="titlepage"><div><div><h3 class="title">F.17.2. <code class="type">hstore</code>の演算子と関数</h3></div></div></div><p><code class="literal">hstore</code>モジュールで提供される演算子を<a class="xref" href="hstore.html#HSTORE-OP-TABLE" title="Table F.8. hstore演算子">Table F.8</a>に、関数を<a class="xref" href="hstore.html#HSTORE-FUNC-TABLE" title="Table F.9. hstoreの関数">Table F.9</a>に示します。
  </p><div class="table" id="HSTORE-OP-TABLE"><p class="title"><strong>Table F.8. <code class="type">hstore</code>演算子</strong></p><div class="table-contents"><table class="table" summary="hstore演算子" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>演算子</th><th>説明</th><th>例</th><th>結果</th></tr></thead><tbody><tr><td><code class="type">hstore</code> <code class="literal">-&gt;</code> <code class="type">text</code></td><td>キーの値を取り出します（存在しなければ<code class="literal">NULL</code>）</td><td><code class="literal">'a=&gt;x, b=&gt;y'::hstore -&gt; 'a'</code></td><td><code class="literal">x</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-&gt;</code> <code class="type">text[]</code></td><td>キーの値を取り出します（存在しなければ<code class="literal">NULL</code>）</td><td><code class="literal">'a=&gt;x, b=&gt;y, c=&gt;z'::hstore -&gt; ARRAY['c','a']</code></td><td><code class="literal">{"z","x"}</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">||</code> <code class="type">hstore</code></td><td><code class="type">hstore</code>を連結します。</td><td><code class="literal">'a=&gt;b, c=&gt;d'::hstore || 'c=&gt;x, d=&gt;q'::hstore</code></td><td><code class="literal">"a"=&gt;"b", "c"=&gt;"x", "d"=&gt;"q"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?</code> <code class="type">text</code></td><td><code class="type">hstore</code>がキーを含むかどうか。</td><td><code class="literal">'a=&gt;1'::hstore ? 'a'</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?&amp;</code> <code class="type">text[]</code></td><td><code class="type">hstore</code>が指定したキーをすべて含むかどうか。</td><td><code class="literal">'a=&gt;1,b=&gt;2'::hstore ?&amp; ARRAY['a','b']</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?|</code> <code class="type">text[]</code></td><td><code class="type">hstore</code>が指定したキーのいずれかを含むかどうか。</td><td><code class="literal">'a=&gt;1,b=&gt;2'::hstore ?| ARRAY['b','c']</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">@&gt;</code> <code class="type">hstore</code></td><td>左辺は右辺を含むかどうか。</td><td><code class="literal">'a=&gt;b, b=&gt;1, c=&gt;NULL'::hstore @&gt; 'b=&gt;1'</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">&lt;@</code> <code class="type">hstore</code></td><td>左辺は右辺に含まれるかどうか。</td><td><code class="literal">'a=&gt;c'::hstore &lt;@ 'a=&gt;b, b=&gt;1, c=&gt;NULL'</code></td><td><code class="literal">f</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">text</code></td><td>左辺からキーを削除します。</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'b'::text</code></td><td><code class="literal">"a"=&gt;"1", "c"=&gt;"3"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">text[]</code></td><td>左辺からキー(複数)を削除します。</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - ARRAY['a','b']</code></td><td><code class="literal">"c"=&gt;"3"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">hstore</code></td><td>左辺から一致する組み合わせを削除します。</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'a=&gt;4, b=&gt;2'::hstore</code></td><td><code class="literal">"a"=&gt;"1", "c"=&gt;"3"</code></td></tr><tr><td><code class="type">record</code> <code class="literal">#=</code> <code class="type">hstore</code></td><td><code class="type">record</code>内のフィールドを<code class="type">hstore</code>の対応する値で置換します。</td><td>後述の例を参照</td><td> </td></tr><tr><td><code class="literal">%%</code> <code class="type">hstore</code></td><td>キーと値を変更して<code class="type">hstore</code>を配列に変換します。</td><td><code class="literal">%% 'a=&gt;foo, b=&gt;bar'::hstore</code></td><td><code class="literal">{a,foo,b,bar}</code></td></tr><tr><td><code class="literal">%#</code> <code class="type">hstore</code></td><td><code class="type">hstore</code>をキーと値の2次元配列に変換します。</td><td><code class="literal">%# 'a=&gt;foo, b=&gt;bar'::hstore</code></td><td><code class="literal">{{a,foo},{b,bar}}</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Note</h3><p>PostgreSQL 8.2より前では、包含演算子<code class="literal">@&gt;</code>と<code class="literal">&lt;@</code>はそれぞれ<code class="literal">@</code>と<code class="literal">~</code>と呼ばれていました。
これらの名前はまだ利用できますが、廃止予定であり、最終的にはなくなります。
古い名前がコアの幾何データ型が従う規約と反対であることに注意してください。
   </p></div><div class="table" id="HSTORE-FUNC-TABLE"><p class="title"><strong>Table F.9. <code class="type">hstore</code>の関数</strong></p><div class="table-contents"><table class="table" summary="hstoreの関数" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>戻り値の型</th><th>説明</th><th>例</th><th>結果</th></tr></thead><tbody><tr><td><code class="function">hstore(record)</code><a id="id-1.11.7.26.5.5.2.2.1.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td>レコードまたは行から<code class="type">hstore</code>を生成します。</td><td><code class="literal">hstore(ROW(1,2))</code></td><td><code class="literal">f1=&gt;1,f2=&gt;2</code></td></tr><tr><td><code class="function">hstore(text[])</code></td><td><code class="type">hstore</code></td><td>配列から<code class="type">hstore</code>を生成します。配列はキー、値の配列でも2次元の配列でも構いません</td><td><code class="literal">hstore(ARRAY['a','1','b','2']) || hstore(ARRAY[['c','3'],['d','4']])</code></td><td><code class="literal">a=&gt;1, b=&gt;2, c=&gt;3, d=&gt;4</code></td></tr><tr><td><code class="function">hstore(text[], text[])</code></td><td><code class="type">hstore</code></td><td>キー、値で分けた配列から<code class="type">hstore</code>を作成します。</td><td><code class="literal">hstore(ARRAY['a','b'], ARRAY['1','2'])</code></td><td><code class="literal">"a"=&gt;"1","b"=&gt;"2"</code></td></tr><tr><td><code class="function">hstore(text, text)</code></td><td><code class="type">hstore</code></td><td><code class="type">hstore</code>型の単一項目を作成します。</td><td><code class="literal">hstore('a', 'b')</code></td><td><code class="literal">"a"=&gt;"b"</code></td></tr><tr><td><code class="function">akeys(hstore)</code><a id="id-1.11.7.26.5.5.2.2.5.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td><code class="type">hstore</code>のキーを配列として入手します。</td><td><code class="literal">akeys('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{a,b}</code></td></tr><tr><td><code class="function">skeys(hstore)</code><a id="id-1.11.7.26.5.5.2.2.6.1.2" class="indexterm"></a></td><td><code class="type">setof text</code></td><td><code class="type">hstore</code>のキーを集合として入手します。</td><td><code class="literal">skeys('a=&gt;1,b=&gt;2')</code></td><td><pre class="programlisting">a
b</pre></td></tr><tr><td><code class="function">avals(hstore)</code><a id="id-1.11.7.26.5.5.2.2.7.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td><code class="type">hstore</code>の値を配列として入手します。</td><td><code class="literal">avals('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{1,2}</code></td></tr><tr><td><code class="function">svals(hstore)</code><a id="id-1.11.7.26.5.5.2.2.8.1.2" class="indexterm"></a></td><td><code class="type">setof text</code></td><td><code class="type">hstore</code>の値を集合として入手します。</td><td><code class="literal">svals('a=&gt;1,b=&gt;2')</code></td><td><pre class="programlisting">1
2</pre></td></tr><tr><td><code class="function">hstore_to_array(hstore)</code><a id="id-1.11.7.26.5.5.2.2.9.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td><code class="type">hstore</code>のキーと値を、キーと値を交互に表した配列として入手します。</td><td><code class="literal">hstore_to_array('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{a,1,b,2}</code></td></tr><tr><td><code class="function">hstore_to_matrix(hstore)</code><a id="id-1.11.7.26.5.5.2.2.10.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td><code class="type">hstore</code>のキーと値を2次元配列として入手します。</td><td><code class="literal">hstore_to_matrix('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{{a,1},{b,2}}</code></td></tr><tr><td><code class="function">hstore_to_json(hstore)</code><a id="id-1.11.7.26.5.5.2.2.11.1.2" class="indexterm"></a></td><td><code class="type">json</code></td><td>非nullの値をすべてJSON文字列に変換し、<code class="type">hstore</code>を<code class="type">json</code>値として入手します。</td><td><code class="literal">hstore_to_json('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": "1", "b": "t", "c": null, "d": "12345", "e": "012345", "f": "1.234", "g": "2.345e+4"}</code></td></tr><tr><td><code class="function">hstore_to_jsonb(hstore)</code><a id="id-1.11.7.26.5.5.2.2.12.1.2" class="indexterm"></a></td><td><code class="type">jsonb</code></td><td>非nullの値をすべてJSON文字列に変換し、<code class="type">hstore</code>を<code class="type">jsonb</code>値として入手します。</td><td><code class="literal">hstore_to_jsonb('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": "1", "b": "t", "c": null, "d": "12345", "e": "012345", "f": "1.234", "g": "2.345e+4"}</code></td></tr><tr><td><code class="function">hstore_to_json_loose(hstore)</code><a id="id-1.11.7.26.5.5.2.2.13.1.2" class="indexterm"></a></td><td><code class="type">json</code></td><td><code class="type">hstore</code>を<code class="type">json</code>値として入手します。ですが、数値およびブール値を識別しようとするため、その2つはJSON中では引用符が付きません。</td><td><code class="literal">hstore_to_json_loose('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": 1, "b": true, "c": null, "d": 12345, "e": "012345", "f": 1.234, "g": 2.345e+4}</code></td></tr><tr><td><code class="function">hstore_to_jsonb_loose(hstore)</code><a id="id-1.11.7.26.5.5.2.2.14.1.2" class="indexterm"></a></td><td><code class="type">jsonb</code></td><td><code class="type">hstore</code>を<code class="type">jsonb</code>値として入手します。ですが、数値およびブール値を識別しようとするため、その2つはJSON中では引用符が付きません。</td><td><code class="literal">hstore_to_jsonb_loose('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": 1, "b": true, "c": null, "d": 12345, "e": "012345", "f": 1.234, "g": 2.345e+4}</code></td></tr><tr><td><code class="function">slice(hstore, text[])</code><a id="id-1.11.7.26.5.5.2.2.15.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td><code class="type">hstore</code>の部分集合を取り出します。</td><td><code class="literal">slice('a=&gt;1,b=&gt;2,c=&gt;3'::hstore, ARRAY['b','c','x'])</code></td><td><code class="literal">"b"=&gt;"2", "c"=&gt;"3"</code></td></tr><tr><td><code class="function">each(hstore)</code><a id="id-1.11.7.26.5.5.2.2.16.1.2" class="indexterm"></a></td><td><code class="type">setof(key text, value text)</code></td><td><code class="type">hstore</code>のキーと値を集合として入手します。</td><td><code class="literal">select * from each('a=&gt;1,b=&gt;2')</code></td><td><pre class="programlisting"> key | value
-----+-------
 a   | 1
 b   | 2</pre></td></tr><tr><td><code class="function">exist(hstore,text)</code><a id="id-1.11.7.26.5.5.2.2.17.1.2" class="indexterm"></a></td><td><code class="type">boolean</code></td><td><code class="type">hstore</code>がキーを含むかどうか。</td><td><code class="literal">exist('a=&gt;1','a')</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="function">defined(hstore,text)</code><a id="id-1.11.7.26.5.5.2.2.18.1.2" class="indexterm"></a></td><td><code class="type">boolean</code></td><td><code class="type">hstore</code>がキーに対して非<code class="literal">NULL</code>の値を持つかどうか</td><td><code class="literal">defined('a=&gt;NULL','a')</code></td><td><code class="literal">f</code></td></tr><tr><td><code class="function">delete(hstore,text)</code><a id="id-1.11.7.26.5.5.2.2.19.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td>キーに一致する組み合わせを削除します。</td><td><code class="literal">delete('a=&gt;1,b=&gt;2','b')</code></td><td><code class="literal">"a"=&gt;"1"</code></td></tr><tr><td><code class="function">delete(hstore,text[])</code></td><td><code class="type">hstore</code></td><td>キー(複数)に対応する組み合わせを削除します。</td><td><code class="literal">delete('a=&gt;1,b=&gt;2,c=&gt;3',ARRAY['a','b'])</code></td><td><code class="literal">"c"=&gt;"3"</code></td></tr><tr><td><code class="function">delete(hstore,hstore)</code></td><td><code class="type">hstore</code></td><td>第二引数内の組み合わせと一致する組み合わせを削除します。</td><td><code class="literal">delete('a=&gt;1,b=&gt;2','a=&gt;4,b=&gt;2'::hstore)</code></td><td><code class="literal">"a"=&gt;"1"</code></td></tr><tr><td><code class="function">populate_record(record,hstore)</code><a id="id-1.11.7.26.5.5.2.2.22.1.2" class="indexterm"></a></td><td><code class="type">record</code></td><td><code class="type">record</code>内のフィールドを<code class="type">hstore</code>の対応する値で置換します。</td><td>後述の例を参照</td><td> </td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">Note</h3><p><code class="function">hstore_to_json</code>関数は<code class="type">hstore</code>値を<code class="type">json</code>にキャストする時に使われます。
同様に、<code class="function">hstore_to_jsonb</code>関数は<code class="type">hstore</code>値を<code class="type">jsonb</code>にキャストする時に使われます。
   </p></div><div class="note"><h3 class="title">Note</h3><p><code class="function">populate_record</code>関数の最初の引数は実際には<code class="type">record</code>ではなく<code class="type">anyelement</code>と宣言されています。
しかし、実行時にはレコード型以外は拒絶されます。
   </p></div></div><div class="sect2" id="id-1.11.7.26.6"><div class="titlepage"><div><div><h3 class="title">F.17.3. インデックス</h3></div></div></div><p><code class="type">hstore</code>は<code class="literal">@&gt;</code>、<code class="literal">?</code>、<code class="literal">?&amp;</code>および<code class="literal">?|</code>演算子向けのGiSTおよびGINインデックスをサポートします。
以下に例を示します。
  </p><pre class="programlisting">CREATE INDEX hidx ON testhstore USING GIST (h);

CREATE INDEX hidx ON testhstore USING GIN (h);</pre><p><code class="type">hstore</code>はまた、<code class="literal">=</code>演算子向けに<code class="type">btree</code>または<code class="type">hash</code>インデックスをサポートします。
これにより<code class="type">hstore</code>の列を<code class="literal">UNIQUE</code>と宣言すること、また、<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>、<code class="literal">DISTINCT</code>の式で使用することができます。
<code class="type">hstore</code>値のソート順序付けはあまり有用ではありません。
しかしこれらのインデックスは同値検索の際に有用になるかもしれません。
<code class="literal">=</code>比較用のインデックスを以下のように作成します。
  </p><pre class="programlisting">CREATE INDEX hidx ON testhstore USING BTREE (h);

CREATE INDEX hidx ON testhstore USING HASH (h);</pre></div><div class="sect2" id="id-1.11.7.26.7"><div class="titlepage"><div><div><h3 class="title">F.17.4. 例</h3></div></div></div><p>キーを追加、または、既存のキーを新しい値で更新します。
</p><pre class="programlisting">UPDATE tab SET h = h || hstore('c', '3');</pre><p>
  </p><p>キーを削除します。
</p><pre class="programlisting">UPDATE tab SET h = delete(h, 'k1');</pre><p>
  </p><p><code class="type">record</code>を<code class="type">hstore</code>に変換します。
</p><pre class="programlisting">CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT hstore(t) FROM test AS t;
                   hstore                    
---------------------------------------------
 "col1"=&gt;"123", "col2"=&gt;"foo", "col3"=&gt;"bar"
(1 row)</pre><p>
  </p><p><code class="type">hstore</code>を事前に定義された<code class="type">record</code>型に変換します。
</p><pre class="programlisting">CREATE TABLE test (col1 integer, col2 text, col3 text);

SELECT * FROM populate_record(null::test,
                              '"col1"=&gt;"456", "col2"=&gt;"zzz"');
 col1 | col2 | col3 
------+------+------
  456 | zzz  | 
(1 row)</pre><p>
  </p><p><code class="type">hstore</code>の値を使用して既存のレコードを変更します。
</p><pre class="programlisting">CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT (r).* FROM (SELECT t #= '"col3"=&gt;"baz"' AS r FROM test t) s;
 col1 | col2 | col3 
------+------+------
  123 | foo  | baz
(1 row)</pre><p>
  </p></div><div class="sect2" id="id-1.11.7.26.8"><div class="titlepage"><div><div><h3 class="title">F.17.5. 統計情報</h3></div></div></div><p>内在する自由度のため、<code class="type">hstore</code>型は異なるキーを多く含むことができます。
有効なキーを検査することはアプリケーション側の作業です。
以下の例では、キー検査および統計情報の入手に関する複数の技法を示します。
  </p><p>簡単な例を示します。
</p><pre class="programlisting">SELECT * FROM each('aaa=&gt;bq, b=&gt;NULL, ""=&gt;1');</pre><p>
  </p><p>テーブルを使用する例です。
</p><pre class="programlisting">SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;</pre><p>
  </p><p>オンライン統計値です。
</p><pre class="programlisting">SELECT key, count(*) FROM
  (SELECT (each(h)).key FROM testhstore) AS stat
  GROUP BY key
  ORDER BY count DESC, key;
    key    | count
-----------+-------
 line      |   883
 query     |   207
 pos       |   203
 node      |   202
 space     |   197
 status    |   195
 public    |   194
 title     |   190
 org       |   189
...................</pre><p>
  </p></div><div class="sect2" id="id-1.11.7.26.9"><div class="titlepage"><div><div><h3 class="title">F.17.6. 互換性</h3></div></div></div><p>PostgreSQL 9.0から<code class="type">hstore</code>の内部表現はこれまでから変更されました。
(ダンプ内で使用される)テキスト表現には変更がありませんので、ダンプ/リストアによる更新の妨げにはなりません。
  </p><p>バイナリによる更新の際、新しいコードで古い書式のデータを認識させることにより、上位互換が保持されます。
これには、新しいコードによりまだ変更されていないデータを処理する際に、性能の劣化を多少伴います。
以下のように<code class="literal">UPDATE</code>文を実行することによりテーブル列内のすべての値を強制的に更新することができます。
</p><pre class="programlisting">UPDATE tablename SET hstorecol = hstorecol || '';</pre><p>
  </p><p>上を行う他の方法を以下に示します。
</p><pre class="programlisting">ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || '';</pre><p>
<code class="command">ALTER TABLE</code>による方法はテーブルに対して排他ロックを必要とします。
しかし、古いバージョンの行でテーブルが膨張することはありません。
  </p></div><div class="sect2" id="id-1.11.7.26.10"><div class="titlepage"><div><div><h3 class="title">F.17.7. 変換</h3></div></div></div><p>PL/Perl言語やPL/Python言語向けに<code class="type">hstore</code>型の変換を実装した追加の拡張が入手可能です。
PL/Perl向けの拡張は、信頼されたPL/Perlに対しては<code class="literal">hstore_plperl</code>という名前で、信頼されないものに対しては<code class="literal">hstore_plperlu</code>という名前です。
関数を作成するときにこの変換をインストールして指定していれば、<code class="type">hstore</code>の値はPerlのハッシュにマップされます。
PL/Python向けの拡張は<code class="literal">hstore_plpythonu</code>、<code class="literal">hstore_plpython2u</code>、<code class="literal">hstore_plpython3u</code>という名前です(PL/Pythonの命名規約については<a class="xref" href="plpython-python23.html" title="45.1. Python 2対Python 3">Section 45.1</a>を参照してください)。
この拡張を使うと<code class="type">hstore</code>の値はPythonの辞書型にマップされます。
  </p></div><div class="sect2" id="id-1.11.7.26.11"><div class="titlepage"><div><div><h3 class="title">F.17.8. 作者</h3></div></div></div><p>   Oleg Bartunov <code class="email">&lt;<a class="email" href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>&gt;</code>, Moscow, Moscow University, Russia
  </p><p>   Teodor Sigaev <code class="email">&lt;<a class="email" href="mailto:teodor@sigaev.ru">teodor@sigaev.ru</a>&gt;</code>, Moscow, Delta-Soft Ltd., Russia
  </p><p>追加の改良はAndrew Gierth <code class="email">&lt;<a class="email" href="mailto:andrew@tao11.riddles.org.uk">andrew@tao11.riddles.org.uk</a>&gt;</code>,United Kingdomによりなされました。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fuzzystrmatch.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="intagg.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">F.16. fuzzystrmatch </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> F.18. intagg</td></tr></table></div></body></html>