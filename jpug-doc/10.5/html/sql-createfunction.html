<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE FUNCTION</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE" /><link rel="next" href="sql-creategroup.html" title="CREATE GROUP" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE FUNCTION</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-creategroup.html" title="CREATE GROUP">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATEFUNCTION"><div class="titlepage"></div><a id="id-1.9.3.64.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE FUNCTION</span></h2><p>CREATE FUNCTION — 新しい関数を定義する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE [ OR REPLACE ] FUNCTION
    <em class="replaceable"><code>name</code></em> ( [ [ <em class="replaceable"><code>argmode</code></em> ] [ <em class="replaceable"><code>argname</code></em> ] <em class="replaceable"><code>argtype</code></em> [ { DEFAULT | = } <em class="replaceable"><code>default_expr</code></em> ] [, ...] ] )
    [ RETURNS <em class="replaceable"><code>rettype</code></em>
      | RETURNS TABLE ( <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>column_type</code></em> [, ...] ) ]
  { LANGUAGE <em class="replaceable"><code>lang_name</code></em>
    | TRANSFORM { FOR TYPE <em class="replaceable"><code>type_name</code></em> } [, ... ]
    | WINDOW
    | IMMUTABLE | STABLE | VOLATILE | [ NOT ] LEAKPROOF
    | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
    | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
    | PARALLEL { UNSAFE | RESTRICTED | SAFE }
    | COST <em class="replaceable"><code>execution_cost</code></em>
    | ROWS <em class="replaceable"><code>result_rows</code></em>
    | SET <em class="replaceable"><code>configuration_parameter</code></em> { TO <em class="replaceable"><code>value</code></em> | = <em class="replaceable"><code>value</code></em> | FROM CURRENT }
    | AS '<em class="replaceable"><code>definition</code></em>'
    | AS '<em class="replaceable"><code>obj_file</code></em>', '<em class="replaceable"><code>link_symbol</code></em>'
  } ...
    [ WITH ( <em class="replaceable"><code>attribute</code></em> [, ...] ) ]</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-DESCRIPTION"><h2>説明</h2><p><code class="command">CREATE FUNCTION</code>は新しい関数を定義します。
<code class="command">CREATE OR REPLACE FUNCTION</code>は、新しい関数の作成、または、既存定義の置換のどちらかを行います。
関数を定義するには、ユーザはその言語の<code class="literal">USAGE</code>権限が必要です。
  </p><p>スキーマ名が含まれている場合、関数は指定されたスキーマに作成されます。
スキーマ名がなければ、関数は現在のスキーマに作成されます。
同じスキーマ内の同じ入力引数データ型を持つ既存の関数の名前は、新しい関数の名前として使用できません。
しかし、異なる引数データ型を持つ関数であれば、名前が重複しても構いません
（これを、<em class="firstterm">オーバーロード</em>と言います）。
  </p><p>既存の関数定義を入れ替えるには、<code class="command">CREATE OR REPLACE FUNCTION</code>を使用してください。
この方法では関数の名前や引数の型を変更することはできません
（これを行った場合、新しく別の関数が作成されます）。
また、<code class="command">CREATE OR REPLACE FUNCTION</code>では、既存の関数の戻り値の型を変更することはできません。
戻り値の型を変更したい場合は、その関数を削除し、再度作成してください。
（これは、<code class="literal">OUT</code>パラメータを使用している場合、関数を削除しない限り<code class="literal">OUT</code>パラメータの型を変更できないことを意味します。）
  </p><p><code class="command">CREATE OR REPLACE FUNCTION</code>を使用して既存の関数を置き換える場合、関数の所有者と権限は変わりません。
他の関数に関するすべての属性には、そのコマンドで指定された値、または暗黙的な値が設定されます。
関数を置き換えるためにはその関数を所有していなければなりません。
（これには所有するロールのメンバであることが含まれています。）
  </p><p>関数を削除し再作成した場合、新しい関数は古いものと同じ実体にはなりません。
古い関数を参照する、既存のルール、ビュー、トリガなどを削除しなければならないでしょう。
関数を参照するオブジェクトを破壊せずに関数定義を変更するには、<code class="command">CREATE OR REPLACE FUNCTION</code>を使用してください。
また、<code class="command">ALTER FUNCTION</code>を使用して、既存の関数の補助属性のほとんどを変更することができます。
  </p><p>関数を作成したユーザが、その関数の所有者となります。
  </p><p>関数を作成するためには、引数の型および戻り値の型に対する<code class="literal">USAGE</code>権限を持たなければなりません。
  </p></div><div class="refsect1" id="id-1.9.3.64.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>作成する関数の名前です（スキーマ修飾名も可）。
      </p></dd><dt><span class="term"><em class="replaceable"><code>argmode</code></em></span></dt><dd><p>引数のモードで、<code class="literal">IN</code>、<code class="literal">OUT</code>、<code class="literal">INOUT</code>、<code class="literal">VARIADIC</code>のいずれかです。
省略時のデフォルトは<code class="literal">IN</code>です。
<code class="literal">OUT</code>引数のみが<code class="literal">VARIADIC</code>の後に続けることができます。
また、<code class="literal">RETURNS TABLE</code>記法では、<code class="literal">OUT</code>と<code class="literal">INOUT</code>引数の両方を使用することはできません。
      </p></dd><dt><span class="term"><em class="replaceable"><code>argname</code></em></span></dt><dd><p>引数の名前です。
（SQLおよびPL/pgSQLを含む）言語の中にはこの名前を関数本体で使用できるものもあります。
他の言語では、関数そのものに注目する限り、入力引数の名前は単なる追加ドキュメントとして扱われます。
しかし関数呼び出し時に入力引数の名前を使用することで可読性を高めることができます。
（<a class="xref" href="sql-syntax-calling-funcs.html" title="4.3. 関数呼び出し">Section 4.3</a>参照）
どのような場合であっても、出力引数の名前は、結果の行型の列名となりますので重要です。
（出力引数の名前を省略した場合、システムはデフォルトの列名を付与します。）
      </p></dd><dt><span class="term"><em class="replaceable"><code>argtype</code></em></span></dt><dd><p>関数の引数のデータ型です（スキーマ修飾名も可）。
基本データ型、複合データ型、ドメイン型、または、テーブル列の型の参照を使用することができます。
      </p><p>また、実装する言語に依存しますが、<code class="type">cstring</code>といった<span class="quote">“<span class="quote">疑似型</span>”</span>を指定できる場合もあります。
疑似型は、実引数の型の指定が不完全である、もしくは、通常のSQLデータ型の集合を越えていることを示します。
      </p><p>列の型を参照するには、<code class="literal"><em class="replaceable"><code>table_name</code></em>.<em class="replaceable"><code>column_name</code></em>%TYPE</code>と記述します。
これを使用すると、テーブル定義が変更されても関数が影響を受けないようにするのに役に立つことがあります。
      </p></dd><dt><span class="term"><em class="replaceable"><code>default_expr</code></em></span></dt><dd><p>パラメータが指定されなかった場合のデフォルト値として使用される式です。
この式はパラメータの引数型と変換可能でなければなりません。
入力パラメータ（<code class="literal">INOUT</code>を含みます）のみがデフォルト値を持つことができます。
デフォルト値を持つパラメータの後ろにあるパラメータはすべて、同様にデフォルト値を持たなければなりません。
      </p></dd><dt><span class="term"><em class="replaceable"><code>rettype</code></em></span></dt><dd><p>関数が返すデータの型です（スキーマ修飾名も可）。
基本型、複合型、ドメイン型、または、テーブル列の型の参照を設定することができます。
また、実装している言語によりますが、<code class="type">cstring</code>のような<span class="quote">“<span class="quote">疑似型</span>”</span>も指定することが可能です。
その関数が値を返すことを想定していない場合は、戻り値として<code class="type">void</code>を指定してください。
      </p><p><code class="literal">OUT</code>もしくは<code class="literal">INOUT</code>パラメータが存在する場合、<code class="literal">RETURNS</code>句を省略することができます。
省略しない場合は、出力用パラメータが意味する結果型に従ったもの、つまり、複数の出力用パラメータがあれば<code class="literal">RECORD</code>、単一の出力用パラメータであればそれと同じ型、でなければなりません。
      </p><p><code class="literal">SETOF</code>修飾子は、その関数が、1つではなく複数のアイテムの集合を返すことを示します。
      </p><p>列の型は、<code class="literal"><em class="replaceable"><code>table_name</code></em>.<em class="replaceable"><code>column_name</code></em>%TYPE</code>と記述することで参照されます。
      </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p><code class="literal">RETURNS TABLE</code>構文における出力列の名前です。
これは実際名前付けされた<code class="literal">OUT</code>パラメータを宣言する別の方法ですが、<code class="literal">RETURNS TABLE</code>が<code class="literal">RETURNS SETOF</code>をも意味する点が異なります。
      </p></dd><dt><span class="term"><em class="replaceable"><code>column_type</code></em></span></dt><dd><p><code class="literal">RETURNS TABLE</code>構文における出力列のデータ型です。
      </p></dd><dt><span class="term"><em class="replaceable"><code>lang_name</code></em></span></dt><dd><p>関数を実装している言語の名前です。
このパラメータには、<code class="literal">sql</code>、<code class="literal">c</code>、<code class="literal">internal</code>、もしくはユーザ定義手続き言語(例：<code class="literal">plpgsql</code>)の名前を指定可能です。
名前を単一引用符で囲むのは廃止予定で、大文字小文字の一致が必要になります。
      </p></dd><dt><span class="term"><code class="literal">TRANSFORM { FOR TYPE <em class="replaceable"><code>type_name</code></em> } [, ... ] }</code></span></dt><dd><p>関数呼び出しにどの変換を適用すべきかのリストです。
変換はSQLの型と言語独自のデータ型の間の変換を行います（<a class="xref" href="sql-createtransform.html" title="CREATE TRANSFORM"><span class="refentrytitle">CREATE TRANSFORM</span></a>を参照）。
手続言語の実装では、通常、ビルトインの型についてハードコードされた知識があるので、それらをこのリストに含める必要はありません。
手続言語の実装が型の処理について定めておらず、変換が提供されない場合は、データ型変換のデフォルトの動作によることになりますが、これは実装に依存します。
      </p></dd><dt><span class="term"><code class="literal">WINDOW</code></span></dt><dd><p><code class="literal">WINDOW</code>は、この関数が普通の関数ではなく<em class="firstterm">ウィンドウ関数</em>であることを示します。
現在これはC言語で作成した関数のみに使用することができます。
既存の関数定義を置き換える場合、<code class="literal">WINDOW</code>属性を変更することはできません。
      </p></dd><dt><span class="term"><code class="literal">IMMUTABLE</code><br /></span><span class="term"><code class="literal">STABLE</code><br /></span><span class="term"><code class="literal">VOLATILE</code></span></dt><dd><p>これらの属性は、関数の動作に関する情報を問い合わせオプティマイザに提供します。
いずれか1つのキーワードのみ指定できます。
指定がない場合は、デフォルトで<code class="literal">VOLATILE</code>と解釈されます。
      </p><p><code class="literal">IMMUTABLE</code>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合に常に同じ結果を返すことを示します。
つまり、データベースを検索したり、引数リスト中に直接存在しない情報を使用したりしないということです。
このオプションが指定された場合、引数が全て定数である関数呼び出しは、即座に関数値と置き換えることができます。
      </p><p><code class="literal">STABLE</code>は、関数がデータベースに対する変更を行わないこと、および、その関数に同じ引数値を与えた場合、常に同じ結果を返すが、SQL文が異なると結果が変わってしまう可能性があることを示します。
これは、データベース検索や（現在の時間帯のような）パラメータ変数などに結果が依存する関数に適します。
(これは現在のコマンドで変更された行を問い合わせたい<code class="literal">AFTER</code>トリガには不適切です。)
また、<code class="function">current_timestamp</code>系の関数は、1つのトランザクション内では値が変化しないため、STABLEであることに注意してください。
      </p><p><code class="literal">VOLATILE</code>は、1つのテーブルスキャン内でも関数の値が変化する可能性があるため、最適化できないことを示します。
このような意味で変動的（volatile）なデータベース関数は、比較的少数です。
例えば、<code class="literal">random()</code>、<code class="literal">currval()</code>、<code class="literal">timeofday()</code>などは変動的な関数です。
しかし、例えば<code class="literal">setval()</code>などの副作用がある関数は、その結果を完全に予測できるとしても、呼び出しを最適化しないよう、<code class="literal">VOLATILE</code>（変動的）に分類する必要があることに注意してください。
      </p><p>詳細は<a class="xref" href="xfunc-volatility.html" title="37.6. 関数の変動性分類">Section 37.6</a>を参照してください。
      </p></dd><dt><span class="term"><code class="literal">LEAKPROOF</code></span></dt><dd><p><code class="literal">LEAKPROOF</code>は、関数が副作用を持たないことを示します。
その引数に関する情報を戻り値以外で漏らしません。
例えば、一部の引数値に対してのみエラーメッセージを返す関数や何らかのエラーメッセージの中に引数の値を含める関数は漏洩防止(leakproof)とはいえません。
これは<code class="literal">security_barrier</code>オプション付きで作成されたビュー、あるいは行単位セキュリティが有効にされたテーブルに対して、システムが問い合わせを実行する方法に影響します。
データが偶然に露見することを防ぐため、システムは、漏洩防止でない関数を含む問い合わせのユーザが提供した条件より前に、セキュリティポリシーおよびセキュリティバリアビューの条件を強制します。
漏洩防止であるとされた関数および演算子は信頼できると見なされ、セキュリティポリシーおよびセキュリティバリアビューによる条件より先に実行されることがあります。
なお、引数を取らない、あるいはセキュリティバリアビューやテーブルから引数を渡されない関数は、セキュリティ条件より前に実行するために漏洩防止とする必要はありません。
<a class="xref" href="sql-createview.html" title="CREATE VIEW"><span class="refentrytitle">CREATE VIEW</span></a>および<a class="xref" href="rules-privileges.html" title="40.5. ルールと権限">Section 40.5</a>を参照してください。
このオプションはスーパーユーザによってのみ設定することができます。
      </p></dd><dt><span class="term"><code class="literal">CALLED ON NULL INPUT</code><br /></span><span class="term"><code class="literal">RETURNS NULL ON NULL INPUT</code><br /></span><span class="term"><code class="literal">STRICT</code></span></dt><dd><p><code class="literal">CALLED ON NULL INPUT</code>（デフォルト）を指定すると、引数にNULLが含まれていても、関数が通常通り呼び出されます。
その場合は、必要に応じてNULL値を確認し、適切な対応をすることは関数作成者の責任です。
      </p><p><code class="literal">RETURNS NULL ON NULL INPUT</code>もしくは<code class="literal">STRICT</code>を指定すると、関数の引数に1つでもNULLがある場合、常にNULLを返します。
このパラメータが指定されると、NULL引数がある場合、関数は実行されません。
代わりに、NULLという結果が自動的に与えられます。
      </p></dd><dt><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY INVOKER</code><br /></span><span class="term"><code class="literal">[<span class="optional">EXTERNAL</span>] SECURITY DEFINER</code></span></dt><dd><p><code class="literal">SECURITY INVOKER</code>を指定すると、関数を呼び出したユーザの権限で、その関数が実行されます。
これがデフォルトです。
<code class="literal">SECURITY DEFINER</code>を指定すると、関数を所有するユーザの権限で、その関数が実行されます。
     </p><p><code class="literal">EXTERNAL</code>キーワードは、SQLとの互換性を保つために許されています。
しかし、SQLとは異なり、この機能は外部関数だけではなくすべての関数に適用されるため、このキーワードは省略可能です。
     </p></dd><dt><span class="term"><code class="literal">PARALLEL</code></span></dt><dd><p><code class="literal">PARALLEL UNSAFE</code>は、その関数が並列モードでは実行できないこと、そしてそのような関数がSQL文の中にある場合は順次の実行プランが強制されることを意味します。
これがデフォルトです。
<code class="literal">PARALLEL RESTRICTED</code>はその関数が並列モードで実行できますが、その実行は並列グループのリーダーに制限されることを意味します。
<code class="literal">PARALLEL SAFE</code>はその関数が並列モードで制限なく実行することについて安全であることを意味します。
     </p><p>関数がデータベースの状態に何らかの変更を行う、サブトランザクションを使うなどトランザクションを変更する、シーケンスにアクセスするか設定に恒久的な変更をする（例えば<code class="literal">setval</code>）という場合はparallel unsafe（並列は安全でない）という印をつけるべきです。
一時テーブル、クライアントの接続状態、カーソル、プリペアド文、その他並列モードでシステムが同期できない様々なバックエンド独自の状態に関数がアクセスする場合、parallel restricted（並列は制限される）という印をつけるべきです（例えば、<code class="literal">setseed</code>はグループのリーダー以外では実行できません。なぜなら他のプロセスでなされた変更がリーダーに反映されないからです）。
一般的に、restrictedあるいはunsafeな関数がsafeとラベル付けされた場合、あるいはunsafeな関数がrestrictedとラベル付けされた場合、それがパラレルクエリ内で使用されると、エラーが発生したり、誤った結果が生成されたりします。
C言語の関数は、ラベルが間違っていると、理論的には全く予想できない動作をすることがあります。
これは任意のCプログラムに対してシステムが自分を保護する手段がないからですが、多くの場合、その結果は他の関数と同程度の悪さでしょう。
よくわからない場合は、デフォルトの<code class="literal">UNSAFE</code>で関数にラベル付けしてください。
     </p></dd><dt><span class="term"><em class="replaceable"><code>execution_cost</code></em></span></dt><dd><p>この関数の推定実行コストを表す正数で、単位は<a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>です。
関数が集合を返す場合、これは1行当たりのコストとなります。
このコストが指定されない場合、C言語および内部関数では1、他のすべての言語では100となります。
値をより大きくすると、プランナは必要以上に頻繁に関数を評価しないようになります。
      </p></dd><dt><span class="term"><em class="replaceable"><code>result_rows</code></em></span></dt><dd><p>プランナが想定する、この関数が返す行数の推定値を表す正数です。
これは、関数が集合を返すものと宣言された場合のみ使用可能です。
デフォルト推定値は1000行です。
      </p></dd><dt><span class="term"><em class="replaceable"><code>configuration_parameter</code></em><br /></span><span class="term"><em class="replaceable"><code>value</code></em></span></dt><dd><p><code class="literal">SET</code>句により、関数が始まった時に指定した設定パラメータを指定した値に設定し、関数の終了時にそれを以前の値に戻すことができます。
<code class="literal">SET FROM CURRENT</code>は、<code class="command">CREATE FUNCTION</code>の実行時点でのパラメータ値を、関数に入る時に適用する値として保管します。
      </p><p>関数に<code class="literal">SET</code>句が付いている場合、関数内部で実行される<code class="command">SET LOCAL</code>コマンドの同一変数に対する効果はその関数に制限されます。
つまり、設定パラメータの前の値は関数が終了する時に元に戻ります。
しかし、通常の（<code class="literal">LOCAL</code>がない）<code class="command">SET</code>コマンドは<code class="literal">SET</code>句を上書きします。
これは過去に行われた<code class="command">SET LOCAL</code>コマンドに対してもほぼ同じです。
つまり、このコマンドの効果は、現在のトランザクションがロールバックされない限り、関数が終了した後も永続化されます。
      </p><p>使用可能なパラメータと値については、<a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a>および<a class="xref" href="runtime-config.html" title="Chapter 19. サーバの設定">Chapter 19</a>を参照してください。

      </p></dd><dt><span class="term"><em class="replaceable"><code>definition</code></em></span></dt><dd><p>関数を定義する文字列定数です。
このパラメータの意味は言語に依存します。
内部的な関数名、オブジェクトファイルへのパス、SQLコマンド、手続き言語で記述されたテキストなどを指定できます。
      </p><p>関数を定義する文字列を記述する際に、通常の単一引用符ではなく、ドル引用符（<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-DOLLAR-QUOTING" title="4.1.2.4. ドル記号で引用符付けされた文字列定数">Section 4.1.2.4</a>参照）を使用すると便利なことが多くあります。
ドル引用符を使用しなければ、関数定義内の単一引用符やバックスラッシュは必ず二重にしてエスケープしなければなりません。
      </p></dd><dt><span class="term"><code class="literal"><em class="replaceable"><code>obj_file</code></em>, <em class="replaceable"><code>link_symbol</code></em></code></span></dt><dd><p>この構文の<code class="literal">AS</code>句は、動的にロードされるC言語関数において、C言語のソースコード中の関数名がSQL関数の名前と同じでない場合に使われます。
<em class="replaceable"><code>obj_file</code></em>という文字列はコンパイルされたC関数を含む共有ライブラリファイルの名前で、<a class="xref" href="sql-load.html" title="LOAD"><span class="refentrytitle">LOAD</span></a>コマンドの場合と同じように解釈されます。
文字列<em class="replaceable"><code>link_symbol</code></em>はその関数のリンクシンボル、つまり、C言語ソースコード中の関数の名前です。
リンクシンボルが省略された場合、定義されるSQL関数の名前と同じものであるとみなされます。
      </p><p>同一オブジェクトファイルを参照する、<code class="command">CREATE FUNCTION</code>呼び出しが繰り返された場合、そのファイルはセッション毎に一度だけロードされます。
（おそらく開発段階で）ファイルをアンロードし再ロードするには、新しいセッションを開始してください。
      </p></dd><dt><span class="term"><em class="replaceable"><code>attribute</code></em></span></dt><dd><p>関数に関するオプション情報を指定する伝統的な方法です。
ここで指定できる属性を以下に示します。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">isStrict</code></span></dt><dd><p><code class="literal">STRICT</code>または<code class="literal">RETURNS NULL ON NULL INPUT</code>と同じです。
         </p></dd><dt><span class="term"><code class="literal">isCachable</code></span></dt><dd><p><code class="literal">isCachable</code>は、<code class="literal">IMMUTABLE</code>と同じですが、既に廃止されています。
しかし、後方互換性を保持するため、まだ有効とされています。
         </p></dd></dl></div><p>

属性名では、大文字小文字を区別しません。
     </p></dd></dl></div><p>さらに詳しい関数の作成方法については<a class="xref" href="xfunc.html" title="37.3. ユーザ定義関数">Section 37.3</a>を参照してください。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-OVERLOADING"><h2>オーバーロード</h2><p><span class="productname">PostgreSQL</span>では関数の<em class="firstterm">オーバーロード</em>が可能です。
つまり、入力引数の型が異なっていれば、複数の関数に同じ名前を使用することができます。
しかし、全ての関数について、C言語における名前は、重複してはいけません。
したがって、オーバーロードするC言語関数には、異なるC言語の名前を与える必要があります
（例えば、C言語における名前の一部に引数の型を使用してください）。
   </p><p>同じ名前、同じ<span class="emphasis"><em>入力用</em></span>パラメータ型を持つ場合、2つの関数は同一であるとみなされます。
<code class="literal">OUT</code>パラメータは無視されます。
したがって、例えば以下の宣言は競合しています。
</p><pre class="programlisting">CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, out text) ...</pre><p>
   </p><p>異なる引数型のリストを持つ関数は、作成時に競合するとはみなされませんが、デフォルト値が指定された場合使用時に競合する可能性があります。
例えば以下を考えてみましょう。
</p><pre class="programlisting">CREATE FUNCTION foo(int) ...
CREATE FUNCTION foo(int, int default 42) ...</pre><p>
<code class="literal">foo(10)</code>という呼び出しは、どちらの関数を呼び出すべきかに関して曖昧さがあるために失敗します。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-NOTES"><h2>注釈</h2><p>関数の引数と戻り値の宣言において、完全な<acronym class="acronym">SQL</acronym>型の構文が使用できます。
しかし、括弧付けされた型修飾子（例えば<code class="type">numeric</code>型の精度フィールド）は、<code class="command">CREATE FUNCTION</code>により破棄されます。
従って、<code class="literal">CREATE FUNCTION foo (varchar(10)) ...</code>は<code class="literal">CREATE FUNCTION foo (varchar) ...</code>とまったく同じになります。
   </p><p>既存の関数を<code class="command">CREATE OR REPLACE FUNCTION</code>を使って置き換える場合、パラメータ名の変更に関して制限があります。
すでに何らかの入力パラメータに割り当てられた名前を変更することはできません。
（しかし、これまで名前を持たなかったパラメータに名前を追加することは可能です。）
複数の出力パラメータが存在する場合、関数の結果を表わす無名複合型の列名を変更することになるため、出力パラメータの名前を変更することはできません。
既存の関数呼び出しが置き換わった時に動作しなくなることを確実に防ぐために、これらの制限がなされています。
   </p><p>関数が<code class="literal">VARIADIC</code>引数を持つ<code class="literal">STRICT</code>と宣言された場合、その厳密性検査では、variadic配列<span class="emphasis"><em>全体</em></span>が非NULLかどうかを検査します。
配列がNULL要素を持っていたとしても関数は呼び出されます。
   </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-EXAMPLES"><h2>例</h2><p>ここでは、初心者向けの簡単な例をいくつか示します。
<a class="xref" href="xfunc.html" title="37.3. ユーザ定義関数">Section 37.3</a>には、より多くの情報と例が記載されています。
</p><pre class="programlisting">CREATE FUNCTION add(integer, integer) RETURNS integer
    AS 'select $1 + $2;'
    LANGUAGE SQL
    IMMUTABLE
    RETURNS NULL ON NULL INPUT;</pre><p>
  </p><p><span class="application">PL/pgSQL</span>で、引数名を使用して、整数を1増やします。

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;</pre><p>
  </p><p>複数の出力用パラメータを持つレコードを返します。
</p><pre class="programlisting">CREATE FUNCTION dup(in int, out f1 int, out f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p>
上と同じことを、明示的な名前が付いた複合型を使用して、より冗長に行うことができます。
</p><pre class="programlisting">CREATE TYPE dup_result AS (f1 int, f2 text);

CREATE FUNCTION dup(int) RETURNS dup_result
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p>
複数列を返す別の方法は、<code class="literal">TABLE</code>関数を使用することです。
</p><pre class="programlisting">CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)
    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$
    LANGUAGE SQL;

SELECT * FROM dup(42);</pre><p>
しかし、これは実際には、1つのレコードではなく、レコードの<span class="emphasis"><em>集合</em></span>を返しますので、<code class="literal">TABLE</code>関数は上の例とは異なります。

  </p></div><div class="refsect1" id="SQL-CREATEFUNCTION-SECURITY"><h2><code class="literal">SECURITY DEFINER</code>関数の安全な作成</h2><a id="id-1.9.3.64.10.2" class="indexterm"></a><p><code class="literal">SECURITY DEFINER</code>関数は関数を所有するユーザの権限で実行されますので、その関数を間違って使用できないことを確実にしなければなりません。
安全上、<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>は、信頼できないユーザが書き込み可能なスキーマを除去した形で設定すべきです。
これは、悪意のあるユーザがその関数で使用されるオブジェクトを隠すようなオブジェクト（例えば、テーブル、関数、演算子など）を作成することを防ぎます。
ここで特に重要なことは、一時テーブルスキーマです。
このスキーマはデフォルトで最初に検索され、そして、通常誰でも書き込み可能です。
一時スキーマの検索を強制的に最後にすることで、セキュリティを調整できます。
このためには、<code class="literal">pg_temp</code>を<code class="varname">search_path</code>の最後の項目として記載してください。
<a id="id-1.9.3.64.10.3.5" class="indexterm"></a>
安全な使用方法を以下の関数で示します。

</p><pre class="programlisting">CREATE FUNCTION check_password(uname TEXT, pass TEXT)
RETURNS BOOLEAN AS $$
DECLARE passed BOOLEAN;
BEGIN
        SELECT  (pwd = $2) INTO passed
        FROM    pwds
        WHERE   username = $1;

        RETURN passed;
END;
$$  LANGUAGE plpgsql
    SECURITY DEFINER
    -- 信頼できるスキーマ、その後にpg_tempという順でsearch_pathを安全に設定します。
    SET search_path = admin, pg_temp;</pre><p>

この関数の意図は、テーブル<code class="literal">admin.pwds</code>にアクセスすることです。
しかし<code class="literal">SET</code>句がなければ、あるいは<code class="literal">SET</code>句が<code class="literal">admin</code>だけしか記述していなければ、<code class="literal">pwds</code>という名前の一時テーブルを作成することで、この関数は無意味になってしまいます。
   </p><p><span class="productname">PostgreSQL</span>バージョン8.3より前では、<code class="literal">SET</code>句は利用できません。
このため古い関数には、<code class="varname">search_path</code>を保管し、設定、そして元に戻すという、多少複雑なロジックが含まれているかもしれません。
こうした目的に<code class="literal">SET</code>句を使用すると、かなり簡単になります。
   </p><p>この他に注意すべき点として、新しく作成された関数ではデフォルトで実行権限が<code class="literal">PUBLIC</code>に付与されていることがあります。
（詳細は<a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>を参照してください。）
SECURITY DEFINER関数の使用を一部のユーザのみに制限したいことはよくあります。
このためには、デフォルトの<code class="literal">PUBLIC</code>権限を取り消し、そして、実行権限の付与を選択して行ってください。
新しい関数がすべてのユーザに実行可能となる隙間が存在することを防ぐためには、単一トランザクション内で作成と権限設定を行ってください。
以下に例を示します。
   </p><pre class="programlisting">BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;</pre></div><div class="refsect1" id="SQL-CREATEFUNCTION-COMPAT"><h2>互換性</h2><p><code class="command">CREATE FUNCTION</code>コマンドはSQL:1999以降で定義されています。
<span class="application">PostgreSQL</span>における<code class="command">CREATE FUNCTION</code>も類似の機能を持ちますが、完全な互換性はありません。
属性には移植性がありません。また、使用可能な言語も異なります。
  </p><p>他のデータベースシステムとの互換性のために、<em class="replaceable"><code>argmode</code></em>は<em class="replaceable"><code>argname</code></em>の前に書くことも後に書くこともできます。
しかし、1つ目の方法が標準に従っています。
  </p><p>パラメータのデフォルトに関しては、標準SQLでは<code class="literal">DEFAULT</code>キーワードの構文のみを規定します。
<code class="literal">=</code>を持つ構文はT-SQLおよびFirebirdで使用されています。
  </p></div><div class="refsect1" id="id-1.9.3.64.12"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-alterfunction.html" title="ALTER FUNCTION"><span class="refentrytitle">ALTER FUNCTION</span></a>, <a class="xref" href="sql-dropfunction.html" title="DROP FUNCTION"><span class="refentrytitle">DROP FUNCTION</span></a>, <a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>, <a class="xref" href="sql-load.html" title="LOAD"><span class="refentrytitle">LOAD</span></a>, <a class="xref" href="sql-revoke.html" title="REVOKE"><span class="refentrytitle">REVOKE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createforeigntable.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-creategroup.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE FOREIGN TABLE </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE GROUP</td></tr></table></div></body></html>