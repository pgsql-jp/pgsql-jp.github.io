<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>56.4. 外部データラッパのクエリプラン作成</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fdw-helpers.html" title="56.3. 外部データラッパヘルパ関数" /><link rel="next" href="fdw-row-locking.html" title="56.5. 外部データラッパでの行ロック" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">56.4. 外部データラッパのクエリプラン作成</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-helpers.html" title="56.3. 外部データラッパヘルパ関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="Chapter 56. 外部データラッパの作成">Up</a></td><th width="60%" align="center">Chapter 56. 外部データラッパの作成</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="fdw-row-locking.html" title="56.5. 外部データラッパでの行ロック">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="FDW-PLANNING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">56.4. 外部データラッパのクエリプラン作成</h2></div></div></div><p>FDWコールバック関数の<code class="function">GetForeignRelSize</code>、<code class="function">GetForeignPaths</code>、<code class="function">GetForeignPlan</code>、<code class="function">PlanForeignModify</code>、<code class="function">GetForeignJoinPaths</code>、<code class="function">GetForeignUpperPaths</code>、<code class="function">PlanDirectModify</code>は<span class="productname">PostgreSQL</span>プランナの動作と協調しなければなりません。ここでは、これらの関数がすべき事に関するいくつかの注意事項を述べます。
    </p><p><code class="literal">root</code>と<code class="literal">baserel</code>に含まれる情報は、外部テーブルから取得する必要のある情報の量(とそれによるコスト)を削減するために使用できます。
<code class="literal">baserel-&gt;baserestrictinfo</code>は、取得される行をフィルタリングする検索条件(<code class="literal">WHERE</code>句)を含んでいるため、特に興味深いものです。(コアのエグゼキュータが代わりにそれらをチェックできるので、FDW自身がこれらの制約を適用しなければならないわけではありません。)
<code class="literal">baserel-&gt;reltarget-&gt;exprs</code>はどの列が取得される必要があるかを決定するのに使用できます。ただし、このリストは<code class="structname">ForeignScan</code>プランノードから出力すべき列しか含んでおらず、条件検査には必要だがクエリからは出力されない列は含まないことに注意してください。
    </p><p>様々なプライベートフィールドがFDWのプラン作成関数で情報を格納する目的で利用できます。
一般的に、プラン作成の最後に回収できるように、FDW固有フィールドに格納するものは全てpallocで確保すべきです。
    </p><p><code class="literal">baserel-&gt;fdw_private</code>は、<code class="type">void</code>ポインタで、FDWのプラン作成関数で特定の外部テーブルに関する情報を格納する目的で利用できます。
コアプランナは、<code class="literal">RelOptInfo</code>ノードが作成されるときにNULLで初期化するときを除いて、このフィールドに一切に触れません。
このフィールドは、<code class="function">GetForeignRelSize</code>から<code class="function">GetForeignPaths</code>や<code class="function">GetForeignPaths</code>から<code class="function">GetForeignPlan</code>といったように情報を順次伝えるの便利で、結果として再計算を省くことができます。
    </p><p><code class="function">GetForeignPaths</code>では、<code class="structname">ForeignPath</code>ノードの<code class="structfield">fdw_private</code>フィールドに固有情報を格納することで、異なるアクセスパスを区別できます。<code class="structfield">fdw_private</code>は<code class="type">List</code>ポインタとして宣言されていますが、コアプランナがこのフィールドを操作することはないため、実際にはなんでも格納できます。
しかし、バックエンドのデバッグサポート機能を利用できるように<code class="function">nodeToString</code>でダンプ出来る形式を使うのが最良の手法です。
    </p><p><code class="function">GetForeignPlan</code>では、選択された<code class="structname">ForeignPath</code>ノードの<code class="structfield">fdw_private</code>フィールドを調べて、<code class="structname">ForeignScan</code>プランノード内に格納されプラン実行時に利用可能な<code class="structfield">fdw_exprs</code>と<code class="structfield">fdw_private</code>の二つのリストを生成することができます。
これらは両方とも<code class="function">copyObject</code>がコピーできる形式でなければなりません。
<code class="structfield">fdw_private</code>リストにはこれ以外に制約はなく、コアバックエンドによって解釈されることはありません。
<code class="structfield">fdw_exprs</code>リストがNILでない場合は、クエリ実行時に実行されることを意図した式ツリーが含まれていることが期待されます。
これらのツリーは、完全に実行可能な状態にするためにプランナによる後処理を受けます。
    </p><p><code class="function">GetForeignPlan</code>では、一般的に渡されたターゲットリストはそのままプランノードにコピーできます。
渡された<code class="literal">scan_clauses</code>リストは<code class="literal">baserel-&gt;baserestrictinfo</code>と同じ句を含みますが、実行効率のよい別の順番に並べ替えることもできます。
FDWにできるのが<code class="structname">RestrictInfo</code>ノードを<code class="literal">scan_clauses</code>リストから(<code class="function">extract_actual_clauses</code>を使って)抜き出して、全ての句をプランノードの条件リストに入れるだけ、といった単純なケースでは、全ての句は実行時にエグゼキュータによってチェックされます。
より複雑なFDWは内部で一部の句をチェックできるかもしれませんが、そのような場合には、エグゼキュータが再チェックのために時間を無駄にしないように、それらの句はプランノードの条件リストから削除できます。
    </p><p>たとえば、ローカル側で評価された<em class="replaceable"><code>sub_expression</code></em>の値があればリモートサーバ側で実行出来るとFDWが判断するような、<em class="replaceable"><code>foreign_variable</code></em> <code class="literal">=</code> <em class="replaceable"><code>sub_expression</code></em>といった形式の条件句をFDWが識別するかもしれません。
パスのコスト見積もりに影響するので、そのような句の実際の識別は<code class="function">GetForeignPaths</code>でなされるべきです。
おそらく、そのパスの<code class="structfield">fdw_private</code>フィールドは識別された句の<code class="structname">RestrictInfo</code>ノードをさすポインタを含むでしょう。
そして、<code class="function">GetForeignPlan</code>はその句を<code class="literal">scan_clauses</code>から取り除き、実行可能な形式にほぐされることを保障するために<em class="replaceable"><code>sub_expression</code></em>を<code class="structfield">fdw_exprs</code>に追加するでしょう。
また、おそらく、実行時に何をすべきかをプラン実行関数に伝えるためにプランノードの<code class="structfield">fdw_private</code>フィールドに制御情報を入れるでしょう。
リモートサーバに送られたクエリは、実行時に<code class="structfield">fdw_exprs</code>式ツリーを評価して得られた値をパラメータ値とする<code class="literal">WHERE <em class="replaceable"><code>foreign_variable</code></em> = $1</code>のようなものを伴うでしょう。
    </p><p><code class="literal">READ COMMITTED</code>分離レベルでの正しい動作を保証するため、プランノードの条件リストから除かれた句はすべて、代わりに<code class="literal">fdw_recheck_quals</code>に追加されるか、<code class="literal">RecheckForeignScan</code>で再検査される必要があります。
問い合わせに含まれる他のテーブルで同時更新があった場合、エグゼキュータはタプルが元の条件を、それも場合によっては異なるパラメータ値の組み合わせに対して満たすことを確認する必要があるかもしれません。
<code class="literal">fdw_recheck_quals</code>を使うのは、<code class="literal">RecheckForeignScan</code>の内部で検査を実装するより、通常は簡単でしょう。
しかしこの方法は、外部結合がプッシュダウンされる場合は不十分です。
なぜなら、この場合の結合タプルはタプル全体を拒絶せずに、一部のフィールドをNULLにしてしまうからです。
    </p><p>FDWがセットできる別の<code class="structname">ForeignScan</code>フィールドに<code class="structfield">fdw_scan_tlist</code>があります。
これはこのプランノードについてFDWが返すタプルを記述するものです。
単純な外部テーブルスキャンに対しては、これを<code class="literal">NIL</code>にセットすることができ、それは戻されるタプルが外部テーブルで宣言された行型を持つことを意味します。
<code class="symbol">NIL</code>でない値はVar型の変数、あるいは返される列を表す式、あるいはその両方を含む対象のリスト（<code class="structname">TargetEntry</code>のリスト）でなければなりません。
これは例えば、FDWが問い合わせのために必要ないと気づいた列を無視したことを示すのに使えるかもしれません。
また、FDWが問い合わせで使われる式をローカルで計算するより安価に計算できるなら、それらの式を<code class="structfield">fdw_scan_tlist</code>に追加することができます。
結合プラン（<code class="function">GetForeignJoinPaths</code>が作るパスから作成される）は、それが返す列の集合を記述する<code class="structfield">fdw_scan_tlist</code>を必ず提供しなければならないことに注意して下さい。
    </p><p>FDWはそのテーブルの条件句のみに依存するパスを常に少なくとも一つは生成すべきです。結合クエリでは、例えば<em class="replaceable"><code>foreign_variable</code></em> <code class="literal">=</code> <em class="replaceable"><code>local_variable</code></em>といった結合句に依存するパス(群)を生成することもできます。
そのような句は<code class="literal">baserel-&gt;baserestrictinfo</code>には見つからず、リレーションの結合リストにあるはずです。
そのような句を使用するパスは<span class="quote">“<span class="quote">パラメータ化されたパス</span>”</span>と呼ばれます。
このようなパスでは、選択された結合句（群）で使用されているリレーション（群）を<code class="literal">param_info</code>の適合する値から特定しなければなりません;その値を計算するには<code class="function">get_baserel_parampathinfo</code>を使用します。
<code class="function">GetForeignPlan</code>では、結合句の<em class="replaceable"><code>local_variable</code></em>部分が<code class="structfield">fdw_exprs</code>に追加され、実行時には通常の条件句と同じように動作します。
    </p><p>FDWがリモートでの結合をサポートする場合、<code class="function">GetForeignPaths</code>がベーステーブルに対して処理するのとほぼ同じように、<code class="function">GetForeignJoinPaths</code>は潜在的なリモートの結合に対して<code class="structname">ForeignPath</code>を生成することになります。
意図した結合に関する情報は、上記と同じ方法で<code class="function">GetForeignPlan</code>に送ることができます。
しかし、<code class="structfield">baserestrictinfo</code>は結合のリレーションには関連がなく、代わりに、特定の結合に関連するJOIN句は<code class="function">GetForeignJoinPaths</code>に別のパラメータ(<code class="literal">extra-&gt;restrictlist</code>)として渡されます。
    </p><p>FDWはグルーピングや集約のような、スキャンや結合のレベルより上位のプラン動作の直接実行を追加的にサポートできるかもしれません。
このような方法を行うには、FDWはパスを生成して、それを適切な<em class="firstterm">上位リレーション</em>に挿入する必要があります。
例えば、リモート集約をあらわすパスは<code class="function">add_path</code>を使って<code class="literal">UPPERREL_GROUP_AGG</code>リレーションに挿入されるべきです。
このパスは外部リレーションに対する単純なスキャンパスを読むことによるローカル集約実行とコストに基づいて比較されます（このようなパスが提供されなければならないことに注意してください、さもないとプラン時にエラーになります）。
リモート集約パスが、通常そうなりますが、勝った場合には、パスは<code class="function">GetForeignPlan</code>を呼ぶ通常の手段でプランに変換されます。
もし問い合わせの全てのベースリレーションが同じFDWから来るなら、このようなパスを生成するのに推奨される場所は、各上位リレーション（すなわち各スキャン/結合後の処理の段階）に対して呼び出される<code class="function">GetForeignUpperPaths</code>コールバック関数の中です。
    </p><p><code class="function">PlanForeignModify</code>と<a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-UPDATE" title="56.2.4. 外部テーブル更新のためのFDWルーチン">Section 56.2.4</a>で記述された他のコールバックは、外部リレーションは通常の方法でスキャンされ、それから個別の行変更がローカルの<code class="literal">ModifyTable</code>プランノードで駆動されるという想定をもとに設計されています。
この方法は変更が外部テーブルと同様にローカルテーブルを読む必要がある一般的な場合に必要です。
しかしながら、操作が全体的に外部サーバで実行できるなら、FDWはそのようにするパスを生成して<code class="literal">UPPERREL_FINAL</code>上位リレーションに挿入することができます。ここでは<code class="literal">ModifyTable</code>方式に対して競合します。
この方式は、<a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="56.2.5. 行ロックのためのFDWルーチン">Section 56.2.5</a>で記述された行ロックコールバックを使うのでなしに、リモート<code class="literal">SELECT FOR UPDATE</code>を実装するのにも使われます。
<code class="literal">UPPERREL_FINAL</code>に挿入されたパスは問い合わせの<span class="emphasis"><em>全ての</em></span>振る舞いの実装に責任があることに留意してください。
    </p><p><code class="command">UPDATE</code>や<code class="command">DELETE</code>のプランを生成しているとき、
<code class="function">PlanForeignModify</code>と<code class="function">PlanDirectModify</code>は、事前にスキャンプラン生成関数で作られた<code class="literal">baserel-&gt;fdw_private</code>データを使うために、その外部テーブルのための<code class="structname">RelOptInfo</code>構造体を検索することができます。
しかしながら、<code class="command">INSERT</code>では対象テーブルはスキャンされないので対応する<code class="structname">RelOptInfo</code>は存在しません。
<code class="function">PlanForeignModify</code>から返される<code class="structname">List</code>には、<code class="structname">ForeignScan</code>プランノードの<code class="structfield">fdw_private</code>リストと同様に、<code class="function">copyObject</code>がコピーの仕方を知っている構造体しか保持してはいけないという制約があります。
    </p><p><code class="literal">ON CONFLICT</code>句のある<code class="command">INSERT</code>は競合の対象の指定をサポートしません。
なぜなら、リモートのテーブルの一意制約や排他制約についての情報がローカルにはないからです。
これは結果的に<code class="literal">ON CONFLICT DO UPDATE</code>がサポートされないことを意味します。
なぜなら、競合の対象の指定が必須だからです。
    </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-helpers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="fdw-row-locking.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">56.3. 外部データラッパヘルパ関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 56.5. 外部データラッパでの行ロック</td></tr></table></div></body></html>