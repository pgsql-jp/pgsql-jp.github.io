<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>40.4. INSERT、UPDATE、DELETEについてのルール</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="rules-materializedviews.html" title="40.3. マテリアライズドビュー" /><link rel="next" href="rules-privileges.html" title="40.5. ルールと権限" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">40.4. <code xmlns="http://www.w3.org/1999/xhtml" class="command">INSERT</code>、<code xmlns="http://www.w3.org/1999/xhtml" class="command">UPDATE</code>、<code xmlns="http://www.w3.org/1999/xhtml" class="command">DELETE</code>についてのルール</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules-materializedviews.html" title="40.3. マテリアライズドビュー">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="Chapter 40. ルールシステム">Up</a></td><th width="60%" align="center">Chapter 40. ルールシステム</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-privileges.html" title="40.5. ルールと権限">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="RULES-UPDATE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">40.4. <code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>についてのルール</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="rules-update.html#id-1.8.6.9.7">40.4.1. 更新ルールの動作</a></span></dt><dt><span class="sect2"><a href="rules-update.html#RULES-UPDATE-VIEWS">40.4.2. ビューとの協調</a></span></dt></dl></div><a id="id-1.8.6.9.2" class="indexterm"></a><a id="id-1.8.6.9.3" class="indexterm"></a><a id="id-1.8.6.9.4" class="indexterm"></a><p><code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>に定義するルールは前節で解説したビューのルールとはまったく異なります。
第一点として、これらの<code class="command">CREATE RULE</code>コマンドでは以下を行うことができます。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>アクションがないルールも可能です。
        </p></li><li class="listitem"><p>複数のアクションを持てます。
        </p></li><li class="listitem"><p><code class="literal">INSTEAD</code>もしくは<code class="literal">ALSO</code>（デフォルト）を取ることができます。
        </p></li><li class="listitem"><p>疑似リレーション<code class="literal">NEW</code>と<code class="literal">OLD</code>が役立つようになります。
        </p></li><li class="listitem"><p>ルール条件を持たせることができます。
        </p></li></ul></div><p>

第二点として、その場で問い合わせツリーを変更しません。
その代わりに新規の0個以上の問い合わせツリーを生成して、オリジナルを破棄することができます。</p><div class="caution"><h3 class="title">Caution</h3><p>多くの場合、<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>におけるルールによって実行できるタスクは、トリガーで実行した方が良いでしょう。
トリガーは概念としては少し複雑ですが、意味を理解するにはとても単純です。
元の問い合わせにvolatile関数を含む場合、ルールは驚かせる結果を返すことがよくあります。（volatile関数はルールを遂行する過程で予期していた回数よりより多く実行されてしまうかもしれません）

 </p><p>また、これらのタイプのルールが全くサポートしない場合もあります。
特に<code class="literal">WITH</code>句を元の問い合わせに含む場合と<code class="command">UPDATE</code>問い合わせの<code class="literal">SET</code>リストの中で複数列に代入するサブ<code class="literal">SELECT</code>の場合です。
これはルール問い合わせにこれらの構造を複製すると副問い合わせを複数回評価し、問い合わせの作者が表現したかった意図と異なる結果となるためです。
 </p></div><div class="sect2" id="id-1.8.6.9.7"><div class="titlepage"><div><div><h3 class="title">40.4.1. 更新ルールの動作</h3></div></div></div><p>
</p><pre class="programlisting">CREATE [ OR REPLACE ] RULE <em class="replaceable"><code>name</code></em> AS ON <em class="replaceable"><code>event</code></em>
    TO <em class="replaceable"><code>table</code></em> [ WHERE <em class="replaceable"><code>condition</code></em> ]
    DO [ ALSO | INSTEAD ] { NOTHING | <em class="replaceable"><code>command</code></em> | ( <em class="replaceable"><code>command</code></em> ; <em class="replaceable"><code>command</code></em> ... ) }</pre><p>

上記の構文を覚えておいてください。
以下では、<em class="firstterm">更新ルール</em>は<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>に定義されたルールを意味します。</p><p>更新ルールは、問い合わせツリーの結果リレーションとコマンド種類が<code class="command">CREATE RULE</code>で与えられるオブジェクトとイベントと等しい場合にルールシステムによって適用されます。
更新ルールに対してルールシステムは問い合わせツリーのリストを生成します。
最初は問い合わせツリーリストは空です。
0（<code class="literal">NOTHING</code>キーワード）、1つまたは複数のアクションが有効です。
簡単にするため、ここでは1つのアクションのルールを取り上げます。
このルールは条件を持っていても持っていなくても構いませんし、また<code class="literal">INSTEAD</code>か<code class="literal">ALSO</code>（デフォルト）のいずれかを取ることができます。</p><p>ルール条件とはどんなものでしょうか。
それはルールのアクションを行わなければならない時と、行ってはならない時を指定する条件です。
基本的に（特別な意味合いを持った）オブジェクトとして与えられるリレーションである<code class="literal">NEW</code>疑似リレーションか<code class="literal">OLD</code>疑似リレーション、または、その両者のみをこの条件は参照することができます。</p><p>1アクションのルールに対し、以下の問い合わせツリーを生成する3つの場合があります。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ALSO</code>または<code class="literal">INSTEAD</code>で条件がない場合。</span></dt><dd><p>元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリー
       </p></dd><dt><span class="term">条件付き、かつ<code class="literal">ALSO</code></span></dt><dd><p>ルール条件と元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリー
       </p></dd><dt><span class="term">条件付き、かつ<code class="literal">INSTEAD</code></span></dt><dd><p>ルール条件と元の問い合わせツリーの条件が追加された、ルールアクションからの問い合わせツリーとルール条件の否定条件が追加された元の問い合わせツリー
       </p></dd></dl></div><p>

最後に、もしルールが<code class="literal">ALSO</code>の場合、変更されていない元の問い合わせツリーがリストに付け加えられます。
条件付きの<code class="literal">INSTEAD</code>ルールのみが既に元の構文解析ツリーに追加をしているので、最後は1つのアクションを持つルールに対して1つもしくは2つの問い合わせツリーにたどり着きます。</p><p> 
<code class="literal">ON INSERT</code>ルールでは、元の問い合わせは、（<code class="literal">INSTEAD</code>により止められていない限り）ルールによって追加されたアクションの前に実行されます。
これにより、アクションは挿入された行（複数可）を参照することができます。
しかし、<code class="literal">ON UPDATE</code>と<code class="literal">ON DELETE</code>ルールでは、元の問い合わせはルールによって追加されたアクションの後に実行されます。
これは、アクションが更新される予定の、または削除される予定の行を参照できることを保証します。
さもないと、条件に一致する行を見つけることができないためにアクションが作動しなくなる可能性が起こります。</p><p>ルールアクションで生成された問い合わせツリーは、再度書き換えシステムに渡され、より多くのルールの適用を受けてより多くのもしくは少ない問い合わせツリーになるかもしれません。
ですから、ルールのアクションはルール自身とは異なるコマンド種類か、異なる結果リレーションを持っていなければなりません。
さもないと、この再帰的処理により無限ループに陥ってしまいます。
(ルールの再帰展開は検知され、エラーとして報告されます。)</p><p><code class="structname">pg_rewrite</code>システムカタログのアクションにある問い合わせツリーは単なるテンプレートです。
これらは<code class="literal">NEW</code>と<code class="literal">OLD</code>に対する範囲テーブルの項目を参照することができるため、使用される前に何らかの置換措置がとられていなければなりません。
<code class="literal">NEW</code>を参照する全てに対し、元の問い合わせの目的リストは対応する項目があるかどうか検索されます。
項目が見つかった場合には、その項目式が参照を置き換えます。
項目がなかった場合、<code class="literal">NEW</code>は<code class="literal">OLD</code>と同じ意味になる（<code class="command">UPDATE</code>の場合）か、NULLによって置き換えられます（<code class="command">INSERT</code>の場合）。
<code class="literal">OLD</code>に対する参照は全て結果リレーションである範囲テーブルの項目への参照に置き換えられます。</p><p>更新ルールの適用が終わると、システムはそこで作られた構文解析ツリーにビュールールを適用します。
ビューは、新しい更新アクションを挿入できないため、ビュー書き換えの結果に更新ルールを適用する必要はありません。</p><div class="sect3" id="id-1.8.6.9.7.10"><div class="titlepage"><div><div><h4 class="title">40.4.1.1. 最初のルール、ステップバイステップ</h4></div></div></div><p><code class="literal">shoelace_data</code>リレーションの<code class="literal">sl_avail</code>列の変化を追跡してみたいと思います。
そこでログ用テーブルと、<code class="literal">shoelace_data</code>に対して行われる<code class="command">UPDATE</code>をログに記録するルールを用意しました。

</p><pre class="programlisting">CREATE TABLE shoelace_log (
    sl_name    text,          -- 変更された靴紐
    sl_avail   integer,       -- 新しい現在値
    log_who    text,          -- 誰が行ったか
    log_when   timestamp      -- いつ行ったか
);

CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
    WHERE NEW.sl_avail &lt;&gt; OLD.sl_avail
    DO INSERT INTO shoelace_log VALUES (
                                    NEW.sl_name,
                                    NEW.sl_avail,
                                    current_user,
                                    current_timestamp
                                );</pre><p>ここで誰かが以下を実行します。

</p><pre class="programlisting">UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';</pre><p>

ログテーブルを見てみましょう。

</p><pre class="programlisting">SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who | log_when                        
---------+----------+---------+----------------------------------
 sl7     |        6 | Al      | Tue Oct 20 16:14:45 1998 MET DST
(1 row)</pre><p>
   </p><p>思った通りの結果が出ました。
以下に裏で何が起こったのかを説明します。
パーサがまず以下の構文解析ツリーを生成しました。

</p><pre class="programlisting">UPDATE shoelace_data SET sl_avail = 6
  FROM shoelace_data shoelace_data
 WHERE shoelace_data.sl_name = 'sl7';</pre><p>

以下のルール条件式

</p><pre class="programlisting">NEW.sl_avail &lt;&gt; OLD.sl_avail</pre><p>

および、以下のアクションを持つ<code class="literal">ON UPDATE</code>の<code class="literal">log_shoelace</code>ルールがあります。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old;</pre><p>

（通常、<code class="literal">INSERT ... VALUES ... FROM</code>を書くことはできないのでちょっと奇妙に見えるかもしれません。
ここの<code class="literal">FROM</code>句は単に<code class="literal">new</code>と<code class="literal">old</code>の問い合わせツリーの範囲テーブル項目があることを示しているだけです。
これらは、<code class="command">INSERT</code>コマンドの問い合わせツリー中の変数から参照されるために必要なのです。）</p><p>このルールは条件付きの<code class="literal">ALSO</code>ルールですので、ルールシステムは変更されたルールアクションと元の問い合わせツリーという2つの問い合わせツリーを返さなければなりません。
第1の段階で元の問い合わせの範囲テーブルはルールアクション問い合わせツリーに取り込まれます。
そして、次の結果を生みます。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       <span class="emphasis"><strong>shoelace_data shoelace_data</strong></span>;</pre><p>

第2段階で、以下のようにルール条件が付け加えられます。
これにより、この結果集合は<code class="literal">sl_avail</code>が変更した行に限定されます。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 <span class="emphasis"><strong>WHERE new.sl_avail &lt;&gt; old.sl_avail</strong></span>;</pre><p>

（<code class="literal">INSERT ... VALUES</code>は<code class="literal">WHERE</code>句を持たないため、これはさらに奇妙です。
しかし、プランナとエクゼキュータには問題はありません。
これらはどのみち<code class="literal">INSERT ... SELECT</code>のために同じ機能をサポートしなければなりません。）
   </p><p>第3段階で、以下のように元の問い合わせツリーの条件が付け加えられ、結果集合は元の問い合わせで変更された行のみにさらに限定されます。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       new.sl_name, new.sl_avail,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE new.sl_avail &lt;&gt; old.sl_avail
   <span class="emphasis"><strong>AND shoelace_data.sl_name = 'sl7'</strong></span>;</pre><p>
   </p><p>第4段階では、以下のように元の問い合わせツリーの目的リスト項目、または結果リレーションの該当する変数参照で、<code class="literal">NEW</code>の参照を置換します。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       <span class="emphasis"><strong>shoelace_data.sl_name</strong></span>, <span class="emphasis"><strong>6</strong></span>,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE <span class="emphasis"><strong>6</strong></span> &lt;&gt; old.sl_avail
   AND shoelace_data.sl_name = 'sl7';</pre><p>

   </p><p>第5段階は、以下のように<code class="literal">OLD</code>参照を結果リレーション参照に置き換えます。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data new, shoelace_data old,
       shoelace_data shoelace_data
 WHERE 6 &lt;&gt; <span class="emphasis"><strong>shoelace_data.sl_avail</strong></span>
   AND shoelace_data.sl_name = 'sl7';</pre><p>
   </p><p>これで終わりです。このルールは<code class="literal">ALSO</code>のため、元の問い合わせツリーも出力します。
まとめると、ルールシステムからの出力は以下の文に対応する2つの問い合わせツリーのリストです。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, 6,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE 6 &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';

UPDATE shoelace_data SET sl_avail = 6
 WHERE sl_name = 'sl7';</pre><p>

この2つは順番通りに処理され、正確にルールが定義した通りです。
   </p><p>元の問い合わせが例えば下記のような場合に、置換と追加された条件は、ログには何も書かれないことを確実にします。

</p><pre class="programlisting">UPDATE shoelace_data SET sl_color = 'green'
 WHERE sl_name = 'sl7';</pre><p>

この場合、元の問い合わせツリーの目的リストには<code class="literal">sl_avail</code>の項目がありませんので、<code class="literal">NEW.sl_avail</code>が<code class="literal">shoelace_data.sl_avail</code>に置き換えられます。
その結果、このルールによって以下のような特別の問い合わせが生成されます。

</p><pre class="programlisting">INSERT INTO shoelace_log VALUES (
       shoelace_data.sl_name, <span class="emphasis"><strong>shoelace_data.sl_avail</strong></span>,
       current_user, current_timestamp )
  FROM shoelace_data
 WHERE <span class="emphasis"><strong>shoelace_data.sl_avail</strong></span> &lt;&gt; shoelace_data.sl_avail
   AND shoelace_data.sl_name = 'sl7';</pre><p>

そしてこの条件は決して真にはなりません。
   </p><p>もし元の問い合わせが複数の行を変更してもうまくいきます。
ですから、誰かが下記のようなコマンドを実行したとします。

</p><pre class="programlisting">UPDATE shoelace_data SET sl_avail = 0
 WHERE sl_color = 'black';</pre><p>

この場合、実際には4行が更新されます（<code class="literal">sl1</code>、<code class="literal">sl2</code>、<code class="literal">sl3</code>および<code class="literal">sl4</code>）。
しかし<code class="literal">sl3</code>は既に<code class="literal">sl_avail = 0</code>を持っています。
この場合、元の問い合わせツリーの条件を満たさず、その結果、以下のような特別の問い合わせツリーがルールによって生成されます。

</p><pre class="programlisting">INSERT INTO shoelace_log
SELECT shoelace_data.sl_name, 0,
       current_user, current_timestamp
  FROM shoelace_data
 WHERE 0 &lt;&gt; shoelace_data.sl_avail
   AND <span class="emphasis"><strong>shoelace_data.sl_color = 'black'</strong></span>;</pre><p>

この構文解析ツリーは確実に3つの新しいログ項目を挿入します。
これはまったく正しい動作です
[訳注：sl3行はWHERE 0 != shoelace_data.sl_avail条件を満たさない（0!=0）ので、実際に更新される4行-1の3行分のログ項目が挿入されます]。</p><p>ここで元の構文解析ツリーが最後に実行されるということが重要な理由がわかります。
もし<code class="command">UPDATE</code>が先に実行されたとしたら、全ての行は0にセットされ、<code class="literal">0 &lt;&gt; shoelace_data.sl_avail</code>である行をログ書き込み時の<code class="command">INSERT</code>の段階で見つけられなくなります。</p></div></div><div class="sect2" id="RULES-UPDATE-VIEWS"><div class="titlepage"><div><div><h3 class="title">40.4.2. ビューとの協調</h3></div></div></div><a id="id-1.8.6.9.8.2" class="indexterm"></a><p>誰かがビューに対して<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>を発行するといった、前述の可能性からビューリレーションを保護する簡単な方法は、それらの構文解析ツリーを破棄してしまうことです。
このために以下のルールを作ることができます。

</p><pre class="programlisting">CREATE RULE shoe_ins_protect AS ON INSERT TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe
    DO INSTEAD NOTHING;
CREATE RULE shoe_del_protect AS ON DELETE TO shoe
    DO INSTEAD NOTHING;</pre><p>

誰かが<code class="literal">shoe</code>ビューリレーションに上記の操作を行おうとすると、ルールシステムはルールを適用します。
ルールにはアクションがなく、かつ、<code class="literal">INSTEAD</code>ですから、結果の問い合わせツリーリストは空になります。
ルールシステムの処理が完了した後に最適化されるものや実行されるべきものが何も残っていませんので、問い合わせ全体が無効になります。</p><p>より洗練されたルールシステムの使用方法は、実テーブルに適当な操作を行う問い合わせツリーへの書き換えを行うルールを作ることです。
<code class="literal">shoelace</code>ビューにこれを適用するために以下のルールを作ります。

</p><pre class="programlisting">CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    );

CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
    DO INSTEAD
    UPDATE shoelace_data
       SET sl_name = NEW.sl_name,
           sl_avail = NEW.sl_avail,
           sl_color = NEW.sl_color,
           sl_len = NEW.sl_len,
           sl_unit = NEW.sl_unit
     WHERE sl_name = OLD.sl_name;

CREATE RULE shoelace_del AS ON DELETE TO shoelace
    DO INSTEAD
    DELETE FROM shoelace_data
     WHERE sl_name = OLD.sl_name;</pre><p>
   </p><p>このビュー上で<code class="literal">RETURNING</code>問い合わせをサポートしたい場合、ビューの行を計算する<code class="literal">RETURNING</code>句を含むルールを作成しなければなりません。
これは通常、単一テーブルに対するビューでは非常に簡単ですが、<code class="literal">shoelace</code>のような結合されたビューの場合は多少やっかいです。
挿入する場合を例として以下に示します。

</p><pre class="programlisting">CREATE RULE shoelace_ins AS ON INSERT TO shoelace
    DO INSTEAD
    INSERT INTO shoelace_data VALUES (
           NEW.sl_name,
           NEW.sl_avail,
           NEW.sl_color,
           NEW.sl_len,
           NEW.sl_unit
    )
    RETURNING
           shoelace_data.*,
           (SELECT shoelace_data.sl_len * u.un_fact
            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);</pre><p>

この1つのルールが、ビューに対する<code class="command">INSERT</code>問い合わせと<code class="command">INSERT RETURNING</code>問い合わせルールをサポートすることに注意してください。
<code class="command">INSERT</code>では<code class="literal">RETURNING</code>句が無視されるだけです。
   </p><p>ここで店には不定期に靴紐のケースが分厚い送り状とともに届けられると仮定します。
しかし、毎回毎回手作業で<code class="literal">shoelace</code>ビューを更新したくはありません。
代わりに、送り状から品目を挿入するテーブルと特殊な仕掛けを持つテーブルの2つの小さなテーブルを用意します。
以下はそれらを作成するコマンドです。

</p><pre class="programlisting">CREATE TABLE shoelace_arrive (
    arr_name    text,
    arr_quant   integer
);

CREATE TABLE shoelace_ok (
    ok_name     text,
    ok_quant    integer
);

CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
    DO INSTEAD
    UPDATE shoelace
       SET sl_avail = sl_avail + NEW.ok_quant
     WHERE sl_name = NEW.ok_name;</pre><p>

これで、送り状のデータを<code class="literal">shoelace_arrive</code>テーブルに投入することができます。

</p><pre class="programlisting">SELECT * FROM shoelace_arrive;

 arr_name | arr_quant
----------+-----------
 sl3      |        10
 sl6      |        20
 sl8      |        20
(3 rows)</pre><p>

そして現在のデータをチェックします。

</p><pre class="programlisting">SELECT * FROM shoelace;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl3      |        0 | black    |     35 | inch    |      88.9
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl8      |        1 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |        0 | brown    |    0.9 | m       |        90
(8 rows)</pre><p>

さて、届いた靴紐を移動します。

</p><pre class="programlisting">INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;</pre><p>

そして結果を確認します。

</p><pre class="programlisting">SELECT * FROM shoelace ORDER BY sl_name;

 sl_name  | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
----------+----------+----------+--------+---------+-----------
 sl1      |        5 | black    |     80 | cm      |        80
 sl2      |        6 | black    |    100 | cm      |       100
 sl7      |        6 | brown    |     60 | cm      |        60
 sl4      |        8 | black    |     40 | inch    |     101.6
 sl3      |       10 | black    |     35 | inch    |      88.9
 sl8      |       21 | brown    |     40 | inch    |     101.6
 sl5      |        4 | brown    |      1 | m       |       100
 sl6      |       20 | brown    |    0.9 | m       |        90
(8 rows)

SELECT * FROM shoelace_log;

 sl_name | sl_avail | log_who| log_when                        
---------+----------+--------+----------------------------------
 sl7     |        6 | Al     | Tue Oct 20 19:14:45 1998 MET DST
 sl3     |       10 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl6     |       20 | Al     | Tue Oct 20 19:25:16 1998 MET DST
 sl8     |       21 | Al     | Tue Oct 20 19:25:16 1998 MET DST
(4 rows)</pre><p>
   </p><p>1つの<code class="literal">INSERT ... SELECT</code>からこの結果になるには、長い道のりがあります。
本章での問い合わせツリーの変形に関する説明はこれが最後です。
まず、以下のようなパーサの出力があります。

</p><pre class="programlisting">INSERT INTO shoelace_ok
SELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;</pre><p>

最初の<code class="literal">shoelace_ok_ins</code>ルールが適用され、結果は以下のようになります。

</p><pre class="programlisting">UPDATE shoelace
   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace
 WHERE shoelace.sl_name = shoelace_arrive.arr_name;</pre><p>

そして、<code class="literal">shoelace_ok</code>に対する元の<code class="command">INSERT</code>を破棄します。
この書き換えられた問い合わせは再びルールシステムに渡されて、2番目に適用される<code class="literal">shoelace_upd</code>ルールは以下を生成します。

</p><pre class="programlisting">UPDATE shoelace_data
   SET sl_name = shoelace.sl_name,
       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,
       sl_color = shoelace.sl_color,
       sl_len = shoelace.sl_len,
       sl_unit = shoelace.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data
 WHERE shoelace.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = shoelace.sl_name;</pre><p>

これは再び<code class="literal">INSTEAD</code>ルールですので、以前の問い合わせツリーは破棄されます。
この問い合わせは<code class="literal">shoelace</code>ビューを引き続き使用していることに注意してください。
しかし、この段階ではルールシステムは終了していないため、引き続き<code class="literal">_RETURN</code>ルールが適用され、下記のようになります。

</p><pre class="programlisting">UPDATE shoelace_data
   SET sl_name = s.sl_name,
       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,
       sl_color = s.sl_color,
       sl_len = s.sl_len,
       sl_unit = s.sl_unit
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name;</pre><p>

最後に、<code class="literal">log_shoelace</code>ルールが適用され、以下のような特別な問い合わせツリーが生成されます。

</p><pre class="programlisting">INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,
       shoelace_ok old, shoelace_ok new,
       shoelace shoelace, shoelace old,
       shoelace new, shoelace_data shoelace_data,
       shoelace old, shoelace new,
       shoelace_data s, unit u,
       shoelace_data old, shoelace_data new
       shoelace_log shoelace_log
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND (s.sl_avail + shoelace_arrive.arr_quant) &lt;&gt; s.sl_avail;</pre><p>

この後、ルールシステムはルールを使い切り、生成された問い合わせツリーを返します。
   </p><p>そして、以下の<acronym class="acronym">SQL</acronym>文と等価となる2つの最終問い合わせツリーで終結します。

</p><pre class="programlisting">INSERT INTO shoelace_log
SELECT s.sl_name,
       s.sl_avail + shoelace_arrive.arr_quant,
       current_user,
       current_timestamp
  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.arr_name
   AND shoelace_data.sl_name = s.sl_name
   AND s.sl_avail + shoelace_arrive.arr_quant &lt;&gt; s.sl_avail;

UPDATE shoelace_data
   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant
  FROM shoelace_arrive shoelace_arrive,
       shoelace_data shoelace_data,
       shoelace_data s
 WHERE s.sl_name = shoelace_arrive.sl_name
   AND shoelace_data.sl_name = s.sl_name;</pre><p>

結果は、1つのリレーションから来たデータが別のリレーションに挿入され、3つ目のリレーションの更新に変更され、4つ目の更新と5つ目への最終更新のログ記録に変更され、最終的に2つの問い合わせに縮小されます。</p><p>ちょっと見苦しい小さな事項があります。
でき上がった2つの問い合わせを見ると、1つに縮小されたはずの<code class="literal">shoelace_data</code>リレーションが範囲テーブルに二度出てきます。
プランナは処理をしないので、<code class="command">INSERT</code>のルールシステムの出力に対する実行計画は次のようになります。

</p><pre class="literallayout">Nested Loop
  -&gt;  Merge Join
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on s
        -&gt;  Seq Scan
              -&gt;  Sort
                    -&gt;  Seq Scan on shoelace_arrive
  -&gt;  Seq Scan on shoelace_data</pre><p>

一方、余計な範囲テーブル項目を省略することで、以下のようにログテーブルにまったく同じ項目が作られます。

</p><pre class="literallayout">Merge Join
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on s
  -&gt;  Seq Scan
        -&gt;  Sort
              -&gt;  Seq Scan on shoelace_arrive</pre><p>

ですから、ルールシステムは、まったく必要のない<code class="literal">shoelace_data</code>リレーションに対する余計なスキャンを一度行うことになります。
そして<code class="command">UPDATE</code>でも同様な不要なスキャンが再度実行されます。
しかしながら、これらを全て可能にするのは大変な仕事です。</p><p>最後に<span class="productname">PostgreSQL</span>のルールシステムとその効力を示しましょう。
例えば、まったく売れそうもない靴紐をデータベースに追加してみます。

</p><pre class="programlisting">INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);</pre><p>

全ての靴に合わない色が<code class="literal">shoelace</code>項目にあるかどうかを検査するビューを作成したいと考えます。
ビューは以下のようになります。

</p><pre class="programlisting">CREATE VIEW shoelace_mismatch AS
    SELECT * FROM shoelace WHERE NOT EXISTS
        (SELECT shoename FROM shoe WHERE slcolor = sl_color);</pre><p>

この出力は以下のようになります。

</p><pre class="programlisting">SELECT * FROM shoelace_mismatch;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl9     |        0 | pink     |     35 | inch    |      88.9
 sl10    |     1000 | magenta  |     40 | inch    |     101.6</pre><p>
   </p><p>ここで、合う靴がない靴紐のうち、在庫がないものをデータベースから削除するように設定してみます。
これは<span class="productname">PostgreSQL</span>では困難な作業ですので、直接削除しません。
代わりに、以下のようにもう1つビューを作成します。

</p><pre class="programlisting">CREATE VIEW shoelace_can_delete AS
    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;</pre><p>

そして、以下を行います。

</p><pre class="programlisting">DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_can_delete
             WHERE sl_name = shoelace.sl_name);</pre><p>

さあできました。

</p><pre class="programlisting">SELECT * FROM shoelace;

 sl_name | sl_avail | sl_color | sl_len | sl_unit | sl_len_cm
---------+----------+----------+--------+---------+-----------
 sl1     |        5 | black    |     80 | cm      |        80
 sl2     |        6 | black    |    100 | cm      |       100
 sl7     |        6 | brown    |     60 | cm      |        60
 sl4     |        8 | black    |     40 | inch    |     101.6
 sl3     |       10 | black    |     35 | inch    |      88.9
 sl8     |       21 | brown    |     40 | inch    |     101.6
 sl10    |     1000 | magenta  |     40 | inch    |     101.6
 sl5     |        4 | brown    |      1 | m       |       100
 sl6     |       20 | brown    |    0.9 | m       |        90
(9 rows)</pre><p>
   </p><p>合計4つのネスト/結合されたビューを副問い合わせの条件として持ち、その中の1つはビューを含む副問い合わせ条件を持ち、かつ演算を施されたビューの列が使われる場合の、ビューに対する<code class="command">DELETE</code>が、実テーブルから要求されたデータを削除する単一の問い合わせツリーに書き換えられます。</p><p>このような構造が必要な状況は実社会ではほとんどないと思われます。
しかし、実際に動くことを確認できれば安心できます。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules-materializedviews.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-privileges.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">40.3. マテリアライズドビュー </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 40.5. ルールと権限</td></tr></table></div></body></html>