<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.1. 序文</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes.html" title="Chapter 11. インデックス" /><link rel="next" href="indexes-types.html" title="11.2. インデックスの種類" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.1. 序文</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes.html" title="Chapter 11. インデックス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-types.html" title="11.2. インデックスの種類">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.1. 序文</h2></div></div></div><p>次のようなテーブルを考えてみましょう。
</p><pre class="programlisting">CREATE TABLE test1 (
    id integer,
    content varchar
);</pre><p>
アプリケーションはこの形式の多くの問い合わせを発行します。
</p><pre class="programlisting">SELECT content FROM test1 WHERE id = <em class="replaceable"><code>constant</code></em>;</pre><p>
事前に準備を行っていなければ、システムで一致する項目を全て検出するためには、<code class="structname">test1</code>テーブル全体を1行ごとにスキャンする必要があります。
<code class="structname">test1</code>に数多くの行があり、その問い合わせで返されるのが数行（おそらく0行か1行）しかない場合、これは明らかに効率が悪い方法と言えます。
システムがインデックスを<code class="structfield">id</code>列上で維持するように指示されていれば、一致する行を検出するのにより効率の良い方法を使うことができます。
例えば、検索ツリーを数層分検索するだけで済む可能性もあります。
  </p><p>ほとんどのノンフィクションの本で、同じような手法が使われています。
読者が頻繁に調べる用語および概念は、その本の最後にアルファベット順に索引としてまとめられています。
その本に興味を持った読者は、索引（インデックス）を調べ、比較的速く簡単に該当するページを開くことができるため、見たい場所を探すために本全部を読む必要はありません。
読者がよく調べそうな項目を予想するのが著者の仕事であるように、どのインデックスが実用的であるかを予測するのはデータベースプログラマの仕事です。
  </p><p>上述のように<code class="structfield">id</code>列にインデックスを作成する場合は、以下のようなコマンドが使用できます。
</p><pre class="programlisting">CREATE INDEX test1_id_index ON test1 (id);</pre><p>
<code class="structname">test1_id_index</code>というインデックス名には、何を選んでも構いませんが、そのインデックスを何のために作成したかを後で思い出せるような名前を選ぶべきです。
  </p><p>インデックスを削除するには、<code class="command">DROP INDEX</code>コマンドを使用します。
テーブルのインデックスは、いつでも追加および削除できます。
  </p><p>いったんインデックスを作成すれば、それ以上の処理は必要はありません。
システムは、テーブルが変更される時インデックスを更新し、シーケンシャルスキャンよりもインデックススキャンを行うことがより効率的と判断した場合、問い合わせでインデックスを使用します。
しかし、問い合わせプランナで情報に基づいた判断をするためには、定期的に<code class="command">ANALYZE</code>コマンドを実行し、統計情報を更新する必要があるかもしれません。
インデックスが使われているかどうか、およびプランナがインデックスを<span class="emphasis"><em>使わない</em></span>と判断した状況および理由を調べる方法については、<a class="xref" href="performance-tips.html" title="Chapter 14. 性能に関するヒント">Chapter 14</a>を参照してください。
  </p><p>インデックスは、<code class="command">UPDATE</code>や<code class="command">DELETE</code>コマンドの検索条件でも使用できます。
さらに、インデックスは結合問い合わせでも使用されます。
したがって、結合条件で記述されている列にインデックスを定義すれば、結合を伴った問い合わせにかかる時間もかなり短縮できます。
  </p><p>大規模テーブルに対するインデックス作成が長時間にわたる可能性があります。
デフォルトで<span class="productname">PostgreSQL</span>はインデックス作成と並行してテーブルを読み取る（<code class="command">SELECT</code>文）ことができますが、書き込み（<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>）はインデックス作成が終わるまでブロックされます。
これは多くの運用環境では受け入れられません。
インデックス作成中でも並行して書き込みできるようにすることができますが、いくつか注意しなければならないことがあります。
<a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY" title="インデックスの同時作成">インデックスの同時作成</a>の情報を参照してください。
  </p><p>インデックスが作成された後、システムでは、テーブルとインデックスとの間で常に同期を取っておく必要があります。
これにより、データ操作の処理にオーバーヘッドが加わります。
したがって、めったに使用されないインデックスや、まったく使用されなくなったインデックスは、削除しておいた方が良いでしょう。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-types.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 11. インデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.2. インデックスの種類</td></tr></table></div></body></html>