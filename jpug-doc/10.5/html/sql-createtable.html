<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE TABLE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION" /><link rel="next" href="sql-createtableas.html" title="CREATE TABLE AS" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE TABLE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-createsubscription.html" title="CREATE SUBSCRIPTION">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createtableas.html" title="CREATE TABLE AS">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATETABLE"><div class="titlepage"></div><a id="id-1.9.3.81.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE TABLE</span></h2><p>CREATE TABLE — 新しいテーブルを定義する</p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em> ( [
  { <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em>
    | LIKE <em class="replaceable"><code>source_table</code></em> [ <em class="replaceable"><code>like_option</code></em> ... ] }
    [, ... ]
] )
[ INHERITS ( <em class="replaceable"><code>parent_table</code></em> [, ... ] ) ]
[ PARTITION BY { RANGE | LIST } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em>
    OF <em class="replaceable"><code>type_name</code></em> [ (
  { <em class="replaceable"><code>column_name</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em> }
    [, ... ]
) ]
[ PARTITION BY { RANGE | LIST } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } | UNLOGGED ] TABLE [ IF NOT EXISTS ] <em class="replaceable"><code>table_name</code></em>
    PARTITION OF <em class="replaceable"><code>parent_table</code></em> [ (
  { <em class="replaceable"><code>column_name</code></em> [ WITH OPTIONS ] [ <em class="replaceable"><code>column_constraint</code></em> [ ... ] ]
    | <em class="replaceable"><code>table_constraint</code></em> }
    [, ... ]
) ] FOR VALUES <em class="replaceable"><code>partition_bound_spec</code></em>
[ PARTITION BY { RANGE | LIST } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [, ... ] ) ]
[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

<span class="phrase">ここで<em class="replaceable"><code>column_constraint</code></em>には、次の構文が入ります。</span>

[ CONSTRAINT <em class="replaceable"><code>constraint_name</code></em> ]
{ NOT NULL |
  NULL |
  CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] |
  DEFAULT <em class="replaceable"><code>default_expr</code></em> |
  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>sequence_options</code></em> ) ] |
  UNIQUE <em class="replaceable"><code>index_parameters</code></em> |
  PRIMARY KEY <em class="replaceable"><code>index_parameters</code></em> |
  REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
    [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">また、<em class="replaceable"><code>table_constraint</code></em>には、次の構文が入ります。</span>

[ CONSTRAINT <em class="replaceable"><code>constraint_name</code></em> ]
{ CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] |
  UNIQUE ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> |
  PRIMARY KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> |
  EXCLUDE [ USING <em class="replaceable"><code>index_method</code></em> ] ( <em class="replaceable"><code>exclude_element</code></em> WITH <em class="replaceable"><code>operator</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> [ WHERE ( <em class="replaceable"><code>predicate</code></em> ) ] |
  FOREIGN KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] ) REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> [, ... ] ) ]
    [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

<span class="phrase">また<em class="replaceable"><code>like_option</code></em>は、以下の通りです。</span>

{ INCLUDING | EXCLUDING } { COMMENTS | CONSTRAINTS | DEFAULTS | IDENTITY | INDEXES | STATISTICS | STORAGE | ALL }

<span class="phrase">また<em class="replaceable"><code>partition_bound_spec</code></em>は、以下の通りです。</span>

IN ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | NULL } [, ...] ) |
FROM ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )
  TO ( { <em class="replaceable"><code>numeric_literal</code></em> | <em class="replaceable"><code>string_literal</code></em> | TRUE | FALSE | MINVALUE | MAXVALUE } [, ...] )

<span class="phrase"><code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>および<code class="literal">EXCLUDE</code>制約内の<em class="replaceable"><code>index_parameters</code></em>は以下の通りです。</span>

[ WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] ) ]
[ USING INDEX TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]

<span class="phrase"><code class="literal">EXCLUDE</code>制約内の<em class="replaceable"><code>exclude_element</code></em>は以下の通りです。</span>

{ <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ <em class="replaceable"><code>opclass</code></em> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ]</pre></div><div class="refsect1" id="SQL-CREATETABLE-DESCRIPTION"><h2>説明</h2><p><code class="command">CREATE TABLE</code>は、現在のデータベースに新しい空のテーブルを作成します。
作成したテーブルはこのコマンドを実行したユーザが所有します。
  </p><p>スキーマ名が付けられている場合（例えば、<code class="literal">CREATE TABLE myschema.mytable ...</code>）、テーブルは指定されたスキーマに作成されます。
スキーマ名がなければ、テーブルは現在のスキーマに作成されます。
また、一時テーブルは特別なスキーマに存在するため、一時テーブルの作成時にスキーマ名を与えることはできません。
テーブル名は、同じスキーマ内の他のテーブル、シーケンス、インデックス、ビュー、外部テーブルとは異なる名前にする必要があります。
  </p><p>さらに、<code class="command">CREATE TABLE</code>は、作成するテーブルの1行に対応する複合型のデータ型を作成します。
したがって、テーブルは、同じスキーマ内の既存のデータ型と同じ名前を持つことができません。

  </p><p>制約句には、挿入、更新操作を行うときに、新しい行、または更新する行が満たさなければならない制約（検査項目）を指定します。制約句は省略可能です。
制約は、テーブル内で有効な値の集合を様々な方法で定義できるSQLオブジェクトです。
  </p><p>制約の定義にはテーブル制約と列制約という2種類があります。
列制約は列定義の一部として定義されます。
テーブル制約定義は、特定の列とは結びつけられておらず、複数の列を含有することができます。
また、全ての列制約はテーブル制約として記述することができます。
列制約は、1つの列にのみ影響する制約のための、簡便な記述方法に過ぎません。
  </p><p>テーブルを作成するためには、すべての列の型または<code class="literal">OF</code>句中の型に対する<code class="literal">USAGE</code>権限を持たなければなりません。
  </p></div><div class="refsect1" id="id-1.9.3.81.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt id="SQL-CREATETABLE-TEMPORARY"><span class="term"><code class="literal">TEMPORARY</code>または<code class="literal">TEMP</code></span></dt><dd><p>このパラメータが指定された場合、テーブルは一時テーブルとして作成されます。
一時テーブルは、そのセッションの終わり、場合によっては、現在のトランザクションの終わり（後述の<code class="literal">ON COMMIT</code>を参照）に自動的に削除されます。
一時テーブルが存在する場合、同じ名前を持つ既存の永続テーブルは、スキーマ修飾名で参照されていない限り、現在のセッションでは非可視になります。
一時テーブルに作られるインデックスも、全て自動的に一時的なものとなります。
     </p><p><a class="link" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">自動バキュームデーモン</a>は一時テーブルにアクセスできないため、一時テーブルのバキュームや解析を行うことはできません。
このためセッションのSQLコマンドを用いて適切なバキュームと解析を実行しなければなりません。
例えば、一時テーブルが複雑な問い合わせで使用される場合、一時テーブルにデータを投入した後にそれに対し<code class="command">ANALYZE</code>を実行することを勧めます。
     </p><p>オプションで、<code class="literal">GLOBAL</code>または<code class="literal">LOCAL</code>を<code class="literal">TEMPORARY</code>や<code class="literal">TEMP</code>の前に記述することができます。
<span class="productname">PostgreSQL</span>では、現在違いがなく、廃止予定です。
<a class="xref" href="sql-createtable.html#SQL-CREATETABLE-COMPATIBILITY" title="互換性">互換性</a>を参照してください。
     </p></dd><dt id="SQL-CREATETABLE-UNLOGGED"><span class="term"><code class="literal">UNLOGGED</code></span></dt><dd><p>指定された場合、テーブルはログを取らないテーブルとして作成されます。
ログを取らないテーブルに書き出されたデータは先行書き込みログ（<a class="xref" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み">Chapter 30</a>参照）には書き出されません。
このため通常のテーブルより相当高速になります。
しかしこれらはクラッシュ時に安全ではありません。
クラッシュまたは異常停止の後、ログを取らないテーブルは自動的に切り詰められます。
またログを取らないテーブルの内容はスタンバイサーバに複製されません。
ログを取らないテーブル上に作成されたインデックスはすべて同様に、ログを取らないようになります。
     </p></dd><dt><span class="term"><code class="literal">IF NOT EXISTS</code></span></dt><dd><p>同じ名前のリレーションがすでに存在していてもエラーとしません。
この場合注意が発せられます。
既存のリレーションが作成しようとしたものと何かしら似たものであることは保証されません。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>作成するテーブルの名前です（スキーマ修飾名でも可）。
     </p></dd><dt><span class="term"><code class="literal">OF <em class="replaceable"><code>type_name</code></em></code></span></dt><dd><p>指定した複合型(スキーマ修飾可能)から構造を取り出した<em class="firstterm">型付きテーブル</em>を作成します。
型付きテーブルはその型に束縛されます。
例えば、型が(<code class="literal">DROP TYPE ... CASCADE</code>で)削除されるとそのテーブルは削除されます。
     </p><p>型付きテーブルが作成されると、その列のデータ型は背後の複合型により決定され、<code class="literal">CREATE TABLE</code>コマンドでは指定されません。
しかし<code class="literal">CREATE TABLE</code>コマンドではテーブルにデフォルトと制約を追加できます。
また、格納パラメータの指定も可能です。
     </p></dd><dt id="SQL-CREATETABLE-PARTITION"><span class="term"><code class="literal">PARTITION OF <em class="replaceable"><code>parent_table</code></em> FOR VALUES <em class="replaceable"><code>partition_bound_spec</code></em></code></span></dt><dd><p>指定した親テーブルの<em class="firstterm">パーティション</em>としてテーブルを作成します。
     </p><p><em class="replaceable"><code>partition_bound_spec</code></em>は親テーブルのパーティショニング方法とパーティションキーに対応していなければならず、またそのテーブルのどの既存のパーティションとも重なり合ってはいけません。
<code class="literal">IN</code>の構文はリストパーティショニングで使用され、<code class="literal">FROM</code>と<code class="literal">TO</code>の構文は範囲パーティショニングで使用されます。
     </p><p><em class="replaceable"><code>partition_bound_spec</code></em>で指定される各値はリテラル、<code class="literal">NULL</code>、<code class="literal">MINVALUE</code>あるいは<code class="literal">MAXVALUE</code>です。
各リテラル値はパーティションキー列の型に変換可能な数値定数か、その列の型として有効な入力である文字列リテラルのいずれかです。
     </p><p>リストパーティションを作るときは、<code class="literal">NULL</code>を指定することができて、それはそのパーティションではパーティションキーの列をNULLにすることができるということを意味します。
しかし、1つの親テーブルで2つ以上、そのようなリストパーティションを作ることはできません。
範囲パーティションでは<code class="literal">NULL</code>を指定することはできません。
     </p><p>範囲パーティションを作るとき、<code class="literal">FROM</code>で指定する下限はそれを含む境界、<code class="literal">TO</code>で指定する上限はそれを含まない境界になります。
つまり、<code class="literal">FROM</code>リストで指定される値は、そのパーティションの対応するパーティションキー列において有効な値ですが、<code class="literal">TO</code>リストで指定される値はそうではない、ということです。
この文の意味は行単位の比較の規則（<a class="xref" href="functions-comparisons.html#ROW-WISE-COMPARISON" title="9.23.5. 行コンストラクタの比較">Section 9.23.5</a>）に従って理解しなければならないことに注意してください。
例えば、<code class="literal">PARTITION BY RANGE (x,y)</code>について、パーティション境界<code class="literal">FROM (1, 2) TO (3, 4)</code>には、<code class="literal">x=1</code>で<code class="literal">y&gt;=2</code>の任意の値のもの、<code class="literal">x=2</code>でNULLでない任意の<code class="literal">y</code>のもの、<code class="literal">x=3</code>で<code class="literal">y&lt;4</code>の任意の値のものが入ります。
     </p><p>範囲パーティションを作るとき、<code class="literal">MINVALUE</code>および<code class="literal">MAXVALUE</code>という特別な値を使用することができて、これらはそれぞれ列の値に下限と上限がないことを示します。
例えば、<code class="literal">FROM (MINVALUE) TO (10)</code>で定義されたパーティションには10より小さいすべての値が入り、<code class="literal">FROM (10) TO (MAXVALUE)</code>で定義されたパーティションには10以上のすべての値が入ります。
     </p><p>2つ以上の列を含む範囲パーティションを作るとき、<code class="literal">MAXVALUE</code>を下限の一部として使うことや、<code class="literal">MINVALUE</code>を上限の一部として使うことも意味を持ちえます。
例えば、<code class="literal">FROM (0, MAXVALUE) TO (10, MAXVALUE)</code>で定義されたパーティションには、パーティションキーの第1列が0より大きく、かつ10以下であるものが入ります。
同様に、<code class="literal">FROM ('a', MINVALUE) TO ('b', MINVALUE)</code>で定義されたパーティションには、パーティションキーの第1列が"a"で始まるすべての行が入ります。
     </p><p><code class="literal">MINVALUE</code>または<code class="literal">MAXVALUE</code>をパーティション境界の1つの列で使用する場合、それより後の列では同じ値を使用しなければならないことに注意してください。
例えば、<code class="literal">(10, MINVALUE, 0)</code>は有効な境界ではありません。
<code class="literal">(10, MINVALUE, MINVALUE)</code>とします。
     </p><p><code class="literal">timestamp</code>,など一部の要素型では、"infinity"（無限）の概念があり、それも保存できる値であることにも注意してください。
<code class="literal">MINVALUE</code>と<code class="literal">MAXVALUE</code>は保存できる真の値ではなく、値に境界がないということを表現するための方法に過ぎないため、これとは違います。
<code class="literal">MAXVALUE</code>は"infinity"も含め、他のすべての値より大きいものと考えることができ、また<code class="literal">MINVALUE</code>は"minus infinity"も含め、他のすべての値より小さいものと考えることができます。
従って、境界<code class="literal">FROM ('infinity') TO (MAXVALUE)</code>は空の範囲ではなく、たった1つの値、つまり"infinity"だけを保存します。
     </p><p>パーティションは、それが属するパーティションテーブルと同じ列名および型を持っていなければなりません。
親が<code class="literal">WITH OIDS</code>を指定している場合は、すべてのパーティションがOIDを持っていなければならず、親のOIDは他の列と同様にすべてのパーティションに継承されます。
パーティションテーブルの列名や型の変更や、OID列の追加や削除は自動的にすべてのパーティションに反映されます。
<code class="literal">CHECK</code>制約はすべてのパーティションで自動的に継承されますが、個々のパーティションで追加の<code class="literal">CHECK</code>制約を指定することができます。
親の制約と同じ名前と条件を持つ追加制約は親の制約と統合されます。
デフォルト制約は各パーティションで別々に指定できます。
     </p><p>パーティションテーブルに挿入された行は、自動的に正しいパーティションに回されます。
適当なパーティションが存在しないときは、エラーが発生します。
また、パーティション内の行の更新で、パーティションキーの値が新しくなることにより他のパーティションに移動する必要がある場合も、エラーが発生します。
      will occur.
     </p><p>TRUNCATEのように通常はテーブルとそれを継承するすべての子テーブルに影響を及ぼす操作は、すべてのパーティションに対しても適用されますが、個別のパーティションに対して操作することも可能です。
<code class="literal">DROP TABLE</code>でパーティションを削除するには、親テーブルについて<code class="literal">ACCESS EXCLUSIVE</code>のロックを取得する必要があることに注意してください。
     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>新しいテーブルで作成される列の名前です。
     </p></dd><dt><span class="term"><em class="replaceable"><code>data_type</code></em></span></dt><dd><p>列のデータ型です。
これには、配列指定子を含めることができます。
<span class="productname">PostgreSQL</span>でサポートされるデータ型の情報に関する詳細は<a class="xref" href="datatype.html" title="Chapter 8. データ型">Chapter 8</a>を参照してください。
     </p></dd><dt><span class="term"><code class="literal">COLLATE <em class="replaceable"><code>collation</code></em></code></span></dt><dd><p><code class="literal">COLLATE</code>句は列（照合順の設定が可能なデータ型でなければなりません）に照合順を割り当てます。
指定がなければ、列のデータ型のデフォルトの照合順が使用されます。
     </p></dd><dt><span class="term"><code class="literal">INHERITS ( <em class="replaceable"><code>parent_table</code></em> [, ... ] )</code></span></dt><dd><p>オプションの<code class="literal">INHERITS</code>句でテーブルの一覧を指定すると、新しいテーブルは指定されたテーブルの全ての列を自動的に継承します。
親テーブルには通常のテーブルまたは外部テーブルを指定できます。
     </p><p><code class="literal">INHERITS</code>を使用すると、新しい子テーブルとその親テーブル（複数可）との間に永続的な関連が作成されます。
通常、親へのスキーマ変更は子にも伝播します。また、デフォルトでは、親テーブルの走査結果には子テーブルのデータが含まれます。
     </p><p>複数の親テーブルに同一名の列が存在する場合、それらのデータ型が一致していなければ、エラーとして報告されます。
競合がなければ、これらの重複した列は新しいテーブルで1つの列の形に融合されます。
新しいテーブルの列名の一覧に継承する列の名前が含まれる場合も、そのデータ型は継承する列のデータ型と一致していなければなりません。さらに、その列定義は1つに融合されます。
新しいテーブルで明示的に列のデフォルト値を指定した場合、継承した列宣言における全てのデフォルト値は上書きされます。
デフォルト値を指定しなかった場合、親側でデフォルト値が指定されている時は、それらのデフォルト値が全て同じ値でなければなりません。
値が違う場合はエラーになります。
     </p><p><code class="literal">CHECK</code>制約は、基本的には列と同様の方法でマージされます。
複数の親テーブル、新しいテーブル、またはその両方の定義に同じ名前の<code class="literal">CHECK</code>制約が存在した場合、これらの制約はすべて同じ検査式を持たなければなりません。
さもなくば、エラーが報告されます。
同じ名前と式を持つ制約は１つのコピーにまとめられます。
親テーブルで<code class="literal">NO INHERIT</code>と印が付いた制約は考慮されません。
新しいテーブル内の無名の<code class="literal">CHECK</code>制約は、一意な名前が必ず作られるため、マージされないことに注意してください。
     </p><p>列の<code class="literal">STORAGE</code>設定もまた親テーブルからコピーされます。
     </p><p>親テーブルのある列がIDENTITY列の場合、その属性は継承されません。
望むなら子テーブルの列をIDENTY列と宣言することができます。
     </p></dd><dt><span class="term"><code class="literal">PARTITION BY { RANGE | LIST } ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ <em class="replaceable"><code>opclass</code></em> ] [, ...] ) </code></span></dt><dd><p>オプションの<code class="literal">PARTITION BY</code>句により、テーブルのパーティショニングの戦略を指定できます。
このようにして作られたテーブルを<em class="firstterm">パーティション</em>テーブルと呼びます。
括弧に囲まれた列や式のリストはテーブルの<em class="firstterm">パーティションキー</em>を構成します。
範囲パーティションを使うときは、パーティションキーは複数の列または式にまたがることができます（最大で32ですが、この制限は<span class="productname">PostgreSQL</span>をビルドする時に変更できます）が、リストパーティションでは、パーティションキーは1つだけの列または式で構成されなければなりません。
パーティションテーブルの作成時にBツリー演算子クラスを指定しない場合は、そのデータ型のデフォルトのBツリー演算子クラスが使用されます。
Bツリー演算子クラスがない場合はエラーが報告されます。
     </p><p>パーティションテーブルは（パーティションと呼ばれる）副テーブルに分割され、それらは別の<code class="literal">CREATE TABLE</code>コマンドにより作成されます。
パーティションテーブルそれ自体は空になります。
テーブルに挿入されるデータ行は、パーティションキーの列あるいは式の値に基づいて、1つのパーティションに回されます。
新しい行の値に適合するパーティションが存在しないときは、エラーが報告されます。
     </p><p>パーティションテーブルは<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、<code class="literal">EXCLUDE</code>、<code class="literal">FOREIGN KEY</code>の各制約をサポートしませんが、個々のパーティションでこれらの制約を定義することはできます。
     </p></dd><dt><span class="term"><code class="literal">LIKE <em class="replaceable"><code>source_table</code></em> [ <em class="replaceable"><code>like_option</code></em> ... ]</code></span></dt><dd><p><code class="literal">LIKE</code>句にテーブルを指定すると、自動的にそのテーブルの全ての列名、そのデータ型、非NULL制約が新しいテーブルにコピーされます。
     </p><p><code class="literal">INHERITS</code>とは違い、作成した後、新しいテーブルと元のテーブルが完全に分離されます。
元のテーブルへの変更は新しいテーブルには適用されません。また、元のテーブルを走査しても新しいテーブルのデータは見つかりません。
     </p><p>コピーする列のデフォルト式は、<code class="literal">INCLUDING DEFAULTS</code>が指定された場合にのみコピーされます。
デフォルトの動作では、デフォルト式がコピーされないため、新しいテーブルのコピーされた列はデフォルト値としてNULLを持つことになります。
<code class="function">nextval</code>のようにデータベースを変更する関数を呼び出すデフォルトをコピーすると、元のテーブルと新しいテーブルの間に関数的なリンクが作成される場合があることに注意してください。
     </p><p>コピーされる列定義のIDENTITYの指定は、<code class="literal">INCLUDING IDENTITY</code>が指定された場合にのみコピーされます。
新しいテーブルの各IDENTITY列には新しいシーケンスが作られ、古いテーブルに紐付けられたシーケンスとは別になります。
     </p><p>非NULL制約は常に新しいテーブルにコピーされます。
<code class="literal">CHECK</code>制約は、<code class="literal">INCLUDING CONSTRAINTS</code>が指定された場合にのみコピーされます。
列制約とテーブル制約は区別されません。
     </p><p>拡張統計情報は<code class="literal">INCLUDING STATISTICS</code>が指定された場合にのみコピーされます。
     </p><p>元のテーブルのインデックス、および<code class="literal">PRIMARY KEY</code>、<code class="literal">UNIQUE</code>、<code class="literal">EXCLUDE</code>の制約は<code class="literal">INCLUDING INDEXES</code>が指定された場合のみ、新しいテーブル上で作成されます。
新しいインデックスと制約の名前は、元の名前とは関係なく、デフォルトの規則に従って付けられます。
（この動作により、新しいインデックスが名前の重複によりエラーになる可能性を回避しています。）
     </p><p>複製された列定義に関する<code class="literal">STORAGE</code>設定は、<code class="literal">INCLUDING STORAGE</code>が指定された場合のみコピーされます。
このデフォルトの動作では、<code class="literal">STORAGE</code>設定は除外され、新しいテーブルにおけるコピーされた列は型固有のデフォルトの設定を持つようになります。
<code class="literal">STORAGE</code>の詳細については<a class="xref" href="storage-toast.html" title="66.2. TOAST">Section 66.2</a>を参照してください。
     </p><p>コピーされた列、制約、インデックスについてのコメントは<code class="literal">INCLUDING COMMENTS</code>が指定された場合のみコピーされます。
このデフォルトの動作では、コメントは除外され、新しいテーブルにおけるコピーされた列や制約はコメントを持ちません。
     </p><p><code class="literal">INCLUDING ALL</code>は<code class="literal">INCLUDING DEFAULTS INCLUDING IDENTITY INCLUDING CONSTRAINTS INCLUDING INDEXES INCLUDING STORAGE INCLUDING COMMENTS</code>の省略形です。
     </p><p><code class="literal">INHERITS</code>と異なり、<code class="literal">LIKE</code>によりコピーされた列や制約は類似の名前の列や制約にまとめられません。
同じ名前が明示的に、あるいは他の<code class="literal">LIKE</code>句で指定された場合、エラーが通知されます。
     </p><p>また<code class="literal">LIKE</code>句をビュー、外部テーブル、複合型から列の定義をコピーするために使用することができます。
適用できないオプション（ビューからの<code class="literal">INCLUDING INDEXES</code>など）は無視されます。
     </p></dd><dt><span class="term"><code class="literal">CONSTRAINT <em class="replaceable"><code>constraint_name</code></em></code></span></dt><dd><p>列制約、テーブル制約の名前(省略可能)です。
制約に違反すると、制約名がエラーメッセージに含まれます。
ですので、<code class="literal">col must be positive(正数でなければならない)</code>といった名前の制約名を付与することで、クライアントアプリケーションへ有用な制約情報を渡すことができます。
（空白を含む制約名を指定する場合、二重引用符が必要です。）
指定されなければ、システムが名前を生成します。
     </p></dd><dt><span class="term"><code class="literal">NOT NULL</code></span></dt><dd><p>その列がNULL値を持てないことを指定します。
     </p></dd><dt><span class="term"><code class="literal">NULL</code></span></dt><dd><p>その列がNULL値を持てることを指定します。
これがデフォルトです。
     </p><p>この句は非標準的なSQLデータベースとの互換性のためだけに提供されています。
新しいアプリケーションでこれを使用するのはお勧めしません。
     </p></dd><dt><span class="term"><code class="literal">CHECK ( <em class="replaceable"><code>expression</code></em> ) [ NO INHERIT ] </code></span></dt><dd><p><code class="literal">CHECK</code>句は、論理型の結果を生成する、新しい行または更新される行が挿入または更新処理を成功させるために満足しなければならない式を指定します。
TRUEまたはUNKNOWNと評価される式は成功します。
挿入または更新処理の行がFALSEという結果をもたらす場合はエラー例外が発生し、その挿入または更新によるデータベースの変更は行われません。
列制約として指定された検査制約は列の値のみを参照しなければなりません。
テーブル制約内の式は複数の列を参照できます。
     </p><p>現時点では、<code class="literal">CHECK</code>式には副問い合わせも現在の行の列以外の変数も含めることはできません。
システム列<code class="literal">tableoid</code>を参照することはできますが、他のシステム列は参照できません。
     </p><p><code class="literal">NO INHERIT</code>と印が付いた制約は子テーブルには伝搬しません。
     </p><p>テーブルに複数の<code class="literal">CHECK</code>制約がある場合、それらは<code class="literal">NOT NULL</code>制約について検証した後で、各行について名前のアルファベット順に検証されます。
（<span class="productname">PostgreSQL</span>の9.5より前のバージョンでは、<code class="literal">CHECK</code>制約の実行について特定の順序はありませんでした。）
     </p></dd><dt><span class="term"><code class="literal">DEFAULT
    <em class="replaceable"><code>default_expr</code></em></code></span></dt><dd><p><code class="literal">DEFAULT</code>句を列定義に付けると、その列にデフォルトデータ値が割り当てられます。
値として指定するのは、任意の無変数式です（副問い合わせや現在のテーブル内の他の列へ交差参照はできません）。
デフォルト式のデータ型はその列のデータ型と一致する必要があります。
     </p><p>デフォルト式は、全ての挿入操作において、その列に値が指定されていない場合に使用されます。
列にデフォルト値がない場合、デフォルト値はNULLになります。
     </p></dd><dt><span class="term"><code class="literal">GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( <em class="replaceable"><code>sequence_options</code></em> ) ]</code></span></dt><dd><p>この句は列を<em class="firstterm">IDENTITY列</em>として作成します。
それには暗示的なシーケンスが紐付けられ、新しい行のその列には紐付けられたシーケンスから取られた値が自動的に入ります。
     </p><p><code class="literal">ALWAYS</code>と<code class="literal">BY DEFAULT</code>の句は、ユーザが<code class="command">INSERT</code>文で指定した値に対するシーケンスの値の優先度がどうなるかを決定します。
<code class="literal">ALWAYS</code>が指定された場合、ユーザが指定した値は<code class="command">INSERT</code>文で<code class="literal">OVERRIDING SYSTEM VALUE</code>を指定した場合にのみ受け付けられます。
<code class="literal">BY DEFAULT</code>が指定された場合は、ユーザが指定した値が優先します。
詳細は<a class="xref" href="sql-insert.html" title="INSERT"><span class="refentrytitle">INSERT</span></a>を参照してください。
（<code class="command">COPY</code>コマンドでは、この設定と関係なく、ユーザが指定した値が常に使用されます。）
     </p><p>オプションで<em class="replaceable"><code>sequence_options</code></em>句を指定することにより、シーケンスのオプションを変更できます。
詳しくは<a class="xref" href="sql-createsequence.html" title="CREATE SEQUENCE"><span class="refentrytitle">CREATE SEQUENCE</span></a>を参照してください。
     </p></dd><dt><span class="term"><code class="literal">UNIQUE</code> （列制約）<br /></span><span class="term"><code class="literal">UNIQUE ( <em class="replaceable"><code>column_name</code></em> [, ... ] )</code> （表制約）</span></dt><dd><p><code class="literal">UNIQUE</code>制約は、テーブルの1つまたは複数の列からなるグループが、一意な値のみを持つことができることを指定します。
一意性テーブル制約の動作は一意性列制約と同じですが、さらに複数列にまたがる機能を持ちます。
     </p><p>一意性制約では、NULL値同士は等しいとはみなされなせん。
     </p><p>それぞれの一意性テーブル制約には、そのテーブルの他の一意性制約もしくは主キー制約によって指定された列の集合とは、異なる名前の列の集合を指定しなければなりません
（同じ名前を指定すると、同じ制約が2回現れるだけになります）。
     </p></dd><dt><span class="term"><code class="literal">PRIMARY KEY</code> （列制約）<br /></span><span class="term"><code class="literal">PRIMARY KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] )</code> （表制約）</span></dt><dd><p><code class="literal">PRIMARY KEY</code>制約はテーブルの一列または複数の列が一意（重複がない）で、非NULLの値のみを持つことを指定します。
列制約か表制約かに関わらず、１つのテーブルには主キーを１つだけ指定できます。
     </p><p>主キー制約では、同じテーブルに一意制約で指定した列の集合とは異なる列の集合を指定します。
（そうでなければ、一意制約は冗長となり、捨てられます。）
     </p><p><code class="literal">PRIMARY KEY</code>は<code class="literal">UNIQUE</code>と<code class="literal">NOT NULL</code>の組み合わせと同じデータ制約を課しますが、列の集合を主キーと指定することは、スキーマの設計についてのメタデータを提供することにもなります。
なぜなら、主キーであることは、行を一意に特定するものとして、他のテーブルがその列の集合を当てにして良い、ということを意味するからです。
     </p></dd><dt id="SQL-CREATETABLE-EXCLUDE"><span class="term"><code class="literal">EXCLUDE [ USING <em class="replaceable"><code>index_method</code></em> ] ( <em class="replaceable"><code>exclude_element</code></em> WITH <em class="replaceable"><code>operator</code></em> [, ... ] ) <em class="replaceable"><code>index_parameters</code></em> [ WHERE ( <em class="replaceable"><code>predicate</code></em> ) ]</code></span></dt><dd><p><code class="literal">EXCLUDE</code>句は排他制約を定義し、任意の2行について指定した列(複数可)または式(複数可)を指定した演算子(複数可)を使用して比較した場合、比較結果のすべてが<code class="literal">TRUE</code>を返さないことを保証します。
指定した演算子のすべてが等価性を試験するものであれば、これは<code class="literal">UNIQUE</code>制約と同じですが、通常の一意性制約のほうが高速です。
しかし、排他制約では単純な等価性よりも一般的な制約を指定することができます。
例えば、テーブル内の2つの行が重複する円(<a class="xref" href="datatype-geometric.html" title="8.8. 幾何データ型">Section 8.8</a>参照)を持たないといった制約を<code class="literal">&amp;&amp;</code>演算子を使用して指定することができます。
     </p><p>排他制約はインデックスを使用して実装されています。
このため指定した演算子はそれぞれ適切な演算子クラス(<a class="xref" href="indexes-opclass.html" title="11.9. 演算子クラスと演算子族">Section 11.9</a>参照)で<em class="replaceable"><code>index_method</code></em>インデックスアクセスメソッドと関連付けされていなければなりません。
演算子は交換可能でなければなりません。
オプションで、各<em class="replaceable"><code>exclude_element</code></em>は演算子クラス、順序付けオプション、またはその両方を指定することができます。
これらについては<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>で説明します。
     </p><p>アクセスメソッドは<code class="literal">amgettuple</code>をサポートしなければなりません(<a class="xref" href="indexam.html" title="Chapter 60. インデックスアクセスメソッドのインタフェース定義">Chapter 60</a>参照)。
現時点では、これは<acronym class="acronym">GIN</acronym>を使用できないことを意味します。
B-treeやHashインデックスを排他制約で使用することは許容されますが、そうすることにあまり意味はありません。
これが通常の一意性制約より良いことは何もないからです。
このため現実的にはアクセスメソッドは常に<acronym class="acronym">GiST</acronym>もしくは<acronym class="acronym">SP-GiST</acronym>となります。
     </p><p><em class="replaceable"><code>predicate</code></em>により、排他制約をテーブルの部分集合に指定することができます。
内部的には、これは部分インデックスを作成します。
predicateの前後に括弧が必要であることに注意して下さい。
     </p></dd><dt><span class="term"><code class="literal">REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> ) ] [ MATCH <em class="replaceable"><code>matchtype</code></em> ] [ ON DELETE <em class="replaceable"><code>action</code></em> ] [ ON UPDATE <em class="replaceable"><code>action</code></em> ]</code> （列制約）<br /></span><span class="term"><code class="literal">FOREIGN KEY ( <em class="replaceable"><code>column_name</code></em> [, ... ] )
    REFERENCES <em class="replaceable"><code>reftable</code></em> [ ( <em class="replaceable"><code>refcolumn</code></em> [, ... ] ) ]
    [ MATCH <em class="replaceable"><code>matchtype</code></em> ]
    [ ON DELETE <em class="replaceable"><code>action</code></em> ]
    [ ON UPDATE <em class="replaceable"><code>action</code></em> ]</code>
    （表制約）</span></dt><dd><p>これらの句は、外部キー制約を指定します。
外部キー制約は、新しいテーブルの1つまたは複数の列の集合が、被参照テーブルの一部の行の被参照列に一致する値を持たなければならないことを指定するものです。
<em class="replaceable"><code>refcolumn</code></em>リストが省略された場合、<em class="replaceable"><code>reftable</code></em>の主キーが使用されます。
被参照列は、被参照テーブルにおいて遅延不可の一意性制約もしくは主キー制約を持った列でなければなりません。
ユーザは被参照テーブル（テーブル全体または特定の被参照列）について<code class="literal">REFERENCES</code>権限を持っていなければなりません。
一時テーブルと永続テーブルとの間で外部キー制約を定義できないことに注意してください。
     </p><p>参照列に挿入された値は、被参照テーブルと被参照列の値に対して、指定した照合型で照会されます。
照合型には3種類があります。
<code class="literal">MATCH FULL</code>、<code class="literal">MATCH PARTIAL</code>、<code class="literal">MATCH SIMPLE</code>（これがデフォルト）照合型です。
<code class="literal">MATCH FULL</code>は全ての外部キー列がNULLとなる場合を除き、複数列外部キーのある列がNULLとなることを許可しません。
それらがすべてNULLであれば、その行は被参照テーブル内で一致があることは要求されません。
<code class="literal">MATCH SIMPLE</code>は、外部キーの一部がNULLであることを許可します。
それらの一部がNULLであれば、その行は被参照テーブル内で一致があることは要求されません。
<code class="literal">MATCH PARTIAL</code>はまだ実装されていません。
（当然ですが、<code class="literal">NOT NULL</code>制約を参照列に適用し、こうした状態が発生することを防止することができます。）
     </p><p>さらに、被参照列のデータが変更された場合、このテーブルの列のデータに何らかの動作が発生します。
<code class="literal">ON DELETE</code>句は、被参照テーブルの被参照行が削除されようとした場合の動作を指定します。
同様に<code class="literal">ON UPDATE</code>句は、被参照テーブルの被参照列が新しい値に更新されようとした場合の動作を指定します。
行の更新があった場合でも、被参照列が実際に変更されない場合は、動作は実行されません。
制約が遅延可能と宣言されていても、<code class="literal">NO ACTION</code>検査以外の参照動作は遅延させられません。
各句について、以下の動作を指定可能です。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">NO ACTION</code></span></dt><dd><p>削除もしくは更新により外部キー制約違反が起こることを示すエラーを発生します。
制約が遅延可能な場合、何らかの参照行が存在する限り、このエラーは制約の検査時点で発生します。
これはデフォルトの動作です。
         </p></dd><dt><span class="term"><code class="literal">RESTRICT</code></span></dt><dd><p>削除もしくは更新が外部キー制約違反となることを示すエラーを発生します。
検査が遅延できない点を除き、<code class="literal">NO ACTION</code>と同じです。
         </p></dd><dt><span class="term"><code class="literal">CASCADE</code></span></dt><dd><p>削除された行を参照している行は全て削除します。また、参照している列の値を、被参照列の新しい値にします。
         </p></dd><dt><span class="term"><code class="literal">SET NULL</code></span></dt><dd><p>参照する列をNULLに設定します。
         </p></dd><dt><span class="term"><code class="literal">SET DEFAULT</code></span></dt><dd><p>参照する列をそのデフォルト値に設定します。
（デフォルト値がNULLでない場合は被参照テーブルの中にデフォルト値に一致する行が存在しなければなりません。さもないと操作が失敗します。）
         </p></dd></dl></div><p>
     </p><p>被参照列が頻繁に更新される場合、参照列にインデックスを付け、その外部キー制約に関連する参照動作がより効率的に実行できるようにする方が良いでしょう。
     </p></dd><dt><span class="term"><code class="literal">DEFERRABLE</code><br /></span><span class="term"><code class="literal">NOT DEFERRABLE</code></span></dt><dd><p>制約を遅延させることが可能かどうかを制御します。
遅延不可の制約は各コマンドの後すぐに検査されます。
遅延可能な制約の検査は、（<a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a>コマンドを使用して）トランザクションの終了時まで遅延させることができます。
<code class="literal">NOT DEFERRABLE</code>がデフォルトです。
現在、<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、<code class="literal">EXCLUDE</code>、<code class="literal">REFERENCES</code>（外部キー）制約のみがこの句を受け付けることができます。
<code class="literal">NOT NULL</code>および <code class="literal">CHECK</code>制約は遅延させることができません。
遅延可能な制約は<code class="literal">ON CONFLICT DO UPDATE</code>句を含む<code class="command">INSERT</code>文において、競合解決のために使うことはできないことに注意してください。
     </p></dd><dt><span class="term"><code class="literal">INITIALLY IMMEDIATE</code><br /></span><span class="term"><code class="literal">INITIALLY DEFERRED</code></span></dt><dd><p>制約が遅延可能な場合、この句は制約検査を行うデフォルトの時期を指定します。
制約が<code class="literal">INITIALLY IMMEDIATE</code>の場合、各文の実行後に検査されます。
これがデフォルトです。
制約が<code class="literal">INITIALLY DEFERRED</code>の場合、トランザクションの終了時にのみ検査されます。
制約検査の時期は<a class="xref" href="sql-set-constraints.html" title="SET CONSTRAINTS"><span class="refentrytitle">SET CONSTRAINTS</span></a>コマンドを使用して変更することができます。
     </p></dd><dt><span class="term"><code class="literal">WITH ( <em class="replaceable"><code>storage_parameter</code></em> [= <em class="replaceable"><code>value</code></em>] [, ... ] )</code></span></dt><dd><p>この句は、テーブルまたはインデックスに対して格納パラメータ(省略可能)を指定します。
詳細は<a class="xref" href="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS" title="格納パラメータ">格納パラメータ</a>を参照してください。
テーブルについての<code class="literal">WITH</code>には、<code class="literal">OIDS=TRUE</code>（もしくは単に<code class="literal">OIDS</code>）を含めて、新しいテーブルの行が行に割り当てられたOID（オブジェクト識別子）を持たなければならないことを指定することもできます。
また、<code class="literal">OIDS=FALSE</code>を含めて、OIDを持たないことを指定することもできます。
<code class="literal">OIDS</code>が指定されない場合、デフォルトの設定は設定パラメータ<a class="xref" href="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS">default_with_oids</a>に依存します。
（新しいテーブルがOIDを持つテーブルから継承する場合、コマンドで<code class="literal">OIDS=FALSE</code>と指定しても強制的に<code class="literal">OIDS=TRUE</code> となります。）
     </p><p><code class="literal">OIDS=FALSE</code>が明示的または暗黙的に指定されている場合、新しいテーブルはOIDを格納しません。また、挿入される行にはOIDが割り当てられません。
このような動作は一般的に有益であると考えられます。それは、OIDの使用を抑え、32ビットのOIDカウンタの回転周期を延長できるためです。
カウンタが一周するとOIDの一意性を保証できなくなるので、その有用性を減少させることになります。
また、OIDをなくすことで、テーブル1行当たり（ほとんどのマシンで）4バイト分、テーブルをディスクに格納するための容量を軽減するので、多少性能が向上します。

     </p><p>テーブルの作成後にOIDを削除するには、<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>を使用してください。
     </p></dd><dt><span class="term"><code class="literal">WITH OIDS</code><br /></span><span class="term"><code class="literal">WITHOUT OIDS</code></span></dt><dd><p>これは古い構文で、それぞれ<code class="literal">WITH (OIDS)</code>および<code class="literal">WITH (OIDS=FALSE)</code>と同じです。
<code class="literal">OIDS</code>の設定と格納パラメータの設定の両方を指定したい場合は、上述の<code class="literal">WITH ( ... )</code>を使用しなければなりません。
     </p></dd><dt><span class="term"><code class="literal">ON COMMIT</code></span></dt><dd><p><code class="literal">ON COMMIT</code>を使用して、トランザクションブロックの終了時点での一時テーブルの動作を制御することができます。
以下の3つのオプションがあります。

      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">PRESERVE ROWS</code></span></dt><dd><p>トランザクションの終了時点で、特別な動作は行われません。
これがデフォルトの動作です。
         </p></dd><dt><span class="term"><code class="literal">DELETE ROWS</code></span></dt><dd><p>一時テーブル内の全ての行は、各トランザクションブロックの終わりで削除されます。
実質的には、コミットの度に自動的に<a class="xref" href="sql-truncate.html" title="TRUNCATE"><span class="refentrytitle">TRUNCATE</span></a>が実行されます。
         </p></dd><dt><span class="term"><code class="literal">DROP</code></span></dt><dd><p>一時テーブルは、現在のトランザクションブロックの終了時点で削除されます。
         </p></dd></dl></div></dd><dt><span class="term"><code class="literal">TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code></span></dt><dd><p><em class="replaceable"><code>tablespace_name</code></em>は、新しいテーブルが作成されるテーブル空間名です。
指定されていない場合、<a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>が、また一時テーブルの場合は<a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>が考慮されます。
     </p></dd><dt><span class="term"><code class="literal">USING INDEX TABLESPACE <em class="replaceable"><code>tablespace_name</code></em></code></span></dt><dd><p>この句により、<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、または<code class="literal">EXCLUDE</code>制約に関連したインデックスを作成するテーブル空間を選択することができます。
指定されていない場合、<a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>が、また一時テーブルであれば<a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>が考慮されます。
     </p></dd></dl></div><div class="refsect2" id="SQL-CREATETABLE-STORAGE-PARAMETERS"><h3>格納パラメータ</h3><a id="id-1.9.3.81.6.3.2" class="indexterm"></a><p><code class="literal">WITH</code>句により、テーブルおよび<code class="literal">UNIQUE</code>、<code class="literal">PRIMARY KEY</code>、または<code class="literal">EXCLUDE</code>制約と関連づいたインデックスの<em class="firstterm">格納パラメータ</em>を指定することができます。
インデックスの格納パラメータについては<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>で説明します。
現在テーブルで設定可能な格納パラメータの一覧を以下に示します。
これらのパラメータの多くに対して、示した通り、さらに<code class="literal">toast</code>という接頭辞のついた、同一の名前のパラメータがあります。
これはもしあれば、テーブルの補助<acronym class="acronym">TOAST</acronym>テーブルの動作を制御します。
(TOASTに関する詳細については<a class="xref" href="storage-toast.html" title="66.2. TOAST">Section 66.2</a>を参照してください。)
テーブルのパラメータ値が設定され、それと同等の<code class="literal">toast.</code>パラメータが設定されていない場合、TOASTテーブルはテーブルのパラメータ値を利用します。
これらのパラメータをパーティションテーブルについて指定することはサポートされませんが、個々の末端のパーティションについて指定することはできます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">fillfactor</code> (<code class="type">integer</code>)</span></dt><dd><p>テーブルのフィルファクタ(fillfactor)は10から100までの間の割合（パーセント）です。
100（すべて使用）がデフォルトです。
より小さな値を指定すると、<code class="command">INSERT</code>操作は指定した割合までしかテーブルページを使用しません。
各ページの残りの部分は、そのページ内の行の更新用に予約されます。
これにより<code class="command">UPDATE</code>は、元の行と同じページ上に更新済みの行を格納することができるようになります。
これは別のページに更新済みの行を格納することよりも効率的です。
項目の更新がまったくないテーブルでは、すべてを使用することが最善の選択ですが、更新が非常に多いテーブルではより小さめのフィルファクタが適切です。
TOASTテーブルではこのパラメータを設定できません。
     </p></dd><dt><span class="term"><code class="literal">parallel_workers</code> (<code class="type">integer</code>)</span></dt><dd><p>このテーブルの並列スキャンを支援するために使用されるワーカの数を設定します。
設定されなければ、リレーションのサイズに基づいてシステムが値を決定します。
プランナが選ぶ実際のワーカの数は、例えば<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>の設定によって、それより少なくなるかもしれません。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_enabled</code>, <code class="literal">toast.autovacuum_enabled</code> (<code class="type">boolean</code>)</span></dt><dd><p>特定のテーブルに対する自動バキュームデーモンを有効または無効にします。
trueの場合、自動バキュームデーモンは、更新または削除されたタプル数が<code class="literal">autovacuum_vacuum_threshold</code>＋<code class="literal">autovacuum_vacuum_scale_factor</code>×リレーション内の推定有効タプル数を超えたときに、特定のテーブルに対する<code class="command">VACUUM</code>操作を始めます。
trueの場合、自動バキュームデーモンは、<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自動バキュームデーモン">Section 24.1.6</a>に記述されたルールに従って、このテーブルに対して自動的に<code class="command">VACUUM</code>あるいは<code class="command">ANALYZE</code>またはその両方の操作を行います。
falseの場合、トランザクションIDの周回問題を回避するためを除き自動バキュームは行われません。
周回問題の回避については<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-WRAPAROUND" title="24.1.5. トランザクションIDの周回エラーの防止">Section 24.1.5</a>を参照してください。
<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM">autovacuum</a>パラメータがfalseの場合、（トランザクションIDの周回問題を回避する場合を除き）自動バキュームデーモンはまったく実行されないことに注意して下さい。
個々のテーブルの格納パラメータを設定しても、それは優先されません。
従って、この格納パラメータを明示的に<code class="literal">true</code>に設定することにはほとんど意味はなく、<code class="literal">false</code>に設定することのみが意味を持ちます。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_threshold</code>, <code class="literal">toast.autovacuum_vacuum_threshold</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-THRESHOLD">autovacuum_vacuum_threshold</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_scale_factor</code>, <code class="literal">toast.autovacuum_vacuum_scale_factor</code> (<code class="type">float4</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-SCALE-FACTOR">autovacuum_vacuum_scale_factor</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_analyze_threshold</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-THRESHOLD">autovacuum_analyze_threshold</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_analyze_scale_factor</code> (<code class="type">float4</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-ANALYZE-SCALE-FACTOR">autovacuum_analyze_scale_factor</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_cost_delay</code>, <code class="literal">toast.autovacuum_vacuum_cost_delay</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-DELAY">autovacuum_vacuum_cost_delay</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_vacuum_cost_limit</code>, <code class="literal">toast.autovacuum_vacuum_cost_limit</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-VACUUM-COST-LIMIT">autovacuum_vacuum_cost_limit</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_min_age</code>, <code class="literal">toast.autovacuum_freeze_min_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-MIN-AGE">vacuum_freeze_min_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_freeze_min_age</code>パラメータをシステム全体の<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>設定の1/2より大きく設定しても、自動バキュームが無視することに注意してください。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_max_age</code>, <code class="literal">toast.autovacuum_freeze_max_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-FREEZE-MAX-AGE">autovacuum_freeze_max_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_freeze_max_age</code>パラメータをシステム全体に対する設定より大きく設定しても、自動バキュームが無視することに注意してください（より小さな値しか設定できません）。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_freeze_table_age</code>, <code class="literal">toast.autovacuum_freeze_table_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-client.html#GUC-VACUUM-FREEZE-TABLE-AGE">vacuum_freeze_table_age</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_min_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_min_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-MIN-AGE">vacuum_multixact_freeze_min_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_multixact_freeze_min_age</code>パラメータをシステム全体の<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>の半分より大きく設定しても、自動バキュームが無視することに注意してください。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_max_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_max_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MULTIXACT-FREEZE-MAX-AGE">autovacuum_multixact_freeze_max_age</a>パラメータについて、テーブル毎に設定する値です。
テーブル単位の<code class="literal">autovacuum_multixact_freeze_max_age</code>をシステム全体に対する設定より大きくしても、自動バキュームが無視することに注意してください（より小さな値しか設定できません）。
     </p></dd><dt><span class="term"><code class="literal">autovacuum_multixact_freeze_table_age</code>, <code class="literal">toast.autovacuum_multixact_freeze_table_age</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-client.html#GUC-VACUUM-MULTIXACT-FREEZE-TABLE-AGE">vacuum_multixact_freeze_table_age</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">log_autovacuum_min_duration</code>, <code class="literal">toast.log_autovacuum_min_duration</code> (<code class="type">integer</code>)</span></dt><dd><p><a class="xref" href="runtime-config-autovacuum.html#GUC-LOG-AUTOVACUUM-MIN-DURATION">log_autovacuum_min_duration</a>パラメータについて、テーブル毎に設定する値です。
     </p></dd><dt><span class="term"><code class="literal">user_catalog_table</code> (<code class="type">boolean</code>)</span></dt><dd><p>テーブルを論理レプリケーションのための追加のカタログテーブルとして宣言します。
詳しくは<a class="xref" href="logicaldecoding-output-plugin.html#LOGICALDECODING-CAPABILITIES" title="48.6.2. 機能">Section 48.6.2</a>を参照してください。
このパラメータはTOASTテーブルには設定できません。
     </p></dd></dl></div></div></div><div class="refsect1" id="SQL-CREATETABLE-NOTES"><h2>注釈</h2><p>新規のアプリケーションでOIDを使用するのはお勧めしません。
可能であれば、テーブルの主キーとしてIDENTITY列や他のシーケンスジェネレータを使用する方が望ましいです。
しかし、アプリケーションがテーブルの特定の行を識別するためにOIDを使用する場合は、そのテーブルの<code class="structfield">oid</code>列に一意性制約を作成することを推奨します。
これにより、カウンタが一周してしまった場合でも、テーブル内のOIDで一意に行を識別できることが保証されるからです。
OIDがテーブルをまたがって一意であると考えるのは止めてください。
データベース全体で一意な識別子が必要な場合は、<code class="structfield">tableoid</code>と行のOIDの組み合わせを使用してください。
    </p><div class="tip"><h3 class="title">Tip</h3><p><code class="literal">OIDS=FALSE</code>の使用は、主キーのないテーブルでは推奨されません。
OIDも一意なデータキーも存在しないと、特定行を識別することが難しくなるからです。
     </p></div><p><span class="productname">PostgreSQL</span>は自動的に各一意性制約と主キー制約に対してインデックスを作成し、その一意性を確実なものにします。
したがって、主キーの列に明示的にインデックスを作成することは必要ありません
（詳細については<a class="xref" href="sql-createindex.html" title="CREATE INDEX"><span class="refentrytitle">CREATE INDEX</span></a>を参照してください）。
    </p><p>現在の実装では、一意性制約と主キーは継承されません。
これは、継承と一意性制約を組み合わせると障害が発生するからです。
    </p><p>テーブルは1600列以上の列を持つことはできません
（タプル長の制限により実際の制限はもっと小さくなります）。
    </p></div><div class="refsect1" id="SQL-CREATETABLE-EXAMPLES"><h2>例</h2><p><code class="structname">films</code>テーブルと<code class="structname">distributors</code>テーブルを作成します。

</p><pre class="programlisting">CREATE TABLE films (
    code        char(5) CONSTRAINT firstkey PRIMARY KEY,
    title       varchar(40) NOT NULL,
    did         integer NOT NULL,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute
);

CREATE TABLE distributors (
     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
     name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</pre><p>
  </p><p>2次元配列を持つテーブルを作成します。

</p><pre class="programlisting">CREATE TABLE array_int (
    vector  int[][]
);</pre><p>
  </p><p><code class="literal">films</code>テーブルに 一意性テーブル制約を定義します。
一意性テーブル制約はテーブルの1つ以上の列に定義することができます。

</p><pre class="programlisting">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT production UNIQUE(date_prod)
);</pre><p>
  </p><p>検査列制約を定義します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer CHECK (did &gt; 100),
    name    varchar(40)
);</pre><p>
  </p><p>検査テーブル制約を定義します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    CONSTRAINT con1 CHECK (did &gt; 100 AND name &lt;&gt; '')
);</pre><p>
  </p><p><code class="structname">films</code>テーブルに主キーテーブル制約を定義します。

</p><pre class="programlisting">CREATE TABLE films (
    code        char(5),
    title       varchar(40),
    did         integer,
    date_prod   date,
    kind        varchar(10),
    len         interval hour to minute,
    CONSTRAINT code_title PRIMARY KEY(code,title)
);</pre><p>
  </p><p><code class="structname">distributors</code>テーブルに主キー制約を定義します。
以下の2つの例は同等で、前者はテーブル制約構文を使用し、後者は列制約構文を使用します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    PRIMARY KEY(did)
);

CREATE TABLE distributors (
    did     integer PRIMARY KEY,
    name    varchar(40)
);</pre><p>
  </p><p>以下では、<code class="literal">name</code>列のデフォルト値にリテラル定数を割り当てています。また、<code class="literal">did</code>列のデフォルト値として、シーケンスオブジェクトの次の値が生成されるように調整しています。
<code class="literal">modtime</code>のデフォルト値は、その行が挿入された時刻となります。

</p><pre class="programlisting">CREATE TABLE distributors (
    name      varchar(40) DEFAULT 'Luso Films',
    did       integer DEFAULT nextval('distributors_serial'),
    modtime   timestamp DEFAULT current_timestamp
);</pre><p>
  </p><p>2つの<code class="literal">NOT NULL</code>列制約を<code class="classname">distributors</code>テーブルに定義します。
そのうち1つには明示的な名前を付けています。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer CONSTRAINT no_null NOT NULL,
    name    varchar(40) NOT NULL
);</pre><p>
    </p><p><code class="literal">name</code>列に対し、一意性制約を定義します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40) UNIQUE
);</pre><p>

上と同じですが、テーブル制約として指定します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name)
);</pre><p>
  </p><p>テーブルとその一意性インデックスの両方に70%のフィルファクタを指定して、同じテーブルを作成します。

</p><pre class="programlisting">CREATE TABLE distributors (
    did     integer,
    name    varchar(40),
    UNIQUE(name) WITH (fillfactor=70)
)
WITH (fillfactor=70);</pre><p>
  </p><p>2つの円の重複を許さない排他制約を持つ<code class="structname">circles</code>テーブルを作成します。

</p><pre class="programlisting">CREATE TABLE circles (
    c circle,
    EXCLUDE USING gist (c WITH &amp;&amp;)
);</pre><p>
  </p><p><code class="structname">diskvol1</code>テーブル空間に<code class="structname">cinemas</code>テーブルを作成します。

</p><pre class="programlisting">CREATE TABLE cinemas (
        id serial,
        name text,
        location text
) TABLESPACE diskvol1;</pre><p>
  </p><p>複合型と型付きテーブルを作成します。
</p><pre class="programlisting">CREATE TYPE employee_type AS (name text, salary numeric);

CREATE TABLE employees OF employee_type (
    PRIMARY KEY (name),
    salary WITH OPTIONS DEFAULT 1000
);</pre><p>範囲パーティションテーブルを作成します。
</p><pre class="programlisting">CREATE TABLE measurement (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);</pre><p>パーティションキーに複数の列がある範囲パーティションテーブルを作成します。
</p><pre class="programlisting">CREATE TABLE measurement_year_month (
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));</pre><p>リストパーティションテーブルを作成します。
</p><pre class="programlisting">CREATE TABLE cities (
    city_id      bigserial not null,
    name         text not null,
    population   bigint
) PARTITION BY LIST (left(lower(name), 1));</pre><p>範囲パーティションテーブルのパーティションを作成します。
</p><pre class="programlisting">CREATE TABLE measurement_y2016m07
    PARTITION OF measurement (
    unitsales DEFAULT 0
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');</pre><p>パーティションキーに複数の列がある範囲パーティションテーブルに、パーティションをいくつか作成します。
</p><pre class="programlisting">CREATE TABLE measurement_ym_older
    PARTITION OF measurement_year_month
    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);

CREATE TABLE measurement_ym_y2016m11
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 11) TO (2016, 12);

CREATE TABLE measurement_ym_y2016m12
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2016, 12) TO (2017, 01);

CREATE TABLE measurement_ym_y2017m01
    PARTITION OF measurement_year_month
    FOR VALUES FROM (2017, 01) TO (2017, 02);</pre><p>リストパーティションテーブルのパーティションを作成します。
</p><pre class="programlisting">CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b');</pre><p>リストパーティションテーブルにパーティションを作成しますが、それ自体がさらにパーティションになり、それにパーティションを追加します。
</p><pre class="programlisting">CREATE TABLE cities_ab
    PARTITION OF cities (
    CONSTRAINT city_id_nonzero CHECK (city_id != 0)
) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);

CREATE TABLE cities_ab_10000_to_100000
    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);</pre></div><div class="refsect1" id="SQL-CREATETABLE-COMPATIBILITY"><h2>互換性</h2><p><code class="command">CREATE TABLE</code>は、以下に挙げるものを除いて、標準<acronym class="acronym">SQL</acronym>に従います。
  </p><div class="refsect2" id="id-1.9.3.81.9.3"><h3>一時テーブル</h3><p><code class="literal">CREATE TEMPORARY TABLE</code>は標準SQLに類似していますが、その効果は同じではありません。
標準では、一時テーブルは一度だけ定義され、それを必要とするセッションごとに自動的に（空の内容で始まる形で）出現します。
<span class="productname">PostgreSQL</span>では、これと異なり、各セッションで独自に、使用する一時テーブル用の<code class="literal">CREATE TEMPORARY TABLE</code>コマンドを発行しなければなりません。
これにより、異なるセッションで同じ名前の一時テーブルを異なる目的で使用することができます。
一方、標準の方法では、ある一時テーブル名を持つインスタンスが、全て同一のテーブル構造を持つという制限があります。
   </p><p>標準における一時テーブルの動作定義の多くは無視されています。
この点での<span class="productname">PostgreSQL</span>の動作は、他の多くのSQLデータベースと似ています。
   </p><p>また標準SQLではグローバル一時テーブルとローカル一時テーブルを区別しています。
ローカル一時テーブルは各セッション内のSQLモジュールそれぞれ用に内容の集合を分離しますが、その定義はセッション全体で共有されます。
<span class="productname">PostgreSQL</span>はSQLモジュールをサポートしませんので、<span class="productname">PostgreSQL</span>ではこの区別は適切ではありません。
   </p><p>互換性を保持するため、<span class="productname">PostgreSQL</span>は一時テーブルの宣言において<code class="literal">GLOBAL</code>と<code class="literal">LOCAL</code>キーワードを受け付けますが、これらには現在、何の効果もありません。
<span class="productname">PostgreSQL</span>の今後のバージョンでは、これらの意味についてより標準に近い実装を取り入れる可能性がありますので、これらのキーワードの使用は勧めません。
   </p><p>一時テーブル用の<code class="literal">ON COMMIT</code>句もまた、標準SQLに類似していますが、いくつか違いがあります。
<code class="literal">ON COMMIT</code>句が省略された場合、SQLでは、デフォルトの動作は<code class="literal">ON COMMIT DELETE ROWS</code>であると規定しています。
しかし、<span class="productname">PostgreSQL</span>でのデフォルトの動作は<code class="literal">ON COMMIT PRESERVE ROWS</code>です。
また、<code class="literal">ON COMMIT DROP</code>はSQLにはありません。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.4"><h3>非遅延一意性制約</h3><p><code class="literal">UNIQUE</code>または<code class="literal">PRIMARY KEY</code>制約が非遅延の場合、<span class="productname">PostgreSQL</span>は行が挿入または変更されると即座に一意性を検査します。
標準SQLでは一意性は文が完了した時にのみ強制されなければならないと記述しています。
これにより、たとえば、1つのコマンドが複数のキー値を更新する時に違いが現れます。
標準互換の動作をさせるためには、非遅延（つまり<code class="literal">INITIALLY IMMEDIATE</code>）ではなく<code class="literal">DEFERRABLE</code>として制約を宣言してください。
これが即座に行われる一意性検査よりかなり低速になる可能性があることに注意してください。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.5"><h3>列検査制約</h3><p>標準SQLでは、<code class="literal">CHECK</code>列制約はそれを適用する列のみを参照でき、複数の列を参照できるのは<code class="literal">CHECK</code>テーブル制約のみであるとされています。
<span class="productname">PostgreSQL</span>にはこの制限はありません。
列検査制約とテーブル検査制約を同様のものとして扱っています。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.6"><h3><code class="literal">EXCLUDE</code>制約</h3><p><code class="literal">EXCLUDE</code>という種類の制約は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.7"><h3><code class="literal">NULL</code> <span class="quote">“<span class="quote">制約</span>”</span></h3><p><code class="literal">NULL</code><span class="quote">“<span class="quote">制約</span>”</span>（実際には非制約）は、標準SQLに対する<span class="productname">PostgreSQL</span>の拡張で、他のいくつかのデータベースシステムとの互換性（および <code class="literal">NOT NULL</code>制約との対称性）のために含まれています。
どんな列に対してもデフォルトとなるため、これには意味はありません。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.8"><h3>継承</h3><p><code class="literal">INHERITS</code>句による複数継承は、<span class="productname">PostgreSQL</span>の言語拡張です。
SQL:1999以降では、異なる構文と意味体系による単一継承を定義しています。
今のところ、SQL:1999方式の継承は<span class="productname">PostgreSQL</span>ではサポートされていません。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.9"><h3>列を持たないテーブル</h3><p><span class="productname">PostgreSQL</span>では、列を持たないテーブルを作成することができます
（例えば、<code class="literal">CREATE TABLE foo();</code>）。
これは標準SQLからの拡張です。
標準SQLでは列を持たないテーブルは許されません。
列を持たないテーブルそれ自体は役に立ちませんが、これを無効とすると、<code class="command">ALTER TABLE DROP COLUMN</code>に対して奇妙な特例を生成することになります。
したがって、この仕様上の制限を無視する方が簡潔であると考えます。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.10"><h3>複数のIDENTITY列</h3><p><span class="productname">PostgreSQL</span>ではテーブルに2つ以上のIDENTITY列を持つことを許しています。
標準SQLでは、1つのテーブルは最大で1つのIDENTITY列を持つことができると規定しています。
主にスキーマの変更や移行でより柔軟性を持たせるために、この制約を緩和しています。
<code class="command">INSERT</code>コマンドはOVERRIDING句を1つだけしかサポートせず、これが文全体に適用されるため、複数のIDENTITY列があり、これらの動作が異なる場合は正しくサポートされないことに注意してください。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.11"><h3><code class="literal">LIKE</code>句</h3><p><code class="literal">LIKE</code>句は標準SQLにありますが、<span class="productname">PostgreSQL</span>で利用可能な多くのオプションは標準にはなく、また標準のオプションの一部は<span class="productname">PostgreSQL</span>では実装されていません。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.12"><h3><code class="literal">WITH</code>句</h3><p><code class="literal">WITH</code>句は<span class="productname">PostgreSQL</span>の拡張です。
格納パラメータもOIDも標準にはありません。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.13"><h3>テーブル空間</h3><p><span class="productname">PostgreSQL</span>のテーブル空間の概念は標準にはありません。
したがって、<code class="literal">TABLESPACE</code>と<code class="literal">USING INDEX TABLESPACE</code>は、<span class="productname">PostgreSQL</span>における拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.14"><h3>型付きテーブル</h3><p>型付きテーブルは標準SQLのサブセットを実装します。
標準に従うと、型付きテーブルは背後の複合型に対応した列の他に<span class="quote">“<span class="quote">自己参照列</span>”</span>という列も持ちます。
PostgreSQLはこうした自己参照列を明示的にサポートしません。
しかし、OID機能を使用して同様の効果を持たせることができます。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.15"><h3><code class="literal">PARTITION BY</code>句</h3><p><code class="literal">PARTITION BY</code>は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div><div class="refsect2" id="id-1.9.3.81.9.16"><h3><code class="literal">PARTITION OF</code>句</h3><p><code class="literal">PARTITION OF</code>句は<span class="productname">PostgreSQL</span>の拡張です。
   </p></div></div><div class="refsect1" id="id-1.9.3.81.10"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>, <a class="xref" href="sql-droptable.html" title="DROP TABLE"><span class="refentrytitle">DROP TABLE</span></a>, <a class="xref" href="sql-createtableas.html" title="CREATE TABLE AS"><span class="refentrytitle">CREATE TABLE AS</span></a>, <a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>, <a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-createsubscription.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createtableas.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE SUBSCRIPTION </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE TABLE AS</td></tr></table></div></body></html>