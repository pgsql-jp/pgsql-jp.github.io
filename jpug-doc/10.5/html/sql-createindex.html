<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CREATE INDEX</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-creategroup.html" title="CREATE GROUP" /><link rel="next" href="sql-createlanguage.html" title="CREATE LANGUAGE" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">CREATE INDEX</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-creategroup.html" title="CREATE GROUP">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQLコマンド">Up</a></td><th width="60%" align="center">SQLコマンド</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-createlanguage.html" title="CREATE LANGUAGE">Next</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-CREATEINDEX"><div class="titlepage"></div><a id="id-1.9.3.66.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">CREATE INDEX</span></h2><p>CREATE INDEX — 新しいインデックスを定義する
  </p></div><div class="refsynopsisdiv"><h2>Synopsis</h2><pre class="synopsis">CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <em class="replaceable"><code>name</code></em> ] ON <em class="replaceable"><code>table_name</code></em> [ USING <em class="replaceable"><code>method</code></em> ]
    ( { <em class="replaceable"><code>column_name</code></em> | ( <em class="replaceable"><code>expression</code></em> ) } [ COLLATE <em class="replaceable"><code>collation</code></em> ] [ <em class="replaceable"><code>opclass</code></em> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <em class="replaceable"><code>storage_parameter</code></em> = <em class="replaceable"><code>value</code></em> [, ... ] ) ]
    [ TABLESPACE <em class="replaceable"><code>tablespace_name</code></em> ]
    [ WHERE <em class="replaceable"><code>predicate</code></em> ]</pre></div><div class="refsect1" id="id-1.9.3.66.5"><h2>説明</h2><p><code class="command">CREATE INDEX</code>は、指定したリレーションの指定した列(複数可)に対するインデックスを作ります。
リレーションとしてテーブルまたはマテリアライズドビューを取ることができます。
インデックスは主にデータベースの性能を向上するために使われます
（しかし、インデックスの不適切な使用は性能の低下につながる可能性があります）。
  </p><p>インデックスのキーフィールドは、列名、または括弧に囲まれた式として指定されます。
インデックスメソッドが複数列に対するインデックスをサポートする場合は、複数のフィールドを指定できます。
  </p><p>インデックスのフィールドとして、テーブル行の1つ以上の列の値から計算する式を指定できます。
この機能は、元のデータに何らかの変換を加えた値を基とするデータへの高速なアクセスを行う手段として使用することができます。
例えば、<code class="literal">upper(col)</code>という計算に基づくインデックスがあれば、<code class="literal">WHERE upper(col) = 'JIM'</code>という句ではインデックスを使用することができます。
  </p><p><span class="application">PostgreSQL</span>はB-tree、ハッシュ、GiST、SP-GiST、GIN、BRINのインデックスメソッドを用意しています。
ユーザが独自にインデックスメソッドを定義することもできますが、これはかなり複雑です。
  </p><p><code class="literal">WHERE</code>句が存在する場合、<em class="firstterm">部分インデックス</em>が作成されます。
部分インデックスは、テーブルの一部、通常は、テーブルの中でよりインデックスが有用な部分のみのエントリを持つインデックスです。
例えば、請求済みの注文と未請求の注文を情報として持つテーブルがあり、テーブル全体における未請求の注文の割合が小さく、かつ、頻繁に使用される場合、未請求の注文のみにインデックスを作成することで性能を向上できます。
部分インデックスのその他の利用方法として、<code class="command">UNIQUE</code>付きの<code class="command">WHERE</code>を使用して、テーブルの部分集合に一意性を強制する例が考えられます。
詳細は<a class="xref" href="indexes-partial.html" title="11.8. 部分インデックス">Section 11.8</a>を参照してください。
  </p><p><code class="literal">WHERE</code>句内の式では、元となるテーブルの列のみを参照できます。
しかし、インデックスを付加する列だけではなく、全ての列を使用することができます。
また、現在、副問い合わせと集約式については、<code class="command">WHERE</code>で使用することができません。
同一の制限は、式で表されたインデックスのフィールドにも適用されます。
  </p><p>インデックスの定義で使用される全ての関数と演算子は、<span class="quote">“<span class="quote">不変</span>”</span>（immutable）でなければなりません。
つまり、結果は入力引数にのみに依存し、（他のテーブルの内容や現時刻などの）外部からの影響を受けてはなりません。
この制限によって、インデックスの動作が十分定義されていることが保証されます。
インデックス式や<code class="literal">WHERE</code>句にユーザ定義の関数を使用する場合、関数を作成する際、IMMUTABLE（不変）オプションを付けることを忘れないでください。
  </p></div><div class="refsect1" id="id-1.9.3.66.6"><h2>パラメータ</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">UNIQUE</code></span></dt><dd><p>インデックスを（既にデータがある状態で）作成する時、およびテーブルにデータを追加する時に、テーブル内の値が重複していないかを検査します。
重複エントリを生じるデータの挿入または更新はエラーとなります。
       </p></dd><dt><span class="term"><code class="literal">CONCURRENTLY</code></span></dt><dd><p>このオプションを使用すると、<span class="productname">PostgreSQL</span>は、対象テーブルに対する同時挿入、更新、削除を防止するようなロックを獲得せずにインデックスを作成します。
通常のインデックス作成処理では、完了するまで対象テーブルへの書き込みはできません（読み取りは可能です）。
このオプションを使用する際に注意しなければならない点が複数あります。
<a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY" title="インデックスの同時作成">インデックスの同時作成</a>を参照してください。
       </p></dd><dt><span class="term"><code class="literal">IF NOT EXISTS</code></span></dt><dd><p>同じ名前のリレーションが既に存在している場合にエラーとしません。
この場合、注意が発行されます。
既存のインデックスが、作成されようとしていたものと類似のものである保証は全くないことに注意してください。
<code class="literal">IF NOT EXISTS</code>を指定する場合はインデックス名が必須です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>作成するインデックスの名前です。
この名前には、スキーマ名を含めることはできません。
インデックスは、常にその親テーブルと同じスキーマに作成されます。
この名前を省略すると、<span class="productname">PostgreSQL</span>はその親テーブルの名前とインデックス付けされる列名に基づいた適切な名前を選びます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>インデックスを作成するテーブルの名前です（スキーマ修飾名の場合もあります）。
       </p></dd><dt><span class="term"><em class="replaceable"><code>method</code></em></span></dt><dd><p>使用するインデックスメソッドの名前です。
<code class="literal">btree</code>、<code class="literal">hash</code>、<code class="literal">gist</code>、<code class="literal">spgist</code>、<code class="literal">gin</code>、<code class="literal">brin</code>から選択します。
デフォルトのメソッドは<code class="literal">btree</code>です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>テーブルの列の名前です。
       </p></dd><dt><span class="term"><em class="replaceable"><code>expression</code></em></span></dt><dd><p>テーブル上の1つ以上の列を使用した式です。
通常この式は、構文で示した通り括弧で囲む必要があります。
しかし、式が関数呼び出し形式になっている場合は括弧を省略することができます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>collation</code></em></span></dt><dd><p>インデックスで使用する照合順序の名前です。
デフォルトではインデックスはインデックス付け対象の列で宣言された照合順序またはインデックス付け対象の式の結果の照合順序を使用します。
デフォルト以外の照合順序を使用する式を含む問い合わせで、デフォルト以外の照合順序を持つインデックスが有用になるかもしれません。
       </p></dd><dt><span class="term"><em class="replaceable"><code>opclass</code></em></span></dt><dd><p>演算子クラスの名前です。詳細は下記を参照してください。
       </p></dd><dt><span class="term"><code class="literal">ASC</code></span></dt><dd><p>正方向のソート順を指定します(これがデフォルトです)。
       </p></dd><dt><span class="term"><code class="literal">DESC</code></span></dt><dd><p>逆方向のソート順を指定します。
       </p></dd><dt><span class="term"><code class="literal">NULLS FIRST</code></span></dt><dd><p>NULLを非NULLより前にソートすることを指定します。
これは<code class="literal">DESC</code>が指定された場合のデフォルトです。
       </p></dd><dt><span class="term"><code class="literal">NULLS LAST</code></span></dt><dd><p>NULLを非NULLより後にソートすることを指定します。
これは<code class="literal">DESC</code>が指定されない場合のデフォルトです。
       </p></dd><dt><span class="term"><em class="replaceable"><code>storage_parameter</code></em></span></dt><dd><p>インデックスメソッド固有の格納パラメータの名前です。
<a class="xref" href="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS" title="インデックス格納パラメータ">インデックス格納パラメータ</a>を参照してください。
       </p></dd><dt><span class="term"><em class="replaceable"><code>tablespace_name</code></em></span></dt><dd><p>インデックスを生成するテーブル空間です。
指定されなかった場合、<a class="xref" href="runtime-config-client.html#GUC-DEFAULT-TABLESPACE">default_tablespace</a>、もし一時テーブル上のインデックスであれば、<a class="xref" href="runtime-config-client.html#GUC-TEMP-TABLESPACES">temp_tablespaces</a>が考慮されます。
       </p></dd><dt><span class="term"><em class="replaceable"><code>predicate</code></em></span></dt><dd><p>部分インデックス用の制約式です。
       </p></dd></dl></div><div class="refsect2" id="SQL-CREATEINDEX-STORAGE-PARAMETERS"><h3>インデックス格納パラメータ</h3><p><code class="literal">WITH</code>句を使うと、インデックスの<em class="firstterm">格納パラメータ</em>を指定できます。
インデックスメソッドはそれぞれ固有の設定可能な格納パラメータを持ちます。
B-tree、ハッシュ、GiSTおよびSP-GiSTといったインデックスはすべて次のパラメータを受け付けます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">fillfactor</code></span></dt><dd><p>インデックス用のフィルファクタは割合（パーセント）で、インデックスメソッドがインデックスページをまとめ上げる時にどの程度ページを使用するかを決定するものです。
B-treeでは、リーフページは初期インデックス構築時と右側（新しい最大キー値を追加する方向）にインデックスを拡張する時にこの割合分までページを使用します。
その後ページすべてが完全に使用されると分割され、インデックスの効果が徐々に劣化します。
B-treeのデフォルトのフィルファクタは90ですが、10から100までの任意の整数値を設定することができます。
テーブルが静的な場合、100が最善でインデックスの物理サイズを最小化できます。
更新が非常に多い場合は、ページ分割の頻度を少なくするために、より小さなフィルファクタを設定する方が良いです。
この他のインデックスメソッドでは、フィルファクタを異なる意味で使用しますが、おおよそは同じです。
メソッドによってフィルファクタのデフォルト値は異なります。
     </p></dd></dl></div><p>GiSTインデックスではさらに以下のパラメータを受け付けます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">buffering</code></span></dt><dd><p><a class="xref" href="gist-implementation.html#GIST-BUFFERING-BUILD" title="62.4.1. バッファ付きGiST構築">Section 62.4.1</a>で説明するバッファリング構築技術をインデックスを構築する時に使用するかどうかを決定します。
<code class="literal">OFF</code>で無効に、<code class="literal">ON</code>で有効になります。
また<code class="literal">AUTO</code>と指定すると、最初は無効ですが、
インデックスサイズが<a class="xref" href="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE">effective_cache_size</a>に達した後はその場で有効になります。
デフォルトは<code class="literal">AUTO</code>です。
    </p></dd></dl></div><p>GINインデックスでは以下の異なるパラメータを受け付けます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">fastupdate</code></span></dt><dd><p>この設定は<a class="xref" href="gin-implementation.html#GIN-FAST-UPDATE" title="64.4.1. GIN高速更新手法">Section 64.4.1</a>で説明する高速更新技法を使用するかどうかを制御します。
これは論理値パラメータであり、<code class="literal">ON</code>は高速更新を有効に、<code class="literal">OFF</code>は無効にします。
（<a class="xref" href="config-setting.html" title="19.1. パラメータの設定">Section 19.1</a>の説明のように、<code class="literal">ON</code>や<code class="literal">OFF</code>と異なる記載も可能です。）
デフォルトは<code class="literal">ON</code>です。
    </p><div class="note"><h3 class="title">Note</h3><p><code class="command">ALTER INDEX</code>を使用して<code class="literal">fastupdate</code>を無効にすることにより、以後の挿入は待機中のインデックス項目リストに入らないようになります。
しかし、このコマンド自体はこれまでの項目を吐き出しません。
確実に待機中のリストを空にするためには、続いてテーブルを<code class="command">VACUUM</code>するか、<code class="function">gin_clean_pending_list</code>関数を呼び出すのが良いでしょう。
     </p></div></dd></dl></div><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">gin_pending_list_limit</code></span></dt><dd><p><a class="xref" href="runtime-config-client.html#GUC-GIN-PENDING-LIST-LIMIT">gin_pending_list_limit</a>のカスタムパラメータです。
値はキロバイト単位で指定します。
    </p></dd></dl></div><p><acronym class="acronym">BRIN</acronym>インデックスは別のパラメータを受け入れます。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">pages_per_range</code></span></dt><dd><p><acronym class="acronym">BRIN</acronym>インデックスの各エントリについて1つのブロックレンジを構成するテーブルブロックの数を定義します（詳しくは<a class="xref" href="brin-intro.html" title="65.1. はじめに">Section 65.1</a>参照）。
デフォルトは<code class="literal">128</code>です。
    </p></dd><dt><span class="term"><code class="literal">autosummarize</code></span></dt><dd><p>次のページへの挿入が検知された時に、いつでも直前のページに対してサマリー処理を起動するかどうかを定義します。
    </p></dd></dl></div></div><div class="refsect2" id="SQL-CREATEINDEX-CONCURRENTLY"><h3>インデックスの同時作成</h3><a id="id-1.9.3.66.6.4.2" class="indexterm"></a><p>インデックスの作成が、通常のデータベース操作に影響を与えることがあります。
通常<span class="productname">PostgreSQL</span>は、対象テーブルに対する書き込みをロックしてから、対象テーブル全体のインデックス作成を一度のスキャンで行います。
他のトランザクションはテーブルを読み取ることはできますが、対象テーブル内の行を挿入、更新、削除しようとすると、インデックス作成が完了するまでブロックされます。
実行中の運用状態のデータベースシステムの場合、これは重大な影響を与える可能性があります。
非常に大規模なテーブルに対するインデックス作成は何時間もかかることがあり得ます。
また小規模なテーブルであっても、インデックス作成により、運用状態のシステムとしては受け入れられないほど長い時間、書き込みロックがかかる可能性があります。
   </p><p><span class="productname">PostgreSQL</span>は書き込みをロックしないインデックス作成もサポートしています。
<code class="command">CREATE INDEX</code>に<code class="literal">CONCURRENTLY</code>オプションをつけることでこの方式が行われます。
このオプションを使うと、<span class="productname">PostgreSQL</span>はテーブルを2回スキャンしなければなりません。
さらに、潜在的にそのインデックスを更新または使用する可能性がある、実行中のすべてのトランザクションが終わるまで待機しなければなりません。
したがって、この方式は通常の方式よりも総作業時間がかかり、また、完了するまでの時間が非常に長くなります。
しかし、インデックス作成中に通常の操作を行い続けることができますので、この方式は運用環境での新規インデックス作成に有用です。
もちろん、インデックス作成によりCPUや入出力に余分に負荷がかかりますので、他の操作が低速になる可能性があります。
   </p><p>同時実行インデックス構築では実際には、1つのトランザクションでシステムカタログに登録され、さらに2つのトランザクションで２つのテーブルスキャンが起こります。
各テーブルスキャンの前に、インデックス構築はテーブルを修正した実行中のトランザクションが終了するのを待たなければなりません。
2回目のスキャンの後、インデックス構築は2回目のスキャンより前のスナップショット（<a class="xref" href="mvcc.html" title="Chapter 13. 同時実行制御">Chapter 13</a>参照）を持つすべてのトランザクションが終了するのを待たなければなりません。
その後でようやく、インデックスは利用可能であると印が付けられ、<code class="command">CREATE INDEX</code>コマンドが終了します。
しかし、それでもインデックスは問い合わせに対して即座に利用可能であるとは限りません。
最悪の場合、インデックス構築開始前のトランザクションが存在する間は利用できません。
   </p><p>たとえばデッドロックや一意性インデックスにおける一意性違反など、テーブルスキャン中に問題が発生すると、<code class="command">CREATE INDEX</code>は失敗しますが、<span class="quote">“<span class="quote">無効な</span>”</span>インデックスが残ってしまいます。
こうしたインデックスは完全ではない可能性がありますので、問い合わせの際には無視されます。
しかし、更新時にオーバーヘッドがかかります。
<span class="application">psql</span>の<code class="command">\d</code>コマンドでは、こうしたインデックスを<code class="literal">INVALID</code>として報告します。

</p><pre class="programlisting">postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 col    | integer |           |          | 
Indexes:
    "idx" btree (col) INVALID</pre><p>

こうした場合の推奨復旧方法は、インデックスを削除し、再度<code class="command">CREATE INDEX CONCURRENTLY</code>を実行することです。
（他にも<code class="command">REINDEX</code>を使用したインデックスの再作成という方法もあります。
しかし、<code class="command">REINDEX</code>は同時作成をサポートしていませんので、この方法は魅力がありません。）
   </p><p>この他に一意性インデックスを同時作成する場合の注意事項があります。
2回目のテーブルスキャンが始まる時点で、他のトランザクションに対する一意性制約が既に有効になっているという点です。
これは、インデックスが使用できるようになる前やインデックス作成が最終的に失敗したとしても、制約違反が他のトランザクションで報告されてしまうことを意味します。
また、2回目のスキャン中に失敗した後も、<span class="quote">“<span class="quote">無効な</span>”</span>インデックスによる一意性制約は強制され続けます。
   </p><p>式インデックスや部分インデックスの同時作成もサポートされています。
式の評価中にエラーが発生した場合も、上で説明した一意性制約違反と同様な状況が発生します。
   </p><p>同一テーブルに対する通常のインデックス作成処理は複数並行して行うことができます。
しかし、あるテーブルに対するインデックスの同時作成は一度に1つしか行うことができません。
また、どの場合でもインデックス作成中はテーブルスキーマの変更はできません。
この他に、通常の<code class="command">CREATE INDEX</code>コマンドはトランザクションブロック内で実行させることができますが、<code class="command">CREATE INDEX CONCURRENTLY</code>は実行させることができないという相違点があります。
   </p></div></div><div class="refsect1" id="id-1.9.3.66.7"><h2>注釈</h2><p>インデックスが、どのような時に使用され、どのような時に使用されないか、また、どのような場合に有用かといった情報については<a class="xref" href="indexes.html" title="Chapter 11. インデックス">Chapter 11</a>を参照してください。
  </p><p>現在は、B-tree、GiST、GIN、BRINインデックスメソッドのみが、複数列に対するインデックスをサポートしています。
指定できる列は、デフォルトでは32個までです（この制限は<span class="productname">PostgreSQL</span>のコンパイル時に変更できます）。
現在、B-treeのみが一意性インデックスをサポートしています。
  </p><p><em class="firstterm">演算子クラス</em>は、インデックスのそれぞれの列に指定することができます。
演算子クラスは、その列のインデックスが使う演算子を識別します。
例えば、4バイト整数に対するB-treeインデックスには、<code class="literal">int4_ops</code>クラスを使います。
この演算子クラスには、4バイト整数の比較関数が含まれています。
実際の使用では、通常、列のデータ型のデフォルト演算子クラスで十分です。
演算子クラスを保持する主な理由は、データ型の中には有意な順序を2つ以上持つものがあるかもしれないからです。
例えば、複素数のソートで絶対値または実数部のどちらかを使いたい場合がありえます。
これを実現するには、データ型として2つの演算子クラスを定義し、インデックスを作る時に適切なクラスを選択します。
演算子クラスについての詳細は、<a class="xref" href="indexes-opclass.html" title="11.9. 演算子クラスと演算子族">Section 11.9</a>と<a class="xref" href="xindex.html" title="37.14. インデックス拡張機能へのインタフェース">Section 37.14</a>を参照してください。
  </p><p>順序付きスキャンをサポートするインデックスメソッド（現時点ではB-Treeのみ）では、<code class="literal">ASC</code>、<code class="literal">DESC</code>、<code class="literal">NULLS FIRST</code>、<code class="literal">NULLS LAST</code>句(省略可能)をオプションで指定し、インデックスのソート順を変更することができます。
順序付きインデックスは正方向にも逆方向にもスキャンすることができますので、単一列に対する<code class="literal">DESC</code>インデックスは通常は有用ではありません。
このソート順序はすでに通常のインデックスを使用して実現できます。
これらのオプションの価値は、<code class="literal">SELECT ... ORDER BY x ASC, y DESC</code>などの順序指定が混在する問い合わせによって要求されるソート順に一致する、複数列に対するインデックスを作成できる点です。
<code class="literal">NULLS</code>オプションは、インデックスに基づいた問い合わせにおいてソート処理を省略するために<span class="quote">“<span class="quote">NULLのソート順を低くする</span>”</span>動作をサポートする必要がある場合に有用です。
デフォルトの動作は<span class="quote">“<span class="quote">NULLのソート順を高くする</span>”</span>です。
  </p><p>ほとんどのインデックスメソッドにおいて、インデックス作成速度は<a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>の設定に依存します。
より大きな値を設定すると、インデックス作成に必要となる時間が短縮されます。
ただし、実際に使用できるメモリ量を超えるほど大きくすると、マシンがスワップ状態になり、遅くなります。
  </p><p>インデックスを削除するには、<a class="xref" href="sql-dropindex.html" title="DROP INDEX"><span class="refentrytitle">DROP INDEX</span></a>を使用してください。
  </p><p>以前の<span class="productname">PostgreSQL</span>にはR-treeインデックスメソッドがありました。
GiSTメソッドに比べて大きな利点がありませんでしたので、このメソッドは削除されました。
古いデータベースからGiSTへの変換を簡単にするため、<code class="literal">USING rtree</code>が指定された場合、<code class="command">CREATE INDEX</code>は<code class="literal">USING gist</code>と解釈します。
  </p></div><div class="refsect1" id="id-1.9.3.66.8"><h2>例</h2><p>テーブル<code class="literal">films</code>の列<code class="literal">title</code>にB-treeインデックスを作成します。
</p><pre class="programlisting">CREATE UNIQUE INDEX title_idx ON films (title);</pre><p>
  </p><p>大文字小文字を区別しない検索が効率的になるように、式<code class="literal">lower(title)</code>に対してインデックスを作成します。
</p><pre class="programlisting">CREATE INDEX ON films ((lower(title)));</pre><p>
(この例では、インデックス名を省略することを選びました。
このためシステムが<code class="literal">films_lower_idx</code>などという名前を選ぶことになります。)
  </p><p>デフォルト以外の照合順序でインデックスを作成します。
</p><pre class="programlisting">CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</pre><p>
  </p><p>デフォルトと異なるNULLのソート順を指定したインデックスを作成します。
</p><pre class="programlisting">CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</pre><p>
  </p><p>デフォルトと異なるフィルファクタを持つインデックスを作成します。
</p><pre class="programlisting">CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</pre><p>
  </p><p>高速更新を無効にして<acronym class="acronym">GIN</acronym>インデックスを作成します。
</p><pre class="programlisting">CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);</pre><p>
  </p><p>テーブル<code class="literal">films</code>上の列<code class="literal">code</code>に対するインデックスを作成します。
また、このインデックスをテーブル空間<code class="literal">indexspace</code>内に生成します。
</p><pre class="programlisting">CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</pre><p>
  </p><p>変換関数の結果に対するbox操作を効率的に使用できるようにpoint属性にGiSTインデックスを作成します。
</p><pre class="programlisting">CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</pre><p>
  </p><p>対象テーブルへの書き込みをロックせずにインデックスを作成します。
</p><pre class="programlisting">CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</pre></div><div class="refsect1" id="id-1.9.3.66.9"><h2>互換性</h2><p><code class="command">CREATE INDEX</code>は<span class="productname">PostgreSQL</span>の拡張です。
標準SQLにはインデックスについての規定はありません。
  </p></div><div class="refsect1" id="id-1.9.3.66.10"><h2>関連項目</h2><span class="simplelist"><a class="xref" href="sql-alterindex.html" title="ALTER INDEX"><span class="refentrytitle">ALTER INDEX</span></a>, <a class="xref" href="sql-dropindex.html" title="DROP INDEX"><span class="refentrytitle">DROP INDEX</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-creategroup.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-createlanguage.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">CREATE GROUP </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> CREATE LANGUAGE</td></tr></table></div></body></html>