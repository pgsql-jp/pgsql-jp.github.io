<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.2. プランナで使用される統計情報</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="using-explain.html" title="14.1. EXPLAINの利用" /><link rel="next" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.2. プランナで使用される統計情報</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="using-explain.html" title="14.1. EXPLAINの利用">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="Chapter 14. 性能に関するヒント">Up</a></td><th width="60%" align="center">Chapter 14. 性能に関するヒント</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLANNER-STATS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.2. プランナで使用される統計情報</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="planner-stats.html#id-1.5.13.5.3">14.2.1. 単一列統計情報</a></span></dt><dt><span class="sect2"><a href="planner-stats.html#PLANNER-STATS-EXTENDED">14.2.2. 拡張統計情報</a></span></dt></dl></div><a id="id-1.5.13.5.2" class="indexterm"></a><div class="sect2" id="id-1.5.13.5.3"><div class="titlepage"><div><div><h3 class="title">14.2.1. 単一列統計情報</h3></div></div></div><p>前節で説明した通り、問い合わせプランナは、より良い問い合わせ計画を選択するために問い合わせによって取り出される行数の推定値を必要としています。
本節では、システムがこの推定に使用する統計情報について簡単に説明します。
  </p><p>統計情報の1つの構成要素は、各テーブルとインデックスの項目の総数と、各テーブルとインデックスが占めるディスクブロック数です。
この情報は<a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>の<code class="structfield">reltuples</code>と<code class="structfield">relpages</code>列に保持されます。
以下のような問い合わせによりこれを参照することができます。

</p><pre class="screen">SELECT relname, relkind, reltuples, relpages
FROM pg_class
WHERE relname LIKE 'tenk1%';

       relname        | relkind | reltuples | relpages
----------------------+---------+-----------+----------
 tenk1                | r       |     10000 |      358
 tenk1_hundred        | i       |     10000 |       30
 tenk1_thous_tenthous | i       |     10000 |       30
 tenk1_unique1        | i       |     10000 |       30
 tenk1_unique2        | i       |     10000 |       30
(5 rows)</pre><p>

ここで、<code class="structname">tenk1</code>とそのインデックスには10000行が存在し、そして、（驚くには値しませんが）インデックスはテーブルよりもかなり小さなものであることがわかります。
  </p><p>効率を上げるため、<code class="structfield">reltuples</code>と<code class="structfield">relpages</code>は処理の度には更新されず、したがって通常は多少古い値のみ所有しています。
これらは<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>、<code class="command">CREATE INDEX</code>などの一部のDDLコマンドによって更新されます。
テーブル全体をスキャンしない<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>操作（一般的な状況です）は、スキャンされたテーブルの部分に基づいて<code class="structfield">reltuples</code>値を漸次更新し、概算値を生成します。
いずれの場合でもプランナは、現在の物理的なテーブルサイズに合わせるために<code class="structname">pg_class</code>から検索した値を調整して、より高精度な近似値を得ます。
  </p><a id="id-1.5.13.5.3.5" class="indexterm"></a><p>ほとんどの問い合わせは、検証される行を制限する<code class="literal">WHERE</code>句によって、テーブル内の行の一部のみを取り出します。
したがって、プランナは<code class="literal">WHERE</code>句の<em class="firstterm">選択性</em>、つまり<code class="literal">WHERE</code>句の各条件にどれだけの行が一致するかを推定する必要があります。
この処理に使用される情報は<a class="link" href="catalog-pg-statistic.html" title="51.50. pg_statistic"><code class="structname">pg_statistic</code></a>システムカタログ内に格納されます。
<code class="structname">pg_statistic</code>内の項目は、<code class="command">ANALYZE</code>と<code class="command">VACUUM ANALYZE</code>コマンドによって更新され、また１から更新がかかったとしても常に概算値になります。
  </p><a id="id-1.5.13.5.3.7" class="indexterm"></a><p>統計情報を手作業で確認する場合、<code class="structname">pg_statistic</code>を直接参照するのではなく、<a class="link" href="view-pg-stats.html" title="51.87. pg_stats"><code class="structname">pg_stats</code></a>ビューを参照する方が良いでしょう。
<code class="structname">pg_stats</code>はより読みやすくなるように設計されています。
さらに、<code class="structname">pg_stats</code>は誰でも読み取ることができますが、<code class="structname">pg_statistic</code>はスーパーユーザのみ読み取ることができます。
（これは、非特権ユーザが統計情報から他人のテーブルの内容に関わる事項を読み取ることを防止します。
<code class="structname">pg_stats</code>ビューは現在のユーザが読み取ることができるテーブルに関する行のみを表示するよう制限されています。）
例えば、以下を行うことができます。

</p><pre class="screen">SELECT attname, inherited, n_distinct,
       array_to_string(most_common_vals, E'\n') as most_common_vals
FROM pg_stats
WHERE tablename = 'road';

 attname | inherited | n_distinct |          most_common_vals
---------+-----------+------------+------------------------------------
 name    | f         |  -0.363388 | I- 580                        Ramp+
         |           |            | I- 880                        Ramp+
         |           |            | Sp Railroad                       +
         |           |            | I- 580                            +
         |           |            | I- 680                        Ramp
 name    | t         |  -0.284859 | I- 880                        Ramp+
         |           |            | I- 580                        Ramp+
         |           |            | I- 680                        Ramp+
         |           |            | I- 580                            +
         |           |            | State Hwy 13                  Ramp
(2 rows)</pre><p>

同じ列に対して2行が表示されていることに注意してください。
1つは<code class="literal">road</code>テーブルが始まる継承階層(<code class="literal">inherited</code>=<code class="literal">t</code>)全体に相当し、もう1つは<code class="literal">road</code>テーブル自身(<code class="literal">inherited</code>=<code class="literal">f</code>)のみを含むものです。
  </p><p><code class="command">ANALYZE</code>により<code class="structname">pg_statistic</code>に格納される情報量、具体的には、それぞれの列に対する<code class="structfield">most_common_vals</code>内と<code class="structfield">histogram_bounds</code>配列のエントリの最大数は、<code class="command">ALTER TABLE SET STATISTICS</code>コマンドによって列ごとに、<a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>設定パラメータを設定することによってグローバルに設定することができます。
現在のデフォルトの上限は100エントリです。
この上限を上げることで、特に、少し変わったデータ分布を持つ列でより正確なプランナの推定が行われますが、<code class="structname">pg_statistic</code>により多くの容量が必要になり、多少推定計算にかかる時間が多くなります。
反対に上限を下げることは、単純なデータ分布の列に対して順当です。
  </p><p>プランナによる統計情報の使用に関する詳細については<a class="xref" href="planner-stats-details.html" title="Chapter 68. プランナは統計情報をどのように使用するか">Chapter 68</a>を参照してください。
  </p></div><div class="sect2" id="PLANNER-STATS-EXTENDED"><div class="titlepage"><div><div><h3 class="title">14.2.2. 拡張統計情報</h3></div></div></div><a id="id-1.5.13.5.4.2" class="indexterm"></a><a id="id-1.5.13.5.4.3" class="indexterm"></a><a id="id-1.5.13.5.4.4" class="indexterm"></a><p>問い合わせ句で使われている複数列に相関性があることにより、悪い実行計画を実行する遅いクエリがしばしば観察されます。
プランナは通常複数の条件がお互いに独立あるとみなしますが、列の値に相関性がある場合はそれは成り立ちません。
通常の列ごとの統計情報は、それが個々の列ごとであるという性質上、列をまたがる相関性に関する知識を把握することはできません。
しかしながら、<span class="productname">PostgreSQL</span>は、<em class="firstterm">多変量統計情報</em>を計算することができ、それによってそうした情報を把握することができます。
   </p><p>列の組み合わせの数は非常に大きいため、自動的に多変量統計情報を計算するのは現実的ではありません。
代わりに、サーバが興味のある列の集合にまたがる統計情報を得るように指示する目的で、<em class="firstterm">拡張統計情報オブジェクト</em>（しばしば単に<em class="firstterm">統計情報オブジェクト</em>と呼ばれます）を作成することができます。
   </p><p>統計情報オブジェクトは<a class="xref" href="sql-createstatistics.html" title="CREATE STATISTICS"><span class="refentrytitle">CREATE STATISTICS</span></a>で作成します。
詳細はそちらを参照してください。
そうしたオブジェクトを作っても、単に統計情報として興味があることを示すカタログエントリが作られるだけです。
実際のデータ収集は、<code class="command">ANALYZE</code> （手動のコマンドを起動あるいはバックグラウンドでの自動ANALYZE）が行います。
収集したデータは、<a class="link" href="catalog-pg-statistic-ext.html" title="51.51. pg_statistic_ext"><code class="structname">pg_statistic_ext</code></a>カタログで参照することができます。
   </p><p>通常の単一列統計情報の計算に使うのと同じテーブル行のサンプルに基づき、<code class="command">ANALYZE</code>は、拡張統計情報を計算します。
（前節で述べたように）テーブルあるいはそのテーブルの対象となる列統計情報の増やすと、サンプルのサイズも増えるので、より大きな統計情報の対象を使うと、通常、より精度の高い拡張統計情報を得られますが、計算に費やす時間も増えます。
   </p><p>次の節では、現在サポートしている拡張統計情報の種類を説明します。
   </p><div class="sect3" id="id-1.5.13.5.4.10"><div class="titlepage"><div><div><h4 class="title">14.2.2.1. 関数従属性</h4></div></div></div><p>もっとも単純な拡張統計情報は、データベースの正規形の定義で使われる考え方である、<em class="firstterm">関数従属性</em>を追跡します。
<code class="structfield">a</code>の値に関する知識が<code class="structfield">b</code>の値を決定するのに十分であるとき、列<code class="structfield">b</code>は列<code class="structfield">a</code>に関数的に従属していると言います。
これはすなわち、同じ<code class="structfield">a</code>の値を持ちながら、異なる<code class="structfield">b</code>の値を持つ二つの行は存在しないということです。
完全に正規化されたデータベースでは、関数従属性は主キーと超キーにのみ存在します。
実際には様々な理由でデータの集合は完全には正規化されません。
性能上の理由により非正規化するというのが典型的な例です。
完全に正規化されたデータベースにおいても、ある列の間に部分的な相関関係が存在することがあり、これは部分的関数従属性として表現されます。
    </p><p>ある問い合わせでは、関数従属性が存在することが見積もりの精度に直接影響を与えます。
問い合わせに独立した列と依存する列の両方に関する条件が含まれていると、依存する列に関する条件はそれ以上結果サイズを小さくしません。
しかし関数従属性に関する知識がなければ、クエリプランナはそれらの条件が独立であると見なし、結果サイズの過少見積もりすることになります。
    </p><p>プランナに関数従属性について知らせるために、<code class="command">ANALYZE</code>は列をまたがる依存性の強さを収集することができます。
すべての列の集合間の依存性度合いを調査するのは、受け入れられないほど高価になります。
そこでデータ収集は、<code class="literal">dependencies</code>オプションで定義された統計情報オブジェクトの中に一緒に現れた列のグループに制限されます。
<code class="command">ANALYZE</code>および後々のクエリプランニングにおける不必要なオーバーヘッドを避けるために、強い相関関係のある列のグループのみを対象に、<code class="literal">dependencies</code>統計情報を作成することをお勧めします。
    </p><p>関数従属性統計情報の収集例です。
</p><pre class="programlisting">CREATE STATISTICS stts (dependencies) ON zip, city FROM zipcodes;

ANALYZE zipcodes;

SELECT stxname, stxkeys, stxdependencies
  FROM pg_statistic_ext
  WHERE stxname = 'stts';
 stxname | stxkeys |             stxdependencies               
---------+---------+------------------------------------------
 stts    | 1 5     | {"1 =&gt; 5": 1.000000, "5 =&gt; 1": 0.423130}
(1 row)</pre><p>
ここでは、列1（zip code）が完全に列5（city）を決定しているので、係数は1.0です。
一方、cityはzip codeを42%しか決定していないので、一つ以上のzip codeで表現されている多くのcity(58%)が存在するということになります。
    </p><p>関数従属する列を伴うクエリの選択率を計算する際、過小評価を行わないように、プランナは依存性係数を使って条件ごとの選択率を調整します。
    </p><div class="sect4" id="id-1.5.13.5.4.10.7"><div class="titlepage"><div><div><h5 class="title">14.2.2.1.1. 関数従属性の制限事項</h5></div></div></div><p>今のところ、列と定数を比較する単純な等価条件を考慮する際にしか関数従属性は適用されません。
二つの列を比較する、あるいは列を式と比較する等価条件、範囲句、<code class="literal">LIKE</code>その他の条件の見積もりを改善するのには使われません。
     </p><p>関数従属性による見積もりでは、プランナは関係する列は両立で、冗長であると見なします。
それらが両立でなければ、正しい見積もりは0行となりますが、その可能性は考慮されません。
たとえば次のクエリを見てください。
</p><pre class="programlisting">SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '94105';</pre><p>
プランナは、選択率が変わらないという正しい推定に基づき<code class="structfield">city</code>句を無視します。
しかし、これを満たす行が0行であるにもかかわらず、次の問い合わせでも同じ推測をします。
</p><pre class="programlisting">SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '90210';</pre><p>
関数従属性統計情報は、これを結論付けるだけの十分な情報を提供しません。
     </p><p>多くの実用的な場合には、この前提は通常満たされます。
たとえば、あるアプリケーションには、クエリの中で両立するcityとZIP codeだけを許すGUIが備わっているかもしれません。
もしそうでなければ、関数従属性は実行可能なオプションではないかもしれません。
     </p></div></div><div class="sect3" id="id-1.5.13.5.4.11"><div class="titlepage"><div><div><h4 class="title">14.2.2.2. 多変量N個別値計数</h4></div></div></div><p>単一列統計情報は、それぞれの列で異なる値の数を保持します。
たとえば、<code class="literal">GROUP BY a, b</code>のように、一つ以上の列を組み合わせての異なる値の数の見積もりは、プランナに単一列の統計情報だけしか与えられない場合は、しばしば間違ったものになり、プランナは悪いプランの選択をしてしまいます。
    </p><p>見積もり改善のために、列のグループに対して<code class="command">ANALYZE</code>はN個別統計情報を収集することができます。
以前述べたのと同様に、可能なすべての列のグループに対してこれを行なうのは現実的ではありません。
<code class="literal">ndistinct</code>オプションで定義された統計オブジェクト中に一緒に現れる列のグループに対してのみデータを
収集します。
列リストの中から、可能な二つ以上の列の組み合わせそれぞれに対してデータが収集されます。
    </p><p>先ほどの例の続きで、ZIP codeのテーブルのN個別値計数は次のようになります。
</p><pre class="programlisting">CREATE STATISTICS stts2 (ndistinct) ON zip, state, city FROM zipcodes;

ANALYZE zipcodes;

SELECT stxkeys AS k, stxndistinct AS nd
  FROM pg_statistic_ext
  WHERE stxname = 'stts2';
-[ RECORD 1 ]--------------------------------------------------------
k  | 1 2 5
nd | {"1, 2": 33178, "1, 5": 33178, "2, 5": 27435, "1, 2, 5": 33178}
(1 row)</pre><p>
この例では、33178の異なる値を持つ列の組み合わせが三つあることを示しています。
ZIP codeとstate、ZIP codeとcity、cityとstateです。（これらが等しいという事実は、ZIP codeだけがテーブル中でユニークであることから期待されます。）
一方、cityとstateの組み合わせには、27435だけの異なる値があります。
    </p><p>グループ化で実際に使用する列の組み合わせで、かつグループ数の見積もり間違いによって悪いプランをもたらすものに対してだけ、<code class="literal">ndistinct</code>統計情報オブジェクトを作ることをお勧めします。
さもないと、<code class="command">ANALYZE</code>サイクルは単に無駄になります。
    </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using-explain.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="explicit-joins.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">14.1. <code class="command">EXPLAIN</code>の利用 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 14.3. 明示的な<code class="literal">JOIN</code>句でプランナを制御する</td></tr></table></div></body></html>