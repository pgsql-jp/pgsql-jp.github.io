<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.4. カーネルリソースの管理</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="server-start.html" title="18.3. データベースサーバの起動" /><link rel="next" href="server-shutdown.html" title="18.5. サーバのシャットダウン" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">18.4. カーネルリソースの管理</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="server-start.html" title="18.3. データベースサーバの起動">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Chapter 18. サーバの準備と運用">Up</a></td><th width="60%" align="center">Chapter 18. サーバの準備と運用</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="server-shutdown.html" title="18.5. サーバのシャットダウン">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="KERNEL-RESOURCES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">18.4. カーネルリソースの管理</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="kernel-resources.html#SYSVIPC">18.4.1. 共有メモリとセマフォ</a></span></dt><dt><span class="sect2"><a href="kernel-resources.html#SYSTEMD-REMOVEIPC">18.4.2. systemd RemoveIPC</a></span></dt><dt><span class="sect2"><a href="kernel-resources.html#id-1.6.5.6.5">18.4.3. リソースの制限</a></span></dt><dt><span class="sect2"><a href="kernel-resources.html#LINUX-MEMORY-OVERCOMMIT">18.4.4. Linuxのメモリオーバーコミット</a></span></dt><dt><span class="sect2"><a href="kernel-resources.html#LINUX-HUGE-PAGES">18.4.5. LinuxのHugePages</a></span></dt></dl></div><p><span class="productname">PostgreSQL</span>は、特に同一システム上で複数のサーバコピーを実行している場合や非常に大規模なインストレーションでは、オペレーティングシステムの様々なリソース制限を超えてしまうことがあります。
本節では、<span class="productname">PostgreSQL</span>で使用されるカーネルリソース、およびカーネルリソース消費に関連した問題を解消する時に取ることができる手順について説明します。
  </p><div class="sect2" id="SYSVIPC"><div class="titlepage"><div><div><h3 class="title">18.4.1. 共有メモリとセマフォ</h3></div></div></div><a id="id-1.6.5.6.3.2" class="indexterm"></a><a id="id-1.6.5.6.3.3" class="indexterm"></a><p><span class="productname">PostgreSQL</span>はオペレーティングシステムが、プロセス間通信(<acronym class="acronym">IPC</acronym>)特に共有メモリとセマフォ機能を提供することを要求します。
Unix（派生）システムでは、<span class="quote">“<span class="quote"><span class="systemitem">System V</span></span>”</span> <acronym class="acronym">IPC</acronym>や、<span class="quote">“<span class="quote"><span class="systemitem">POSIX</span></span>”</span> <acronym class="acronym">IPC</acronym>、またはその両方を提供します。
<span class="systemitem">Windows</span>は、これらの機能を独自で実装しているため、ここでは説明しません。
   </p><p>これらの機能の完全な欠落は、サーバ起動時の<span class="quote">“<span class="quote"><span class="errorname">Illegal system call</span></span>”</span>エラーによって判明します。
その場合はカーネルを設定し直すしかありません。
<span class="productname">PostgreSQL</span>はこれらの機能なしでは動きません。
しかし最近のオペレーティングシステムではこうした状況はまれなものです。
   </p><p>サーバの起動時、<span class="productname">PostgreSQL</span>は通常、非常に少量のSystem V共有メモリと、もっと大量のPOSIX (<code class="function">mmap</code>)共有メモリを持ちます。
さらに、System V又はPOSIXスタイルのどちらかのセマフォがサーバの起動時に作成されます。
現在、LinuxとFreeBSDシステムではPOSIXセマフォが使用され、それ以外のプラットフォームではSystem Vセマフォが使用されます。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span> 9.3より前では、System V共有メモリだけが使用されていたので、サーバを起動させるために必要なSystem V共有メモリの量は非常に大きなものでした。
より古いバージョンのサーバで実行しているのであれば、該当するバージョンのサーバの文書を参照してください。
    </p></div><p>System V <acronym class="acronym">IPC</acronym>機能は、通常システム全体の割り当て制限に制約されます。
<span class="productname">PostgreSQL</span>がこれらの制限のいずれかを超えると、サーバは起動を拒否し、問題および何をすべきかを説明するエラーメッセージを残します。
（<a class="xref" href="server-start.html#SERVER-START-FAILURES" title="18.3.1. サーバ起動の失敗">Section 18.3.1</a> も参照してください。）
関係するカーネルパラメータは別々のシステム上でも統一して名付けられています。
<a class="xref" href="kernel-resources.html#SYSVIPC-PARAMETERS" title="Table 18.1. System V IPCパラメータ">Table 18.1</a>で概略がわかります。
しかしこれらを設定するための方法は異なります。
以下に、いくつかのプラットフォームへの提案を挙げます。
   </p><div class="table" id="SYSVIPC-PARAMETERS"><p class="title"><strong>Table 18.1. <span class="systemitem">System V</span> <acronym class="acronym">IPC</acronym>パラメータ</strong></p><div class="table-contents"><table class="table" summary="System V IPCパラメータ" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名前</th><th>説明</th><th>一つの<span class="productname">PostgreSQL</span>インスタンスに必要な値</th></tr></thead><tbody><tr><td><code class="varname">SHMMAX</code></td><td>共有メモリセグメントの最大サイズ（バイト）</td><td>最小でも1キロバイト（ただしデフォルトはもっと多くなっています）</td></tr><tr><td><code class="varname">SHMMIN</code></td><td>共有メモリセグメントの最小サイズ（バイト）</td><td>1</td></tr><tr><td><code class="varname">SHMALL</code></td><td>使用可能な共有メモリの総量（バイトまたはページ）</td><td>バイト指定の場合は<code class="varname">SHMMAX</code>と同じ。ページ指定の場合は<code class="literal">ceil(SHMMAX/PAGE_SIZE)</code>。 + 他のアプリケーション用の空間</td></tr><tr><td><code class="varname">SHMSEG</code></td><td>プロセスごとの共有メモリセグメントの最大数</td><td>必要なのは1セグメントのみ（ただしデフォルトはもっと多くなっています）</td></tr><tr><td><code class="varname">SHMMNI</code></td><td>システム全体の共有メモリセグメントの最大数</td><td><code class="varname">SHMSEG</code>と同様 + 他のアプリケーション用の空間</td></tr><tr><td><code class="varname">SEMMNI</code></td><td>セマフォ識別子の最大数（つまりセット）</td><td>最低<code class="literal">ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</code> + 他のアプリケーション用の空間</td></tr><tr><td><code class="varname">SEMMNS</code></td><td>システム全体のセマフォの最大数</td><td><code class="literal">ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16) * 17</code> + 他のアプリケーション用の空間</td></tr><tr><td><code class="varname">SEMMSL</code></td><td>セットごとのセマフォの最大数</td><td>最低17</td></tr><tr><td><code class="varname">SEMMAP</code></td><td>セマフォマップの中の項目の数</td><td>本文を参照</td></tr><tr><td><code class="varname">SEMVMX</code></td><td>セマフォの最大値</td><td>最低1000（デフォルトはしばしば32767ですが、必要がなければ変更しないでください）</td></tr></tbody></table></div></div><br class="table-break" /><p><span class="productname">PostgreSQL</span>は、サーバのコピー毎にSystem V共有メモリの数バイト（64ビットプラットフォームでは通常48バイト）を必要とします。
最近のほとんどのオペレーティングシステムでは、このくらいの量は簡単に割り当てられます。
しかし複数のサーバのコピーを実行している場合やSystem V共有メモリを使用する他のアプリケーションを実行している場合は、システム全体のSystem V共有メモリである<code class="varname">SHMALL</code>を増加させる必要があるかもしれません。
多くのシステムでは<code class="varname">SHMALL</code>をバイト単位ではなくページ単位で測ることに注意してください。
   </p><p>問題が少ないのは共有メモリセグメントの最小サイズ（<code class="varname">SHMMIN</code>）で、<span class="productname">PostgreSQL</span>では最大でもおよそ32バイトのはずです（通常では1です）。
システム全体のセグメントの最大数（<code class="varname">SHMMNI</code>）もしくはプロセスごとのセグメントの最大数（<code class="varname">SHMSEG</code>）に関して、使用しているシステムで0に設定されていない限り、問題が起きることはほぼありません。
   </p><p>System V セマフォを使用している場合、<span class="productname">PostgreSQL</span>は、許可した接続（<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>）、許可したオートバキュームワーカプロセス（<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a>）、許可したバックエンドプロセス(<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>)ごとに1つのセマフォを使用し、16個のセマフォをセットとして扱います。
それぞれそのようなセットは、他のアプリケーションに使われているセマフォセットとの衝突を検出するための<span class="quote">“<span class="quote">マジックナンバー</span>”</span>が含まれている17個目のセマフォを持っています。
システム内のセマフォの最大数は<code class="varname">SEMMNS</code>によって設定され、その結果としてその値は少なくとも<code class="varname">max_connections</code>＋<code class="varname">autovacuum_max_workers</code>＋<code class="varname">max_worker_processes</code>と同じ、ただし、許可された接続とワーカ16個ごとに余分な1個を加えた値以上はなければいけません（<a class="xref" href="kernel-resources.html#SYSVIPC-PARAMETERS" title="Table 18.1. System V IPCパラメータ">Table 18.1</a>の公式を参照してください）。
<code class="varname">SEMMNI</code>パラメータはシステム上に同時に存在できるセマフォ集合の数の上限を決定します。
ですから、このパラメータは少なくとも<code class="literal">ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</code>以上はなくてはいけません。
一時的な失敗の回避策としては許可される接続の数を下げることができますが、<span class="quote">“<span class="quote">No space left on device</span>”</span>という紛らわしい言葉が<code class="function">semget</code>関数から表示されます。
   </p><p>場合によっては<code class="varname">SEMMAP</code>を少なくとも<code class="varname">SEMMNS</code>と同程度に増やすことが必要になる場合があるかもしれません。
このパラメータはセマフォリソースマップのサイズを定義し、その中では有効なセマフォのそれぞれの隣接したブロックの項目が必要です。
セマフォ集合が解放されると、解放されたブロックに隣接する既に存在する項目に追加されるか、もしくは新しいマップの項目の下に登録されます。
もしマップが一杯だった場合、解放されたセマフォは（再起動するまで）失われます。
セマフォ空間の断片化により時間が経つごとに、有効なセマフォがあるべき量よりも少なくなる可能性があります。
   </p><p><code class="varname">SEMMNU</code>と<code class="varname">SEMUME</code>のような、その他の様々な<span class="quote">“<span class="quote">semaphore undo</span>”</span>に関する設定は<span class="productname">PostgreSQL</span>には影響を与えません。
   </p><p>POSIXセマフォを使用している場合、System Vと同じ数のセマフォを必要とします。
つまり、許可した接続（<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>）、許可したオートバキュームワーカプロセス（<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a>）、許可したバックエンドプロセス(<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>)ごとに1つのセマフォを使用します。
このオプションが優先されるプラットフォームでは、POSIXセマフォの数に特定のカーネル制限はありません。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="systemitem">AIX</span>
      <a id="id-1.6.5.6.3.16.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>少なくともバージョン5.1では、すべてのメモリが共有メモリとして使用できるように設定されているようにみえますので、<code class="varname">SHMMAX</code>などのパラメータに対して特別な設定は必要ありません。
これは<span class="application">DB/2</span>などの他のデータベースでも使用される、一般的な設定方法です。

       </p><p>しかし、<code class="filename">/etc/security/limits</code>内の大域的な<code class="command">ulimit</code>情報は変更しなければならないかもしれません。
デフォルトのファイルサイズ（<code class="varname">fsize</code>）とファイル数（<code class="varname">nofiles</code>）用のハードリミットは低過ぎるかもしれないためです。
       </p></dd><dt><span class="term"><span class="systemitem">FreeBSD</span>
      <a id="id-1.6.5.6.3.16.2.1.2" class="indexterm"></a>
      </span></dt><dd><p>デフォルトの設定は<code class="command">sysctl</code>または<code class="command">loader</code>インタフェースを使用して変更を行うことができます。
以下では<code class="command">sysctl</code>を使用してパラメータを変更しています。
</p><pre class="screen"><code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.ipc.shmall=32768</code></strong>
<code class="prompt">#</code> <strong class="userinput"><code>sysctl kern.ipc.shmmax=134217728</code></strong></pre><p>
これらの設定を再起動しても永続化するには、<code class="filename">/etc/sysctl.conf</code>を変更します。
       </p><p>セマフォ関連の設定は<code class="command">sysctl</code>では読み取りのみとみなされていますが、<code class="filename">/boot/loader.conf</code>内で設定することができます。
</p><pre class="programlisting">kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256</pre><p>
これらの値を変更した後、新しい設定を有効にするためには再起動が必要です。
(注意: FreeBSD は<code class="varname">SEMMAP</code>を使用しません。古いバージョンは<code class="literal">kern.ipc.semmap</code>の設定を受け入れますが無視します; 新しいバージョンでは拒否します。)
       </p><p>また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<code class="command">sysctl</code>を使用して<code class="literal">kern.ipc.shm_use_phys</code>を設定することで実現できます。
       </p><p><span class="application">sysctl</span>の<code class="literal">security.jail.sysvipc_allowed</code>を有効にしてFreeBSD jailを実行している場合、異なるjailで実行する<span class="application">postmaster</span>を別のオペレーティングシステムユーザで実行しなければなりません。
これは、非特権ユーザが別のjailの共有メモリやセマフォに干渉することを防止できるため、セキュリティが向上します。
また、これによりPostgreSQLのIPCを整理するコードを適切に動作させることができます。
（FreeBSD 6.0以降では、IPC整理コードは他のjailにおけるプロセスを適切に検出せず、異なるjailで同一ポートでpostmasterを実行させることができません。）
       </p><p><span class="systemitem">FreeBSD</span>バージョン4.0以前では、（後述の）<span class="systemitem">OpenBSD</span>と同様に動作します。
       </p></dd><dt><span class="term"><span class="systemitem">NetBSD</span>
      <a id="id-1.6.5.6.3.16.3.1.2" class="indexterm"></a>
      </span></dt><dd><p><span class="systemitem">NetBSD</span> 5.0以降では、以下の例のようにIPCパラメータを<code class="command">sysctl</code>を用いて調整することができます。
</p><pre class="screen"><code class="prompt">$</code> <strong class="userinput"><code>sysctl -w kern.ipc.shmmax=16777216</code></strong></pre><p>
この設定を再起動しても永続化させるためには<code class="filename">/etc/sysctl.conf</code>を編集してください。
       </p><p>また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<code class="command">sysctl</code>を使用して<code class="literal">kern.ipc.shm_use_phys</code>を設定することで実現できます。
       </p><p>5.0より前のバージョンの<span class="systemitem">NetBSD</span>では、（後述の）<span class="systemitem">OpenBSD</span>のように動作します。
ただし、パラメータは<code class="literal">option</code>ではなく<code class="literal">options</code>キーワードを付けて設定する必要があります。
       </p></dd><dt><span class="term"><span class="systemitem">OpenBSD</span>
      <a id="id-1.6.5.6.3.16.4.1.2" class="indexterm"></a>
      </span></dt><dd><p><code class="varname">SYSVSHM</code>オプションと<code class="varname">SYSVSEM</code>オプションはカーネルのコンパイル時に有効にする必要があります（デフォルトでは有効になっています）。
共有メモリの最大サイズは<code class="varname">SHMMAXPGS</code>オプション（ページ数）で決定されます。
以下に様々なパラメータの設定方法の例を示します。
</p><pre class="programlisting">option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256</pre><p>
       </p></dd><dt><span class="term"><span class="systemitem">HP-UX</span>
      <a id="id-1.6.5.6.3.16.5.1.2" class="indexterm"></a>
      </span></dt><dd><p>デフォルトの設定は通常のインストールではほぼ十分です。
<span class="productname">HP-UX</span> 10では<code class="varname">SEMMNS</code>の出荷時のデフォルトは128ですが、これは大規模なデータベースサイトには低過ぎるかもしれません。
       </p><p><acronym class="acronym">IPC</acronym>パラメータは<span class="application">システム管理マネージャ</span>（<acronym class="acronym">SAM</acronym>）から<span class="guimenu">Kernel Configuration</span> → <span class="guimenuitem">Configurable Parameters</span>の下で、設定することができます。
終わったら<span class="guibutton">Create A New Kernel</span>を選択してください。
       </p></dd><dt><span class="term"><span class="systemitem">Linux</span>
      <a id="id-1.6.5.6.3.16.6.1.2" class="indexterm"></a>
      </span></dt><dd><p>デフォルトの最大セグメントサイズは32メガバイト、デフォルトの最大総サイズは2097152ページです。
<span class="quote">“<span class="quote">huge pages</span>”</span>を持つ通常ではないカーネル設定を除き、1ページはほとんど常に4096バイトです。
(検証には<code class="literal">getconf PAGE_SIZE</code>を使用してください。)
       </p><p>共有メモリサイズの設定は<code class="command">sysctl</code>インタフェースを使用して変更可能です。
例えば16ギガバイトまで許すには以下のようにします。
</p><pre class="screen"><code class="prompt">$</code> <strong class="userinput"><code>sysctl -w kernel.shmmax=17179869184</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>sysctl -w kernel.shmall=4194304</code></strong></pre><p>
更にこれらの設定を再起動時に保持できるように<code class="filename">/etc/sysctl.conf</code>に保存することができます。
こうすることを大いに勧めます。
       </p><p>古めのディストリビューションでは<code class="command">sysctl</code>プログラムが存在しない可能性があります。
この場合、<code class="filename">/proc</code>ファイルシステムに対する操作で同等の変更を行うことができます。
</p><pre class="screen"><code class="prompt">$</code> <strong class="userinput"><code>echo 17179869184 &gt;/proc/sys/kernel/shmmax</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>echo 4194304 &gt;/proc/sys/kernel/shmall</code></strong></pre><p>
       </p><p>他のデフォルトはかなり豊富なサイズですので、通常は変更する必要はありません。
       </p></dd><dt><span class="term"><span class="systemitem">macOS</span>
      <a id="id-1.6.5.6.3.16.7.1.2" class="indexterm"></a>
      </span></dt><dd><p>macOSにおける共有メモリの推奨設定方法は、以下のような変数代入文からなる<code class="filename">/etc/sysctl.conf</code>という名称のファイルを作成することです。
</p><pre class="programlisting">kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024</pre><p>
一部のバージョンのmacOSでは<code class="filename">/etc/sysctl.conf</code>内に共有メモリパラメータ<span class="emphasis"><em>5つすべて</em></span>を設定しなければならないという点に注意してください。
さもなくば値が無視されます。
       </p><p>最近のリリースのmacOSは、<code class="varname">SHMMAX</code>を4096の倍数以外に設定しようとすると無視しますので、注意してください。
       </p><p>このプラットフォームでは<code class="varname">SHMALL</code>は4キロバイトページ単位です。
       </p><p>古めのバージョンのmacOSでは、共有メモリパラメータの変更を有効にするために再起動が必要になります。
10.5から<code class="varname">SHMMNI</code>以外の変更は、<span class="application">sysctl</span>を用いることにより、その場で行うことができます。
しかしいずれにせよ<code class="filename">/etc/sysctl.conf</code>経由で望む値に設定することが最善です。
再起動を行っても値が保持されるからです。
       </p><p><code class="filename">/etc/sysctl.conf</code>はmacOS 10.3.9以降でのみ使用されます。
もしこれより前の10.3.xリリースを使用しているのであれば、<code class="filename">/etc/rc</code>ファイルを編集し、以下のコマンドで値を変更しなければなりません。
</p><pre class="programlisting">sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall</pre><p>
通常<code class="filename">/etc/rc</code>はmacOSのアップデートで上書きされることに注意してください。
ですので、アップデートの度に編集し直す必要があるものと考えなければなりません。
       </p><p>macOS 10.2以前では、代わりに<code class="filename">/System/Library/StartupItems/SystemTuning/SystemTuning</code>ファイル内にあるこれらのコマンドを編集してください。
       </p></dd><dt><span class="term"><span class="systemitem">Solaris</span> 2.6から2.9 (Solaris 6からSolaris 9)
      <a id="id-1.6.5.6.3.16.8.1.2" class="indexterm"></a>
      </span></dt><dd><p>必要な設定は<code class="filename">/etc/system</code>で変えることができ、例えば以下のようになります。
</p><pre class="programlisting">set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32</pre><p>
変更を反映させるには再起動する必要があります。
古めのバージョンのSolarisにおける共有メモリの情報は<a class="ulink" href="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html" target="_top">http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html</a>を参照してください。
       </p></dd><dt><span class="term"><span class="systemitem">Solaris</span> 2.10 (Solaris 10)以降<br /></span><span class="term"><span class="systemitem">OpenSolaris</span></span></dt><dd><p>Solaris 10以降とOpenSolarisでは、デフォルトの共有メモリとセマフォ設定は大抵の<span class="productname">PostgreSQL</span>アプリケーションで十分あります。
Solarisのデフォルトの<code class="varname">SHMMAX</code>はシステムの<acronym class="acronym">RAM</acronym>の1/4になりました。
さらにこの設定を調整するためには、<code class="literal">postgres</code>ユーザに関するプロジェクト設定を使用しなければなりません。
例えば以下を<code class="literal">root</code>権限で実行してください。
</p><pre class="programlisting">projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres</pre><p>
       </p><p>このコマンドは<code class="literal">user.postgres</code>プロジェクトを追加し、<code class="literal">postgres</code>ユーザの共有メモリの最大サイズを8GBに設定します。
この影響は次にこのユーザがログインした時、または<span class="productname">PostgreSQL</span>を再起動した時（再読み込み時ではありません）に有効になります。
上では<span class="productname">PostgreSQL</span>は<code class="literal">postgres</code>グループに属する<code class="literal">postgres</code>ユーザにより実行されていることを前提としています。
サーバの再起動は不要です。
       </p><p>多くの接続を受け付けるデータベースサーバにおいて推奨するカーネル設定にはこの他に以下があります。
</p><pre class="programlisting">project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)</pre><p>
       </p><p>さらに、ゾーン内で<span class="productname">PostgreSQL</span>を実行している場合、ゾーンのリソース使用上限も上げる必要があるかもしれません。
<code class="literal">projects</code>と<code class="command">prctl</code>については<em class="citetitle">System Administrator's Guide</em>の第2章 プロジェクトとタスクを参照してください。
       </p></dd></dl></div></div><div class="sect2" id="SYSTEMD-REMOVEIPC"><div class="titlepage"><div><div><h3 class="title">18.4.2. systemd RemoveIPC</h3></div></div></div><a id="id-1.6.5.6.4.2" class="indexterm"></a><p><span class="productname">systemd</span>が使用されている場合、IPCリソース（共有メモリとセマフォ）がオペレーティングシステムによって時期尚早に削除されないように注意する必要があります。
これはPostgreSQLをソースからインストールした場合に特に重要です。
PostgreSQLのディストリビューションパッケージのユーザーは、通常<code class="literal">postgres</code>ユーザーがシステムユーザーで作成されるため、影響を受けにくいでしょう。
   </p><p><code class="filename">logind.conf</code>の<code class="literal">RemoveIPC</code>の設定はユーザが完全にログアウトしたときにIPCオブジェクトを削除するかどうかを制御します。
システムユーザは免除されます。
この設定のデフォルトは<span class="productname">systemd</span>ですが、いくつかのオペレーティングシステムではデフォルトでオフになっています。
   </p><p>この設定が有効になっている時の典型的な影響は、PostgreSQLサーバが使用しているセマフォオブジェクトがランダムな時間に削除され、サーバが以下のようなログメッセージでクラッシュします。
</p><pre class="screen">LOG: semctl(1234567890, 0, IPC_RMID, ...) failed: Invalid argument</pre><p>
IPCオブジェクトの違い（共有メモリ vs. セマフォ、System V vs. POSIX）は<span class="productname">systemd</span>によって若干扱いが異なるため一部のIPCは他のものと違って削除されないことがあります。
しかし、これらの微妙な違いに依存することはお勧めできません。
   </p><p><span class="quote">“<span class="quote">ユーザーログアウト</span>”</span>は、メンテナンスジョブの一環として、又は手動で、管理者が<code class="literal">postgres</code>ユーザーや類似のユーザでログインする可能性があるため、一般的に防止することは困難です。
   </p><p><span class="quote">“<span class="quote">システムユーザー</span>”</span>は、<code class="filename">/etc/login.defs</code>の<code class="symbol">SYS_UID_MAX</code>の設定により<span class="productname">systemd</span>のコンパイル時に決定されます。
   </p><p>パッケージとデプロイスクリプトは、<code class="literal">useradd -r</code>, <code class="literal">adduser --system</code>又は同等のコマンドを使用して<code class="literal">postgres</code>ユーザを作成するように注意する必要があります。
   </p><p>また、ユーザアカウントが誤って作成されて変更出来ないような場合は、以下を設定することを推奨します。
</p><pre class="programlisting">RemoveIPC=no</pre><p>
<code class="filename">/etc/systemd/logind.conf</code>又はその他の設定ファイルで上記を入れます。
   </p><div class="caution"><h3 class="title">Caution</h3><p>これらの２つのうち少なくとも１つが保証されてないとなりません。そうでないとPostgreSQLサーバは非常に信頼性が低くなります。
    </p></div></div><div class="sect2" id="id-1.6.5.6.5"><div class="titlepage"><div><div><h3 class="title">18.4.3. リソースの制限</h3></div></div></div><p>Unixライクなオペレーティングシステムでは<span class="productname">PostgreSQL</span>サーバの操作と関係する可能性のある様々な種類のリソース制限があります。
特に重要なのは、ユーザごとのプロセス数の制限、プロセスごとのオープンファイルの数、プロセスごとの利用可能なメモリの量です。
これらのそれぞれが<span class="quote">“<span class="quote">ハード</span>”</span>と<span class="quote">“<span class="quote">ソフト</span>”</span>の2つの制限を持っています。
ソフト制限が実際に有効な制限ですが、ユーザによってハード制限まで変えることが可能です。
ハード制限はrootユーザによってのみ変えることができます。
<code class="function">setrlimit</code>システムコールがこれらのパラメータの設定を行います。
シェルの組み込みコマンド<code class="command">ulimit</code>（Bourne シェル）もしくは<code class="command">limit</code>（<span class="application">csh</span>）は、コマンドラインからリソース制限を制御するために使われます。
BSD派生システム上では<code class="filename">/etc/login.conf</code>ファイルが、ログイン時に設定される様々なリソース制限を制御します。
詳細はオペレーティングシステムの文書を参照してください。
関連するパラメータは<code class="varname">maxproc</code>、<code class="varname">openfiles</code>、<code class="varname">datasize</code>です。
以下に例を示します。
</p><pre class="programlisting">default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</pre><p>
（<code class="literal">-cur</code>はソフト制限です。
ハード制限を設定するためには<code class="literal">-max</code>を付けてください。）
   </p><p>カーネルはいくつかのリソースに対して、システム全体の制限も持つことができます。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="productname">Linux</span>では、<code class="filename">/proc/sys/fs/file-max</code>が、カーネルがサポートするオープンファイル数の最大を決定します。
この数を変えるためには、そのファイルに別の数を書き込むか、あるいは<code class="filename">/etc/sysctl.conf</code>に代入式を追加します。
プロセスごとのファイルの最大制限はカーネルがコンパイルされた時に固定されます。
詳しい情報については<code class="filename">/usr/src/linux/Documentation/proc.txt</code>を参照してください。
      </p></li></ul></div><p>
   </p><p><span class="productname">PostgreSQL</span>サーバは接続ごとに1つのプロセスを使うので、少なくとも許可された接続の数だけのプロセスに残りのシステムで必要な分を追加したものが必要になります。
通常はこれは問題ではありませんが、1つのマシン上でいくつかのサーバを起動している場合は厳しい状況になるかもしれません。
   </p><p>オープンファイルの制限の出荷時のデフォルトは、しばしば大多数のユーザはマシン上でシステムリソースの不正使用をしないという前堤に立った<span class="quote">“<span class="quote">社会的に友好的な</span>”</span>値を設定してしまいます。
もし1つのマシン上で複数のサーバを起動する場合はそれが必要でしょうが、専用サーバではこの制限を上げたいかもしれません。
   </p><p>反対に、個々のプロセスが多数のファイルをオープンすることを許可するシステムもあります。
そのようなプロセスが数個以上あれば、システム全体の制限は簡単に超えてしまいます。
この発生を検知し、システム全体の制限の変更を望まない場合は、<span class="productname">PostgreSQL</span>の<a class="xref" href="runtime-config-resource.html#GUC-MAX-FILES-PER-PROCESS">max_files_per_process</a>設定パラメータを設定し、オープンファイルの消費を制限することができます。
   </p></div><div class="sect2" id="LINUX-MEMORY-OVERCOMMIT"><div class="titlepage"><div><div><h3 class="title">18.4.4. Linuxのメモリオーバーコミット</h3></div></div></div><a id="id-1.6.5.6.6.2" class="indexterm"></a><a id="id-1.6.5.6.6.3" class="indexterm"></a><a id="id-1.6.5.6.6.4" class="indexterm"></a><p>Linux 2.4以降では、デフォルトの仮想メモリの動作は<span class="productname">PostgreSQL</span>には最適ではありません。
カーネルがメモリオーバーコミットを実装する方法のため、カーネルは、<span class="productname">PostgreSQL</span>や他のプロセスのメモリ要求がシステムの仮想メモリを枯渇させた場合、<span class="productname">PostgreSQL</span> postmaster （マスタサーバプロセス）を終了させる可能性があります。
   </p><p>これが発生した場合、以下のようなカーネルメッセージが現れます
（こうしたメッセージを検索する場所についてはシステム文書と設定を参照してください）。
</p><pre class="programlisting">Out of Memory: Killed process 12345 (postgres).</pre><p>
これは、<code class="filename">postgres</code>プロセスがメモリ不足のために終了してしまったことを示します。
起動中のデータベース接続は正常に動作しますが、新しい接続は受け付けられません。
復旧するには、<span class="productname">PostgreSQL</span>を再起動しなければなりません。
   </p><p>この問題を防止する1つの方法として、<span class="productname">PostgreSQL</span>を他のプロセスがそのマシンのメモリを枯渇させないことが確実なマシンで起動するというものがあります。
物理メモリとスワップ領域が消費尽くされた時のみにメモリ不足（OOM）killerが発生するため、メモリが不足する場合、オペレーティングシステムのスワップ領域を増やすことが問題解決の役にたちます。
   </p><p><span class="productname">PostgreSQL</span>自体が実行中のシステムのメモリ不足を引き起こした場合、設定を変更することで問題を防止することができます。
メモリ関連の設定パラメータ、具体的には<a class="link" href="runtime-config-resource.html#GUC-SHARED-BUFFERS"><code class="varname">shared_buffers</code></a>および<a class="link" href="runtime-config-resource.html#GUC-WORK-MEM"><code class="varname">work_mem</code></a>、を低くすることで回避できる場合もあります。
個の他にもデータベースサーバ自体への接続が多く許可しすぎることで問題が引き起こされる場合もあります。
多くの場合、<a class="link" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS"><code class="varname">max_connections</code></a>を減らし、外部のコネクションプールソフトウェアを使用することで改善されます。
   </p><p>Linux 2.6以降では、メモリを<span class="quote">“<span class="quote">オーバーコミット</span>”</span>させないようにカーネルの動作を変更することができます。
この設定は完全に<a class="ulink" href="http://lwn.net/Articles/104179/" target="_top">OOM killer</a>の発生を防ぐことはできませんが、その発生頻度をかなり軽減しますので、システム動作の堅牢性をより高めます。
これは、以下のように<code class="command">sysctl</code>を使用して厳密なオーバーコミットモードを選択すること、もしくは、<code class="filename">/etc/sysctl.conf</code>に同等の項目を記述することで実施されます。
</p><pre class="programlisting">sysctl -w vm.overcommit_memory=2</pre><p>
また、関連する<code class="varname">vm.overcommit_ratio</code>設定を変更した方が良いでしょう。
詳細はカーネル文書ファイル<a class="ulink" href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting" target="_top">https://www.kernel.org/doc/Documentation/vm/overcommit-accounting</a>を参照してください。
   </p><p><code class="varname">vm.overcommit_memory</code>の変更と関係なく使用できるその他の方法は、プロセス固有の<em class="firstterm">OOMスコア調整</em>値をpostmasterプロセス向けに<code class="literal">-1000</code>に設定することです。
これによりOOM killerの対象とならないことが保証されます。
このための最も簡単な方法は以下をpostmasterの起動スクリプト内でpostmasterを実行する直前に実行することです。
</p><pre class="programlisting">echo -1000 &gt; /proc/self/oom_score_adj</pre><p>
この作業をrootで実行しなければならないことに注意して下さい。
さもないと効果がありません。
このためrootが所有する起動スクリプトが、これを行うための最も簡単な場所です。
その場合には、スタートアップスクリプトのpostmasterの起動前に以下の環境変数を設定することも推奨します。
</p><pre class="programlisting">export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0</pre><p>
これらの設定は、いざという時にpostmasterの子プロセスをOOM killerのターゲットに出来るようにOOMスコア調整を通常のゼロで実行します。
子プロセスを他のOOMスコア調整で実行したい場合には、<code class="envar">PG_OOM_ADJUST_VALUE</code>により別の値にすることが出来ます。
（<code class="envar">PG_OOM_ADJUST_VALUE</code>は省略することが出来て、その場合はデフォルトのゼロになります。）
<code class="envar">PG_OOM_ADJUST_FILE</code>を設定しない場合、子プロセスはpostmasterと同じOOMスコア調整で実行されますが、postmasterが優先される設定にすることが肝心なので、それは賢明とは言えません。
   </p><p>古いLinuxカーネルは<code class="filename">/proc/self/oom_score_adj</code>を提供していませんが、同様の機能を持つ<code class="filename">/proc/self/oom_adj</code>があるでしょう。
これは、無効にするための設定値が<code class="literal">-1000</code>ではなく<code class="literal">-17</code>であるという点を除いては同じように動作します。
   </p><div class="note"><h3 class="title">Note</h3><p>Linux 2.4カーネルのベンダの中には、2.6のオーバーコミット<code class="command">sysctl</code>版を持つものがあることが報告されています。
しかし、関係するコードを持たない2.4カーネルで<code class="literal">vm.overcommit_memory</code>を2に設定することはより状況を悪化させます。
2.4のインストレーションではこれを試す前に、実際のカーネルソースコードを調査し、その中でサポートしているかどうかを検証することをお勧めします（<code class="filename">mm/mmap.c</code>ファイル内の<code class="function">vm_enough_memory</code>関数を参照してください）。
<code class="filename">overcommit-accounting</code>文書ファイルの存在は、この機能が存在するかどうかを証明するものでは<span class="emphasis"><em>ありません</em></span>。
疑わしい場合は、使用中のカーネルベンダのカーネル専門家に相談してください。
   </p></div></div><div class="sect2" id="LINUX-HUGE-PAGES"><div class="titlepage"><div><div><h3 class="title">18.4.5. LinuxのHugePages</h3></div></div></div><p><span class="productname">PostgreSQL</span>のように、メモリの大きな連続チャンクを使用するとき、特に<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>の値が大きい場合に、huge pagesを使用するとオーバーヘッドが減少します。
<span class="productname">PostgreSQL</span>でこの機能を有効にするには、<code class="varname">CONFIG_HUGETLBFS=y</code>および<code class="varname">CONFIG_HUGETLB_PAGE=y</code>としたカーネルが必要です。
またカーネル設定<code class="varname">vm.nr_hugepages</code>を調整する必要もあるでしょう。
必要なhuge pages数を見積もるには、huge pagesを有効にせずに、<span class="productname">PostgreSQL</span>を起動し、procファイルシステムを使用してpostmasterの<code class="varname">VmPeak</code>の値をチェックします。
これは以下のような感じになるでしょう。
</p><pre class="programlisting">$ <strong class="userinput"><code>head -1 $PGDATA/postmaster.pid</code></strong>
4170
$ <strong class="userinput"><code>grep ^VmPeak /proc/4170/status</code></strong>
VmPeak:  6490428 kB
$ <strong class="userinput"><code>grep ^Hugepagesize /proc/meminfo</code></strong>
Hugepagesize:       2048 kB</pre><p>
<code class="literal">6490428</code> / <code class="literal">2048</code>はおよそ<code class="literal">3169.154</code>ですので、この例では少なくとも<code class="literal">3170</code>のhuge pagesが必要で、それは以下のようにして設定できます。
</p><pre class="programlisting">$ <strong class="userinput"><code>sysctl -w vm.nr_hugepages=3170</code></strong></pre><p>
同じマシン上で他にもhuge pagesが必要なプログラムがあるなら、もっと大きな設定が適切でしょう。
再起動のときにこの設定が適用されるように、これを<code class="filename">/etc/sysctl.conf</code>に追加するのを忘れないで下さい。
   </p><p>時には、カーネルは求められた数のhuge pagesを割り当てることができないことがあるので、そのコマンドを繰り返すか、再起動する必要があるかもしれません。
（再起動の直後は、マシンのメモリの大部分はhuge pagesへの変更が可能なはずです。）
huge pagesの割り当ての状況を確認するには、次のようにします。
</p><pre class="programlisting">$ <strong class="userinput"><code>grep Huge /proc/meminfo</code></strong></pre><p>
   </p><p><span class="application">sysctl</span>を使って<code class="varname">vm.hugetlb_shm_group</code>を設定する、あるいは<code class="command">ulimit -l</code>でメモリをロックする権限を与えることで、データベースサーバのOSユーザにhuge pagesを使用する権限を与える必要もあるかもしれません。
   </p><p><span class="productname">PostgreSQL</span>のhuge pagesのデフォルトの動作は、可能な場合はhuge pagesを使用し、失敗した場合は通常のページを使用します。
<code class="filename">postgresql.conf</code>で<a class="link" href="runtime-config-resource.html#GUC-HUGE-PAGES"><code class="varname">huge_pages</code></a>を<code class="literal">on</code>に設定することで、huge pagesの使用を強制することができます。
この設定の場合、十分なhuge pagesが確保できなければ、<span class="productname">PostgreSQL</span>の起動に失敗することに注意してください。
   </p><p><span class="productname">Linux</span>のhuge pages機能の詳細は<a class="ulink" href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt" target="_top">https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</a>を参照してください。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="server-start.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="server-shutdown.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">18.3. データベースサーバの起動 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 18.5. サーバのシャットダウン</td></tr></table></div></body></html>