<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.2. 演算子</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="typeconv-overview.html" title="10.1. 概要" /><link rel="next" href="typeconv-func.html" title="10.3. 関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.2. 演算子</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv-overview.html" title="10.1. 概要">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="Chapter 10. 型変換">Up</a></td><th width="60%" align="center">Chapter 10. 型変換</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-func.html" title="10.3. 関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TYPECONV-OPER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.2. 演算子</h2></div></div></div><a id="id-1.5.9.7.2" class="indexterm"></a><p>演算式に参照される特定の演算子は、以下の手順を用いて決定されます。
関連する演算子の優先順位によりどの下位式をどの演算子の入力と見なすかが決定されますので、この手順はこの優先順位により間接的な影響を受けることに注意して下さい。
詳細は<a class="xref" href="sql-syntax-lexical.html#SQL-PRECEDENCE" title="4.1.6. 演算子の優先順位">Section 4.1.6</a>を参照してください。
  </p><div class="procedure" id="id-1.5.9.7.4"><p class="title"><strong>演算子における型の解決</strong></p><ol class="procedure" type="1"><li class="step" id="OP-RESOL-SELECT"><p><code class="classname">pg_operator</code>システムカタログから、調査の対象とする演算子を選択します。
スキーマ修飾がされていない演算子名が使用される場合（通常の場合）、現行の検索パスで可視になっていて、同一の名前と引数の数を持つ演算子が調査対象であるとみなされます
（<a class="xref" href="ddl-schemas.html#DDL-SCHEMAS-PATH" title="5.8.3. スキーマ検索パス">Section 5.8.3</a>を参照してください）。
修飾された演算子名が与えられている場合、指定されたスキーマの演算子のみが調査対象とみなされます。</p><ol type="a" class="substeps"><li class="step"><p>検索パスで引数のデータ型が同じである複数の演算子を検出した場合、そのパスで最初に検出された演算子のみを調査対象とみなします。
引数のデータ型が異なる演算子は、検索パス内の位置に関係なく、同じように調べられます。</p></li></ol></li><li class="step" id="OP-RESOL-EXACT-MATCH"><p>正確に入力引数型を受け付ける演算子があるかどうか検査します。
該当する演算子があれば（調査される演算子の集合内で正確に一致するものは1つしかあり得ません）、それを使用します。
  <a href="#ftn.OP-QUALIFIED-SECURITY" class="footnote"><sup class="footnote" id="OP-QUALIFIED-SECURITY">[8]</sup></a>
(not typical), any operator found in a schema that permits untrusted users to
create objects.  In such situations, cast arguments to force an exact match.</p><ol type="a" class="substeps"><li class="step" id="OP-RESOL-EXACT-UNKNOWN"><p>二項演算子の1つの引数が<code class="type">unknown</code>型であった場合、この検査のもう片方の引数と同一の型であると仮定します。
2つの<code class="type">unknown</code>入力、もしくは<code class="type">unknown</code>入力を伴う単項演算子が呼び出された場合、この段階では対を見つけることはありません。</p></li><li class="step" id="OP-RESOL-EXACT-DOMAIN"><p>二項演算子の1つの引数が<code class="type">unknown</code>型であり、もう1つがドメイン型の場合、次に両側でドメインの基本型を厳密に受け付ける演算子があるかを確認します。</p></li></ol></li><li class="step" id="OP-RESOL-BEST-MATCH"><p>最もよく合うものを検索します。</p><ol type="a" class="substeps"><li class="step"><p>演算子の候補のうち、入力値のデータ型が一致せず、また、（暗黙的な変換を使用して）一致するように変換できないものを破棄します。
<code class="type">unknown</code>リテラルは、上記の目的で何にでも変換可能とみなされます。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>入力引数のいずれかがドメイン型であれば、以降の段階すべてでドメインの基本型であるかのように扱います。
これにより、曖昧な演算子を解決するのを目的としてその基本型であるかのようにドメインが振る舞うことが確実になります。</p></li><li class="step"><p>全ての候補を検索し、入力型に最も正確に合うものを残します。
正確に合うものが何もなければ全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>全ての候補を検索し、型変換が必要とされる所で（入力データ型カテゴリの）優先される型を受け付けるものを残します。
優先される型を受け付けるものが何もなければ全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step"><p>入力引数で<code class="type">unknown</code>のものがあった場合、それらの残った候補に引数位置で受け入れられる型カテゴリを検査します。
各位置において、候補が<code class="type">string</code>カテゴリを受け付ける場合は、そのカテゴリを選択します
（unknown 型のリテラルは文字列のようなものですので、この文字列への重み付けは適切です）。
そうでなければ、もし残った全ての候補が同じ型カテゴリを受け入れる場合はそのカテゴリを選択します。
そうでもなければ、さらに手掛かりがなければ正しい選択が演繹されることができませんので、失敗となります。
ここで、選択された型カテゴリを受け付けない演算子候補は破棄されます。
さらに、それらカテゴリ内の優先される型を受け付ける候補が1つでもある場合、その引数の優先されない型を受け付ける候補は破棄されます。
これらの検査をどれも通らなかったら全ての候補を残します。
1つの候補しか残らない場合、それを使います。
それ以外の場合は次の段階に進みます。</p></li><li class="step" id="OP-RESOL-LAST-UNKNOWN"><p>もし<code class="type">unknown</code>と既知の型の引数の両方があり、そして全ての既知の型の引数が同じ型を持っていた場合、<code class="type">unknown</code>引数も同じ型であると仮定し、
どの候補が<code class="type">unknown</code>引数の位置にある型を受け付けることができるかを検査します。
正確に1つの候補がこの検査を通過した場合、それを使います。それ以外は失敗します。</p></li></ol></li></ol></div><p>以下に例を示します。</p><div class="example" id="id-1.5.9.7.6"><p class="title"><strong>Example 10.1. 階乗演算子の型解決</strong></p><div class="example-contents"><p>階乗演算子として、<code class="type">bigint</code>を引数とするものが標準カタログ内に1つのみ定義されています（<code class="literal">!</code>を後に付けます）。
スキャナは、以下の問い合わせ式の引数にまず<code class="type">integer</code>型を割り当てます。
</p><pre class="screen">SELECT 40 ! AS "40 factorial";

                   40 factorial
--------------------------------------------------
 815915283247897734345611269596115894272000000000
(1 row)</pre><p>

パーサはオペランドを型変換し、問い合わせは以下と等価になります。

</p><pre class="screen">SELECT CAST(40 AS bigint) ! AS "40 factorial";</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.7"><p class="title"><strong>Example 10.2. 文字列連結演算子の型解決</strong></p><div class="example-contents"><p>文字列類似構文は、文字列の作業の他、複雑な拡張型の作業にも使用されます。
型の指定がない文字列は、類似演算子候補に一致します。</p><p>例えば、以下は指定がない引数が1つあります。
</p><pre class="screen">SELECT text 'abc' || 'def' AS "text and unknown";

 text and unknown
------------------
 abcdef
(1 row)</pre><p>この場合、パーサは両引数で<code class="type">text</code>を取る演算子があるかどうかを検索します。
この演算子は存在しますので、第二引数は<code class="type">text</code>型として解釈されるものと仮定されます。</p><p>以下は型の指定がない2つの値の連結です。
</p><pre class="screen">SELECT 'abc' || 'def' AS "unspecified";

 unspecified
-------------
 abcdef
(1 row)</pre><p>この場合、問い合わせ内に型が指定されていませんので、どの型を使用すべきかについての初期の指針がありません。
ですから、パーサは全ての演算子候補を検索し、文字列カテゴリとビット列カテゴリ入力を受け付ける候補を見つけます。
使用できる場合は文字列カテゴリが優先されますので、文字列カテゴリが選択され、それから文字列に対して優先される型である<code class="type">text</code>が、不明のリテラルを解決する型として使用されます。</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.8"><p class="title"><strong>Example 10.3. 絶対値と否定演算子の型解決</strong></p><div class="example-contents"><p><span class="productname">PostgreSQL</span>の演算子カタログには、前置演算子<code class="literal">@</code>用に複数の項目があります。
これは全て各種数値データ型に対する絶対値計算を実装するものです。
その1つは、数値カテゴリの優先される型である<code class="type">float8</code>型用の項目です。
したがって、<span class="productname">PostgreSQL</span>は、<code class="type">unknown</code>の入力があった場合にこれを使用します。
</p><pre class="screen">SELECT @ '-4.5' AS "abs";
 abs
-----
 4.5
(1 row)</pre><p>
ここでシステムは、選択した演算子を適用する前に、unknown型のリテラルを<code class="type">float8</code>へ暗黙的に型変換します。
以下のように<code class="type">float8</code>が使用され、他の型が使用されていないことを検証することができます。
</p><pre class="screen">SELECT @ '-4.5e500' AS "abs";

ERROR:  "-4.5e500" is out of range for type double precision</pre><p>一方、前置演算子<code class="literal">~</code>（ビット否定）は、整数データ型のみで定義され、<code class="type">float8</code>用は定義されていません。
ですから、<code class="literal">~</code>における上と同様の場合では、以下のような結果になります。
</p><pre class="screen">SELECT ~ '20' AS "negation";

ERROR:  operator is not unique: ~ "unknown"
HINT:  Could not choose a best candidate operator. You might need to add
explicit type casts.</pre><p>
これは、システムが、複数の<code class="literal">~</code>演算子候補のうちどれが優先されるかを決定することができなかったため発生します。
明示的なキャストを使用することで補助することができます。
</p><pre class="screen">SELECT ~ CAST('20' AS int8) AS "negation";

 negation
----------
      -21
(1 row)</pre></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.9"><p class="title"><strong>Example 10.4. 配列包含演算子の型解決</strong></p><div class="example-contents"><p>一方は既知でありもう一方は未知である入力を伴った演算子の解決のもう一つの例です。
</p><pre class="screen">SELECT array[1,2] &lt;@ '{1,2,3}' as "is subset";

 is subset
-----------
 t
(1 row)</pre><p>
<span class="productname">PostgreSQL</span>の演算子カタログは、<code class="literal">&lt;@</code>中置演算子のためのいくつかのエントリを持っていますが、
数値型配列を左側に受け付けることができるのは配列包含(<code class="type">anyarray</code> <code class="literal">&lt;@</code> <code class="type">anyarray</code>)と範囲包含(<code class="type">anyelement</code> <code class="literal">&lt;@</code> <code class="type">anyrange</code>)の2つのみです。
これらの多様な擬似データ型(<a class="xref" href="datatype-pseudo.html" title="8.20. 疑似データ型">Section 8.20</a>を参照)は優先されると見なされないため、このような方法ではパーサは曖昧さを解決することができません。
しかし、<a class="xref" href="typeconv-oper.html#OP-RESOL-LAST-UNKNOWN" title="Step 3.f">Step 3.f</a>では、未知の型のリテラルを別の入力と同じ型であると仮定するために数値配列とみなします。
今のところ2つのうち一つの演算子だけがマッチできるため、配列包含が選択されます。(範囲包含が選択された場合、演算子の右側にある文字列は正しい範囲型のリテラルではないため、エラーとなるでしょう。)</p></div></div><br class="example-break" /><div class="example" id="id-1.5.9.7.10"><p class="title"><strong>Example 10.5. ドメイン型の独自の演算子</strong></p><div class="example-contents"><p>利用者は時々ドメイン型にのみ適用される演算子を宣言しようとします。
これは可能ですが、思ったほど便利ではありません。演算子の解決規則がドメイン基本型に適用される演算子を選ぶように設計されているからです。
例として、以下を考えてください。
</p><pre class="screen">CREATE DOMAIN mytext AS text CHECK(...);
CREATE FUNCTION mytext_eq_text (mytext, text) RETURNS boolean AS ...;
CREATE OPERATOR = (procedure=mytext_eq_text, leftarg=mytext, rightarg=text);
CREATE TABLE mytable (val mytext);

SELECT * FROM mytable WHERE val = 'foo';</pre><p>
この問い合わせは独自の演算子を使いません．
パーサはまず<code class="type">mytext</code> <code class="literal">=</code> <code class="type">mytext</code>演算子(<a class="xref" href="typeconv-oper.html#OP-RESOL-EXACT-UNKNOWN" title="Step 2.a">Step 2.a</a>)があるか確認しますが、ありません。次にドメイン基本型<code class="type">text</code>を考慮して<code class="type">text</code> <code class="literal">=</code> <code class="type">text</code>演算子(<a class="xref" href="typeconv-oper.html#OP-RESOL-EXACT-DOMAIN" title="Step 2.b">Step 2.b</a>)があるか確認すると、あります。そのため<code class="type">unknown</code>型は<code class="type">text</code>として解決され、<code class="type">text</code> <code class="literal">=</code> <code class="type">text</code>演算子が使われます。
独自の演算子を使う唯一の方法は、「正確な一致」規則に従って<code class="type">mytext</code> <code class="literal">=</code> <code class="type">text</code>演算子がすぐに見つかるように、リテラルを明示的にキャストすることだけです。
</p><pre class="screen">SELECT * FROM mytable WHERE val = text 'foo';</pre><p>
もし、「最善の一致」規則に達した場合、ドメイン型の演算子を積極的に差別します。
そうでなければ、そのような演算子は非常に多くの「曖昧な演算子」の失敗を引き起こします。キャストの規則はドメインをその基本型からもしくは基本型へキャスト可能と考え、ドメイン演算子は基本型の似たような名前の演算子とすべて同じ状況で利用できると考えられるからです。</p></div></div><br class="example-break" /><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.OP-QUALIFIED-SECURITY" class="footnote"><p><a href="#OP-QUALIFIED-SECURITY" class="para"><sup class="para">[8] </sup></a>    The hazard does not arise with a non-schema-qualified name, because a
    search path containing schemas that permit untrusted users to create
    objects is not a <a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">secure schema usage
    pattern</a>.
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv-overview.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-func.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">10.1. 概要 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 10.3. 関数</td></tr></table></div></body></html>