<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 47. バックグラウンドワーカプロセス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="spi-spi-freeplan.html" title="SPI_freeplan" /><link rel="next" href="logicaldecoding.html" title="Chapter 48. ロジカルデコーディング" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Chapter 47. バックグラウンドワーカプロセス</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spi-spi-freeplan.html" title="SPI_freeplan">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="server-programming.html" title="Part V. サーバプログラミング">Up</a></td><th width="60%" align="center">Part V. サーバプログラミング</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="logicaldecoding.html" title="Chapter 48. ロジカルデコーディング">Next</a></td></tr></table><hr></hr></div><div class="chapter" id="BGWORKER"><div class="titlepage"><div><div><h2 class="title">Chapter 47. バックグラウンドワーカプロセス</h2></div></div></div><a id="id-1.8.13.2" class="indexterm"></a><p>PostgreSQLはユーザ提供のコードを別のプロセスとして実行できるように拡張することができます。
このプロセスは<code class="command">postgres</code>によって起動、終了、監視され、サーバの状態に密接にリンクした寿命を持つことができます。
これらのプロセスは<span class="productname">PostgreSQL</span>の共有メモリ領域にアタッチしたり、データベースの内部に接続するオプションを持ちます。これらはまた、通常のクライアントに接続された実際のサーバプロセスのように複数のトランザクションを連続して実行することができます。
また、アプリケーションは<span class="application">libpq</span>とリンクすることにより通常のクライアントアプリケーションのようにサーバに接続して動作することができます。
 </p><div class="warning"><h3 class="title">Warning</h3><p>バックグラウンドワーカを使うにあたっては、堅牢性とセキュリティリスクを考慮しなくてはなりません。なぜならば、<code class="literal">C</code>言語で書かれており、データへのアクセスが制限されていないためです。
バックグラウンドワーカプロセスを含むモジュールを有効にしたいと思っている管理者は、細心の注意を払って実践してください。
バックグラウンドワーカプロセスの実行は、注意深く検査されたモジュールだけを許可する必要があります。
  </p></div><p>バックグラウンドワーカは、モジュールを<code class="varname">shared_preload_libraries</code>に記すことによって、<span class="productname">PostgreSQL</span>スタート時に初期化できます。
バックグラウンドワーカとして実行したいモジュールは、<code class="function">_PG_init()</code>から<code class="function">RegisterBackgroundWorker(<code class="type">BackgroundWorker *worker</code>)</code>を呼び出すことで登録できます。
バックグラウンドワーカはシステム起動後も<code class="function">RegisterDynamicBackgroundWorker(<code class="type">BackgroundWorker *worker, BackgroundWorkerHandle **handle</code>)</code>を呼び出すことによって開始することができます。
postmasterからのみ呼び出すことができる<code class="function">RegisterBackgroundWorker</code>とは異なり、<code class="function">RegisterDynamicBackgroundWorker</code>は通常のバックエンドから呼び出す必要があります。
 </p><p><code class="structname">BackgroundWorker</code>の構造体は以下のように定義されます。
</p><pre class="programlisting">typedef void (*bgworker_main_type)(Datum main_arg);
typedef struct BackgroundWorker
{
    char        bgw_name[BGW_MAXLEN];
    int         bgw_flags;
    BgWorkerStartTime bgw_start_time;
    int         bgw_restart_time;       /* in seconds, or BGW_NEVER_RESTART */
    char        bgw_library_name[BGW_MAXLEN];
    char        bgw_function_name[BGW_MAXLEN];
    Datum       bgw_main_arg;
    char        bgw_extra[BGW_EXTRALEN];
    int         bgw_notify_pid;
} BackgroundWorker;</pre><p>
  </p><p><code class="structfield">bgw_name</code>は、ログメッセージ、プロセス一覧等で使用される文字列です。
  </p><p><code class="structfield">bgw_flags</code>は、モジュールが要求する機能をOR演算したビットマスクです。可能な値は以下の通りです。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">BGWORKER_SHMEM_ACCESS</code></span></dt><dd><p><a id="id-1.8.13.8.2.1.2.1.1" class="indexterm"></a>
共有メモリへのアクセスを要求します。
共有メモリアクセスがないワーカは、重量または軽量のロック、共有バッファ、ワーカが作成して利用したいカスタムデータ構造等、<span class="productname">PostgreSQL</span>の共有データ構造にアクセスできません。
      </p></dd><dt><span class="term"><code class="literal">BGWORKER_BACKEND_DATABASE_CONNECTION</code></span></dt><dd><p><a id="id-1.8.13.8.2.2.2.1.1" class="indexterm"></a>
トランザクションやクエリの実行が出来るデータベース接続を要求します。
<code class="literal">BGWORKER_BACKEND_DATABASE_CONNECTION</code>を使用してデータベースに接続するバックグラウンドワーカは<code class="literal">BGWORKER_SHMEM_ACCESS</code>を使用して共有メモリにアタッチしなければなりません。さもなければ起動時に失敗します。
      </p></dd></dl></div><p>

  </p><p><code class="structfield">bgw_start_time</code>は、<code class="command">postgres</code>がプロセスを起動するべきタイミングを指定します。
そのタイミングは、以下のうちの１つです。
<code class="literal">BgWorkerStart_PostmasterStart</code>（<code class="command">postgres</code>自身が初期化を終えるとすぐに起動します。これを要求するプロセスはデータベース接続に望ましいものではありません）、
<code class="literal">BgWorkerStart_ConsistentState</code>（ホットスタンバイで一貫性のある状態に到達し、データベースに接続して参照のみのクエリが実行できるようになると起動します）、
<code class="literal">BgWorkerStart_RecoveryFinished</code>（システムが通常の参照/更新クエリを実行できるようになると起動します）。
最後の２つの値は、ホットスタンバイでないサーバでは同等であることに注意してください。
この設定はいつプロセスが起動されるかを示すだけであることに注意してください。
これらのプロセスは、違う状態になったときに停止するわけではありません。
  </p><p><code class="structfield">bgw_restart_time</code>は、プロセスがクラッシュした場合に<code class="command">postgres</code>がそのプロセスを再起動するために待つ必要のある間隔を秒単位で指定します。
これは任意の正の値、またはクラッシュしても再起動させない場合に<code class="literal">BGW_NEVER_RESTART</code>を指定します。
  </p><p><code class="structfield">bgw_library_name</code>はバックグラウンドワーカの初期エントリーポイントのためのライブラリ名です。
その指定されたライブラリがワーカプロセスによって動的にロードされます。呼び出すべき関数を特定するために<code class="structfield">bgw_function_name</code>が使用されます。
コアコードから関数をロードする場合、"postgres"を設定する必要があります。
  </p><p><code class="structfield">bgw_function_name</code>は新しいバックグラウンドワーカから動的にロードされるときに初期エントリポイントの関数名です。
  </p><p><code class="structfield">bgw_main_arg</code>は、バックグラウンドワーカのメイン関数の<code class="type">Datum</code>引数です。
メイン関数は単一の<code class="type">Datum</code>引数を取り、<code class="type">void</code>を返します。
<code class="structfield">bgw_main_arg</code>は引数として渡されます。
加えて、グローバル変数<code class="literal">MyBgworkerEntry</code>は、登録時に渡された<code class="structname">BackgroundWorker</code>構造体のコピーを指しています。
ワーカはこの構造を調べることがあり、役に立ちます。
  </p><p>Windowsの（どこか他の場所で<code class="literal">EXEC_BACKEND</code>が定義されている）場合、または動的バックグラウンドワーカは、<code class="type">Datum</code>を参照で渡すのは安全ではありません。値のみで渡してください。
引数が必要な場合は、int32型または他の小さな値を渡し、共有メモリに割り当てられた配列へのインデックスとしてそれを使用するのが最も安全です。
<code class="type">cstring</code>や<code class="type">text</code>のようなポインタを渡された場合は、新しいバックグラウンドワーカプロセスから有効になりません。
  </p><p><code class="structfield">bgw_extra</code>はバックグラウンドワーカに渡す追加データを含めることが出来ます。
<code class="structfield">bgw_main_arg</code>とは異なり、このデータはワーカのメイン関数の引数として渡されていませんが、上述したように<code class="literal">MyBgworkerEntry</code>を介してアクセスすることが出来ます。
  </p><p><code class="structfield">bgw_notify_pid</code>はプロセスの開始時と終了時にpostmasterが<code class="literal">SIGUSR1</code>を送信するPostgreSQLバックエンドプロセスのPIDです。
それはpostmasterの起動時に登録されたワーカの場合、またはワーカを登録しているバックエンドがワーカーの起動を待ちたくない場合は0にする必要があります。
それ以外の場合は、<code class="literal">MyProcPid</code>で初期化する必要があります。
  </p><p>ひとたび実行すると、このプロセスは<code class="function">BackgroundWorkerInitializeConnection(<em class="parameter"><code>char *dbname</code></em>, <em class="parameter"><code>char *username</code></em>)</code>または<code class="function">BackgroundWorkerInitializeConnectionByOid(<em class="parameter"><code>Oid dboid</code></em>, <em class="parameter"><code>Oid useroid</code></em>)</code>を呼び出すことによって、データベースに接続できます。
これはプロセスに<code class="literal">SPI</code>インタフェースを使用してのトランザクションとクエリの実行を許します。
もし、<code class="varname">dbname</code>がNULLであった場合、または<code class="varname">dboid</code>が<code class="literal">InvalidOid</code>であった場合には、そのセッションは特定のデータベースに接続しません。しかし、共有カタログにはアクセス出来ます。
もし、<code class="varname">username</code>がNULLの場合、または<code class="varname">useroid</code>が<code class="literal">InvalidOid</code>の場合には、そのプロセスは<code class="command">initdb</code>時に作成されたスーパーユーザとして実行されます。
バックグラウンドワーカはこれら２つの関数をどちらかを一度だけ呼ぶことが出来ます。
データベースを切り替えることができません。
  </p><p>バックグラウンドワーカのメイン関数に制御が達したとき、シグナルは最初にブロックされています。このブロックは解除されなければなりません。
これは、必要に応じてプロセスがシグナルハンドラをカスタマイズできるようにするためです。
シグナルは、新しいプロセスで<code class="function">BackgroundWorkerUnblockSignals</code>を呼び出すことにより解除でき、<code class="function">BackgroundWorkerBlockSignals</code>を呼び出すことでブロックできます。
  </p><p>バックグラウンドワーカは、<code class="structfield">bgw_restart_time</code>が<code class="literal">BGW_NEVER_RESTART</code>に設定されている場合、または終了コード0で終了した場合、または<code class="function">TerminateBackgroundWorker</code>によって終了した場合、postmasterに自動的に登録が解除されて終了します。
それ以外の場合、<code class="structfield">bgw_restart_time</code>で設定された時間の後に再起動します。または、バックエンドの障害のためにpostmasterがクラスタを再初期化した場合は、すぐに再起動します。
一時的に実行を中断するだけでよいバックエンドは、終了するのではなく、割り込み可能なスリープを使用する必要があります。
これは<code class="function">WaitLatch()</code>を呼び出すことによって可能になります。
この関数を呼び出すときには<code class="literal">WL_POSTMASTER_DEATH</code>フラグが設定されているか確認し、<code class="command">postgres</code>自身が終了する緊急事態には、リターンコードを確認するようにしてください。
  </p><p>バックグラウンドワーカを<code class="function">RegisterDynamicBackgroundWorker</code>関数により登録している場合、登録を実行するバックエンドはワーカの状態に関する情報を取得することが可能です。
取得したい場合は<code class="function">RegisterDynamicBackgroundWorker</code>に2番目の引数として<code class="type">BackgroundWorkerHandle *</code>のアドレスを渡す必要があります。
もし登録に成功した場合、このポインタは後で<code class="function">GetBackgroundWorkerPid(<em class="parameter"><code>BackgroundWorkerHandle *</code></em>,<em class="parameter"><code>pid_t *</code></em>)</code>または<code class="function">TerminateBackgroundWorker(<em class="parameter"><code>BackgroundWorkerHandle *</code></em>)</code>に渡すことができるopaque(不透明)ハンドルで、初期化されます。
<code class="function">GetBackgroundWorkerPid</code>はワーカの状態を監視することができます。以下の返り値が得られます。
<code class="literal">BGWH_NOT_YET_STARTED</code>ワーカはまだpostmasterにより開始されていない。
<code class="literal">BGWH_STOPPED</code>開始されたが、もはや実行されていない。
<code class="literal">BGWH_STARTED</code>実行中です。
この最後のケースでは、PIDは、2番目の引数を介して返されます。
<code class="function">TerminateBackgroundWorker</code>はワーカが実行していた場合postmasterがワーカに<code class="literal">SIGTERM</code>を送信し、実行が終了次第すぐに登録を解除します。
  </p><p>場合によっては、バックグラウンドワーカが起動するのを待ってから、ワーカを登録したい場合もあるでしょう。
これは <code class="structfield">bgw_notify_pid</code>を<code class="literal">MyProcPid</code>で初期化し、登録時に得られた<code class="type">BackgroundWorkerHandle *</code>を使用して<code class="function">WaitForBackgroundWorkerStartup(<em class="parameter"><code>BackgroundWorkerHandle *handle</code></em>,<em class="parameter"><code>pid_t *</code></em>)</code>関数を呼び出すことで実現します。
postmasterがバックグラウンドワーカを開始しようと試みたか、postmasterが死ぬまで、この関数はブロックします。
バックグラウンドランナーが実行されている場合、戻り値は<code class="literal">BGWH_STARTED</code>、およびPIDが提供されたアドレスに書き込まれます。
そうでない場合、戻り値は<code class="literal">BGWH_STOPPED</code>または<code class="literal">BGWH_POSTMASTER_DIED</code>になります。
  </p><p>バックグラウンドワーカは、サーバプログラミングインタフェース(<acronym class="acronym">SPI</acronym>)経由で<code class="command">NOTIFY</code>コマンドにより非同期に通知を送る場合、囲んでいるトランザクションをコミットした後、通知を配信することができるように明示的に<code class="function">ProcessCompletedNotifies</code>を呼ぶ必要があります。
バックグラウンドワーカは、<acronym class="acronym">SPI</acronym>を通じて<code class="command">LISTEN</code>による非同期通知の受信を登録した場合、ワーカがこれらの通知をログに記録しますが、ワーカが傍受し、それらの通知に応答するためのプログラム的な方法はありません。
  </p><p>バックグラウンドワーカの実例として、<code class="filename">src/test/modules/worker_spi</code>というモジュールがあります。
これはいくつかの有用な技術を示しています。
  </p><p>登録できるバックグラウンドワーカの最大数は<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>によって制限されています。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spi-spi-freeplan.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="server-programming.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="logicaldecoding.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">SPI_freeplan </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 48. ロジカルデコーディング</td></tr></table></div></body></html>