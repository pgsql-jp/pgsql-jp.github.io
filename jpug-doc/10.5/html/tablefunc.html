<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.39. tablefunc</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sslinfo.html" title="F.38. sslinfo" /><link rel="next" href="tcn.html" title="F.40. tcn" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.39. tablefunc</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sslinfo.html" title="F.38. sslinfo">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="Appendix F. 追加で提供されるモジュール">Up</a></td><th width="60%" align="center">Appendix F. 追加で提供されるモジュール</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="tcn.html" title="F.40. tcn">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TABLEFUNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.39. tablefunc</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="tablefunc.html#id-1.11.7.48.4">F.39.1. 提供される関数</a></span></dt><dt><span class="sect2"><a href="tablefunc.html#id-1.11.7.48.5">F.39.2. 作者</a></span></dt></dl></div><a id="id-1.11.7.48.2" class="indexterm"></a><p><code class="filename">tablefunc</code>モジュールにはテーブル（つまり複数行）を返す各種関数があります。
これらの関数は、その独自の目的として、および、複数行を返すC関数の作成方法を示す例として、有用です。
 </p><div class="sect2" id="id-1.11.7.48.4"><div class="titlepage"><div><div><h3 class="title">F.39.1. 提供される関数</h3></div></div></div><p>  <code class="filename">tablefunc</code>モジュールにより提供される関数を<a class="xref" href="tablefunc.html#TABLEFUNC-FUNCTIONS" title="Table F.31. tablefuncの関数">Table F.31</a>に示します。
  </p><div class="table" id="TABLEFUNC-FUNCTIONS"><p class="title"><strong>Table F.31. <code class="filename">tablefunc</code>の関数</strong></p><div class="table-contents"><table class="table" summary="tablefuncの関数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>戻り値</th><th>説明</th></tr></thead><tbody><tr><td><code class="function">normal_rand(int numvals, float8 mean, float8 stddev)</code></td><td><code class="type">setof float8</code></td><td>正規分布乱数値の集合を生成します。
      </td></tr><tr><td><code class="function">crosstab(text sql)</code></td><td><code class="type">setof record</code></td><td>行の名前と<em class="replaceable"><code>N</code></em>個の値列からなる<span class="quote">“<span class="quote">ピボット表</span>”</span>を生成します。
ここで<em class="replaceable"><code>N</code></em>は呼出元の問い合わせで指定される行型で決定します。
      </td></tr><tr><td><code class="function">crosstab<em class="replaceable"><code>N</code></em>(text sql)</code></td><td><code class="type">setof table_crosstab_<em class="replaceable"><code>N</code></em></code></td><td>行の名前と<em class="replaceable"><code>N</code></em>個の値列からなる<span class="quote">“<span class="quote">ピボット表</span>”</span>を生成します。
<code class="function">crosstab2</code>、<code class="function">crosstab3</code>、<code class="function">crosstab4</code>が定義されていますが、後述する手順で追加の<code class="function">crosstab<em class="replaceable"><code>N</code></em></code>関数を作成することが可能です。
      </td></tr><tr><td><code class="function">crosstab(text source_sql, text category_sql)</code></td><td><code class="type">setof record</code></td><td>2番目の問い合わせで指定された値列を持つ<span class="quote">“<span class="quote">ピボット表</span>”</span>を生成します。
      </td></tr><tr><td><code class="function">crosstab(text sql, int N)</code></td><td><code class="type">setof record</code></td><td>       <p>廃止予定の<code class="function">crosstab(text)</code>です。
値列の数は呼び出す問い合わせで常に決まりますので、現在引数Nは無視されます。
       </p>
      </td></tr><tr><td>       <code class="function">        connectby(text relname, text keyid_fld, text parent_keyid_fld
        [, text orderby_fld ], text start_with, int max_depth
        [, text branch_delim ])
       </code>
       <a id="id-1.11.7.48.4.3.2.2.6.1.2" class="indexterm"></a>
      </td><td><code class="type">setof record</code></td><td>階層ツリー構造表現を生成します。
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="sect3" id="id-1.11.7.48.4.4"><div class="titlepage"><div><div><h4 class="title">F.39.1.1. <code class="function">normal_rand</code></h4></div></div></div><a id="id-1.11.7.48.4.4.2" class="indexterm"></a><pre class="synopsis">normal_rand(int numvals, float8 mean, float8 stddev) returns setof float8</pre><p><code class="function">normal_rand</code>は正規乱数値の集合（ガウス分布）を生成します。
    </p><p>ここで<em class="parameter"><code>numvals</code></em>はこの関数が返す値の数です。
<em class="parameter"><code>mean</code></em>は正規分布の平均値、<em class="parameter"><code>stddev</code></em>は正規分布値の標準偏差です。
    </p><p>例えば、以下の呼出しは、平均5、標準偏差3で1000個の値を要求します。
    </p><pre class="screen">test=# SELECT * FROM normal_rand(1000, 5, 3);
     normal_rand
----------------------
     1.56556322244898
     9.10040991424657
     5.36957140345079
   -0.369151492880995
    0.283600703686639
       .
       .
       .
     4.82992125404908
     9.71308014517282
     2.49639286969028
(1000 rows)</pre></div><div class="sect3" id="id-1.11.7.48.4.5"><div class="titlepage"><div><div><h4 class="title">F.39.1.2. <code class="function">crosstab(text)</code></h4></div></div></div><a id="id-1.11.7.48.4.5.2" class="indexterm"></a><pre class="synopsis">crosstab(text sql)
crosstab(text sql, int N)</pre><p><code class="function">crosstab</code>関数は<span class="quote">“<span class="quote">ピボット</span>”</span>表示を生成するために使用されます。
ここでは、データは下方向にではなくページ横方向に渡って列挙されます。
例えば、以下のようなデータがあるとします。
</p><pre class="programlisting">row1    val11
row1    val12
row1    val13
...
row2    val21
row2    val22
row2    val23
...</pre><p>
これを次のように表示したいとします。
</p><pre class="programlisting">row1    val11   val12   val13   ...
row2    val21   val22   val23   ...
...</pre><p>
<code class="function">crosstab</code>関数は、最初のような書式を持つ生データを生成するSQL問い合わせとなるテキストパラメータを取り、2番目のような書式を持つテーブルを生成します。
   </p><p><em class="parameter"><code>sql</code></em>パラメータは元となるデータ集合を生成するSQL文です。
この文は<code class="structfield">row_name</code>列を1つ、<code class="structfield">category</code>列を1つ、<code class="structfield">value</code>列を1つ返さなければなりません。
<em class="parameter"><code>N</code></em>は廃れたパラメータであり、指定されたとしても無視されます。
（これまでは、これは出力値列の数と一致する必要がありました。しかし、現在これは呼び出し元の問い合わせにより決まります。）
   </p><p>例：指定したSQLは以下のような集合を生成しても構いません。
</p><pre class="programlisting"> row_name    cat    value
----------+-------+-------
  row1      cat1    val1
  row1      cat2    val2
  row1      cat3    val3
  row1      cat4    val4
  row2      cat1    val5
  row2      cat2    val6
  row2      cat3    val7
  row2      cat4    val8</pre><p>
   </p><p><code class="function">crosstab</code>関数は<code class="type">setof record</code>を返すものとして宣言されています。
このため、出力列の実際の名前と型を呼び出し元の<code class="command">SELECT</code>文の<code class="literal">FROM</code>内で宣言しなければなりません。
以下に例を示します。
</p><pre class="programlisting">SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);</pre><p>
この例は以下のような集合を生成します。
</p><pre class="programlisting">           &lt;== value  columns  ==&gt;
 row_name   category_1   category_2
----------+------------+------------
  row1        val1         val2
  row2        val5         val6</pre><p>
   </p><p><code class="literal">FROM</code>句は出力を1つの<code class="structfield">row_name</code>列（SQL問い合わせの最初の結果列と同一データ型）と続くN個の<code class="structfield">value</code>列（SQL問い合わせの3番目の結果列とすべて同じデータ型）を持つものとして定義しなければなりません。
必要なだけの個数の値列を出力するように設定することができます。
出力列の名前は使用者に任されています。
   </p><p><code class="function">crosstab</code>関数は、同じ<code class="structfield">row_name</code>値を持つ入力行の各連続的なグループに対して、1つの出力行を生成します。
左から右へこれらの行の<code class="structfield">value</code>フィールドで出力<code class="structfield">value</code>列を埋めていきます。
もしグループ内の行が存在する出力<code class="structfield">value</code>列より少なければ、余った出力列はNULLになります。
もし行が多ければ、余った入力行は無視されます。
   </p><p>実際のところ、入力行の順序が適切になるように、つまり、同じ<code class="structfield">row_name</code>を持つ値がまとまり、行内で正しく順序付けられるように、SQL問い合わせは常に<code class="literal">ORDER BY 1,2</code>を指定しなければなりません。
<code class="function">crosstab</code>自体が問い合わせ結果の2番目の列に注意を払わないことに注意してください。
これは順序付けのため、3番目の列の値がページに渡って現れる順序を制御するためだけに存在します。
   </p><p>以下に複雑な例を示します。
</p><pre class="programlisting">CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');
INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');
INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');

SELECT *
FROM crosstab(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2')
AS ct(row_name text, category_1 text, category_2 text, category_3 text);

 row_name | category_1 | category_2 | category_3
----------+------------+------------+------------
 test1    | val2       | val3       |
 test2    | val6       | val7       |
(2 rows)</pre><p>
   </p><p>必要な出力行型をその定義に反映した独自のcrosstab関数を構築することで、常に出力列を定義するための<code class="literal">FROM</code>句を書く必要性をなくすことができます。
これは次節で説明します。
他にも必要な<code class="literal">FROM</code>句をビュー定義に埋め込むことでも実現可能です。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="application">psql</span>の<code class="command"><a class="link" href="app-psql.html#APP-PSQL-META-COMMANDS-CROSSTABVIEW">\crosstabview</a></code>コマンドも参照してください。<code class="function">crosstab()</code>と類似の機能を提供します。
    </p></div></div><div class="sect3" id="id-1.11.7.48.4.6"><div class="titlepage"><div><div><h4 class="title">F.39.1.3. <code class="function">crosstab<em class="replaceable"><code>N</code></em>(text)</code></h4></div></div></div><a id="id-1.11.7.48.4.6.2" class="indexterm"></a><pre class="synopsis">crosstab<em class="replaceable"><code>N</code></em>(text sql)</pre><p><code class="function">crosstab<em class="replaceable"><code>N</code></em></code>関数は、呼び出し元の<code class="command">SELECT</code>問い合わせで列名と型を書き出す必要性をなくすことができるように、一般的な<code class="function">crosstab</code>関数に対する独自のラッパを構築する方法の例です。
<code class="filename">tablefunc</code>モジュールには、次のように出力行型が定義された<code class="function">crosstab2</code>、<code class="function">crosstab3</code>、<code class="function">crosstab4</code>が含まれています。
    </p><pre class="programlisting">CREATE TYPE tablefunc_crosstab_N AS (
    row_name TEXT,
    category_1 TEXT,
    category_2 TEXT,
        .
        .
        .
    category_N TEXT
);</pre><p>このように、入力問い合わせが<code class="type">text</code>型の<code class="structfield">row_name</code>列と<code class="structfield">value</code>列を生成し、かつ、2、3、または4個の出力値列を持つ場合、これらの関数を直接使用することができます。
この他の点はすべて、上述の一般的な<code class="function">crosstab</code>関数で説明した通りの動作をします。
    </p><p>例えば、上で挙げた例は下のように動作します。
</p><pre class="programlisting">SELECT *
FROM crosstab3(
  'select rowid, attribute, value
   from ct
   where attribute = ''att2'' or attribute = ''att3''
   order by 1,2');</pre><p>
    </p><p>これらの関数はほぼ説明を目的として提供されたものです。
背後の<code class="function">crosstab()</code>関数に基いた独自の戻り型と関数を作成することができます。
独自のcrosstab関数を構築する方法は2つあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="filename">contrib/tablefunc/tablefunc--1.0.sql</code>の例と同様にして、必要な出力列を記述する複合型を作成します。
そして、<code class="type">text</code>型のパラメータを1つ取り、<code class="type">setof your_type_name</code>を返す一意な名前の関数を、同じ背後の<code class="function">crosstab</code> C関数をリンクさせて定義します。
例えば、元データが行名として<code class="type">text</code>型を、値として<code class="type">float8</code>を生成し、5つの値列を希望する場合、以下のようになります。
</p><pre class="programlisting">CREATE TYPE my_crosstab_float8_5_cols AS (
    my_row_name text,
    my_category_1 float8,
    my_category_2 float8,
    my_category_3 float8,
    my_category_4 float8,
    my_category_5 float8
);

CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)
    RETURNS setof my_crosstab_float8_5_cols
    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;</pre><p>
      </p></li><li class="listitem"><p>暗黙的に戻り値の型を定義する場合は<code class="literal">OUT</code>パラメータを使用してください。
同じ例を以下のように書くこともできます。
</p><pre class="programlisting">CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(
    IN text,
    OUT my_row_name text,
    OUT my_category_1 float8,
    OUT my_category_2 float8,
    OUT my_category_3 float8,
    OUT my_category_4 float8,
    OUT my_category_5 float8)
  RETURNS setof record
  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;</pre><p>
      </p></li></ul></div><p>
    </p></div><div class="sect3" id="id-1.11.7.48.4.7"><div class="titlepage"><div><div><h4 class="title">F.39.1.4. <code class="function">crosstab(text, text)</code></h4></div></div></div><a id="id-1.11.7.48.4.7.2" class="indexterm"></a><pre class="synopsis">crosstab(text source_sql, text category_sql)</pre><p>単一パラメータの<code class="function">crosstab</code>構文の大きな制限は、各値を最初の利用可能な列に挿入して、すべての値をグループのように扱う点です。
値列を特定のデータカテゴリに対応させ、グループの一部はカテゴリの一部のデータを持たない可能性がある場合は、うまく動作しません。
2パラメータを取る<code class="function">crosstab</code>構文は、出力列に対応するカテゴリのリストを明示的に提供することで、こうした状況を扱います。
   </p><p><em class="parameter"><code>source_sql</code></em>は元となるデータ集合を生成するSQL文です。
このSQL文は<code class="structfield">row_name</code>列を1つ<code class="structfield">category</code>列を1つ、<code class="structfield">value</code>列を1つ返さなければなりません。
また1つ以上の<span class="quote">“<span class="quote">追加</span>”</span>の列を持つこともできます。
<code class="structfield">row_name</code>列が先頭でなければなりません。
<code class="structfield">category</code>と<code class="structfield">value</code>列は、この順番で最後の2列でなければなりません。
<code class="structfield">row_name</code>と<code class="structfield">category</code>との間の列はすべて<span class="quote">“<span class="quote">追加</span>”</span>の列とみなされます。
<span class="quote">“<span class="quote">追加</span>”</span>の列は同じ<code class="structfield">row_name</code>値を持つ行すべてで同一であるということが前提です。
   </p><p>例えば、<em class="parameter"><code>source_sql</code></em>は以下のような集合を生成しなければなりません。
</p><pre class="programlisting">SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;

 row_name    extra_col   cat    value
----------+------------+-----+---------
  row1         extra1    cat1    val1
  row1         extra1    cat2    val2
  row1         extra1    cat4    val4
  row2         extra2    cat1    val5
  row2         extra2    cat2    val6
  row2         extra2    cat3    val7
  row2         extra2    cat4    val8</pre><p>
   </p><p><em class="parameter"><code>category_sql</code></em>はカテゴリの集合を生成するSQL文でなければなりません。
このSQL文は1つの列のみを返さなければなりません。
また、少なくとも1つの結果行を生成しなければならず、さもないと、エラーになります。
さらに重複するカテゴリを生成してはなりません。
さもないとエラーとなります。
<em class="parameter"><code>category_sql</code></em>は以下のようなものになります。

</p><pre class="programlisting">SELECT DISTINCT cat FROM foo ORDER BY 1;
    cat
  -------
    cat1
    cat2
    cat3
    cat4</pre><p>
   </p><p><code class="function">crosstab</code>関数は<code class="type">setof record</code>を返すものとして宣言されていますので、出力列の実際の名前と型を、以下の例のように、呼出元の<code class="command">SELECT</code>の<code class="literal">FROM</code>句で定義しなければなりません。

</p><pre class="programlisting">SELECT * FROM crosstab('...', '...')
    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);</pre><p>
   </p><p>これは以下のような集合を生成します。
</p><pre class="programlisting">                  &lt;==  value  columns   ==&gt;
row_name   extra   cat1   cat2   cat3   cat4
---------+-------+------+------+------+------
  row1     extra1  val1   val2          val4
  row2     extra2  val5   val6   val7   val8</pre><p>
   </p><p><code class="literal">FROM</code>句は、出力列の適切な個数、およびその適切なデータ型を定義しなければなりません。
<em class="parameter"><code>source_sql</code></em>問い合わせ結果に<em class="replaceable"><code>N</code></em>個の列がある場合、最初の<em class="replaceable"><code>N</code></em>-2は最初の<em class="replaceable"><code>N</code></em>-2出力列と一致しなければなりません。
残りの出力列は<em class="parameter"><code>source_sql</code></em>問い合わせ結果の最後の列の型を持たなければならず、かつ、<em class="parameter"><code>category_sql</code></em>問い合わせ結果内の行と同じ個数でなければなりません。
   </p><p><code class="function">crosstab</code>関数は、同一<code class="structfield">row_name</code>値を持つ入力行の連続したグループ毎に1つの出力行を生成します。
<code class="structfield">row_name</code>出力列と任意の<span class="quote">“<span class="quote">追加</span>”</span>列はグループの最初の行からコピーされます。
<code class="structfield">value</code>出力列は、<code class="structfield">category</code>値と一致する行の<code class="structfield">value</code>で埋められます。
行の<code class="structfield">category</code>が<em class="parameter"><code>category_sql</code></em>問い合わせの出力とまったく一致しなかった場合、その<code class="structfield">value</code>は無視されます。
グループの入力行内にまったくカテゴリに一致する出力列が存在しない場合、NULLで埋められます。
   </p><p>実際は、同じ<code class="structfield">row_name</code>を持つ値をまとめられるように、<em class="parameter"><code>source_sql</code></em>問い合わせでは常に<code class="literal">ORDER BY 1</code>を指定すべきです。
しかし、グループ内のカテゴリの順序は重要ではありません。
また、<em class="parameter"><code>category_sql</code></em>問い合わせの出力順序が指定された出力列の順序と一致することを確実にすることが重要です。
   </p><p>以下に複雑な例を2つ示します。
</p><pre class="programlisting">create table sales(year int, month int, qty int);
insert into sales values(2007, 1, 1000);
insert into sales values(2007, 2, 1500);
insert into sales values(2007, 7, 500);
insert into sales values(2007, 11, 1500);
insert into sales values(2007, 12, 2000);
insert into sales values(2008, 1, 1000);

select * from crosstab(
  'select year, month, qty from sales order by 1',
  'select m from generate_series(1,12) m'
) as (
  year int,
  "Jan" int,
  "Feb" int,
  "Mar" int,
  "Apr" int,
  "May" int,
  "Jun" int,
  "Jul" int,
  "Aug" int,
  "Sep" int,
  "Oct" int,
  "Nov" int,
  "Dec" int
);
 year | Jan  | Feb  | Mar | Apr | May | Jun | Jul | Aug | Sep | Oct | Nov  | Dec
------+------+------+-----+-----+-----+-----+-----+-----+-----+-----+------+------
 2007 | 1000 | 1500 |     |     |     |     | 500 |     |     |     | 1500 | 2000
 2008 | 1000 |      |     |     |     |     |     |     |     |     |      |
(2 rows)</pre><p>

</p><pre class="programlisting">CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);
INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');
INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');
INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');
INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');
INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');
INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');
INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');

SELECT * FROM crosstab
(
  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',
  'SELECT DISTINCT attribute FROM cth ORDER BY 1'
)
AS
(
       rowid text,
       rowdt timestamp,
       temperature int4,
       test_result text,
       test_startdate timestamp,
       volts float8
);
 rowid |          rowdt           | temperature | test_result |      test_startdate      | volts
-------+--------------------------+-------------+-------------+--------------------------+--------
 test1 | Sat Mar 01 00:00:00 2003 |          42 | PASS        |                          | 2.6987
 test2 | Sun Mar 02 00:00:00 2003 |          53 | FAIL        | Sat Mar 01 00:00:00 2003 | 3.1234
(2 rows)</pre><p>
   </p><p>各問い合わせで結果列の名前と型を記述する必要性をなくすために、事前定義した関数を作成することができます。
前節の例を参照してください。
この<code class="function">crosstab</code>構文用の背後のC関数は<code class="literal">crosstab_hash</code>という名前です。
   </p></div><div class="sect3" id="id-1.11.7.48.4.8"><div class="titlepage"><div><div><h4 class="title">F.39.1.5. <code class="function">connectby</code></h4></div></div></div><a id="id-1.11.7.48.4.8.2" class="indexterm"></a><pre class="synopsis">connectby(text relname, text keyid_fld, text parent_keyid_fld
          [, text orderby_fld ], text start_with, int max_depth
          [, text branch_delim ])</pre><p><code class="function">connectby</code>関数はテーブル内に格納された階層データ表示を生成します。
テーブルは行を一意に識別するキーフィールドと各行の親（もしあれば）を参照する親キーフィールドを持たなければなりません。
<code class="function">connectby</code>は任意の行から辿った部分ツリーを表示することができます。
   </p><p><a class="xref" href="tablefunc.html#TABLEFUNC-CONNECTBY-PARAMETERS" title="Table F.32. connectbyパラメータ">Table F.32</a>ではパラメータを解説します。
   </p><div class="table" id="TABLEFUNC-CONNECTBY-PARAMETERS"><p class="title"><strong>Table F.32. <code class="function">connectby</code>パラメータ</strong></p><div class="table-contents"><table class="table" summary="connectbyパラメータ" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>パラメータ</th><th>説明</th></tr></thead><tbody><tr><td><em class="parameter"><code>relname</code></em></td><td>元となるリレーション名</td></tr><tr><td><em class="parameter"><code>keyid_fld</code></em></td><td>キーフィールドの名前</td></tr><tr><td><em class="parameter"><code>parent_keyid_fld</code></em></td><td>親のキーフィールドの名前</td></tr><tr><td><em class="parameter"><code>orderby_fld</code></em></td><td>兄弟の順序付け用のフィールド名（省略可能）</td></tr><tr><td><em class="parameter"><code>start_with</code></em></td><td>開始行のキー値</td></tr><tr><td><em class="parameter"><code>max_depth</code></em></td><td>辿る深さに対する制限。無制限の場合はゼロ</td></tr><tr><td><em class="parameter"><code>branch_delim</code></em></td><td>キーと分岐出力で区切る文字列（省略可能）</td></tr></tbody></table></div></div><br class="table-break" /><p>キーおよび親キーフィールドは任意のデータ型を取ることができますが、これらは同じデータ型でなければなりません。
キーフィールドのデータ型に関係なく、<em class="parameter"><code>start_with</code></em>はテキスト文字列として入力されなければならないことに注意してください。
    </p><p><code class="function">connectby</code>関数は<code class="type">setof record</code>を返すものとして宣言されていますので、以下の例のように、出力列の実際の名前と型を呼出し元の<code class="command">SELECT</code>文の<code class="literal">FROM</code>句で定義しなければなりません。
    </p><pre class="programlisting">SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
    AS t(keyid text, parent_keyid text, level int, branch text, pos int);</pre><p>先頭から2つの出力列は、現在の行のキーおよび親行のキーとして使用されます。
これらはテーブルのキーフィールドのデータ型と一致する必要があります。
3番目の出力列はツリーの深さであり、<code class="type">integer</code>型である必要があります。
<em class="parameter"><code>branch_delim</code></em>パラメータが与えられた場合、次の出力列は分岐表示であり、<code class="type">text</code>型である必要があります。
最後に、<em class="parameter"><code>orderby_fld</code></em>パラメータが与えられた場合、最後の出力列は連番であり、<code class="type">integer</code>型である必要があります。
    </p><p><span class="quote">“<span class="quote">分岐</span>”</span>出力列は現在の行まで達するために取られるキーの経路を示します。
キーは指定された<em class="parameter"><code>branch_delim</code></em>文字列で区切られます。
分岐表示が不要ならば、<em class="parameter"><code>branch_delim</code></em>パラメータと出力列リスト内の分岐列を省略してください。
    </p><p>同じ親を持つ兄弟の順序が重要な場合、どのフィールドで兄弟の順序付けを行うかを指定する<em class="parameter"><code>orderby_fld</code></em>パラメータを含めてください。
このフィールドは任意のソート可能なデータ型を取ることができます。
<em class="parameter"><code>orderby_fld</code></em>が指定された場合のみ、出力列リストには、最終整数型連番列を含めなければなりません。
    </p><p>テーブルおよびフィールド名を表すパラメータはそのまま<code class="function">connectby</code>が内部的に生成するSQL問い合わせにコピーされます。
したがって、大文字小文字が混在した名前または特殊文字を含む名前の場合は二重引用符で括ってください。
またテーブル名をスキーマで修飾する必要があるかもしれません。
    </p><p>大規模なテーブルでは、親キーフィールド上にインデックスがないと性能が劣化します。
    </p><p><em class="parameter"><code>branch_delim</code></em>文字列がキー値内にまったく出現しないことが重要です。
さもないと、<code class="function">connectby</code>は無限再帰エラーを間違って報告するかもしれません。
<em class="parameter"><code>branch_delim</code></em>が提供されていない場合、再帰を検知するためにデフォルト値<code class="literal">~</code>が使用されます。
     
    </p><p>以下に例を示します。
</p><pre class="programlisting">CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);

INSERT INTO connectby_tree VALUES('row1',NULL, 0);
INSERT INTO connectby_tree VALUES('row2','row1', 0);
INSERT INTO connectby_tree VALUES('row3','row1', 0);
INSERT INTO connectby_tree VALUES('row4','row2', 1);
INSERT INTO connectby_tree VALUES('row5','row2', 0);
INSERT INTO connectby_tree VALUES('row6','row4', 0);
INSERT INTO connectby_tree VALUES('row7','row3', 0);
INSERT INTO connectby_tree VALUES('row8','row6', 0);
INSERT INTO connectby_tree VALUES('row9','row5', 0);

-- 分岐あり、orderby_fldなし(結果の順序は保証されない)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text);
 keyid | parent_keyid | level |       branch
-------+--------------+-------+---------------------
 row2  |              |     0 | row2
 row4  | row2         |     1 | row2~row4
 row6  | row4         |     2 | row2~row4~row6
 row8  | row6         |     3 | row2~row4~row6~row8
 row5  | row2         |     1 | row2~row5
 row9  | row5         |     2 | row2~row5~row9
(6 rows)

-- 分岐なし、orderby_fldなし(結果の順序は保証されない)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int);
 keyid | parent_keyid | level
-------+--------------+-------
 row2  |              |     0
 row4  | row2         |     1
 row6  | row4         |     2
 row8  | row6         |     3
 row5  | row2         |     1
 row9  | row5         |     2
(6 rows)

-- 分岐あり、orderby_fldあり(row5がrow4の前に来ていることに注目)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')
 AS t(keyid text, parent_keyid text, level int, branch text, pos int);
 keyid | parent_keyid | level |       branch        | pos
-------+--------------+-------+---------------------+-----
 row2  |              |     0 | row2                |   1
 row5  | row2         |     1 | row2~row5           |   2
 row9  | row5         |     2 | row2~row5~row9      |   3
 row4  | row2         |     1 | row2~row4           |   4
 row6  | row4         |     2 | row2~row4~row6      |   5
 row8  | row6         |     3 | row2~row4~row6~row8 |   6
(6 rows)

-- 分岐なし、orderby_fldあり(row5がrow4の前に来ていることに注目)
SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)
 AS t(keyid text, parent_keyid text, level int, pos int);
 keyid | parent_keyid | level | pos
-------+--------------+-------+-----
 row2  |              |     0 |   1
 row5  | row2         |     1 |   2
 row9  | row5         |     2 |   3
 row4  | row2         |     1 |   4
 row6  | row4         |     2 |   5
 row8  | row6         |     3 |   6
(6 rows)</pre><p>
    </p></div></div><div class="sect2" id="id-1.11.7.48.5"><div class="titlepage"><div><div><h3 class="title">F.39.2. 作者</h3></div></div></div><p>   Joe Conway
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sslinfo.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tcn.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">F.38. sslinfo </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> F.40. tcn</td></tr></table></div></body></html>