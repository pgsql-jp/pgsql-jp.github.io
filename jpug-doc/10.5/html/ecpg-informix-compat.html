<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.15. Informix互換モード</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ecpg-sql-whenever.html" title="WHENEVER" /><link rel="next" href="ecpg-develop.html" title="35.16. 内部" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.15. <span xmlns="http://www.w3.org/1999/xhtml" class="productname">Informix</span>互換モード</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ecpg-sql-whenever.html" title="WHENEVER">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ecpg.html" title="Chapter 35. ECPG - C言語による埋め込みSQL">Up</a></td><th width="60%" align="center">Chapter 35. <span xmlns="http://www.w3.org/1999/xhtml" class="application">ECPG</span> - C言語による埋め込み<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ecpg-develop.html" title="35.16. 内部">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="ECPG-INFORMIX-COMPAT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.15. <span class="productname">Informix</span>互換モード</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-TYPES">35.15.1. 追加の型</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-STATEMENTS">35.15.2. 追加または存在しない埋め込みSQL文</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-SQLDA">35.15.3. Informix互換SQLDA記述子領域</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-FUNCTIONS">35.15.4. 追加関数</a></span></dt><dt><span class="sect2"><a href="ecpg-informix-compat.html#ECPG-INFORMIX-CONSTANTS">35.15.5. 追加の定数</a></span></dt></dl></div><p><code class="command">ecpg</code>を<em class="firstterm">Informix互換モード</em>というモードで動作させることができます。
このモードが有効ならば、<span class="productname">Informix</span> E/SQL用の<span class="productname">Informix</span>プリプロセッサであるかのように動作します。
一般的にいうと、これにより埋め込みSQLコマンドを導入する際に<code class="literal">EXEC SQL</code>プリミティブの代わりにドル記号を使用することができます。
</p><pre class="programlisting">$int j = 3;
$CONNECT TO :dbname;
$CREATE TABLE test(i INT PRIMARY KEY, j INT);
$INSERT INTO test(i, j) VALUES (7, :j);
$COMMIT;</pre><p>
  </p><div class="note"><h3 class="title">Note</h3><p><code class="literal">$</code>とその後に続く<code class="literal">include</code>、<code class="literal">define</code>、<code class="literal">ifdef</code>などのプリプロセッサ指示子の間に空白文字を含めてはなりません。
こうしないと、プリプロセッサはトークンをホスト変数として解析します。
   </p></div><p><code class="literal">INFORMIX</code>、<code class="literal">INFORMIX_SE</code>という2つの互換モードがあります。
  </p><p>互換モードを使用するプログラムをリンクする際、ECPGに同梱される<code class="literal">libcompat</code>とリンクすることを忘れないでください。
  </p><p>以前に説明した構文上の飾りの他に、<span class="productname">Informix</span>互換モードでは、入力、出力、データ変換関数、E/SQLからECPGで既知の埋め込みSQL文変換に関する関数もいくつか移植しています。
  </p><p><span class="productname">Informix</span>互換モードはECPGのpgtypeslibライブラリと密接に関係しています。
pgtypeslibはSQLデータ型とCホストプログラム内のデータ型を対応付けし、ほとんどの<span class="productname">Informix</span>互換モードで追加された関数を使用してこれらのCホストプログラム型を操作することができます。
しかし、互換範囲は制限されています。
これは<span class="productname">Informix</span>の動作を真似ることはしません。
これを使用して、多少は同じ名前で同じ基本動作を行う関数を操作、提供できますが、<span class="productname">Informix</span>を使用しているのであれば、完全な置き換えにはなりません。
さらに一部のデータ型は異なります。
例えば、<span class="productname">PostgreSQL</span>の日付時刻やinterval型では<code class="literal">YEAR TO MINUTE</code>のような範囲を持ちませんので、これらはECPGではサポートできないことがわかります。
  </p><div class="sect2" id="ECPG-INFORMIX-TYPES"><div class="titlepage"><div><div><h3 class="title">35.15.1. 追加の型</h3></div></div></div><p>右側を切り詰めた文字列データを格納するInformixの特別な"string"仮想型は<code class="literal">typedef</code>を使用せずともInformixモードでサポートされるようになりました。
実際Informixモードでは、ECPGは<code class="literal">typedef sometype string;</code>を含むソースファイルの処理を拒絶します。
</p><pre class="programlisting">EXEC SQL BEGIN DECLARE SECTION;
string userid; /* この変数は切り詰められたデータを含むことになる */
EXEC SQL END DECLARE SECTION;

EXEC SQL FETCH MYCUR INTO :userid;</pre><p>
   </p></div><div class="sect2" id="ECPG-INFORMIX-STATEMENTS"><div class="titlepage"><div><div><h3 class="title">35.15.2. 追加または存在しない埋め込みSQL文</h3></div></div></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">CLOSE DATABASE</code></span></dt><dd><p>このSQL文は現在の接続を閉じます。
実際、これはECPGの<code class="literal">DISCONNECT CURRENT</code>と同義です。
</p><pre class="programlisting">$CLOSE DATABASE;                /* 現在の接続を閉じる */
EXEC SQL CLOSE DATABASE;</pre><p>
       </p></dd><dt><span class="term"><code class="literal">FREE cursor_name</code></span></dt><dd><p>InformixのESQL/Cと比べECPGの動作方法に違いがあります(つまり純粋に文法の変換がどの段階で行われ、背後の実行時ライブラリにどの段階で依存するか)ので、ECPGには<code class="literal">FREE cursor_name</code>文はありません。
このためECPGにおいて、<code class="literal">DECLARE CURSOR</code>がカーソル名を使用する実行時ライブラリ内の関数呼び出しに変換されません。
これはECPG実行時ライブラリ内ではSQLカーソルの実行状況を保持しておらず、PostgreSQLサーバ内のみで保持していることを意味します。
       </p></dd><dt><span class="term"><code class="literal">FREE statement_name</code></span></dt><dd><p><code class="literal">FREE statement_name</code>は<code class="literal">DEALLOCATE PREPARE statement_name</code>の類義語です。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-INFORMIX-SQLDA"><div class="titlepage"><div><div><h3 class="title">35.15.3. Informix互換SQLDA記述子領域</h3></div></div></div><p>Informix互換モードは<a class="xref" href="ecpg-descriptors.html#ECPG-SQLDA-DESCRIPTORS" title="35.7.2. SQLDA記述子領域">Section 35.7.2</a>の説明と異なる構造体をサポートします。
以下を参照してください。
</p><pre class="programlisting">struct sqlvar_compat
{
    short   sqltype;
    int     sqllen;
    char   *sqldata;
    short  *sqlind;
    char   *sqlname;
    char   *sqlformat;
    short   sqlitype;
    short   sqlilen;
    char   *sqlidata;
    int     sqlxid;
    char   *sqltypename;
    short   sqltypelen;
    short   sqlownerlen;
    short   sqlsourcetype;
    char   *sqlownername;
    int     sqlsourceid;
    char   *sqlilongdata;
    int     sqlflags;
    void   *sqlreserved;
};

struct sqlda_compat
{
    short  sqld;
    struct sqlvar_compat *sqlvar;
    char   desc_name[19];
    short  desc_occ;
    struct sqlda_compat *desc_next;
    void  *reserved;
};

typedef struct sqlvar_compat    sqlvar_t;
typedef struct sqlda_compat     sqlda_t;</pre><p>
   </p><p>大域的な属性を以下に示します。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sqld</code></span></dt><dd><p><code class="literal">SQLDA</code>記述子内のフィールド数です。
       </p></dd><dt><span class="term"><code class="literal">sqlvar</code></span></dt><dd><p>フィールド単位の属性へのポインタです。
       </p></dd><dt><span class="term"><code class="literal">desc_name</code></span></dt><dd><p>未使用です。
ゼロバイトで埋められます。
       </p></dd><dt><span class="term"><code class="literal">desc_occ</code></span></dt><dd><p>割り当てられた構造体のサイズです。
       </p></dd><dt><span class="term"><code class="literal">desc_next</code></span></dt><dd><p>結果セットに複数のレコードが含まれる場合、次のSQLDA構造体へのポインタです。
       </p></dd><dt><span class="term"><code class="literal">reserved</code></span></dt><dd><p>未使用のポインタでNULLが含まれます。
Informix互換のために保持されます。
       </p></dd></dl></div><p>

フィールド毎の属性を以下に示します。
これらは<code class="literal">sqlvar</code>配列内に格納されます。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">sqltype</code></span></dt><dd><p>フィールドの型です。
定数は<code class="literal">sqltypes.h</code>内に記載されています。
       </p></dd><dt><span class="term"><code class="literal">sqllen</code></span></dt><dd><p>フィールドデータ長です。
       </p></dd><dt><span class="term"><code class="literal">sqldata</code></span></dt><dd><p>フィールドデータへのポインタです。
このポインタは<code class="literal">char *</code>型です。
指し示されるデータはバイナリ書式です。
以下に例を示します。
</p><pre class="programlisting">int intval;

switch (sqldata-&gt;sqlvar[i].sqltype)
{
    case SQLINTEGER:
        intval = *(int *)sqldata-&gt;sqlvar[i].sqldata;
        break;
  ...
}</pre><p>
       </p></dd><dt><span class="term"><code class="literal">sqlind</code></span></dt><dd><p>NULL指示子へのポインタです。
DESCRIBEまたはFETCHで返される場合、常に有効なポインタです。
<code class="literal">EXECUTE ... USING sqlda;</code>への入力として使用される場合、NULLポインタ値はこのフィールドの値が非NULLであることを意味します。
さもなくば、有効なポインタと<code class="literal">sqlitype</code>は適切に設定されなければなりません。
以下に例を示します。
</p><pre class="programlisting">if (*(int2 *)sqldata-&gt;sqlvar[i].sqlind != 0)
    printf("value is NULL\n");</pre><p>
       </p></dd><dt><span class="term"><code class="literal">sqlname</code></span></dt><dd><p>フィールド名です。
ゼロ終端の文字列です。
       </p></dd><dt><span class="term"><code class="literal">sqlformat</code></span></dt><dd><p>Informixでは予約されています。
このフィールドの<code class="function">PQfformat()</code>の値です。
       </p></dd><dt><span class="term"><code class="literal">sqlitype</code></span></dt><dd><p>NULL指示子データの型です。
サーバからデータが返される場合は常にSQLSMINTです。
パラメータ付き問い合わせで<code class="literal">SQLDA</code>が使用される時、データは集合型にしたがって扱われます。
       </p></dd><dt><span class="term"><code class="literal">sqlilen</code></span></dt><dd><p>NULL指示子データの長さです。
       </p></dd><dt><span class="term"><code class="literal">sqlxid</code></span></dt><dd><p>フィールドの拡張型で、<code class="function">PQftype()</code>の結果です。
       </p></dd><dt><span class="term"><code class="literal">sqltypename</code><br /></span><span class="term"><code class="literal">sqltypelen</code><br /></span><span class="term"><code class="literal">sqlownerlen</code><br /></span><span class="term"><code class="literal">sqlsourcetype</code><br /></span><span class="term"><code class="literal">sqlownername</code><br /></span><span class="term"><code class="literal">sqlsourceid</code><br /></span><span class="term"><code class="literal">sqlflags</code><br /></span><span class="term"><code class="literal">sqlreserved</code></span></dt><dd><p>未使用です。
       </p></dd><dt><span class="term"><code class="literal">sqlilongdata</code></span></dt><dd><p><code class="literal">sqllen</code>が32キロバイトより大きい場合<code class="literal">sqldata</code>と同じです。
       </p></dd></dl></div><p>

以下に例を示します。
</p><pre class="programlisting">EXEC SQL INCLUDE sqlda.h;

    sqlda_t        *sqlda; /* これは埋め込まれたDECLARE SECTIONの中にある必要はない */

    EXEC SQL BEGIN DECLARE SECTION;
    char *prep_stmt = "select * from table1";
    int i;
    EXEC SQL END DECLARE SECTION;

    ...

    EXEC SQL PREPARE mystmt FROM :prep_stmt;

    EXEC SQL DESCRIBE mystmt INTO sqlda;

    printf("# of fields: %d\n", sqlda-&gt;sqld);
    for (i = 0; i &lt; sqlda-&gt;sqld; i++)
      printf("field %d: \"%s\"\n", sqlda-&gt;sqlvar[i]-&gt;sqlname);

    EXEC SQL DECLARE mycursor CURSOR FOR mystmt;
    EXEC SQL OPEN mycursor;
    EXEC SQL WHENEVER NOT FOUND GOTO out;

    while (1)
    {
      EXEC SQL FETCH mycursor USING sqlda;
    }

    EXEC SQL CLOSE mycursor;

    free(sqlda); /* 主な構造体はすべてfree()される、
                  * sqldaとsqlda-&gt;sqlvarは1つの割り当て領域内にある */</pre><p>
より詳細については<code class="literal">sqlda.h</code>ヘッダファイルと<code class="literal">src/interfaces/ecpg/test/compat_informix/sqlda.pgc</code>リグレッションテストを参照してください。
   </p></div><div class="sect2" id="ECPG-INFORMIX-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">35.15.4. 追加関数</h3></div></div></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="function">decadd</code></span></dt><dd><p>2つのdecimal型変数を加算します。
</p><pre class="synopsis">int decadd(decimal *arg1, decimal *arg2, decimal *sum);</pre><p>
この関数は、decimal型の最初の演算項目(<code class="literal">arg1</code>)へのポインタ、decimal型の2番目の演算項目(<code class="literal">arg2</code>)へのポインタ、加算結果を格納するdecimal型値(<code class="literal">sum</code>)へのポインタを受付けます。
成功すると、この関数は0を返します。
オーバーフローが発生した場合は<code class="symbol">ECPG_INFORMIX_NUM_OVERFLOW</code>が、アンダーフローの場合は<code class="symbol">ECPG_INFORMIX_NUM_UNDERFLOW</code>が返ります。
この他の失敗が発生した場合は-1が返り、<code class="varname">errno</code>にはpgtypeslibにおける対応する<code class="varname">errno</code>番号が設定されます。
       </p></dd><dt><span class="term"><code class="function">deccmp</code></span></dt><dd><p>2つのdecimal型変数を比較します。
</p><pre class="synopsis">int deccmp(decimal *arg1, decimal *arg2);</pre><p>
この関数は、最初のdecimal値(<code class="literal">arg1</code>)へのポインタ、2番目のdecimal値(<code class="literal">arg2</code>)へのポインタを受付け、どちらが大きいかを示すint値を返します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">arg1</code>が指し示す値が<code class="literal">arg2</code>が指し示す値より大きければ1。
          </p></li><li class="listitem"><p><code class="literal">arg1</code>が指し示す値が<code class="literal">arg2</code>が指し示す値より小さければ-1。
          </p></li><li class="listitem"><p><code class="literal">arg1</code>が指し示す値と<code class="literal">arg2</code>が指し示す値が同じならば0。
          </p></li></ul></div><p>
       </p></dd><dt><span class="term"><code class="function">deccopy</code></span></dt><dd><p>decimal値をコピーします。
</p><pre class="synopsis">void deccopy(decimal *src, decimal *target);</pre><p>
この関数は、最初の引数としてコピー元のdecimal値(<code class="literal">src</code>)へのポインタ、2番目の引数としてdecimal型のコピー先構造体(<code class="literal">target</code>)へのポインタを受付けます。
       </p></dd><dt><span class="term"><code class="function">deccvasc</code></span></dt><dd><p>ASCII表現からdecimal型に値を変換します。
</p><pre class="synopsis">int deccvasc(char *cp, int len, decimal *np);</pre><p>
この関数は、変換対象の文字列表現を持つ文字列(<code class="literal">cp</code>)へのポインタとその文字列長<code class="literal">len</code>を受付けます。
<code class="literal">np</code>はこの操作結果を格納するdecimal型の値へのポインタです。
       </p><p>有効な書式の例は以下の通りです。
         <code class="literal">-2</code>、
         <code class="literal">.794</code>、
         <code class="literal">+3.44</code>、
         <code class="literal">592.49E07</code>、
         <code class="literal">-32.84e-4</code>。
       </p><p>この関数は成功時0を返します。
オーバーフローやアンダーフローが発生した場合は<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>や<code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>が返されます。
ASCII表現の解析ができなかった場合は<code class="literal">ECPG_INFORMIX_BAD_NUMERIC</code>が、指数部分の解析に問題がある場合は<code class="literal">ECPG_INFORMIX_BAD_EXPONENT</code>が返されます。
       </p></dd><dt><span class="term"><code class="function">deccvdbl</code></span></dt><dd><p>double型の値をdecimal型の値に変換します。
</p><pre class="synopsis">int deccvdbl(double dbl, decimal *np);</pre><p>
この関数は、最初の引数として変換対象のdouble型の変数(<code class="literal">dbl</code>)を受付けます。
2番目の引数(<code class="literal">np</code>)として、この関数は操作結果を格納するdecimal型変数へのポインタを受付けます。
       </p><p>この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </p></dd><dt><span class="term"><code class="function">deccvint</code></span></dt><dd><p>int型の値をdecimal型の値に変換します。
</p><pre class="synopsis">int deccvint(int in, decimal *np);</pre><p>
この関数は最初の引数として、変換対象のint型変数(<code class="literal">in</code>)を受付けます。
2番目の引数(<code class="literal">np</code>)として、この関数は変換結果を格納するdecimal型変数へのポインタを受付けます。
       </p><p>この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </p></dd><dt><span class="term"><code class="function">deccvlong</code></span></dt><dd><p>long型の値をdecimal型の値に変換します。
</p><pre class="synopsis">int deccvlong(long lng, decimal *np);</pre><p>
この関数は最初の引数として、変換対象のlong型変数(<code class="literal">lng</code>)を受付けます。
2番目の引数(<code class="literal">np</code>)として、この関数は変換結果を格納するdecimal型変数へのポインタを受付けます。
       </p><p>この関数は成功時に0を返します。
変換が失敗した場合は負の値が返ります。
       </p></dd><dt><span class="term"><code class="function">decdiv</code></span></dt><dd><p>2つのdecimal型変数の除算を行います。
</p><pre class="synopsis">int decdiv(decimal *n1, decimal *n2, decimal *result);</pre><p>
この関数は、1番目の演算項目(<code class="literal">n1</code>)と2番目の演算項目(<code class="literal">n2</code>)となる変数のポインタを受付け、<code class="literal">n1</code>/<code class="literal">n2</code>を計算します。
<code class="literal">result</code>は、操作結果を格納する変数へのポインタです。
       </p><p>成功時0が返され、除算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>、<code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>を返します。
0割りが発生した場合は<code class="literal">ECPG_INFORMIX_DIVIDE_ZERO</code>が返されます。
       </p></dd><dt><span class="term"><code class="function">decmul</code></span></dt><dd><p>2つのdecimal型変数を乗算します。
</p><pre class="synopsis">int decmul(decimal *n1, decimal *n2, decimal *result);</pre><p>
この関数は、1番目の演算項目(<code class="literal">n1</code>)と2番目の演算項目(<code class="literal">n2</code>)となる変数のポインタを受付け、<code class="literal">n1</code>*<code class="literal">n2</code>を計算します。
<code class="literal">result</code>は、操作結果を格納する変数へのポインタです。
       </p><p>成功時0が返され、乗算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>、<code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>を返します。
       </p></dd><dt><span class="term"><code class="function">decsub</code></span></dt><dd><p>10進数型値同士の引算を行います。
</p><pre class="synopsis">int decsub(decimal *n1, decimal *n2, decimal *result);</pre><p>
この関数は、1番目の演算項目(<code class="literal">n1</code>)と2番目の演算項目(<code class="literal">n2</code>)となる変数のポインタを受付け、<code class="literal">n1</code>-<code class="literal">n2</code>を計算します。
<code class="literal">result</code>は、操作結果を格納する変数へのポインタです。
       </p><p>成功時0が返され、減算の失敗時には負の値が返されます。
オーバーフローやアンダーフローが発生した場合、この関数はそれぞれ<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>、<code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code>を返します。
       </p></dd><dt><span class="term"><code class="function">dectoasc</code></span></dt><dd><p>decimal型変数をC char* 文字列のASCII表現に変換します。
</p><pre class="synopsis">int dectoasc(decimal *np, char *cp, int len, int right)</pre><p>
この関数はdecimal型変数(<code class="literal">np</code>)のポインタを受け付け、テキスト表現に変換します。
<code class="literal">cp</code>は変換結果を格納するためのバッファです。
<code class="literal">right</code>パラメータは、decimal小数点の右側の何桁を出力するかを指定します。
結果はこの10進桁数で丸められます。
<code class="literal">right</code>を-1にすることで、すべての有効な桁数が出力されるようになります。
<code class="literal">len</code>で示す出力バッファ長が、最後のNULL文字を含むテキスト表現を格納するのには不十分であった場合、結果には<code class="literal">*</code>という1文字が格納され、-1が返されます。
       </p><p>この関数は、<code class="literal">cp</code>バッファが小さすぎる場合に-1を返します。
メモリ不足の場合は<code class="literal">ECPG_INFORMIX_OUT_OF_MEMORY</code>を返します。
       </p></dd><dt><span class="term"><code class="function">dectodbl</code></span></dt><dd><p>decimal型変数をdoubleに変換します。
</p><pre class="synopsis">int dectodbl(decimal *np, double *dblp);</pre><p>
この関数は変換対象のdecimal型変数(<code class="literal">np</code>)のポインタと処理結果を格納するdouble変数(<code class="literal">dblp</code>)へのポインタを受け付けます。
       </p><p>成功時0が、変換失敗時負の値が返されます。
       </p></dd><dt><span class="term"><code class="function">dectoint</code></span></dt><dd><p>decimal型変数を整数型に変換します。
</p><pre class="synopsis">int dectoint(decimal *np, int *ip);</pre><p>
この関数は変換対象のdecimal型変数(<code class="literal">np</code>)のポインタと処理結果を格納するint型変数(<code class="literal">ip</code>)へのポインタを受け付けます。
       </p><p>成功時0が、変換失敗時負の値が返されます。
オーバーフローが発生した場合は<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>が返されます。
       </p><p>このECPGの実装は<span class="productname">Informix</span>の実装と異なることに注意してください。
<span class="productname">Informix</span>では、整数範囲に-32767から32767までという制限をしていますが、ECPGでの制限はアーキテクチャに依存(<code class="literal">-INT_MAX .. INT_MAX</code>)します。
       </p></dd><dt><span class="term"><code class="function">dectolong</code></span></dt><dd><p>decimal型変数をlong型に変換します。
</p><pre class="synopsis">int dectolong(decimal *np, long *lngp);</pre><p>
この関数は変換対象のdecimal型変数(<code class="literal">np</code>)のポインタと処理結果を格納するlong変数(<code class="literal">lngp</code>)へのポインタを受け付けます。
       </p><p>成功時0が、変換失敗時負の値が返されます。
オーバーフローが発生した場合は<code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code>が返されます。
       </p><p>このECPGの実装は<span class="productname">Informix</span>の実装と異なることに注意してください。
<span class="productname">Informix</span>では、整数範囲に-2,147,483,647から2,147,483,647までという制限をしていますが、ECPGでの制限はアーキテクチャに依存(<code class="literal">-LONG_MAX .. LONG_MAX</code>)します。
       </p></dd><dt><span class="term"><code class="function">rdatestr</code></span></dt><dd><p>date型をC char*文字列に変換します。
</p><pre class="synopsis">int rdatestr(date d, char *str);</pre><p>
この関数は2つの引数を受付けます。
最初の引数は変換対象のdate型(<code class="literal">d</code>)、2番目は変換後の文字列へのポインタです。
出力書式は常に<code class="literal">yyyy-mm-dd</code>ですので、少なくとも11文字（NULL終端を含む）を結果文字列に割り当てなければなりません。
       </p><p>この関数は成功時0を、エラー時負の値を返します。
       </p><p>このECPGの実装は<span class="productname">Informix</span>の実装と異なることに注意してください。
<span class="productname">Informix</span>では、環境変数により書式を変更できますが、ECPGでは出力書式を変更することはできません。
       </p></dd><dt><span class="term"><code class="function">rstrdate</code></span></dt><dd><p>date型のテキスト表現を解析します。
</p><pre class="synopsis">int rstrdate(char *str, date *d);</pre><p>
この関数は、変換対象のdate型のテキスト表現(<code class="literal">str</code>)とdate型変数のポインタ(<code class="literal">d</code>)を受付けます。
この関数では書式マスクを指定することができません。
<span class="productname">Informix</span>のデフォルトの書式マスクである<code class="literal">mm/dd/yyyy</code>を使用します。
内部的には、この関数は<code class="function">rdefmtdate</code>を使用して実装しています。
したがって<code class="function">rstrdate</code>は速くありません。
もし選択肢があるのであれば、書式マスクを明示的に指定することができる<code class="function">rdefmtdate</code>を選択すべきです。
       </p><p>この関数は<code class="function">rdefmtdate</code>と同様の値を返します。
       </p></dd><dt><span class="term"><code class="function">rtoday</code></span></dt><dd><p>現在の日付を（date型で）入手します。
</p><pre class="synopsis">void rtoday(date *d);</pre><p>
この関数はdate型変数(<code class="literal">d</code>)へのポインタを受付け、そこに現在の日付を格納します。
       </p><p>内部的には、この関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESDATETODAY"><code class="function">PGTYPESdate_today</code></a>関数を使用します。
       </p></dd><dt><span class="term"><code class="function">rjulmdy</code></span></dt><dd><p>date型変数から、日、月、年の値を取り出します。
</p><pre class="synopsis">int rjulmdy(date d, short mdy[3]);</pre><p>
この関数は日付<code class="literal">d</code>、3つのshort integer型の値からなる配列<code class="literal">mdy</code>へのポインタを受付けます。
この変数名はその並びを表し、<code class="literal">mdy[0]</code>には月数、<code class="literal">mdy[1]</code>には日数が、<code class="literal">mdy[2]</code>には年が入ります。
       </p><p>現在この関数は常に0を返します。
       </p><p>内部的にはこの関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEJULMDY"><code class="function">PGTYPESdate_julmdy</code></a>関数を使用します。
       </p></dd><dt><span class="term"><code class="function">rdefmtdate</code></span></dt><dd><p>書式マスクを使用して、文字列をdate型の値に変換します。
</p><pre class="synopsis">int rdefmtdate(date *d, char *fmt, char *str);</pre><p>
この関数は、処理結果を格納するためのdate型へのポインタ(<code class="literal">d</code>)、日付を解析するための書式マスク(<code class="literal">fmt</code>)、dateのテキスト表現を含むCのchar*文字列(<code class="literal">str</code>)を受付けます。
テキスト表現は書式マスクに合った表現であることが仮定されています。
しかし、文字列と書式マスクを1:1に対応付けする必要はありません。
この関数は並んだ順番に解析し、年の位置を表す<code class="literal">yy</code>または<code class="literal">yyyy</code>を、月の位置を表す<code class="literal">mm</code>を、日の位置を表す<code class="literal">dd</code>を検索します。
       </p><p>この関数は以下の値を返します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0 - 関数が正常に終了しました。
          </p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_ENOSHORTDATE</code> - 日付に、日、月、年を区切る文字がありませんでした。
この場合、入力文字列は6バイト、8バイトのいずれかでなければなりませんが、そうではありませんでした。
          </p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_ENOTDMY</code> - 書式文字列が正しく年月日の順番を示していません。
          </p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_DAY</code> - 入力文字列に有効な日が含まれていません。
          </p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_MONTH</code> - 入力文字列に有効な月が含まれていません。
          </p></li><li class="listitem"><p><code class="literal">ECPG_INFORMIX_BAD_YEAR</code> - 入力文字列に有効な年が含まれていません。
          </p></li></ul></div><p>
       </p><p>内部的には、この関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEDEFMTASC"><code class="function">PGTYPESdate_defmt_asc</code></a>関数を使用して実装しています。
この関数の説明には、入力例の表がありますので、こちらも参照してください。
       </p></dd><dt><span class="term"><code class="function">rfmtdate</code></span></dt><dd><p>書式マスクを使用してdate型変数をテキスト表現に変換します。
</p><pre class="synopsis">int rfmtdate(date d, char *fmt, char *str);</pre><p>
この関数は変換対象の日付(<code class="literal">d</code>)、書式マスク(<code class="literal">fmt</code>)、日付のテキスト表現を格納する文字列(<code class="literal">str</code>)を受付けます。
       </p><p>成功時0、エラーが発生した場合は負の値が返されます。
       </p><p>内部的にはこの関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEFMTASC"><code class="function">PGTYPESdate_fmt_asc</code></a>関数を使用します。
例が記載されていますので、こちらも参照してください。
       </p></dd><dt><span class="term"><code class="function">rmdyjul</code></span></dt><dd><p>日付の日、月、年を表す3つのshort integer型からなる配列から日付型の値を作成します。
</p><pre class="synopsis">int rmdyjul(short mdy[3], date *d);</pre><p>
この関数は3つのshort integer型からなる配列(<code class="literal">mdy</code>)と処理結果を格納するdate型変数へのポインタを受付けます。
       </p><p>現在この関数は常に0を返します。
       </p><p>内部的にはこの関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEMDYJUL"><code class="function">PGTYPESdate_mdyjul</code></a>関数を使用して実装しています。
       </p></dd><dt><span class="term"><code class="function">rdayofweek</code></span></dt><dd><p>日付型の値の週内日数を示す値を返します。
</p><pre class="synopsis">int rdayofweek(date d);</pre><p>
この関数はdate型変数<code class="literal">d</code>をその唯一の引数として受付け、その日付の週内日数を示す整数を返します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>0 - 日曜
          </p></li><li class="listitem"><p>1 - 月曜
          </p></li><li class="listitem"><p>2 - 火曜
          </p></li><li class="listitem"><p>3 - 水曜
          </p></li><li class="listitem"><p>4 - 木曜
          </p></li><li class="listitem"><p>5 - 金曜
          </p></li><li class="listitem"><p>6 - 土曜
          </p></li></ul></div><p>
       </p><p>内部的にはこの関数は <a class="xref" href="ecpg-pgtypes.html#PGTYPESDATEDAYOFWEEK"><code class="function">PGTYPESdate_dayofweek</code></a>関数を使用して実装しています。
       </p></dd><dt><span class="term"><code class="function">dtcurrent</code></span></dt><dd><p>現在のタイムスタンプを取り出します。
</p><pre class="synopsis">void dtcurrent(timestamp *ts);</pre><p>
この関数は現在のタイムスタンプを受け取り、<code class="literal">ts</code>が指し示すタイムスタンプ型変数に格納します。
       </p></dd><dt><span class="term"><code class="function">dtcvasc</code></span></dt><dd><p>テキスト表現からtimestamp型変数にタイムスタンプを解析します。
</p><pre class="synopsis">int dtcvasc(char *str, timestamp *ts);</pre><p>
この関数は対象の文字列(<code class="literal">str</code>)と処理結果を格納するtimestamp型変数(<code class="literal">ts</code>)へのポインタを受付けます。
       </p><p>この関数は成功時0を返し、エラー時負の値を返します。
       </p><p>内部的にはこの関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFROMASC"><code class="function">PGTYPEStimestamp_from_asc</code></a>関数を使用します。
入力例の表がありますので、こちらも参照してください。
       </p></dd><dt><span class="term"><code class="function">dtcvfmtasc</code></span></dt><dd><p>書式マスクを使用してタイムスタンプのテキスト表現をtimestamp型変数に変換します。
</p><pre class="synopsis">dtcvfmtasc(char *inbuf, char *fmtstr, timestamp *dtvalue)</pre><p>
この関数は、対象とする文字列(<code class="literal">inbuf</code>)、使用する書式マスク(<code class="literal">fmtstr</code>)、処理結果を格納するtimestamp変数(<code class="literal">dtvalue</code>)へのポインタを受付けます。
       </p><p>この関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPDEFMTASC"><code class="function">PGTYPEStimestamp_defmt_asc</code></a>関数を使用して実装されています。
使用可能な書式指定のリストがありますので、こちらも参照してください。
       </p><p>この関数は成功時に0を、エラー時負の値を返します。
       </p></dd><dt><span class="term"><code class="function">dtsub</code></span></dt><dd><p>timestamp型同士で減算を行い、interval型変数を返します。
</p><pre class="synopsis">int dtsub(timestamp *ts1, timestamp *ts2, interval *iv);</pre><p>
この関数は<code class="literal">ts1</code>が指し示すtimestamp型変数から<code class="literal">ts2</code>が指し示すtimestamp型変数を引きます。
結果は<code class="literal">iv</code>が指し示すinterval型変数に格納されます。
       </p><p>成功時この関数は0を返し、エラー時負の値を返します。
       </p></dd><dt><span class="term"><code class="function">dttoasc</code></span></dt><dd><p>timestamp型変数をC char*文字列に変換します。
</p><pre class="synopsis">int dttoasc(timestamp *ts, char *output);</pre><p>
この関数は対象のtimestamp型変数(<code class="literal">ts</code>)へのポインタ、処理結果を格納する文字列(<code class="literal">output</code>)を受付けます。
これは<code class="literal">ts</code>を標準SQLに従うテキスト表現（<code class="literal">YYYY-MM-DD HH:MM:SS</code>として定義）に変換します。
       </p><p>成功時この関数は0を返し、エラー時負の値を返します。
       </p></dd><dt><span class="term"><code class="function">dttofmtasc</code></span></dt><dd><p>書式マスクを使用してtimestamp型変数をC char*に変換します。
</p><pre class="synopsis">int dttofmtasc(timestamp *ts, char *output, int str_len, char *fmtstr);</pre><p>
この関数は、最初の引数として変換対象のタイムスタンプ(<code class="literal">ts</code>)を、出力バッファのポインタ(<code class="literal">output</code>)、出力バッファで割当て可能な最大長 (<code class="literal">str_len</code>)、変換に使用する書式マスク(<code class="literal">fmtstr</code>)を受付けます。
       </p><p>成功時この関数は0を返します。エラーが発生した場合は負の値を返します。
       </p><p>内部的に、この関数は<a class="xref" href="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"><code class="function">PGTYPEStimestamp_fmt_asc</code></a>関数を使用します。
使用できる書式マスクに関する情報がありますので、こちらも参照してください。
       </p></dd><dt><span class="term"><code class="function">intoasc</code></span></dt><dd><p>interval型変数をC char*文字列に変換します。
</p><pre class="synopsis">int intoasc(interval *i, char *str);</pre><p>
この関数は、変換対象のinterval型変数(<code class="literal">i</code>)へのポインタ、処理結果を格納する文字列(<code class="literal">str</code>)を受付けます。
これは<code class="literal">i</code>を標準SQLに従うテキスト表現（<code class="literal">YYYY-MM-DD HH:MM:SS</code>として定義）に変換します。
       </p><p>成功時、この関数は0を返します。
エラーが発生した場合は負の値を返します。
       </p></dd><dt><span class="term"><code class="function">rfmtlong</code></span></dt><dd><p>long integer値を書式マスクを使用してテキスト表現に変換します。
</p><pre class="synopsis">int rfmtlong(long lng_val, char *fmt, char *outbuf);</pre><p>
この関数は、long型の値<code class="literal">lng_val</code>、書式マスク<code class="literal">fmt</code>、出力バッファ<code class="literal">outbuf</code>へのポインタを受付けます。
これはlong型の値を書式マスクに従ってテキスト表現に変換します。
       </p><p>書式マスクは以下の書式指定文字を組み合わせることができます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">*</code> (アスタリスク) - この位置が空白ならばアスタリスクで埋めます。
          </p></li><li class="listitem"><p><code class="literal">&amp;</code> (アンパサンド) - この位置が空白ならば0で埋めます。
          </p></li><li class="listitem"><p>           <code class="literal">#</code> - 先頭のゼロを空白に変換します。
          </p></li><li class="listitem"><p>           <code class="literal">&lt;</code> - 文字列内で数値を左そろえします。
          </p></li><li class="listitem"><p><code class="literal">,</code> (カンマ) - 4桁以上の数値をカンマで区切った3桁にグループ化します。
          </p></li><li class="listitem"><p>           <code class="literal">.</code> (ピリオド) - この文字は数値から小数部分を区別します。
          </p></li><li class="listitem"><p>           <code class="literal">-</code> (マイナス) - 数値が負の場合、マイナス記号を付けます。
          </p></li><li class="listitem"><p>           <code class="literal">+</code> (プラス) - 数値が正の場合プラス記号を付けます。
          </p></li><li class="listitem"><p>           <code class="literal">(</code> - これは負の値の先頭のマイナス記号を置き換えます。
マイナス記号は現れません。
          </p></li><li class="listitem"><p>           <code class="literal">)</code> - この文字はマイナス記号を置き換え、負の値の最後に出力します。
          </p></li><li class="listitem"><p>           <code class="literal">$</code> - 通貨記号
          </p></li></ul></div><p>
       </p></dd><dt><span class="term"><code class="function">rupshift</code></span></dt><dd><p>文字列を大文字に変換します。
</p><pre class="synopsis">void rupshift(char *str);</pre><p>
この関数は文字列へのポインタを受付け、すべての小文字を大文字に変換します。
       </p></dd><dt><span class="term"><code class="function">byleng</code></span></dt><dd><p>文字列内の文字数を返します。
ただし、末尾の空白は数えません。
</p><pre class="synopsis">int byleng(char *str, int len);</pre><p>
この関数は最初の引数として、固定長の文字列(<code class="literal">str</code>)を、2番目の引数としてその文字列長 (<code class="literal">len</code>)想定しています。
これは、文字列から末尾の空白を取り除いた、有効文字の数を返します。
       </p></dd><dt><span class="term"><code class="function">ldchar</code></span></dt><dd><p>固定長の文字列をNULL終端の文字列に複製します。
</p><pre class="synopsis">void ldchar(char *src, int len, char *dest);</pre><p>
この関数はコピー対象の固定長の文字列(<code class="literal">src</code>)、文字列長(<code class="literal">len</code>)、格納先メモリ(<code class="literal">dest</code>)へのポインタを受付けます。
<code class="literal">dest</code>が指し示す文字列には少なくとも<code class="literal">len+1</code>バイトを割り当てなければならない点に注意してください。
この関数は多くても<code class="literal">len</code>バイトを新しい場所にコピーします。
（元の文字列が末尾に空白文字を持つ場合に少なくなります。）
そして、NULL終端を付与します。
       </p></dd><dt><span class="term"><code class="function">rgetmsg</code></span></dt><dd><pre class="synopsis">int rgetmsg(int msgnum, char *s, int maxsize);</pre><p>
この関数は存在しますが、現在実装されていません。
       </p></dd><dt><span class="term"><code class="function">rtypalign</code></span></dt><dd><pre class="synopsis">int rtypalign(int offset, int type);</pre><p>
この関数は存在しますが、現在実装されていません。
       </p></dd><dt><span class="term"><code class="function">rtypmsize</code></span></dt><dd><pre class="synopsis">int rtypmsize(int type, int len);</pre><p>
この関数は存在しますが、現在実装されていません。
       </p></dd><dt><span class="term"><code class="function">rtypwidth</code></span></dt><dd><pre class="synopsis">int rtypwidth(int sqltype, int sqllen);</pre><p>
この関数は存在しますが、現在実装されていません。
       </p></dd><dt id="RSETNULL"><span class="term"><code class="function">rsetnull</code></span></dt><dd><p>変数にNULLを設定します。
</p><pre class="synopsis">int rsetnull(int t, char *ptr);</pre><p>
この関数は、変数の種類を示す整数とC char*にキャストした変数自体へのポインタを受付けます。
       </p><p>以下の種類が存在します。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>           <code class="literal">CCHARTYPE</code> - <code class="type">char</code>または <code class="type">char*</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CSHORTTYPE</code> - <code class="type">short int</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CINTTYPE</code> - <code class="type">int</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CBOOLTYPE</code> - <code class="type">boolean</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CFLOATTYPE</code> - <code class="type">float</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CLONGTYPE</code> - <code class="type">long</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CDOUBLETYPE</code> - <code class="type">double</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CDECIMALTYPE</code> - <code class="type">decimal</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CDATETYPE</code> - <code class="type">date</code>型の変数用
          </p></li><li class="listitem"><p>           <code class="literal">CDTIMETYPE</code> - <code class="type">timestamp</code>型の変数用
          </p></li></ul></div><p>
       </p><p>以下にこの関数の呼び出し例を示します。
</p><pre class="programlisting">$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

rsetnull(CCHARTYPE, (char *) c);
rsetnull(CSHORTTYPE, (char *) &amp;s);
rsetnull(CINTTYPE, (char *) &amp;i);</pre><p>
       </p></dd><dt><span class="term"><code class="function">risnull</code></span></dt><dd><p>変数がNULLか検査します。
</p><pre class="synopsis">int risnull(int t, char *ptr);</pre><p>
この関数は検査する変数の種類(<code class="literal">t</code>)、変数(<code class="literal">ptr</code>)へのポインタを受付けます。
後者はchar*にキャストする必要があることに注意してください。
取り得る変数種類については <a class="xref" href="ecpg-informix-compat.html#RSETNULL"><code class="function">rsetnull</code></a>関数を参照してください。
       </p><p>この関数の使用方法の例を示します。
</p><pre class="programlisting">$char c[] = "abc       ";
$short s = 17;
$int i = -74874;

risnull(CCHARTYPE, (char *) c);
risnull(CSHORTTYPE, (char *) &amp;s);
risnull(CINTTYPE, (char *) &amp;i);</pre><p>
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="ECPG-INFORMIX-CONSTANTS"><div class="titlepage"><div><div><h3 class="title">35.15.5. 追加の定数</h3></div></div></div><p>ここで示す定数はすべてエラーを示すものであり、負の値を表すように定義されていることに注意してください。
また、他の定数の説明では、現在の実装で定数が表す数値がわかります。
しかし、この数値に依存してはなりません。
しかし、これらのすべてが負の値であることに依存することは可能です。
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ECPG_INFORMIX_NUM_OVERFLOW</code></span></dt><dd><p>計算時にオーバーフローが発生した場合、関数はこの値を返します。
内部的には-1200（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_NUM_UNDERFLOW</code></span></dt><dd><p>計算時にアンダーフローが発生した場合、関数はこの値を返します。
内部的には-1201（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_DIVIDE_ZERO</code></span></dt><dd><p>計算時にゼロ除算が発生した場合、関数はこの値を返します。
内部的には-1202（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_YEAR</code></span></dt><dd><p>日付の解析時に年の値が不正であった場合、関数はこの値を返します。
内部的には-1204（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_MONTH</code></span></dt><dd><p>日付の解析時に月の値が不正であった場合、関数はこの値を返します。
内部的には-1205（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_DAY</code></span></dt><dd><p>日付の解析時に日の値が不正であった場合、関数はこの値を返します。
内部的には-1206（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_ENOSHORTDATE</code></span></dt><dd><p>解析処理が短縮日付表現を必要としているが、正しい長さの日付文字列が得られなかった場合、関数はこの値を返します。
内部的には-1209（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_DATE_CONVERT</code></span></dt><dd><p>日付の書式付けの時にエラーが発生した場合、関数はこの値を返します。
内部的には-1210（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_OUT_OF_MEMORY</code></span></dt><dd><p>操作時にメモリが不足した場合、関数はこの値を返します。
内部的には-1211（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_ENOTDMY</code></span></dt><dd><p>解析処理が書式マスク（<code class="literal">mmddyy</code>のような）が存在することを前提としているが、すべてのフィールドが正しく列挙されていない場合、関数はこの値を返します。
内部的には-1212（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_NUMERIC</code></span></dt><dd><p>解析処理がエラーのため数値のテキスト表現を解析できなかった場合や数値変数の少なくとも1つが無効のため数値変数を使用した計算を完了できなかった場合、関数はこの値を返します。
内部的には-1213（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_EXPONENT</code></span></dt><dd><p>解析処理が指数の解析を行うことができなかった場合、関数はこの値を返します。
内部的には-1216（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_BAD_DATE</code></span></dt><dd><p>解析処理が日付を解析できなかった場合、関数はこの値を返します。
内部的には-1218（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd><dt><span class="term"><code class="literal">ECPG_INFORMIX_EXTRA_CHARS</code></span></dt><dd><p>解析処理が追加の文字列を解析できなかった場合、関数はこの値を返します。
内部的には-1264（<span class="productname">Informix</span>の定義）と定義されています。
       </p></dd></dl></div><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ecpg-sql-whenever.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ecpg.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ecpg-develop.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">WHENEVER </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 35.16. 内部</td></tr></table></div></body></html>