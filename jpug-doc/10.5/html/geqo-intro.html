<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.1. 複雑な最適化問題としての問い合わせ処理</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="geqo.html" title="Chapter 59. 遺伝的問い合わせ最適化" /><link rel="next" href="geqo-intro2.html" title="59.2. 遺伝的アルゴリズム" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">59.1. 複雑な最適化問題としての問い合わせ処理</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="geqo.html" title="Chapter 59. 遺伝的問い合わせ最適化">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="geqo.html" title="Chapter 59. 遺伝的問い合わせ最適化">Up</a></td><th width="60%" align="center">Chapter 59. 遺伝的問い合わせ最適化</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="geqo-intro2.html" title="59.2. 遺伝的アルゴリズム">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="GEQO-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.1. 複雑な最適化問題としての問い合わせ処理</h2></div></div></div><p>リレーショナル演算子の中で、処理と最適化が一番難しいのは<em class="firstterm">結合</em>です。
実行可能な問い合わせ計画の数は問い合わせの中に含まれる結合の数によって指数関数的に増加します。
個々の結合や、多様な<em class="firstterm">インデックス</em>（例えば<span class="productname">PostgreSQL</span>のB-tree、ハッシュ、GiST、GINなど）をリレーションのアクセスパスとして処理するため、様々な<em class="firstterm">結合メソッド</em>（例えば<span class="productname">PostgreSQL</span>のネステッドループ、ハッシュ結合、マージ結合など）を提供することが、さらなる最適化を行わなければならない腐心の原因となっています。
   </p><p>通常の<span class="productname">PostgreSQL</span>問い合わせオプティマイザは、候補ストラテジ空間にわたって<em class="firstterm">しらみつぶしに近い検索</em>を行います。
IBMのSystem Rデータベースで初めて導入された、このアルゴリズムはほぼ最適な結合順を生成しますが、問い合わせ内の結合数が増えると膨大な処理時間とメモリ空間を必要とします。
このため、通常の<span class="productname">PostgreSQL</span>問い合わせオプティマイザは結合するテーブル数の多い問い合わせには向いていません。
   </p><p>ドイツ、フライブルグにあるUniversity of Mining and TechnologyのInstitute of Automatic Controlでは、送電網の保守のための意志決定知識ベースシステムのためのバックエンドとして<span class="productname">PostgreSQL</span> DBMSを使おうとしたため問題が起こりました。
そのDBMSは知識ベースシステムの推論マシンのために、大規模な結合の問い合わせを処理する必要があったのです。
こうした問い合わせに含まれる結合数を行うことは、通常の問い合わせオプティマイザでは実現不可能でした。
   </p><p>以下では、多数の結合を持つ問い合わせを効率的に行うことができるように、結合順問題を解決する<em class="firstterm">遺伝的アルゴリズム</em>の実装を説明します。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="geqo.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="geqo.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="geqo-intro2.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 59. 遺伝的問い合わせ最適化 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 59.2. 遺伝的アルゴリズム</td></tr></table></div></body></html>