<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>33.3. コマンド実行関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq-status.html" title="33.2. 接続状態関数" /><link rel="next" href="libpq-async.html" title="33.4. 非同期コマンドの処理" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">33.3. コマンド実行関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-status.html" title="33.2. 接続状態関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Up</a></td><th width="60%" align="center">Chapter 33. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C ライブラリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-async.html" title="33.4. 非同期コマンドの処理">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LIBPQ-EXEC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">33.3. コマンド実行関数</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-MAIN">33.3.1. 主要な関数</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-SELECT-INFO">33.3.2. 問い合わせ結果の情報の取り出し</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-NONSELECT">33.3.3. 他の結果情報の取り出し</a></span></dt><dt><span class="sect2"><a href="libpq-exec.html#LIBPQ-EXEC-ESCAPE-STRING">33.3.4. SQLコマンドに含めるための文字列のエスケープ処理</a></span></dt></dl></div><p>いったんデータベースサーバへの接続の確立が成功すれば、本節で説明する関数を使ってSQLの問い合わせやコマンドを実行します。
  </p><div class="sect2" id="LIBPQ-EXEC-MAIN"><div class="titlepage"><div><div><h3 class="title">33.3.1. 主要な関数</h3></div></div></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXEC"><span class="term">       <code class="function">PQexec</code>
       <a id="id-1.7.3.10.3.2.1.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>コマンドをサーバに送信し、結果を待機します。

</p><pre class="synopsis">PGresult *PQexec(PGconn *conn, const char *command);</pre><p>
       </p><p>戻り値は<code class="structname">PGresult</code>へのポインタ、場合によってはヌルポインタです。
メモリ不足の状態、あるいはサーバへのコマンド送信が不可能といった深刻なエラーの場合を除けば、通常非ヌルのポインタが返ります。
<code class="function">PQresultStatus</code>関数を呼び出して、何かエラー（ヌルポインタ値を含むエラー。この場合は<code class="symbol">PGRES_FATAL_ERROR</code>が返されます）がないか戻り値を検査しなければなりません。
こうしたエラーの詳しい情報は<code class="function">PQerrorMessage</code>で得ることができます。
       </p></dd></dl></div><p>

コマンド文字列には(セミコロンで区切った)複数のSQLコマンドを含めることができます。
単一の<code class="function">PQexec</code>呼び出しで送信された複数の問い合わせは、単一トランザクションで処理されます。
ただし、問い合わせ文字列内に明示的な<code class="command">BEGIN</code>/<code class="command">COMMIT</code>がある場合は、複数のトランザクションに分離されます。
しかし、返される<code class="structname">PGresult</code>構造体はその文字列内で最後に実行されたコマンドの結果のみが含まれることに注意してください。
そのコマンドの1つが失敗したとすると、文字列の処理はそこで中断し、エラー条件が含まれる<code class="structname">PGresult</code>が返されます。
   </p><p>    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXECPARAMS"><span class="term">       <code class="function">PQexecParams</code>
       <a id="id-1.7.3.10.3.3.1.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>サーバにコマンドを送信し、結果を待ちます。
ただし、SQLコマンドテキストとは別にパラメータを渡すことができます。

</p><pre class="synopsis">PGresult *PQexecParams(PGconn *conn,
                       const char *command,
                       int nParams,
                       const Oid *paramTypes,
                       const char * const *paramValues,
                       const int *paramLengths,
                       const int *paramFormats,
                       int resultFormat);</pre><p>
       </p><p><code class="function">PQexecParams</code>と<code class="function">PQexec</code>は似ていますが、前者は次の機能が追加されています。
パラメータ値をコマンド文字列とは別に適切に指定することができ、また、問い合わせの結果をテキスト書式としてでもバイナリ書式としてでも要求できます。
<code class="function">PQexecParams</code>はプロトコル3.0以降でのみサポートされ、プロトコル2.0で使用した場合は失敗します。
       </p><p>この関数の引数を以下に示します。

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="parameter"><code>conn</code></em></span></dt><dd><p>接続オブジェクトです。これを通してコマンドを送信します。
           </p></dd><dt><span class="term"><em class="parameter"><code>command</code></em></span></dt><dd><p>実行させるSQLコマンド文字列です。
パラメータが使用される場合は、コマンド文字列内で<code class="literal">$1</code>、<code class="literal">$2</code>などのように参照されます。
           </p></dd><dt><span class="term"><em class="parameter"><code>nParams</code></em></span></dt><dd><p>提供されるパラメータ数です。
これは配列<em class="parameter"><code>paramTypes[]</code></em>、<em class="parameter"><code>paramValues[]</code></em>、<em class="parameter"><code>paramLengths[]</code></em>、<em class="parameter"><code>paramFormats[]</code></em>の要素数です。
（この配列ポインタは、<em class="parameter"><code>nParams</code></em>が0の場合、<code class="symbol">NULL</code>とすることができます。）
           </p></dd><dt><span class="term"><em class="parameter"><code>paramTypes[]</code></em></span></dt><dd><p>パラメータシンボルに代入されるデータ型をOIDで指定したものです。
<em class="parameter"><code>paramTypes</code></em>が<code class="symbol">NULL</code>、または、ある配列要素が0の場合、サーバは、型指定のないリテラル文字列に対して行う推定方法と同じ方法を使用して、パラメータシンボルのデータ型を推定します。
           </p></dd><dt><span class="term"><em class="parameter"><code>paramValues[]</code></em></span></dt><dd><p>パラメータの実際の値を指定します。
配列内のヌルポインタは対応するパラメータがNULLであることを意味します。
さもなくば、このポインタはゼロ終端のテキスト文字列（テキスト書式）、または、サーバで想定している書式によるバイナリデータ（バイナリ書式）を指し示します。
           </p></dd><dt><span class="term"><em class="parameter"><code>paramLengths[]</code></em></span></dt><dd><p>バイナリ書式のパラメータの実データ長を指定します。
NULLパラメータおよびテキスト書式のパラメータでは無視されます。
バイナリパラメータが存在しない場合、この配列ポインタはヌルとしてもかまいません。
           </p></dd><dt><span class="term"><em class="parameter"><code>paramFormats[]</code></em></span></dt><dd><p>パラメータがテキスト（パラメータに対応する配列要素に0を設定）か、バイナリ（パラメータに対応する配列要素に1を設定）かを指定します。
この配列ポインタがヌルの場合、すべてのパラメータはテキスト文字列であると仮定されます。
           </p><p>バイナリ書式で渡された値は、バックエンドが想定する内部表現の知識を必要とします。
例えば、整数はネットワークバイト順に渡されなければなりません。
<code class="type">numeric</code>による値は、<code class="filename">src/backend/utils/adt/numeric.c::numeric_send()</code>および<code class="filename">src/backend/utils/adt/numeric.c::numeric_recv()</code>で実装されたようにサーバストレージ書式の知識を必要とします。
           </p></dd><dt><span class="term"><em class="parameter"><code>resultFormat</code></em></span></dt><dd><p>結果をテキスト書式で取り出したい場合は0を、バイナリ書式で取り出したい場合は1を指定します。
（現時点では、プロトコル内部では実現可能ですが、結果の列ごとに異なる書式を指定して取り出す機構は存在しません。）
           </p></dd></dl></div><p>
       </p></dd></dl></div><p>
   </p><p><code class="function">PQexec</code>に対する<code class="function">PQexecParams</code>の主要な利点は、コマンド文字列とパラメータ値を分離することができることです。
これにより、面倒でエラーを招きやすい引用符付けやエスケープ処理を行なう必要がなくなります。
   </p><p><code class="function">PQexec</code>と異なり、<code class="function">PQexecParams</code>は、文字列内に最大でも1つのSQLコマンドを入れることができます。
（セミコロンを入れることはできますが、空でないコマンドを2つ以上入れることはできません。）
これは、プロトコル自体の制限ですが、SQLインジェクション攻撃に対する追加の防御となりますので、多少役に立ちます。
   </p><div class="tip"><h3 class="title">Tip</h3><p>OID経由のパラメータ型の指定は、特にプログラムの中で特定のOID値がソースに直接書き込まれることを好まない場合には退屈です。
しかしながら、パラメータの型をサーバ自身で決定できない場合や、望む型と異なる型を選択する場合であっても、これを避けることができます。
SQLコマンドテキストでどのデータ型を送信するかを示すためにパラメータシンボルに明示的なキャストをつけてください。
以下が例です。

</p><pre class="programlisting">SELECT * FROM mytable WHERE x = $1::bigint;</pre><p>
デフォルトではパラメータ<code class="literal">$1</code>の型は<code class="literal">x</code>と同じデータ型に割り当てられますが、これにより強制的に<code class="type">bigint</code>として扱われます。
この方法または型のOIDを数字で指定する方法で、パラメータの型を強制的に決定することがバイナリ書式においてパラメータ値を送る時に強く推奨されます。
これは、バイナリ書式はテキスト書式より情報が少なく、そのために、サーバが型の不一致という問題を検出する機会が少なくなるためです。
    </p></div><p>    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPREPARE"><span class="term"><code class="function">PQprepare</code>
       <a id="id-1.7.3.10.3.7.1.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>指定パラメータを持つプリペアド文の作成要求を送信し、その完了を待ちます。
</p><pre class="synopsis">PGresult *PQprepare(PGconn *conn,
                    const char *stmtName,
                    const char *query,
                    int nParams,
                    const Oid *paramTypes);</pre><p>
       </p><p><code class="function">PQprepare</code>は、後で<code class="function">PQexecPrepared</code>を使用して実行するプリペアド文を作成します。
この機能を使用すると、コマンドを実行の度に解析して計画することなく、繰り返し実行することができます。
詳しくは<a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>を参照してください。
<code class="function">PQprepare</code>はプロトコル3.0以降でのみサポートされ、プロトコル2.0を使用している場合は失敗します。
       </p><p>この関数は<em class="parameter"><code>query</code></em>文字列から<em class="parameter"><code>stmtName</code></em>という名前のプリペアド文を作成します。
<em class="parameter"><code>query</code></em>は単一のSQLコマンドでなければなりません。
<em class="parameter"><code>stmtName</code></em>を<code class="literal">""</code>にして、無名の文を作成することができます。
もし、無名の文が既に存在していた場合は自動的に置き換えられます。
その他の場合、文の名前が現在のセッションで既に存在するとエラーになります。
何らかのパラメータが使用される場合、問い合わせ内では<code class="literal">$1</code>、<code class="literal">$2</code>などで参照します。
<em class="parameter"><code>nParams</code></em>はパラメータ数です。
その型については事前に<em class="parameter"><code>paramTypes[]</code></em>配列で指定されています。
(<em class="parameter"><code>nParams</code></em>がゼロの場合、この配列ポインタは<code class="symbol">NULL</code>にすることができます。)
<em class="parameter"><code>paramTypes[]</code></em>は、OIDによりパラメータシンボルに割り当てるデータ型を指定します。
<em class="parameter"><code>paramTypes</code></em>が<code class="symbol">NULL</code>の場合、もしくは、配列内の特定要素がゼロの場合、サーバはそのパラメータシンボルに対して、型指定の無いリテラル文字列に対する処理と同等の方法でデータ型を割り当てます。
また、問い合わせでは<em class="parameter"><code>nParams</code></em>より多くのパラメータシンボルを使用することができます。
これらのシンボルに対するデータ型も同様に推測されます。
（どのようなデータ型が推測されるかを検出する手法については<code class="function">PQdescribePrepared</code>を参照してください。）
       </p><p><code class="function">PQexec</code>同様、結果は通常<code class="structname">PGresult</code>オブジェクトで、その内容でサーバ側の成功や失敗を示します。
ヌルという結果はメモリ不足や全くコマンドを送信することができなかったことを示します。
こうしたエラーの詳細情報を入手するには<code class="function">PQerrorMessage</code>を使用してください。
       </p></dd></dl></div><p>

<code class="function">PQexecPrepared</code>で使用するためのプリペアド文は、<a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a> SQL文を実行することでも作成可能です。
また、プリペアド文を削除する<span class="application">libpq</span>関数はありませんが、この目的のために<a class="xref" href="sql-deallocate.html" title="DEALLOCATE"><span class="refentrytitle">DEALLOCATE</span></a>SQL文を使用することができます。
   </p><p>    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQEXECPREPARED"><span class="term">       <code class="function">PQexecPrepared</code>
       <a id="id-1.7.3.10.3.8.1.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>指定パラメータによるプリペアド文の実行要求を送信し、結果を待ちます。
</p><pre class="synopsis">PGresult *PQexecPrepared(PGconn *conn,
                         const char *stmtName,
                         int nParams,
                         const char * const *paramValues,
                         const int *paramLengths,
                         const int *paramFormats,
                         int resultFormat);</pre><p>
       </p><p><code class="function">PQexecPrepared</code>と<code class="function">PQexecParams</code>は似ていますが、前者では実行されるコマンドは、問い合わせ文字列を与えるのではなく、事前にプリペアド文を指名することで指定されます。
この機能により、繰り返し使用する予定のコマンドを実行する度にではなく、一度だけ解析、計画作成を行うことができます。
この文は現在のセッションで事前に準備されていなければなりません。
<code class="function">PQexecPrepared</code>は、プロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用した場合は失敗します。
       </p><p>パラメータは、問い合わせ文字列ではなく指定されたプリペアド文の名前を与える点を除き、<code class="function">PQexecParams</code>と同じです。
また、<em class="parameter"><code>paramTypes[]</code></em>パラメータは存在しません。
(プリペアド文のパラメータ型はその作成時点で決定されているため、これは不要です。)
       </p></dd><dt id="LIBPQ-PQDESCRIBEPREPARED"><span class="term">       <code class="function">PQdescribePrepared</code>
       <a id="id-1.7.3.10.3.8.1.2.1.2" class="indexterm"></a>
      </span></dt><dd><p>指定したプリペアド文に関する情報入手要求を送り、入手完了まで待機します。

</p><pre class="synopsis">PGresult *PQdescribePrepared(PGconn *conn, const char *stmtName);</pre><p>
       </p><p><code class="function">PQdescribePrepared</code>により、アプリケーションは事前にプリペアド文に関する情報を入手できます。
<code class="function">PQdescribePrepared</code>はプロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用すると失敗します。
       </p><p><em class="parameter"><code>stmtName</code></em>を<code class="literal">""</code>または<code class="symbol">NULL</code>とすることで、無名の文を参照することができます。
これ以外では、存在するプリペアド文の名前でなければなりません。
成功すると、<code class="literal">PGRES_COMMAND_OK</code>というステータスの<code class="structname">PGresult</code>が返されます。
<code class="function">PQnparams</code>および<code class="function">PQparamtype</code>関数をこの<code class="structname">PGresult</code>に適用して、プリペアド文のパラメータに関する情報を得ることができます。
また、<code class="function">PQnfields</code>、<code class="function">PQfname</code>、<code class="function">PQftype</code>関数などを使用して、文の結果列（もしあれば）に関する情報を提供できます。
       </p></dd><dt id="LIBPQ-PQDESCRIBEPORTAL"><span class="term">       <code class="function">PQdescribePortal</code>
       <a id="id-1.7.3.10.3.8.1.3.1.2" class="indexterm"></a>
      </span></dt><dd><p>指定したポータルに関する情報入手要求を送信し、完了まで待機します。

</p><pre class="synopsis">PGresult *PQdescribePortal(PGconn *conn, const char *portalName);</pre><p>
       </p><p><code class="function">PQdescribePortal</code>により、アプリケーションは事前に作成されたポータルの情報を入手することができます。
（<span class="application">libpq</span>はポータルへの直接アクセスする方法を提供していませんが、この関数を使用して<code class="command">DECLARE CURSOR</code> SQLコマンドで作成したカーソルの属性を確認することができます。）
<code class="function">PQdescribePortal</code>はプロトコル3.0以降の接続でのみサポートされます。
プロトコル2.0で使用すると失敗します。
       </p><p><em class="parameter"><code>portalName</code></em>に<code class="literal">""</code>または<code class="symbol">NULL</code>を指定して、無名のポータルを参照することができます。
これ以外では、既存のポータルの名前でなければなりません。
成功すると、<code class="literal">PGRES_COMMAND_OK</code>というステータスの<code class="structname">PGresult</code>が返されます。
<code class="function">PQnfields</code>、<code class="function">PQfname</code>、<code class="function">PQftype</code>関数などをこの<code class="structname">PGresult</code>に適用して、ポータルの結果列（もしあれば）に関する情報を得ることができます。
       </p></dd></dl></div><p>
   </p><p><code class="structname">PGresult</code>構造体はサーバから返された結果をカプセル化します。
<a id="id-1.7.3.10.3.9.2" class="indexterm"></a>
<span class="application">libpq</span>アプリケーションのプログラマは注意して<code class="structname">PGresult</code>という抽象化を維持してください。
以下のアクセス用関数を使用して、<code class="structname">PGresult</code>の内容を取り出してください。
将来の変更に影響されますので、<code class="structname">PGresult</code>構造体のフィールドを直接参照することは避けてください。

    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQRESULTSTATUS"><span class="term">       <code class="function">PQresultStatus</code>
       <a id="id-1.7.3.10.3.9.7.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>コマンドの結果状態を返します。
</p><pre class="synopsis">ExecStatusType PQresultStatus(const PGresult *res);</pre><p>
       </p><p><code class="function">PQresultStatus</code>は以下のいずれかの値を返します。

        </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PGRES-EMPTY-QUERY"><span class="term"><code class="literal">PGRES_EMPTY_QUERY</code></span></dt><dd><p>サーバに送信された文字列が空でした。
           </p></dd><dt id="LIBPQ-PGRES-COMMAND-OK"><span class="term"><code class="literal">PGRES_COMMAND_OK</code></span></dt><dd><p>データを返さないコマンドが正常終了しました。
           </p></dd><dt id="LIBPQ-PGRES-TUPLES-OK"><span class="term"><code class="literal">PGRES_TUPLES_OK</code></span></dt><dd><p>データを返すコマンド(<code class="command">SELECT</code>や<code class="command">SHOW</code>など)が正常終了しました。
           </p></dd><dt id="LIBPQ-PGRES-COPY-OUT"><span class="term"><code class="literal">PGRES_COPY_OUT</code></span></dt><dd><p>(サーバからの)コピーアウトデータ転送が始まりました。
           </p></dd><dt id="LIBPQ-PGRES-COPY-IN"><span class="term"><code class="literal">PGRES_COPY_IN</code></span></dt><dd><p>(サーバへの)コピーインデータ転送が始まりました。
           </p></dd><dt id="LIBPQ-PGRES-BAD-RESPONSE"><span class="term"><code class="literal">PGRES_BAD_RESPONSE</code></span></dt><dd><p>サーバが不明な応答を返しました。
           </p></dd><dt id="LIBPQ-PGRES-NONFATAL-ERROR"><span class="term"><code class="literal">PGRES_NONFATAL_ERROR</code></span></dt><dd><p>致命的ではない(注意喚起もしくは警告)エラーが発生しました。
           </p></dd><dt id="LIBPQ-PGRES-FATAL-ERROR"><span class="term"><code class="literal">PGRES_FATAL_ERROR</code></span></dt><dd><p>致命的なエラーが発生しました。
           </p></dd><dt id="LIBPQ-PGRES-COPY-BOTH"><span class="term"><code class="literal">PGRES_COPY_BOTH</code></span></dt><dd><p>（サーバからおよびサーバへの）コピーイン/アウトデータ転送が始まりました。
現在こればストリーミングレプリケーションのみで使用されます。
このためこの状態は通常のアプリケーションでは起こりません。
           </p></dd><dt id="LIBPQ-PGRES-SINGLE-TUPLE"><span class="term"><code class="literal">PGRES_SINGLE_TUPLE</code></span></dt><dd><p><code class="structname">PGresult</code>には現在のコマンドからの結果タプルが１つ含まれます。
この状態は問い合わせで単一行モードが選択された場合（<a class="xref" href="libpq-single-row-mode.html" title="33.5. １行１行問い合わせ結果を受け取る">Section 33.5</a>参照）のみ起こります。
           </p></dd></dl></div><p>

結果状態が<code class="literal">PGRES_TUPLES_OK</code>または<code class="literal">PGRES_SINGLE_TUPLE</code>であれば、以下で説明する関数を使って問い合わせが返した行を取り出すことができます。
ただし、たまたま<code class="command">SELECT</code>コマンドが返す行が０個だったような場合でも<code class="literal">PGRES_TUPLES_OK</code>となることに注意してください。
<code class="literal">PGRES_COMMAND_OK</code>は、行を決して返さない(<code class="literal">RETURNING</code>句の無い<code class="command">INSERT</code>または<code class="command">UPDATE</code>など)コマンド用です。
<code class="literal">PGRES_EMPTY_QUERY</code>という応答はクライアントソフトウェアの不具合を示しているかもしれません。
       </p><p><code class="symbol">PGRES_NONFATAL_ERROR</code>状態の場合、結果は<code class="function">PQexec</code>や他の問い合わせ実行関数によって直接返されません。
その代わりに、この種の結果は注意喚起プロセッサ(<a class="xref" href="libpq-notice-processing.html" title="33.12. 警告処理">Section 33.12</a>参照)に渡されます。
       </p></dd><dt id="LIBPQ-PQRESSTATUS"><span class="term">       <code class="function">PQresStatus</code>
       <a id="id-1.7.3.10.3.9.7.2.1.2" class="indexterm"></a>
      </span></dt><dd><p><code class="function">PQresultStatus</code>が返す列挙型から状態コードを説明する文字列定数に変換します。
呼び出し元はこの結果を解放してはいけません。

</p><pre class="synopsis">char *PQresStatus(ExecStatusType status);</pre><p>
       </p></dd><dt id="LIBPQ-PQRESULTERRORMESSAGE"><span class="term">       <code class="function">PQresultErrorMessage</code>
       <a id="id-1.7.3.10.3.9.7.3.1.2" class="indexterm"></a>
      </span></dt><dd><p>コマンドに関するエラーメッセージを返します。
エラーが何もなければ、空の文字列を返します。
</p><pre class="synopsis">char *PQresultErrorMessage(const PGresult *res);</pre><p>
エラーがあった場合、返される文字列の最後には改行が含まれます。
呼び出し元はこの結果を直接解放してはいけません。
関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時にこれは解放されます。
       </p><p>（接続に対する）<code class="function">PQerrorMessage</code>も、<code class="function">PQexec</code>または<code class="function">PQgetResult</code>呼び出しの直後なら（結果に対する）<code class="function">PQresultErrorMessage</code>と同じ文字列を返します。
しかし、接続に対するエラーメッセージは続いて操作を行うと変化してしまうのに対し、<code class="structname">PGresult</code>は自身が破棄されるまでそのエラーメッセージを維持し続けます。
この<code class="function">PQresultErrorMessage</code>は個々の<code class="structname">PGresult</code>に結び付けられた状態を確認する時に、そして<code class="function">PQerrorMessage</code>は接続における最後の操作の状態を確認する時に使用してください。
       </p></dd><dt id="LIBPQ-PQRESULTVERBOSEERRORMESSAGE"><span class="term">       <code class="function">PQresultVerboseErrorMessage</code>
       <a id="id-1.7.3.10.3.9.7.4.1.2" class="indexterm"></a>
      </span></dt><dd><p><code class="structname">PGresult</code>オブジェクトに関連したエラーメッセージの再フォーマットしたバージョンを返します。
</p><pre class="synopsis">char *PQresultVerboseErrorMessage(const PGresult *res,
                                  PGVerbosity verbosity,
                                  PGContextVisibility show_context);</pre><p>
状況によっては、クライアントは以前に報告されたエラーのより詳細なバージョンを取得したいと思うかもしれません。
<code class="function">PQresultVerboseErrorMessage</code>は、指定の<code class="structname">PGresult</code>が生成されたときに、指定した冗長設定がその接続で使われていたなら<code class="function">PQresultErrorMessage</code>が生成したであろうメッセージを計算することで、この要請に応えます。
<code class="structname">PGresult</code>がエラーの結果ではない場合は、<span class="quote">“<span class="quote">PGresult is not an error result</span>”</span>が代わりに報告されます。
返される文字列は行末に改行コードが含まれます。
       </p><p><code class="structname">PGresult</code>からデータを抽出する他の多くの関数と異なり、この関数の結果は新しく割り当てられた文字列です。
その文字列が必要なくなったときは、呼び出し側が<code class="function">PQfreemem()</code>を使ってそれを解放しなければなりません。
       </p><p>十分なメモリがないときは、NULLが返されることもありえます。
       </p></dd><dt id="LIBPQ-PQRESULTERRORFIELD"><span class="term"><code class="function">PQresultErrorField</code><a id="id-1.7.3.10.3.9.7.5.1.2" class="indexterm"></a></span></dt><dd><p>エラー報告の個々のフィールドを返します。
</p><pre class="synopsis">char *PQresultErrorField(const PGresult *res, int fieldcode);</pre><p>
<em class="parameter"><code>fieldcode</code></em>はエラーフィールド識別子です。
以下に示すシンボルを参照してください。
<code class="structname">PGresult</code>がエラーではない、もしくは、警告付きの結果である場合や指定したフィールドを含まない場合、<code class="symbol">NULL</code>が返されます。
通常フィールド値には改行が含まれません。
フィールド値は関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時に解放されます。
       </p><p>以下のフィールドコードが使用できます。
        </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PG-DIAG-SEVERITY"><span class="term"><code class="symbol">PG_DIAG_SEVERITY</code></span></dt><dd><p>深刻度。
このフィールドの内容は(エラーメッセージの場合)<code class="literal">ERROR</code>、<code class="literal">FATAL</code>、もしくは、<code class="literal">PANIC</code>、(注意喚起メッセージの場合)<code class="literal">WARNING</code>、<code class="literal">NOTICE</code>、<code class="literal">DEBUG</code>、<code class="literal">INFO</code>、もしくは、<code class="literal">LOG</code>です。
これらは、多言語化により翻訳されている可能性があります。
常に存在します。
           </p></dd><dt id="LIBPQ-PG-DIAG-SEVERITY-NONLOCALIZED"><span class="term"><code class="symbol">PG_DIAG_SEVERITY_NONLOCALIZED</code></span></dt><dd><p>深刻度。
このフィールドの内容は(エラーメッセージの場合)<code class="literal">ERROR</code>、<code class="literal">FATAL</code>、もしくは、<code class="literal">PANIC</code>、(注意喚起メッセージの場合)<code class="literal">WARNING</code>、<code class="literal">NOTICE</code>、<code class="literal">DEBUG</code>、<code class="literal">INFO</code>、もしくは、<code class="literal">LOG</code>です。
これは、内容が多言語化されないことを除き、<code class="symbol">PG_DIAG_SEVERITY</code>と同一です。
これは<span class="productname">PostgreSQL</span>のバージョン9.6以降で生成された報告にのみ存在します。
           </p></dd><dt id="LIBPQ-PG-DIAG-SQLSTATE"><span class="term">           <code class="symbol">PG_DIAG_SQLSTATE</code>
          <a id="id-1.7.3.10.3.9.7.5.2.2.1.3.1.2" class="indexterm"></a>
          </span></dt><dd><p>エラーのSQLSTATEコードです。
SQLSTATEコードは発生したエラーの種類を識別します。
フロントエンドアプリケーションにより、特定のデータベースエラーに対して所定の操作（エラー処理など）を行うために使用できます。
起こり得るSQLSTATEコードの一覧については<a class="xref" href="errcodes-appendix.html" title="Appendix A. PostgreSQLエラーコード">Appendix A</a>を参照してください。
このフィールドは多言語化されず、また、常に存在します。
           </p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-PRIMARY"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_PRIMARY</code></span></dt><dd><p>可読性を高めた主要エラーメッセージです。
(通常は1行です。)
常に存在します。
           </p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-DETAIL"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_DETAIL</code></span></dt><dd><p>詳細です。
問題に関するより詳細を表す補助的なエラーメッセージです。
複数行に跨る可能性があります。
           </p></dd><dt id="LIBPQ-PG-DIAG-MESSAGE-HINT"><span class="term"><code class="symbol">PG_DIAG_MESSAGE_HINT</code></span></dt><dd><p>ヒントです。
問題の対応方法についての補助的な提言です。
これは、詳細(detail)とは異なり、問題の事象ではなく、(適切でない可能性がありますが)アドバイスを提供することを目的としています。
複数行に跨る可能性があります。
           </p></dd><dt id="LIBPQ-PG-DIAG-STATEMENT-POSITION"><span class="term"><code class="symbol">PG_DIAG_STATEMENT_POSITION</code></span></dt><dd><p>元の問い合わせ文字列のインデックスとなる、エラーが発生したカーソル位置を示す10進整数を持つ文字列です。
先頭文字がインデックス1となり、また、バイトではなく、文字数で数えた位置です。
           </p></dd><dt id="LIBPQ-PG-DIAG-INTERNAL-POSITION"><span class="term"><code class="symbol">PG_DIAG_INTERNAL_POSITION</code></span></dt><dd><p>この定義は<code class="symbol">PG_DIAG_STATEMENT_POSITION</code>フィールドと同じです。
しかし、これは、クライアントが発行したコマンドではなく、カーソル位置が内部生成コマンドを参照する場合に使用されます。
このフィールドが存在する時は常に<code class="symbol">PG_DIAG_INTERNAL_QUERY</code>フィールドが存在します。
           </p></dd><dt id="LIBPQ-PG-DIAG-INTERNAL-QUERY"><span class="term"><code class="symbol">PG_DIAG_INTERNAL_QUERY</code></span></dt><dd><p>失敗した内部生成コマンドのテキストです。
これは、例えば、PL/pgSQL関数で発行されたSQL問い合わせになります。
           </p></dd><dt id="LIBPQ-PG-DIAG-CONTEXT"><span class="term"><code class="symbol">PG_DIAG_CONTEXT</code></span></dt><dd><p>エラーが発生した文脈を示すものです。
今の所、これは活動中の手続き言語関数や内部生成問い合わせの呼び出しスタックの追跡情報が含まれます。
この追跡は行単位で1項目であり、その順番は呼び出し順の反対になります。
           </p></dd><dt id="LIBPQ-PG-DIAG-SCHEMA-NAME"><span class="term"><code class="symbol">PG_DIAG_SCHEMA_NAME</code></span></dt><dd><p>そのエラーが特定のデータベースオブジェクトに付随する場合、もしあれば、そのオブジェクトを含むスキーマ名です。
           </p></dd><dt id="LIBPQ-PG-DIAG-TABLE-NAME"><span class="term"><code class="symbol">PG_DIAG_TABLE_NAME</code></span></dt><dd><p>そのエラーが特定のテーブルに付随する場合のテーブル名です。
（テーブルのスキーマ名についてはスキーマ名フィールドを参照ください。）
           </p></dd><dt id="LIBPQ-PG-DIAG-COLUMN-NAME"><span class="term"><code class="symbol">PG_DIAG_COLUMN_NAME</code></span></dt><dd><p>そのエラーが特定のテーブル列に付随する場合の列名です。
（テーブルを識別するにはスキーマとテーブル名フィールドを参照ください。）
           </p></dd><dt id="LIBPQ-PG-DIAG-DATATYPE-NAME"><span class="term"><code class="symbol">PG_DIAG_DATATYPE_NAME</code></span></dt><dd><p>そのエラーが特定のデータ型に付随する場合のデータ型名です。
（データ型のスキーマ名についてはスキーマ名フィールドを参照ください。）
           </p></dd><dt id="LIBPQ-PG-DIAG-CONSTRAINT-NAME"><span class="term"><code class="symbol">PG_DIAG_CONSTRAINT_NAME</code></span></dt><dd><p>そのエラーが特定の制約に付随する場合の制約名です。
付随するテーブルまたはドメインについては上記にリストされたフィールドを参照ください。
（この目的のために、制約は制約構文で作成されていなくてもインデックスは制約として扱われます。）
           </p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-FILE"><span class="term"><code class="symbol">PG_DIAG_SOURCE_FILE</code></span></dt><dd><p>エラーが報告された場所のソースコードのファイル名です。
           </p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-LINE"><span class="term"><code class="symbol">PG_DIAG_SOURCE_LINE</code></span></dt><dd><p>エラーが報告された場所のソースコードにおける行番号です。
           </p></dd><dt id="LIBPQ-PG-DIAG-SOURCE-FUNCTION"><span class="term"><code class="symbol">PG_DIAG_SOURCE_FUNCTION</code></span></dt><dd><p>エラーを報告した、ソースコードにおける関数名です。
           </p></dd></dl></div><p>
       </p><div class="note"><h3 class="title">Note</h3><p>スキーマ名、テーブル名、列名、データ型名、および制約名に対するフィールドは限定的なエラー型に対してのみ提供されます。<a class="xref" href="errcodes-appendix.html" title="Appendix A. PostgreSQLエラーコード">Appendix A</a>を参照ください。
これらのフィールドのいかなる存在もその他のフィールドの存在を保証すると推測してはなりません。
コアエラーの出所は上に記載の相互関係を監視しますが、ユーザ定義関数はこれらフィールドを別目的で使用しているかもしれません。
同様の脈絡で、使用しているデータベースで
これらのフィールドが同時に存在するオブジェクトを意味すると推測してはなりません。
        </p></div><p>表示情報の必要に応じた整形はクライアントの責任です。
具体的には、必要に応じて長い行を分割しなければなりません。
エラーメッセージフィールド内の改行文字は、改行としてではなく段落として分かれたものとして取扱うべきです。
       </p><p><span class="application">libpq</span>で内部的に生成されたエラーは、深刻度と主要メッセージを持ちますが、通常は他のフィールドを持ちません。
3.0より前のプロトコルのサーバで返されるエラーは、深刻度と主要メッセージ、場合によって詳細メッセージを持ちますが、他のフィールドを持ちません。
       </p><p>エラーフィールドは<code class="structname">PGresult</code>からのみ利用でき、<code class="structname">PGconn</code>からは利用できません。
<code class="function">PQerrorField</code>という関数はありません。
       </p></dd><dt id="LIBPQ-PQCLEAR"><span class="term"><code class="function">PQclear</code><a id="id-1.7.3.10.3.9.7.6.1.2" class="indexterm"></a></span></dt><dd><p><code class="structname">PGresult</code>に割り当てられた記憶領域を解放します。
個々の問い合わせ結果は、必要なくなった時に<code class="function">PQclear</code>で解放するべきです。

</p><pre class="synopsis">void PQclear(PGresult *res);</pre><p>
       </p><p><code class="structname">PGresult</code>オブジェクトは必要な間保持することができます。
新しい問い合わせを発行する場合でも、接続を閉じてしまうまでは<code class="structname">PGresult</code>は消えません。
<code class="structname">PGresult</code>を解放するには、<code class="function">PQclear</code>を呼び出さなくてはいけません。
その操作に失敗してしまうと、アプリケーションのメモリリークを引き起こしてしまいます。
       </p></dd></dl></div><p>
   </p></div><div class="sect2" id="LIBPQ-EXEC-SELECT-INFO"><div class="titlepage"><div><div><h3 class="title">33.3.2. 問い合わせ結果の情報の取り出し</h3></div></div></div><p>これらの関数を使用して、正常終了した問い合わせ結果を示す(つまり、その状態が<code class="literal">PGRES_TUPLES_OK</code>または<code class="literal">PGRES_SINGLE_TUPLE</code>となっている)<code class="structname">PGresult</code>オブジェクトから情報を抽出することができます。
また、成功したDescribe操作から情報を抽出することもできます。
Describeの結果はすべて、実際に問い合わせを実行した時に提供されるものと同じ列情報を持ちますが、行はありません。
他の状態値を持つオブジェクトでは、これらの関数は、結果が0行0列であるものと同様に動作します。
   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQNTUPLES"><span class="term">      <code class="function">PQntuples</code>
      <a id="id-1.7.3.10.4.3.1.1.2" class="indexterm"></a>
     </span></dt><dd><p>問い合わせ結果内の行(タプル)数を返します。
これは整数を結果として返しますので、32ビットオペレーティングシステムでは、大規模な結果セットの戻り値はオーバーフローする可能性があります。

</p><pre class="synopsis">int PQntuples(const PGresult *res);</pre><p>

      </p></dd><dt id="LIBPQ-PQNFIELDS"><span class="term">      <code class="function">PQnfields</code>
      <a id="id-1.7.3.10.4.3.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>問い合わせ結果の各行の列(フィールド)の数を返します。

</p><pre class="synopsis">int PQnfields(const PGresult *res);</pre><p>
      </p></dd><dt id="LIBPQ-PQFNAME"><span class="term">      <code class="function">PQfname</code>
      <a id="id-1.7.3.10.4.3.3.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列番号に対応する列の名前を返します。
列番号は0から始まります。
呼び出し元はこの結果を直接解放してはいけません。
関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時にこれは解放されます。
</p><pre class="synopsis">char *PQfname(const PGresult *res,
              int column_number);</pre><p>
      </p><p>列番号が範囲外であった場合、<code class="symbol">NULL</code>が返ります。
      </p></dd><dt id="LIBPQ-PQFNUMBER"><span class="term">      <code class="function">PQfnumber</code>
      <a id="id-1.7.3.10.4.3.4.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列名に関連する列番号を返します。
</p><pre class="synopsis">int PQfnumber(const PGresult *res,
              const char *column_name);</pre><p>
      </p><p>指定した名前に一致する列がなければ、-1が返ります。
      </p><p>指定した名前はSQLコマンドの識別子同様に扱われます。
つまり、二重引用符でくくられていない限り、小文字化されます。
例えば、以下のSQLで生成された問い合わせ結果を考えます。
</p><pre class="programlisting">SELECT 1 AS FOO, 2 AS "BAR";</pre><p>
以下により、結果を取り出すことができます。
</p><pre class="programlisting">PQfname(res, 0)              <em class="lineannotation"><span class="lineannotation">foo</span></em>
PQfname(res, 1)              <em class="lineannotation"><span class="lineannotation">BAR</span></em>
PQfnumber(res, "FOO")        <em class="lineannotation"><span class="lineannotation">0</span></em>
PQfnumber(res, "foo")        <em class="lineannotation"><span class="lineannotation">0</span></em>
PQfnumber(res, "BAR")        <em class="lineannotation"><span class="lineannotation">-1</span></em>
PQfnumber(res, "\"BAR\"")    <em class="lineannotation"><span class="lineannotation">1</span></em></pre><p>
      </p></dd><dt id="LIBPQ-PQFTABLE"><span class="term">      <code class="function">PQftable</code>
      <a id="id-1.7.3.10.4.3.5.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列の抽出元であるテーブルのOIDを返します。
列番号は0から始まります。
</p><pre class="synopsis">Oid PQftable(const PGresult *res,
             int column_number);</pre><p>
      </p><p>列番号が範囲外の場合や指定した列がテーブル列への単純な参照でない場合、3.0より前のプロトコルを使用している場合は、<code class="literal">InvalidOid</code>が返されます。
<code class="literal">pg_class</code>システムテーブルに問い合わせ、どのテーブルが参照されているのかを正確に求めることができます。
      </p><p><span class="application">libpq</span>ヘッダファイルをインクルードすると、<code class="type">Oid</code>型と<code class="literal">InvalidOid</code>定数が定義されます。
これらは両方とも何らかの整数型です。
      </p></dd><dt id="LIBPQ-PQFTABLECOL"><span class="term">      <code class="function">PQftablecol</code>
      <a id="id-1.7.3.10.4.3.6.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した問い合わせ結果の列を作成した列の(それが属するテーブル内での)列番号を返します。
問い合わせ結果の列番号は0から始まりますが、テーブル列には0以外の番号が付けられています。
</p><pre class="synopsis">int PQftablecol(const PGresult *res,
                int column_number);</pre><p>
      </p><p>列番号が範囲外の場合や指定した列がテーブル列への単純な参照でなかった場合、3.0より前のプロトコルを使用している場合は、ゼロが返されます。
      </p></dd><dt id="LIBPQ-PQFFORMAT"><span class="term">      <code class="function">PQfformat</code>
      <a id="id-1.7.3.10.4.3.7.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列の書式を示す書式コードを返します。
列番号は0から始まります。
</p><pre class="synopsis">int PQfformat(const PGresult *res,
              int column_number);</pre><p>
      </p><p>ゼロという書式コードはテキストデータ表現を示し、1という書式コードはバイナリ表現を示します。
(他のコードは将来の定義のために予約されています。)
      </p></dd><dt id="LIBPQ-PQFTYPE"><span class="term">      <code class="function">PQftype</code>
      <a id="id-1.7.3.10.4.3.8.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列番号に関連したデータ型を返します。
返された整数はその型の内部的なOID番号です。
列番号は0から始まります。
</p><pre class="synopsis">Oid PQftype(const PGresult *res,
            int column_number);</pre><p>
      </p><p><code class="literal">pg_type</code>システムテーブルに問い合わせて、各種データ型の名前や属性を得ることができます。
組み込みデータ型の<acronym class="acronym">OID</acronym>は、ソースツリー内の<code class="filename">src/include/catalog/pg_type.h</code>ファイル内で定義されています。
      </p></dd><dt id="LIBPQ-PQFMOD"><span class="term">      <code class="function">PQfmod</code>
      <a id="id-1.7.3.10.4.3.9.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列番号に関連した列の型修飾子を返します。
列番号は0から始まります。
</p><pre class="synopsis">int PQfmod(const PGresult *res,
           int column_number);</pre><p>
      </p><p>修飾子の値の解釈は型に固有なものです。
通常これらは精度やサイズの制限を示します。
-1という値は<span class="quote">“<span class="quote">使用できる情報がない</span>”</span>ことを示します。
ほとんどのデータ型は修飾子を使用しません。
この場合は常に-1という値になります。
      </p></dd><dt id="LIBPQ-PQFSIZE"><span class="term">      <code class="function">PQfsize</code>
      <a id="id-1.7.3.10.4.3.10.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定した列番号に関連した列のバイト単位のサイズを返します。
列番号は0から始まります。
</p><pre class="synopsis">int PQfsize(const PGresult *res,
            int column_number);</pre><p>
      </p><p><code class="function">PQfsize</code>はデータベース行内でその列用に割り当てられる領域を返します。
言い替えると、そのデータ型についてのサーバでの内部表現のサイズです。
(従って、実際にはクライアントから見るとあまり役には立ちません。)
負の値は可変長データ型を示します。
      </p></dd><dt id="LIBPQ-PQBINARYTUPLES"><span class="term">      <code class="function">PQbinaryTuples</code>
      <a id="id-1.7.3.10.4.3.11.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="structname">PGresult</code>がバイナリデータを持つ場合は1を、テキストデータを持つ場合は0を返します。
</p><pre class="synopsis">int PQbinaryTuples(const PGresult *res);</pre><p>
      </p><p>この関数は廃れたものです。
(<code class="command">COPY</code>を行う接続での使用を除きます。)
単一の<code class="structname">PGresult</code>で、ある列はテキストデータを持ち、他の列ではバイナリデータを持つことが可能であるためです。
<code class="function">PQfformat</code>の利用が推奨されます。
結果のすべての列がバイナリ(書式1)の場合のみ<code class="function">PQbinaryTuples</code>は1を返します。
      </p></dd><dt id="LIBPQ-PQGETVALUE"><span class="term">      <code class="function">PQgetvalue</code>
       <a id="id-1.7.3.10.4.3.12.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="structname">PGresult</code>の1行における単一フィールドの値を返します。
行番号と列番号は0から始まります。
呼び出し元はこの結果を直接解放してはいけません。
関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時に、これは解放されます。
</p><pre class="synopsis">char *PQgetvalue(const PGresult *res,
                 int row_number,
                 int column_number);</pre><p>
      </p><p>テキスト書式のデータでは、<code class="function">PQgetvalue</code>で返される値はフィールド値のヌル終端の文字列表現となります。
バイナリ書式のデータでは、この値はデータ型の<code class="function">typsend</code>関数と<code class="function">typreceive</code>関数で決まるバイナリ表現となります。
(実際にはこの場合でも値の終わりにゼロというバイトが付与されます。
しかし、この値の内部には大抵の場合ヌルが埋め込まれていますので、通常このバイトは有用ではありません。)
      </p><p>フィールド値がNULLの場合、空文字列が返されます。
NULL値と空文字列という値とを区別する方法は<code class="function">PQgetisnull</code>を参照してください。
      </p><p><code class="function">PQgetvalue</code>によって返されるポインタは<code class="structname">PGresult</code>構造体の一部の格納領域を指し示します。
このポインタが指し示すデータを変更すべきではありません。
また、<code class="structname">PGresult</code>構造体を解放した後も使用し続ける場合は、データを別の格納領域に明示的にコピーしなければなりません。
      </p></dd><dt id="LIBPQ-PQGETISNULL"><span class="term">      <code class="function">PQgetisnull</code>
      <a id="id-1.7.3.10.4.3.13.1.2" class="indexterm"></a>
      <a id="id-1.7.3.10.4.3.13.1.3" class="indexterm"></a>
     </span></dt><dd><p>フィールドがNULL値かどうか検査します。
行番号と列番号は0から始まります。
</p><pre class="synopsis">int PQgetisnull(const PGresult *res,
                int row_number,
                int column_number);</pre><p>
      </p><p>この関数は、フィールドがNULLの場合に1を、フィールドが非NULL値を持つ場合は0を返します。
(<code class="function">PQgetvalue</code>では、NULLフィールドはヌルポインタではなく空文字列を返すことに注意してください。)
      </p></dd><dt id="LIBPQ-PQGETLENGTH"><span class="term">     <code class="function">PQgetlength</code>
     <a id="id-1.7.3.10.4.3.14.1.2" class="indexterm"></a></span></dt><dd><p>実際のフィールド値の長さをバイト単位で返します。
行番号と列番号は0から始まります。
</p><pre class="synopsis">int PQgetlength(const PGresult *res,
                int row_number,
                int column_number);</pre><p>
      </p><p>これは特定のデータ値についての実際のデータ長です。
つまり、<code class="function">PQgetvalue</code>によって指し示されるオブジェクトのサイズです。
テキストデータ書式では<code class="function">strlen()</code>と同一です。
バイナリ書式ではこれは重要な情報です。
実際のデータ長を取り出すために<code class="function">PQfsize</code>を信用しては<span class="emphasis"><em>なりません</em></span>。
      </p></dd><dt id="LIBPQ-PQNPARAMS"><span class="term">      <code class="function">PQnparams</code>
      <a id="id-1.7.3.10.4.3.15.1.2" class="indexterm"></a>
     </span></dt><dd><p>プリペアド文のパラメータ数を返します。
</p><pre class="synopsis">int PQnparams(const PGresult *res);</pre><p>
      </p><p>この関数は<code class="function">PQdescribePrepared</code>の結果を確認する時にのみ有用です。
他の種類の問い合わせではゼロを返します。
      </p></dd><dt id="LIBPQ-PQPARAMTYPE"><span class="term">      <code class="function">PQparamtype</code>
      <a id="id-1.7.3.10.4.3.16.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定された文パラメータのデータ型を返します。
パラメータ番号は0から始まります。
</p><pre class="synopsis">Oid PQparamtype(const PGresult *res, int param_number);</pre><p>
      </p><p>この関数は、<code class="function">PQdescribePrepared</code>の結果を確認する時にのみ有用です。
他の種類の問い合わせではゼロを返します。
      </p></dd><dt id="LIBPQ-PQPRINT"><span class="term">      <code class="function">PQprint</code>
      <a id="id-1.7.3.10.4.3.17.1.2" class="indexterm"></a>
     </span></dt><dd><p>すべての行と列名(省略可能)を指定した出力ストリームに表示します。
</p><pre class="synopsis">void PQprint(FILE *fout,      /* 出力ストリーム */
             const PGresult *res,
             const PQprintOpt *po);

typedef struct
{
    pqbool  header;      /* フィールドヘッダ情報と行数の表示出力 */
    pqbool  align;       /* 位置揃えのためのフィールドへの埋め込み */
    pqbool  standard;    /* 古い、無くなりそうな書式 */
    pqbool  html3;       /* HTML表出力 */
    pqbool  expanded;    /* 拡張テーブル */
    pqbool  pager;       /* 必要に応じたページャの使用 */
    char    *fieldSep;   /* フィールド区切り文字 */
    char    *tableOpt;   /* HTML表要素の属性 */
    char    *caption;    /* HTML 表の表題 */
    char    **fieldName; /* フィールド名を置き換えるNULL終端の配列 */
} PQprintOpt;</pre><p>
      </p><p>この関数は以前に問い合わせ結果を表示するために<span class="application">psql</span>で使用されていましたが、今ではもう使用されていません。
これはすべてのデータがテキスト書式であるという前提で動作することに注意してください。
      </p></dd></dl></div></div><div class="sect2" id="LIBPQ-EXEC-NONSELECT"><div class="titlepage"><div><div><h3 class="title">33.3.3. 他の結果情報の取り出し</h3></div></div></div><p>これらの関数は<code class="structname">PGresult</code>オブジェクトからその他の情報を取り出すために使用されます。
   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCMDSTATUS"><span class="term">      <code class="function">PQcmdStatus</code>
      <a id="id-1.7.3.10.5.3.1.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="structname">PGresult</code>を生成したSQLコマンドのコマンド状態タグを返します。
</p><pre class="synopsis">char *PQcmdStatus(PGresult *res);</pre><p>
      </p><p>これは通常単なるコマンド名ですが、処理行数など追加情報が含まれる場合もあります。
呼び出し元はこの戻り値を直接解放してはいけません。
関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時にこれは解放されます。
      </p></dd><dt id="LIBPQ-PQCMDTUPLES"><span class="term">      <code class="function">PQcmdTuples</code>
      <a id="id-1.7.3.10.5.3.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>SQLコマンドにより影響を受けた行数を返します。
</p><pre class="synopsis">char *PQcmdTuples(PGresult *res);</pre><p>
      </p><p>この関数は<code class="structname">PGresult</code>を生成した<acronym class="acronym">SQL</acronym>コマンドにより影響を受けた行数を含む文字列を返します。
この関数は<code class="command">SELECT</code>、<code class="command">CREATE TABLE AS</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">MOVE</code>、<code class="command">FETCH</code>、<code class="command">COPY</code>文の実行、あるいは、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>を含むプリペアド問い合わせの<code class="command">EXECUTE</code>文の後でのみ使用することができます。
<code class="structname">PGresult</code>を生成したコマンドが他のコマンドであった場合、<code class="function">PQcmdTuples</code>は空文字列を返します。
呼び出し元はこの戻り値を直接解放してはいけません。
関連する<code class="structname">PGresult</code>ハンドルが<code class="function">PQclear</code>に渡された時にこれは解放されます。
      </p></dd><dt id="LIBPQ-PQOIDVALUE"><span class="term">      <code class="function">PQoidValue</code>
      <a id="id-1.7.3.10.5.3.3.1.2" class="indexterm"></a>
     </span></dt><dd><p><acronym class="acronym">SQL</acronym>コマンドが、OIDを持つテーブル内に1行のみを挿入する<code class="command">INSERT</code>だった場合、あるいは、適切な<code class="command">INSERT</code>を持つプリペアド問い合わせの<code class="command">EXECUTE</code>だった場合に、挿入された行のOIDを返します。
さもなくば<code class="literal">InvalidOid</code>を返します。
また、<code class="command">INSERT</code>文の影響を受けたテーブルがOIDを持たなかった場合、この関数は<code class="literal">InvalidOid</code>を返します。
</p><pre class="synopsis">Oid PQoidValue(const PGresult *res);</pre><p>
      </p></dd><dt id="LIBPQ-PQOIDSTATUS"><span class="term">      <code class="function">PQoidStatus</code>
      <a id="id-1.7.3.10.5.3.4.1.2" class="indexterm"></a>
     </span></dt><dd><p>この関数は<code class="function">PQoidValue</code>のため廃止予定になりました。
またこれはスレッドセーフではありません。
これは挿入された行のOIDを文字列として返します。
一方<code class="function">PQoidValue</code>はOID値を返します。
</p><pre class="synopsis">char *PQoidStatus(const PGresult *res);</pre><p>
      </p></dd></dl></div></div><div class="sect2" id="LIBPQ-EXEC-ESCAPE-STRING"><div class="titlepage"><div><div><h3 class="title">33.3.4. SQLコマンドに含めるための文字列のエスケープ処理</h3></div></div></div><a id="id-1.7.3.10.6.2" class="indexterm"></a><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQESCAPELITERAL"><span class="term">      <code class="function">PQescapeLiteral</code>
      <a id="id-1.7.3.10.6.3.1.1.2" class="indexterm"></a>
     </span></dt><dd><pre class="synopsis">char *PQescapeLiteral(PGconn *conn, const char *str, size_t length);</pre><p>
     </p><p><code class="function">PQescapeLiteral</code>は、SQLコマンド内で使用するために文字列をエスケープします。
これは、SQLコマンド内のリテラル定数としてデータ値を挿入する時に有用です。
特定の文字(引用符やバックスラッシュ)は、SQLパーサによって特殊な解釈がなされないようにエスケープされなければなりません。
<code class="function">PQescapeLiteral</code>はこの操作を行います。
     </p><p><code class="function">PQescapeLiteral</code>は<em class="parameter"><code>str</code></em>パラメータをエスケープしたものを<code class="function">malloc()</code>で割り当てたメモリ内に返します。
その結果が不要になったら、そのメモリを<code class="function">PQfreemem()</code>を使用して解放しなければなりません。
ゼロバイト終端は必要なく、<em class="parameter"><code>length</code></em>に含めて数えてはいけません。
(<em class="parameter"><code>length</code></em>バイトを処理する前にゼロバイト終端が見つかると、<code class="function">PQescapeLiteral</code>はそのゼロで終了します。
この動作は<code class="function">strncpy</code>と似ています。)
返される文字列では、<span class="productname">PostgreSQL</span>文字列リテラルパーサで適切に処理することができるように、すべての特殊文字は置換されます。
ゼロバイト終端も追加されます。
<span class="productname">PostgreSQL</span>の文字列リテラルでは前後に必要となる単一引用符も、その結果文字列には含まれています。
     </p><p>エラー時、<code class="function">PQescapeLiteral</code>は<code class="symbol">NULL</code>を返し、<em class="parameter"><code>conn</code></em>オブジェクト内に適切なメッセージを残します。
     </p><div class="tip"><h3 class="title">Tip</h3><p>信用できない入力元から受けとった文字列を扱う場合に適切なエスケープ処理を行なうことは非常に重要です。
さもなくば、セキュリティ上の危険性が発生します。
<span class="quote">“<span class="quote">SQLインジェクション</span>”</span>攻撃という弱点となり、好ましくないSQLコマンドがデータベースに流れてしまいます。
      </p></div><p><code class="function">PQexecParams</code>または同義のルーチン内で別のパラメータとしてデータ値が渡される場合は、エスケープすることは必要でもなければ正しくもないことに注意してください。
     </p></dd><dt id="LIBPQ-PQESCAPEIDENTIFIER"><span class="term">      <code class="function">PQescapeIdentifier</code>
      <a id="id-1.7.3.10.6.3.2.1.2" class="indexterm"></a>
     </span></dt><dd><pre class="synopsis">char *PQescapeIdentifier(PGconn *conn, const char *str, size_t length);</pre><p>
     </p><p><code class="function">PQescapeIdentifier</code>は、テーブル、列、関数名などのSQL識別子として使用できるように文字列をエスケープします。
これはユーザが提供した識別子に、そのままではSQLパーサで識別子として解釈されない特殊な文字が含まれる可能性がある場合、または、大文字小文字の違いを維持しなければならない状況で識別子に大文字が含まれる可能性がある場合に有用です。
     </p><p><code class="function">PQescapeIdentifier</code>は<em class="parameter"><code>str</code></em>パラメータをSQL識別子としてエスケープしたものを<code class="function">malloc()</code>で割り当てたメモリ内に返します。
その結果が不要になったら、そのメモリを<code class="function">PQfreemem()</code>を使用して解放しなければなりません。
ゼロバイト終端は必要なく、<em class="parameter"><code>length</code></em>に含めて数えてはいけません。
(<em class="parameter"><code>length</code></em>バイトを処理する前にゼロバイト終端が見つかると、<code class="function">PQescapeIdentifier</code>はそのゼロで終了します。
この動作は<code class="function">strncpy</code>と似ています。)
返される文字列では、SQL識別子として適切に処理することができるように、すべての特殊文字は置換されます。
ゼロバイト終端も追加されます。
その結果文字列の前後には二重引用符が付与されます。
     </p><p>エラー時、<code class="function">PQescapeIdentifier</code>は<code class="symbol">NULL</code>を返し、<em class="parameter"><code>conn</code></em>オブジェクト内に適切なメッセージを残します。
     </p><div class="tip"><h3 class="title">Tip</h3><p>文字列リテラルと同様、SQLインジェクション攻撃を防ぐために、信頼できない入力元から受けとる場合にはSQL識別子をエスケープしなければなりません。
      </p></div></dd><dt id="LIBPQ-PQESCAPESTRINGCONN"><span class="term">      <code class="function">PQescapeStringConn</code>
      <a id="id-1.7.3.10.6.3.3.1.2" class="indexterm"></a>
     </span></dt><dd><pre class="synopsis">size_t PQescapeStringConn(PGconn *conn,
                          char *to, const char *from, size_t length,
                          int *error);</pre><p>
     </p><p><code class="function">PQescapeStringConn</code>は、<code class="function">PQescapeLiteral</code>とほぼ同様に文字列リテラルをエスケープします。
<code class="function">PQescapeLiteral</code>とは異なり、呼び出し元が適切な大きさのバッファを提供することに責任を持ちます。
さらに<code class="function">PQescapeStringConn</code>は<span class="productname">PostgreSQL</span>の文字リテラルとして囲まれなければならない単一引用符を生成しません。
これは、結果をSQLコマンドに挿入するときに付与しなければなりません。
<em class="parameter"><code>from</code></em>パラメータはエスケープ対象の文字列の先頭を指すポインタです。
<em class="parameter"><code>length</code></em>パラメータはこの文字列のバイト数を示します。
ゼロバイト終端は必要なく、また、<em class="parameter"><code>lenth</code></em>ではこれを数えてはなりません。
(もし<em class="parameter"><code>length</code></em>バイト処理する前にゼロバイト終端が存在すると、<code class="function">PQescapeStringConn</code>はそのゼロで終了します。
この動作は<code class="function">strncpy</code>と同様です。)
<em class="parameter"><code>to</code></em>は、最低でも<em class="parameter"><code>length</code></em>の2倍よりも1バイト多い文字を保持可能なバッファへのポインタにしなければなりません。
さもないと、動作は不定になります。
<em class="parameter"><code>to</code></em>と<em class="parameter"><code>from</code></em>文字領域が重なる場合の動作も不定です。
     </p><p><em class="parameter"><code>error</code></em>パラメータが<code class="symbol">NULL</code>でなければ、<code class="literal">*error</code>には成功の0か、エラーの0以外が設定されます。
現時点であり得る唯一のエラー条件は、元文字列に無効なマルチバイト符号が含まれている場合です。
出力文字列はエラーであっても生成されますが、サーバが不整合として却下することが想定できます。
エラーの際、適切なメッセージは<em class="parameter"><code>error</code></em>が<code class="symbol">NULL</code>かどうかにかかわらず<em class="parameter"><code>conn</code></em>オブジェクト内に格納されます。
     </p><p><code class="function">PQescapeStringConn</code>は<em class="parameter"><code>to</code></em>に書き出したバイト数を返します。
ただし、文字数にはゼロバイト終端は含まれません。
     </p></dd><dt id="LIBPQ-PQESCAPESTRING"><span class="term">      <code class="function">PQescapeString</code>
      <a id="id-1.7.3.10.6.3.4.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="function">PQescapeString</code>は<code class="function">PQescapeStringConn</code>の推奨されない古いものです。
</p><pre class="synopsis">size_t PQescapeString (char *to, const char *from, size_t length);</pre><p>
     </p><p><code class="function">PQescapeStringConn</code>との唯一の違いは、<code class="function">PQescapeString</code>は<code class="structname">PGconn</code>や<em class="parameter"><code>error</code></em>パラメータを取らないことです。
このため(文字符号化方式のような)接続属性に依存する振舞いを調整できません。
その結果<span class="emphasis"><em>間違った結果を返す可能性があります</em></span>。
また、エラー状態を通知する機能がありません。
     </p><p><code class="function">PQescapeString</code>は、一度に1つの<span class="productname">PostgreSQL</span>接続のみで動作するクライアントプログラムでは安全に利用できます。
(この場合知らなければならない<span class="quote">“<span class="quote">裏側に隠された情報</span>”</span>を知ることができるからです。)
他の場合には、セキュリティ要因であり<code class="function">PQescapeStringConn</code>を利用することで避けなければなりません。
     </p></dd><dt id="LIBPQ-PQESCAPEBYTEACONN"><span class="term">      <code class="function">PQescapeByteaConn</code>
      <a id="id-1.7.3.10.6.3.5.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="type">bytea</code>型としてSQLコマンド内で使用するバイナリデータをエスケープします。
<code class="function">PQescapeStringConn</code>と同様、これは、SQLコマンド文字列にデータを直接含める場合にのみに使用されます。
</p><pre class="synopsis">unsigned char *PQescapeByteaConn(PGconn *conn,
                                 const unsigned char *from,
                                 size_t from_length,
                                 size_t *to_length);</pre><p>
      </p><p><acronym class="acronym">SQL</acronym>文内の<code class="type">bytea</code>リテラルの一部として使用する場合、特定のバイト値はエスケープされなければなりません。
<code class="function">PQescapeByteaConn</code>は16進数符号化またはバックスラッシュエスケープ処理を使用してバイトをエスケープします。
詳しくは<a class="xref" href="datatype-binary.html" title="8.4. バイナリ列データ型">Section 8.4</a>を参照してください。
      </p><p><em class="parameter"><code>from</code></em>パラメータはエスケープ対象の文字列の先頭バイトを指し示すポインタです。
<em class="parameter"><code>from_length</code></em>パラメータは、このバイナリ列内のバイト数を指定します。
(ゼロバイト終端は不要、かつ、数えられません。)
<em class="parameter"><code>to_length</code></em>パラメータは結果となるエスケープされた文字列の長さを保持する変数へのポインタです。
この結果文字列長は、結果内のゼロバイト終端を含みます。
      </p><p><code class="function">PQescapeByteaConn</code>は、<em class="parameter"><code>from</code></em>パラメータが示すバイナリ文字列をエスケープしたものを<code class="function">malloc()</code>で確保したメモリ内に返します。
その結果が不要になったら、このメモリを<code class="function">PQfreemem</code>を使用して解放しなければなりません。
返される文字列では、<span class="productname">PostgreSQL</span>リテラル文字列パーサと<code class="type">bytea</code>入力関数によって適切に処理できるように、すべての特殊な文字が置換されています。
ゼロバイト終端も追加されます。
<span class="productname">PostgreSQL</span>のリテラル文字列をくくる単一引用符は結果文字列には含まれません。
      </p><p>エラー時、ヌルポインタを返し適切なエラーメッセージを<em class="parameter"><code>conn</code></em>オブジェクトに格納します。
現在、唯一あり得るエラーは結果文字列のメモリ不足です。
      </p></dd><dt id="LIBPQ-PQESCAPEBYTEA"><span class="term">      <code class="function">PQescapeBytea</code>
      <a id="id-1.7.3.10.6.3.6.1.2" class="indexterm"></a>
     </span></dt><dd><p><code class="function">PQescapeBytea</code>は、<code class="function">PQescapeByteaConn</code>の推奨されない古いものです。
</p><pre class="synopsis">unsigned char *PQescapeBytea(const unsigned char *from,
                             size_t from_length,
                             size_t *to_length);</pre><p>
      </p><p><code class="function">PQescapeBytea</code>の<code class="function">PQescapeByteaConn</code>との唯一の違いは、<code class="structname">PGconn</code>パラメータです。
このため<code class="function">PQescapeBytea</code>は、一度に１つの<span class="productname">PostgreSQL</span>接続を使用するクライアントプログラムのみで安全に利用することができます。
(この場合知らなければならない<span class="quote">“<span class="quote">裏側に隠された情報</span>”</span>を知ることができるからです。)
複数のデータベース接続を使用するプログラムでは<span class="emphasis"><em>間違った結果を返す可能性があります</em></span>。
（このような場合は<code class="function">PQescapeByteaConn</code>を使用してください。）
      </p></dd><dt id="LIBPQ-PQUNESCAPEBYTEA"><span class="term">      <code class="function">PQunescapeBytea</code>
      <a id="id-1.7.3.10.6.3.7.1.2" class="indexterm"></a>
     </span></dt><dd><p>バイナリデータの文字列表現をバイナリデータに変換します。
つまり、<code class="function">PQescapeBytea</code>の逆です。
これは、<code class="type">bytea</code>データをテキスト書式で受けとった場合に必要とされます。
しかし、バイナリ書式で受けとった場合は不要です。

</p><pre class="synopsis">unsigned char *PQunescapeBytea(const unsigned char *from, size_t *to_length);</pre><p>
      </p><p><em class="parameter"><code>from</code></em>パラメータは、例えば、<code class="type">bytea</code>列に<code class="function">PQgetvalue</code>を行なった場合に返される可能性がある、文字列を指し示すポインタです。
<code class="function">PQunescapeBytea</code>は、この文字列表現をバイナリ表現に変換します。
<code class="function">malloc()</code>で確保したバッファへのポインタを返します。
エラー時は<code class="symbol">NULL</code>です。
また、このバッファのサイズを<em class="parameter"><code>to_length</code></em>に格納します。
不要になったら、この結果を<code class="function">PQfreemem</code>を使用して解放しなければなりません。
      </p><p>この変換は、<code class="function">PQescapeBytea</code>の逆ではありません。
文字列は<code class="function">PQgetvalue</code>から受け取る場合<span class="quote">“<span class="quote">エスケープされた</span>”</span>ことを予想しないためです。
特にこれは、文字列の引用符付けを意識する必要がなく、そのため<code class="structname">PGconn</code>パラメータを持つ必要がないことを意味します。
      </p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-status.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-async.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">33.2. 接続状態関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 33.4. 非同期コマンドの処理</td></tr></table></div></body></html>