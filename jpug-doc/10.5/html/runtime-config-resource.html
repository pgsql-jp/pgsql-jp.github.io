<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>19.4. 資源の消費</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="runtime-config-connection.html" title="19.3. 接続と認証" /><link rel="next" href="runtime-config-wal.html" title="19.5. ログ先行書き込み（WAL）" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">19.4. 資源の消費</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="runtime-config-connection.html" title="19.3. 接続と認証">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime-config.html" title="Chapter 19. サーバの設定">Up</a></td><th width="60%" align="center">Chapter 19. サーバの設定</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="runtime-config-wal.html" title="19.5. ログ先行書き込み（WAL）">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="RUNTIME-CONFIG-RESOURCE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">19.4. 資源の消費</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-MEMORY">19.4.1. メモリ</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-DISK">19.4.2. ディスク</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-KERNEL">19.4.3. カーネル資源使用</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST">19.4.4. コストに基づくVacuum遅延</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER">19.4.5. バックグラウンドライタ</a></span></dt><dt><span class="sect2"><a href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR">19.4.6. 非同期動作</a></span></dt></dl></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-MEMORY"><div class="titlepage"><div><div><h3 class="title">19.4.1. メモリ</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-SHARED-BUFFERS"><span class="term"><code class="varname">shared_buffers</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
データベースサーバが共有メモリバッファのために使用するメモリ量を設定します。
デフォルトは一般的に128メガバイト(<code class="literal">128MB</code>)です。
しかし、稼働中のカーネルの設定がこの値をサポートしていない場合、より少なくなることがあります（<span class="application">initdb</span>の過程で決定されます）。
この設定は最低限128キロバイトなければなりません。
（<code class="symbol">BLCKSZ</code>がデフォルト値と異なる場合、この最小値も異なる値になります。）
しかし、良い性能を引き出すためには、最小値よりかなり高い値の設定が通例必要です。
このパラメータはサーバ起動時にのみ設定可能です。
       </p><p>       
1GB以上のRAMを載せた専用データベースサーバを使用している場合、<code class="varname">shared_buffers</code>に対する妥当な初期値はシステムメモリの25%です。
<code class="varname">shared_buffers</code>をこれよりも大きな値に設定することが有効なワークロードもあります。
しかし、<span class="productname">PostgreSQL</span>はオペレーティングシステムキャッシュにも依存するため、<code class="varname">shared_buffers</code>にRAMの40%以上を割り当てても、それより小さい値の時より動作が良くなる見込みはありません。
<code class="varname">shared_buffers</code>をより大きく設定する場合は、大抵<code class="varname">max_wal_size</code>も合わせて増やす必要があります。これは、新規または変更された多量のデータを書き出す処理をより長い時間に渡って分散させるためです。
       </p><p>       
1GB未満のRAMのシステムでは、オペレーティングシステムに十分な余裕を残すために、RAMに対してより小さい割合を設定することが適切です。
       </p></dd><dt id="GUC-HUGE-PAGES"><span class="term"><code class="varname">huge_pages</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.7.2.2.2.1.3" class="indexterm"></a>
      </span></dt><dd><p>        huge memoryページの利用を有効/無効にします。
        可能な値は
        <code class="literal">try</code> (デフォルト), <code class="literal">on</code>,
         <code class="literal">off</code>です。
       </p><p>        今のところこの機能はLinuxでのみサポートされています。
        他のシステムでは<code class="literal">try</code>と設定しても無視されます。
       </p><p>        huge pageを使うと、ページテーブルが小さくなり、メモリ管理に使用されるCPU時間が少なくなり、性能が向上します。詳細は、<a class="xref" href="kernel-resources.html#LINUX-HUGE-PAGES" title="18.4.5. LinuxのHugePages">Section 18.4.5</a>を見てください。
       </p><p>        <code class="varname">huge_pages</code>を<code class="literal">try</code>に設定すると、サーバはhuge pageの利用を試み、失敗すると通常のアロケーションを行います。
        <code class="literal">on</code>にすると、huge pageの利用に失敗した場合サーバは起動しなくなります。
        <code class="literal">off</code>にすると、huge pageは使用されません。
       </p></dd><dt id="GUC-TEMP-BUFFERS"><span class="term"><code class="varname">temp_buffers</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.3.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
それぞれのデータベースセッションが使用する一時バッファの最大数を設定します。
一時バッファは、一時テーブルにアクセスする時にのみ使用されるセッションローカルのバッファです。
デフォルトは8メガバイト（<code class="literal">8MB</code>）です。
設定はそれぞれのセッション内で変更できますが、そのセッション内で一時テーブルが最初に使用されるまでになります。それより後に値の変更を試みても、そのセッションでは効果がありません。
       </p><p>       
セッションは、<code class="varname">temp_buffers</code>を上限として、必要に応じて一時バッファを確保します。
多くの一時バッファを実際に必要としないセッションで大きな値を設定するコストとは、<code class="varname">temp_buffers</code>の増分毎に、1つのバッファ記述子、約64バイトだけです。
しかし、バッファが実際に使用されると、それに対して追加の8192バイト（汎用的に言えば<code class="symbol">BLCKSZ</code>バイト）が消費されます。
       </p></dd><dt id="GUC-MAX-PREPARED-TRANSACTIONS"><span class="term"><code class="varname">max_prepared_transactions</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.4.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
同時に<span class="quote">“<span class="quote">プリペアド</span>”</span>状態にできるトランザクションの最大数を設定します（<a class="xref" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION"><span class="refentrytitle">PREPARE TRANSACTION</span></a>を参照してください）。
このパラメータをゼロ（これがデフォルトです）に設定すると、プリペアドトランザクション機能が無効になります。
このパラメータはサーバ起動時にのみ設定可能です。
       </p><p>       
プリペアドトランザクションの使用を意図しないのであれば、このパラメータはプリペアドトランザクションが偶然に作成されないようゼロに設定すべきです。
プリペアドトランザクションを使用する場合、全てのセッションがプリペアドトランザクションを保留できるように、<code class="varname">max_prepared_transactions</code>を少なくとも<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>と同じ大きさに設定するのが良いでしょう。
       </p><p>       
       スタンバイサーバを運用している場合、このパラメータはマスターサーバ上の設定よりも同等かもしくはより高水準に設定しなければなりません。そうしないと問い合わせがスタンバイサーバ内で受け入れられません。
       </p></dd><dt id="GUC-WORK-MEM"><span class="term"><code class="varname">work_mem</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.5.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       一時ディスクファイルに書き込む前に、内部並べ替えとハッシュテーブル操作が使用するメモリ容量を指定します。
デフォルト値は4メガバイト（<code class="literal">4MB</code>）です。
        複雑な問い合わせの場合、いくつかの並び替えもしくはハッシュ操作が並行して実行されることに注意してください。
        それぞれの操作による一時メモリへの書き込み開始の前に、この値が指定するのと同じメモリ容量の使用をそれらの操作に許容します。さらに、いくつかの実行中のセッションはこれらの動作を同時に行います。したがって、使用されるメモリの合計は、<code class="varname">work_mem</code>の数倍になります。値を選択する時には、この事実に留意することが必要です。並び替え操作は<code class="literal">ORDER BY</code>、<code class="literal">DISTINCT</code>、およびマージ結合に対して使われます。ハッシュテーブルはハッシュ結合、ハッシュに基づいた集約、および<code class="literal">IN</code>副問い合わせのハッシュに基づいた処理で使用されます。
       </p></dd><dt id="GUC-MAINTENANCE-WORK-MEM"><span class="term"><code class="varname">maintenance_work_mem</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.6.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       <code class="command">VACUUM</code>、<code class="command">CREATE INDEX</code>、および<code class="command">ALTER TABLE ADD FOREIGN KEY</code>の様な保守操作で使用されるメモリの最大容量を指定します。
デフォルト値は64メガバイト（<code class="literal">64MB</code>）です。
1つのデータベースセッションでは、一度に1つしか上記操作はできませんし、通常インストレーションでこうした操作が同時に非常に多く発生することはありませんので、これを<code class="varname">work_mem</code>よりもかなり多めの値にしても安全です。
大きい値を設定することでvacuum処理と、ダンプしたデータベースのリストア性能が向上します。
       </p><p>       
自動バキュームが稼動すると、最大でこのメモリの<a class="xref" href="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS">autovacuum_max_workers</a>倍が配分されるので、デフォルトの値をあまり高く設定しないよう注意してください。
別の設定項目<a class="xref" href="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM">autovacuum_work_mem</a>で制御するのが良いかもしれません。
       </p></dd><dt id="GUC-REPLACEMENT-SORT-TUPLES"><span class="term"><code class="varname">replacement_sort_tuples</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.7.1.3" class="indexterm"></a>
      </span></dt><dd><p>ソート対象のタプル数がこの指定値よりも小さい場合、クイックソートではなく、置換選択法を使ってソート処理の最初のラン出力を作ります。
メモリが限られた環境で、物理から論理への強い相関性を持つタプルが大量のソート処理に投入される場合に有用かもしれません。
なお、入力タプルが<span class="emphasis"><em>逆</em></span>相関性を示す場合にはこの限りではありません。
デフォルトの戦略が多数のランを実行してしまい、その結果を最後にマージしなければならないのと違って、置換選択アルゴリズムにおいては、マージを必要としない一つの長いランを実行できる可能性があります。
このことにより、ソート処理を素早く完了できるかもしれません。
       </p><p>デフォルト値は150,000タプルです。
多くの場合、より高い設定値がより良い効率をもたらすどころか、むしろ非生産的かもしれません。
なぜなら、優先度キューは、利用可能なCPUキャッシュの大きさに敏感な一方、デフォルトのソート戦略は<em class="firstterm">キャッシュに縛られない（cache-oblivious）</em>アルゴリズムを使用して実行されるからです。
この性質により、デフォルトのソート戦略では自動的かつ透過的に利用可能なCPUキャッシュを有効に利用できます。
       </p><p><code class="varname">maintenance_work_mem</code>をデフォルト値に設定すると、入力タプルの幅が非常に大きい場合を除き、通常ユーティリティコマンドが外部ソート(たとえば、<code class="command">CREATE INDEX</code>がB-Treeインデックスを作成するために行うソート)が置換選択アルゴリズムを使うことはなくなります。
       </p></dd><dt id="GUC-AUTOVACUUM-WORK-MEM"><span class="term"><code class="varname">autovacuum_work_mem</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.8.1.3" class="indexterm"></a>
      </span></dt><dd><p>        個々の自動バキュームワーカプロセスが使用する最大のメモリ量を指定します。
デフォルトは-1で、<a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>が代わりに使われる設定になります。
       別の文脈で実行される<code class="command">VACUUM</code>にはこの設定は影響しません。
       </p></dd><dt id="GUC-MAX-STACK-DEPTH"><span class="term"><code class="varname">max_stack_depth</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.2.2.9.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
サーバの実行スタックの最大安全深度を指定します。
このパラメータの理想的な設定はカーネルにより強要される実際のスタック容量の（<code class="literal">ulimit -s</code>もしくはそれと同等の機能で設定された）限界から、1メガバイト程度の安全余地を差し引いたものです。
安全余地は、サーバがすべてのルーチンではスタック深度を検査をせず、式評価などの主要な潜在的に再帰的なルーチンでのみ検査をするために必要となるものです。
デフォルト設定は2メガバイト（<code class="literal">2MB</code>）で、かなり控え目で、クラッシュの危険はなさそうです。
しかし、複雑な関数の実行を許容するには小さ過ぎるかも知れません。
スーパーユーザのみがこの設定を変更することができます。
       </p><p>       
       <code class="varname">max_stack_depth</code>を実際のカーネルの制限よりも高い値に設定した場合、暴走した再帰関数により、個々のバックエンドプロセスがクラッシュするかもしれません。
<span class="productname">PostgreSQL</span>がカーネルの制限を決定することができるプラットフォームでは、この変数を危険な値に設定させません。
しかし、すべてのプラットフォームがこの情報を提供できるわけではありません。
このため、値を選ぶ時には注意が必要です。
       </p></dd><dt id="GUC-DYNAMIC-SHARED-MEMORY-TYPE"><span class="term"><code class="varname">dynamic_shared_memory_type</code> (<code class="type">enum</code>)
      <a id="id-1.6.6.7.2.2.10.1.3" class="indexterm"></a>
      </span></dt><dd><p>        サーバが使う動的共有メモリの実装を指定します。可能な値は
        <code class="literal">posix</code> (<code class="literal">shm_open</code>で獲得するPOSIX共有メモリ)、
         <code class="literal">sysv</code>
        (<code class="literal">shmget</code>で獲得するSystem V共有メモリ)、
        <code class="literal">windows</code> (Windows共有メモリ)、 <code class="literal">mmap</code>
        (データディレクトリ内のメモリマップファイルを使ってシミュレートする共有メモリ)、
<code class="literal">none</code> (この機能を使用しない)です。
       すべての値がすべてのプラットフォームでサポートされているわけではありません。
       そのプラットフォームでの推奨実装がデフォルトになります。
       どのプラットフォームでもデフォルトになっていない<code class="literal">mmap</code>は、オペレーティングシステムが変更されたページをディスクに継続的に書き込み、I/O負荷を増加させるので一般的には利用が推奨されていません。
       しかし、デバッグ目的のために<code class="literal">pg_dynshmem</code>ディスクがRAMディスク上にある場合や、他の共有メモリ機能が使えない場合は有用かもしれません。
       </p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-DISK"><div class="titlepage"><div><div><h3 class="title">19.4.2. ディスク</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-TEMP-FILE-LIMIT"><span class="term"><code class="varname">temp_file_limit</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.3.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
あるプロセスが一時ファイルとして使用できるディスクの最大容量を設定します。
例えば、ソートやハッシュの一時ファイルであったり、カーソルを保持する格納ファイルです。
この制限値を超えようとするトランザクションはキャンセルされます。
値はキロバイト単位で指定され、（デフォルトである） <code class="literal">-1</code> の場合は制限がありません。
この設定はスーパーユーザのみ変更可能です。
       </p><p>       
       この設定により、ある <span class="productname">PostgreSQL</span> セッションによって使用される一時ファイルの合計の容量が常に制約されることになります。
       なお、問い合わせの実行において暗黙的に使用される一時ファイルとは異なり、一時テーブルとして明示的に使用されるディスク容量は、この制限には<span class="emphasis"><em>含まれません</em></span>。
       </p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-KERNEL"><div class="titlepage"><div><div><h3 class="title">19.4.3. カーネル資源使用</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-MAX-FILES-PER-PROCESS"><span class="term"><code class="varname">max_files_per_process</code> (<code class="type">integer</code>)
      <a id="id-1.6.6.7.4.2.1.1.3" class="indexterm"></a>
      </span></dt><dd><p>       
       それぞれのサーバ子プロセスが同時にオープンできるファイル数の最大値をセットします。
デフォルトは1000ファイルです。
もしもカーネルがプロセス毎の安全制限を強要している場合、この設定を気にかける必要はありません。
しかし、いくつかのプラットフォーム（特にほとんどのBSDシステム）では、もし多くのプロセス全てがそれだけ多くのファイルを開くことを試みたとした場合、実際にサポートできるファイル数より多くのファイルを開くことを許しています。もしも<span class="quote">“<span class="quote">Too many open files</span>”</span>エラーが発生した場合、この設定を削減してみてください。
このパラメータはサーバ起動時にのみ設定可能です。
       </p></dd></dl></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-VACUUM-COST"><div class="titlepage"><div><div><h3 class="title">19.4.4. コストに基づくVacuum遅延</h3></div></div></div><p>     
      <a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a> および <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a> コマンドの実行中、実行される各種I/O操作の予測コストを追跡し続ける内部カウンタをシステムが保守します。
      累積されたコストが（<code class="varname">vacuum_cost_limit</code>で指定された）限度に達すると、操作を実行しているプロセスは<code class="varname">vacuum_cost_delay</code>で指定されたちょっとの間スリープします。その後、カウンタをリセットし、実行を継続します。
     </p><p>     
この機能の目的は、同時に実行されているデータベースの活動に対するこれらコマンドによるI/Oへの影響を、管理者が軽減できるようにすることです。
<code class="command">VACUUM</code> および <code class="command">ANALYZE</code>の様な保守用コマンドが即座に終了することが重要ではない事態が数多くあります。
しかし、他のデータベースの操作を行うに当たって、これらのコマンドがシステムの能力に多大な阻害を与えないことは通常とても重要です。
コストに基づいたvacuum遅延はこれを実現するための方法を管理者に提供します。
     </p><p>     
手動で実行した<code class="command">VACUUM</code>コマンドについては、デフォルトでこの機能は無効になっています。
有効にするには、<code class="varname">vacuum_cost_delay</code>変数をゼロでない値に設定します。
     </p><div class="variablelist"><dl class="variablelist"><dt id="GUC-VACUUM-COST-DELAY"><span class="term"><code class="varname">vacuum_cost_delay</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.5.5.1.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        コストの限度を越えた場合、プロセスがスリープするミリ秒単位の時間の長さです。
デフォルトの値は0で、コストに基づいたvacuum遅延機能を無効にします。
正の整数はコストに基づいたvacuumを有効にします。
多くのシステムで、スリープ遅延の有効な分解能は10ミリ秒です。
<code class="varname">vacuum_cost_delay</code>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
        </p><p>       
        コストに基づいたバキューム処理を使用する場合、<code class="varname">vacuum_cost_delay</code>の適切な値は通常かなり小さくなり、たいていは10または20ミリ秒になります。
        バキュームによるリソース消費の調整は、他のバキュームのコストパラメータを変更して行うことが最善です。
        </p></dd><dt id="GUC-VACUUM-COST-PAGE-HIT"><span class="term"><code class="varname">vacuum_cost_page_hit</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.5.5.2.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        共有バッファキャッシュの中のバッファにvacuumを掛ける予測コストです。バッファプールのロック、共有ハッシュテーブルの検索、およびページ内容走査のコストを示します。デフォルトの値は1です。
        </p></dd><dt id="GUC-VACUUM-COST-PAGE-MISS"><span class="term"><code class="varname">vacuum_cost_page_miss</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.5.5.3.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        ディスクから読み込まれなければならないバッファにvacuumを掛ける予測コストです。これが示すものは、バッファプールロックの試み、共有ハッシュテーブルの参照、ディスクから目的ブロックの読み込み、そしてその内容走査です。デフォルトの値は10です。
        </p></dd><dt id="GUC-VACUUM-COST-PAGE-DIRTY"><span class="term"><code class="varname">vacuum_cost_page_dirty</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.5.5.4.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        vacuumが、先だって掃除したブロックを変更する時に果たされた予測コストです。
        ダーティブロックを再度ディスクに吐き出すのに必要な余分なI/Oを表します。デフォルトの値は20です。
        </p></dd><dt id="GUC-VACUUM-COST-LIMIT"><span class="term"><code class="varname">vacuum_cost_limit</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.5.5.5.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        vacuumを掛けるプロセスをスリープさせることになる累計されたコストです。
        デフォルトの値は200です。
        </p></dd></dl></div><div class="note"><h3 class="title">Note</h3><p>      
重要なロックを保有し可能なかぎり早急に完了しなければならないある種の操作があります。コストに基づいたvacuum遅延はこの様な操作では起こりません。
したがって、コストの累計が指定された限度をかなり高く越える可能性があります。
このような場合無駄な長い遅延を防止するため、実際の遅延は<code class="varname">vacuum_cost_delay</code> * 4 を上限として、以下のように計算されます。
       <code class="varname">vacuum_cost_delay</code> * <code class="varname">accumulated_balance</code> / <code class="varname">vacuum_cost_limit</code>
      </p></div></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER"><div class="titlepage"><div><div><h3 class="title">19.4.5. バックグラウンドライタ</h3></div></div></div><p>     
<em class="firstterm">バックグラウンドライタ</em>と呼ばれる個別のサーバプロセスがあり、その機能は（新規または更新された）<span class="quote">“<span class="quote">ダーティ</span>”</span>な共有バッファの書き込みを行うことです。
ユーザの問い合わせを処理するサーバプロセスが、書き込みが起きるまで滅多に待つ必要がない、あるいは決して待つ必要がないように、共有バッファの書き込みを行います。
しかし、バックグラウンドライタは正味の全体的I/O負荷の増加を引き起こします。
その理由は、繰り返しダーティ化されるページは、バックグラウンドライタを使わなければチェックポイント間隔で一度だけ書き出されれば十分なのに対し、バックグラウンドライタは同じ間隔内で何度もダーティ化されると、それを複数回書き出すかもしれないからです。
本節で説明する各パラメータは、サイト独自の必要に応じて動作を調整することに使用できます。
     </p><div class="variablelist"><dl class="variablelist"><dt id="GUC-BGWRITER-DELAY"><span class="term"><code class="varname">bgwriter_delay</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.6.3.1.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        バックグラウンドライタの動作周期間の遅延を指定します。
それぞれの周期でライタは、（以下のパラメータで管理される）一部のダーティバッファの書き込みを行います。
そして<code class="varname">bgwriter_delay</code>ミリ秒スリープした後、これを繰りかえします。
しかし、バッファプールにダーティバッファが存在しない場合、<code class="varname">bgwriter_delay</code>に係わらずより長くスリープします。
デフォルトの値は200ミリ秒（<code class="literal">200ms</code>）です。
多くのシステムで、スリープ遅延の実精度は10ミリ秒です。
<code class="varname">bgwriter_delay</code>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインで設定可能です。
        </p></dd><dt id="GUC-BGWRITER-LRU-MAXPAGES"><span class="term"><code class="varname">bgwriter_lru_maxpages</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.6.3.2.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        それぞれの周期で、この数以上のバッファはバックグラウンドライタにより書き込まれません。
         ゼロに設定することでバックグラウンド書き込みは無効になります。
        （分離し、そして専用の補助プロセスにより管理されるチェックポイントは影響を受けません。）
         デフォルト値は100バッファです。
         このパラメータは<code class="filename">postgresql.conf</code>ファイル内、または、サーバのコマンドラインでのみで設定可能です。
        </p></dd><dt id="GUC-BGWRITER-LRU-MULTIPLIER"><span class="term"><code class="varname">bgwriter_lru_multiplier</code> (<code class="type">floating point</code>)
       <a id="id-1.6.6.7.6.3.3.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
        各周期で書き出されるダーティバッファ数は、最近の周期でサーバプロセスが必要とした新しいバッファ数を基にします。
次の周期で必要となるバッファ数を推定するために、最近必要とされた平均が<code class="varname">bgwriter_lru_multiplier</code>と掛け合わせられます。
ダーティバッファの書き出しは、同数の整理済み、再利用可能なバッファが利用できるようになるまで行われます。
（しかし1周期に<code class="varname">bgwriter_lru_maxpages</code>を越えるバッファ数を書き出しません。）
したがって、1.0と設定することは、必要と予想されるバッファ数の書き込みについて<span class="quote">“<span class="quote">必要なときに必要なだけ</span>”</span>というポリシーを表します。
より大きな値は突発的な要求に対する多少の緩衝材を提供します。
より小さな値はサーバプロセスでなされる書き込みを意図的に残します。
デフォルトは2.0です。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみで設定可能です。
        </p></dd><dt id="GUC-BGWRITER-FLUSH-AFTER"><span class="term"><code class="varname">bgwriter_flush_after</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.6.3.4.1.3" class="indexterm"></a>
       </span></dt><dd><p>バックグラウンドライターが<code class="varname">bgwriter_flush_after</code>バイトより多く書く度に、OSが記憶装置に書き込むことを強制しようとします。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後に<code class="function">fsync</code>が実行される際、あるいはOSがバックグラウンドでデータを大きな塊で書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延が大幅に少なくなりますが、あるケース、特にワークロードが<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<code class="literal">0</code>から、<code class="literal">2MB</code>までです。
デフォルト値は、Linuxでは<code class="literal">512kB</code>で、それ以外は<code class="literal">0</code>です。
(<code class="symbol">BLCKSZ</code>が8kBでなければ、この設定のデフォルト値と最大値が<code class="symbol">BLCKSZ</code>に比例して変更されます。)
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみで設定可能です。
        </p></dd></dl></div><p>     
      <code class="varname">bgwriter_lru_maxpages</code>および<code class="varname">bgwriter_lru_multiplier</code>の値がより少ないと、バックグラウンドライタで引き起こされる追加のI/O負荷を軽減しますが、サーバプロセスが自分自身で行わなければならない書き込みが増加することになり、会話型問い合わせを遅らせることになります。
     </p></div><div class="sect2" id="RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR"><div class="titlepage"><div><div><h3 class="title">19.4.6. 非同期動作</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt id="GUC-EFFECTIVE-IO-CONCURRENCY"><span class="term"><code class="varname">effective_io_concurrency</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.1.1.3" class="indexterm"></a>
       </span></dt><dd><p>       
<span class="productname">PostgreSQL</span>が同時実行可能であると想定する同時ディスクI/O操作の数を設定します。
この値を大きくすると、あらゆる個別の<span class="productname">PostgreSQL</span>セッションが並行して開始を試みるI/O操作の数が増加します。
設定可能な範囲は1から1000まで、または非同期I/Oリクエストの発行を無効にするゼロです。
現在、この設定はビットマップヒープスキャンのみに影響します。
        </p><p>       
磁気ディスクドライブにおいては、データベースに使用されるRAID 0ストライプ、RAID 1ミラーを構成する個々のドライブ数から始めると良いでしょう。（RAID 5ではパリティ用のドライブを数に含めません）
しかし、同時実行セッションで発行される複数の問い合わせでデータベースが頻繁にビジーとなる場合、小さめの値で十分ディスクアレイがビジーになるかもしれません。
ディスクをビジーにするのに必要な値より大きな値を設定しても、余計なCPUオーバーヘッドを発生させるだけです。
SSDやそれ以外のメモリーベースの記憶装置は、多くの同時リクエストをこなすことができるので、最適な値は数百になるかもしれません。
        </p><p>       
        非同期I/Oは実質的に<code class="function">posix_fadvise</code>関数に依存します。
        これは一部のオペレーティングシステムには存在しません。
        この関数が存在しない場合、この値をゼロ以外に設定するとエラーとなります。
        一部のオペレーティングシステム（例えばSolaris）では存在するけれども、実際何も行わないものもあります。
        </p><p>デフォルトは、サポートされているシステムでは1、そうでなければ0です。
この値は、テーブルスペースパラメータの同じ名前のパラメータを設定することで、特定のテーブルスペース内のテーブルに対して上書きできます。
(<a class="xref" href="sql-altertablespace.html" title="ALTER TABLESPACE"><span class="refentrytitle">ALTER TABLESPACE</span></a>を参照ください)。
        </p></dd><dt id="GUC-MAX-WORKER-PROCESSES"><span class="term"><code class="varname">max_worker_processes</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.2.1.3" class="indexterm"></a>
       </span></dt><dd><p>システムがサポートするバックグラウンドプロセスの最大数を指定します。
このパラメータはサーバ起動時にのみ設定できます。
デフォルトは8です。
        </p><p>         スタンバイサーバを起動しているときは、このパラメータを、マスタサーバの設定値と同じかそれ以上にしなければなりません。さもなければ、スタンバイサーバで問い合わせの実行ができなくなります。
        </p><p>この値を変更する際は、<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>と<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>を変更することも考慮してください。

        </p></dd><dt id="GUC-MAX-PARALLEL-WORKERS-PER-GATHER"><span class="term"><code class="varname">max_parallel_workers_per_gather</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.3.1.3" class="indexterm"></a>
       </span></dt><dd><p>一つの<code class="literal">Gather</code>または<code class="literal">Gather Merge</code>ノードに対して起動できるワーカー数の最大値を設定します。
パラレルワーカーは、<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>で上限が決まる<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>で確立されたプロセスのプールから取得されます。
実行時には、要求された数のワーカーは取得できないかもしれないことに注意してください。
そうなると、実行プランは期待していたよりも少ない数のワーカーで実行されることになり、効率は悪化するかもしれません。
デフォルト値は2です。
この設定値を0にすると、パラレルクエリの実行は行われません。
        </p><p>パラレルクエリの実行により、パラレルクエリではない場合に比べて非常に多くのリソースが使用されるかもしれないことに注意してください。
これは、個々のワーカープロセスは完全に別個のプロセスであり、システムに対してユーザセッションが追加されたのと大体同じくらいの影響があるからです。
この設定値を選択する際には、他のリソースの消費量を制御する他の設定値、たとえば<a class="xref" href="runtime-config-resource.html#GUC-WORK-MEM">work_mem</a>を設定するときと同様に、この点を考慮しておく必要があります。
<code class="varname">work_mem</code>のような設定値によるリソース制限は、個々のワーカーに対して個別に適用されます。
つまり、ひとつのプロセス対するよりも、すべてのプロセスの全体のリソース消費はずっと多いかもしれないということです。
たとえば、あるパラレルクエリが4つのワーカーを使っているとすると、ワーカーを使わない場合に比べて、最大5倍のCPU時間、メモリ、I/Oバンド幅、その他を使うかもしれません。
        </p><p>         パラレルクエリに関する更なる情報については、<a class="xref" href="parallel-query.html" title="Chapter 15. パラレルクエリ">Chapter 15</a>をご覧ください。
        </p></dd><dt id="GUC-MAX-PARALLEL-WORKERS"><span class="term"><code class="varname">max_parallel_workers</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.4.1.3" class="indexterm"></a>
       </span></dt><dd><p>パラレルクエリ用にシステムがサポートできる最大のワーカー数を設定します。
デフォルト値は8です。
この値を増減するときは、<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>を調整することを考慮してください。
また、この設定値を<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>よりも高い値にしても効果がないことに注意してください。
<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>で決まるワーカープロセスのプールから、パラレルワーカーが使われるからです。
        </p></dd><dt id="GUC-BACKEND-FLUSH-AFTER"><span class="term"><code class="varname">backend_flush_after</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.5.1.3" class="indexterm"></a>
       </span></dt><dd><p><code class="varname">backend_flush_after</code>バイトが単一のバックエンドによって書き込まれる度に、OSが記憶装置に書き込むことを強制します。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後に<code class="function">fsync</code>が実行される際、あるいはバックグラウンドで実行される大きなバッチの中でOSがデータを書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延を大幅に少なくなりますが、あるケース、特にワークロードが<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<code class="literal">0</code>から、<code class="literal">2MB</code>までです。
デフォルト値は<code class="literal">0</code>です(すなわち書き出し制御を行いません)。
(<code class="symbol">BLCKSZ</code>が8kbでなければ、最大値が<code class="symbol">BLCKSZ</code>に比例して変更されます。)
        </p></dd><dt id="GUC-OLD-SNAPSHOT-THRESHOLD"><span class="term"><code class="varname">old_snapshot_threshold</code> (<code class="type">integer</code>)
       <a id="id-1.6.6.7.7.2.6.1.3" class="indexterm"></a>
       </span></dt><dd><p>スナップショットが使用されるときに、<code class="literal">snapshot too old</code>エラーを引き起こす危険性なしにスナップショットを利用できる最小時間を設定します。
このパラメータはサーバ起動時にのみ設定できます。
        </p><p>この制限値を越えると、古いデータはバキュームされます。
これにより、長い間残っていたスナップショットによりデータが溢れてしまうのを防ぐことができます。
スナップショットから見えるデータが消えることによる不正な結果を防ぐため、スナップショットがこの制限値よりも古く、かつこのスナップショットが作られた以降に変更されたページを読むためにスナップショットが使用されるときはエラーが発生します。
        </p><p><code class="literal">-1</code>を設定するとこの機能が無効になります。
これがデフォルトです。
実際の環境でのおすすめの値はおそらく数時間から2, 3日の間となるでしょう。
設定値は、分の粒度に書き換えられます。
小さな値(たとえば<code class="literal">0</code>や<code class="literal">1min</code>)は、テストの際に有用だということで許可されています。
<code class="literal">60d</code>のような大きな値の設定もできますが、多くのワークロードにおいて、大きなデータ溢れやトランザクションIDの周回がそれよりはずっと短い期間で起こる可能性があることに注意してください。
        </p><p>この機能が有効であると、リレーションの終端部にあるフリースペースはオペレーティングシステムには返却されません。
そうしないと、<code class="literal">snapshot too old</code>の条件の検出に必要な情報を削除してしまうことになるからです。
明示的に解放されない限り（たとえば<code class="command">VACUUM FULL</code>によって）、リレーションに割り当てられた領域は、そのリレーションの中での再利用に限定して紐付けられます。
        </p><p>この設定は、どのような状況でもエラーが検出されることを保証するものではありません。
（たとえば）マテリアライズされた結果集合を持つカーソルから正しい結果を得ることができるのであれば、たとえ参照している元のテーブルからVACUUMによって行が削除されたとしてもエラーにはなりません。
ある種のテーブルでは、早期にVACUUMできないので、この設定の影響を受けません。
例としては、システムカタログが挙げられます。
このようなテーブルにおいては、この設定によってデータ溢れを防ぐことも、スキャンの際に<code class="literal">snapshot too old</code>エラーを起こす可能性を作り出すこともできません。
        </p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-connection.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-wal.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">19.3. 接続と認証 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 19.5. ログ先行書き込み（WAL）</td></tr></table></div></body></html>