<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>33.18. SSLサポート</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq-ldap.html" title="33.17. 接続パラメータのLDAP検索" /><link rel="next" href="libpq-threading.html" title="33.19. スレッド化プログラムの振舞い" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">33.18. SSLサポート</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-ldap.html" title="33.17. 接続パラメータのLDAP検索">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Up</a></td><th width="60%" align="center">Chapter 33. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C ライブラリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-threading.html" title="33.19. スレッド化プログラムの振舞い">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LIBPQ-SSL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">33.18. SSLサポート</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-ssl.html#LIBQ-SSL-CERTIFICATES">33.18.1. サーバ証明書のクライアント検証</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-CLIENTCERT">33.18.2. クライアント証明書</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-PROTECTION">33.18.3. 異なるモードで提供される保護</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-FILEUSAGE">33.18.4. SSLクライアントファイル使用方法</a></span></dt><dt><span class="sect2"><a href="libpq-ssl.html#LIBPQ-SSL-INITIALIZE">33.18.5. SSLライブラリの初期化</a></span></dt></dl></div><a id="id-1.7.3.25.2" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は、セキュリティを高めるためにクライアントサーバ間の通信を暗号化する<acronym class="acronym">SSL</acronym>接続の使用を元来サポートしています。
サーバ側の<acronym class="acronym">SSL</acronym>機能についての詳細は<a class="xref" href="ssl-tcp.html" title="18.9. SSLによる安全なTCP/IP接続">Section 18.9</a>を参照してください。
  </p><p><span class="application">libpq</span>はシステム全体に対する<span class="productname">OpenSSL</span>設定ファイルを読み込みます。
デフォルトでは、ファイル名は<code class="filename">openssl.cnf</code>で、<code class="literal">openssl version -d</code>で報告されるディレクトリに格納されています。
このデフォルトは<code class="envar">OPENSSL_CONF</code>環境変数に希望する設定ファイル名を設定することで変更することができます。
  </p><div class="sect2" id="LIBQ-SSL-CERTIFICATES"><div class="titlepage"><div><div><h3 class="title">33.18.1. サーバ証明書のクライアント検証</h3></div></div></div><p>デフォルトでは<span class="productname">PostgreSQL</span>はサーバ証明書の検証をまったく行いません。
これは、（例えば、DNSレコードを変更したり、もしくはサーバのIPアドレスを乗っ取ったりして）クライアントに知られずにサーバの身元をなりすませることを意味します。
なりすましを防止するには、クライアントは、トラストチェーン(chain of trust)を通じて、サーバの身元を検証できなければなりません。
トラストチェーンは、ルート（自己署名）認証局（<acronym class="acronym">CA</acronym>）証明書をあるコンピュータに設置し、そのルート証明書によって<span class="emphasis"><em>署名された</em></span>リーフ証明書を他のコンピュータに設置することによって確立されます。
また、ルート証明書によって署名された<span class="quote">“<span class="quote">中間</span>”</span>証明書を使って、リーフ証明書に署名することによっても可能です。
  </p><p>クライアントがサーバの身元を検証するためには、ルート証明書をクライアントに設置し、そのルート証明書によって署名されたリーフ証明書をサーバに設置します。
サーバがクライアントの身元を検証するためには、ルート証明書をサーバに設置し、そのルート証明書によって署名されたリーフ証明書をクライアントに設置します。
一つ以上の中間証明書（通常リーフ証明書とともに格納されます）を使って、リーフ証明書をルート証明書につなげることもできます。
  </p><p>トラストチェーンがひとたび確立されれば、クライアントがサーバから送信されたリーフ証明書を検証する二つの方法があります。
パラメータ<code class="literal">sslmode</code>が<code class="literal">verify-ca</code>に設定されている場合、libpqはクライアントに格納されたルート証明書までの証明書連鎖を検査することで、サーバが信用に足るかを検証します。
<code class="literal">sslmode</code>が<code class="literal">verify-full</code>に設定されていると、libpqは<span class="emphasis"><em>同時に</em></span>サーバホスト名が証明書のそれと一致するかを検証します。
SSL接続はサーバ証明書が検証されない場合失敗します。
安全性に慎重を期するほとんどのサーバ環境では<code class="literal">verify-full</code>を推奨します。
  </p><p><code class="literal">verify-full</code>モードでは、ホスト名を証明書のサブジェクト別名(Subject Alternative Name)属性と、あるいは<code class="literal">dNSName</code>タイプのサブジェクト別名がないときはコモンネーム属性とマッチさせます。
証明書の名前属性がアスタリスク（<code class="literal">*</code>）で始まると、それはワイルドカードとして取り扱われ、ドット（<code class="literal">.</code>）を除くすべての文字とマッチします。
これは、証明書がサブドメインとマッチしないことを意味します。
もし接続がホスト名ではなくIPアドレスを使用するのであれば、（いかなるDNS検索もせず）IPアドレスがマッチさせられます。
  </p><p>サーバ証明書の検証を可能にするには、1つ以上のルート証明書を、ユーザのホームディレクトリの<code class="filename">~/.postgresql/root.crt</code>ファイルに置かなければなりません。
（Microsoft Windowsの場合、このファイルの名前は<code class="filename">%APPDATA%\postgresql\root.crt</code>です。）
サーバより送信された証明書連鎖から、クライアントに格納されたルート証明書にリンクするために（中間証明書）が必要なら、中間証明書もそのファイルに追加する必要があります。
  </p><p><code class="filename">~/.postgresql/root.crl</code>ファイル（Microsoft Windowsでは<code class="filename">%APPDATA%\postgresql\root.crl</code>）が存在する場合、証明書失効リスト（CRL）の項目もまた検査されます。
  </p><p>ルート証明書ファイルとCRLの格納場所を接続パラメータ<code class="literal">sslrootcert</code>と<code class="literal">sslcrl</code>、もしくは環境変数<code class="envar">PGSSLROOTCERT</code>と<code class="envar">PGSSLCRL</code>で変更することができます。
  </p><div class="note"><h3 class="title">Note</h3><p>より古いバージョンのPostgreSQLとの後方互換性のために、ルートCAファイルが存在する場合、<code class="literal">sslmode</code>=<code class="literal">require</code>の動作は<code class="literal">verify-ca</code>の場合と同じになっています。
つまり、サーバ証明書がCAに対して検証されます。
この動作に依存することは勧めません。
また証明書の検証を必要とするアプリケーションは常に<code class="literal">verify-ca</code>または<code class="literal">verify-full</code>を使用すべきです。
   </p></div></div><div class="sect2" id="LIBPQ-SSL-CLIENTCERT"><div class="titlepage"><div><div><h3 class="title">33.18.2. クライアント証明書</h3></div></div></div><p>サーバが、クライアントのリーフ証明書を要求することによってクライアントの身元を検証しようとする場合、<span class="application">libpq</span>はユーザのホームディレクトリにある<code class="filename">~/.postgresql/postgresql.crt</code>ファイルに格納された証明書を送信します。
証明書は、サーバが信頼するルート証明書につながらなければなりません。
対応する<code class="filename">~/.postgresql/postgresql.key</code>秘密キーファイルも存在しなければなりません。
秘密キーファイルは他者やグループからのアクセスを許可してはいけません。
<code class="command">chmod 0600 ~/.postgresql/postgresql.key</code>コマンドでこれを実現してください。
Microsoft Windowsでは、このファイルの名前はそれぞれ<code class="filename">%APPDATA%\postgresql\postgresql.crt</code>と<code class="filename">%APPDATA%\postgresql\postgresql.key</code>であり、このディレクトリは安全であると想定されますので、特別な権限検査は行われません。
証明書とキーファイルの格納場所は<code class="literal">sslcert</code>および<code class="literal">sslkey</code>接続パラメータ、または<code class="envar">PGSSLCERT</code>および<code class="envar">PGSSLKEY</code>環境変数で上書きされます。
  </p><p><code class="filename">postgresql.crt</code>中の最初の証明書は、クライアント証明書でなければなりません。
クライアントの秘密鍵と一致していなければならないからです。
オプションで、<span class="quote">“<span class="quote">中間</span>”</span>証明書を追加することができます。
そうすることによって、サーバの<code class="filename">root.crt</code>ファイル上の中間証明書用の記憶領域が不要になります。
  </p><p>証明書の作成手順については、<a class="xref" href="ssl-tcp.html#SSL-CERTIFICATE-CREATION" title="18.9.3. 証明書の作成">Section 18.9.3</a>をご覧ください。
  </p></div><div class="sect2" id="LIBPQ-SSL-PROTECTION"><div class="titlepage"><div><div><h3 class="title">33.18.3. 異なるモードで提供される保護</h3></div></div></div><p><code class="literal">sslmode</code>パラメータ値を変更することで、異なったレベルの保護を提供します。
SSLは以下の３種類の攻撃に対する保護を提供することができます。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">盗聴</span></dt><dd><p>クライアント・サーバ間のネットワークトラフィックを第三者が監視することができれば、（ユーザ名とパスワードを含め）双方の接続情報と通過するデータを読み取ることができます。
<acronym class="acronym">SSL</acronym>はこれを防止するために暗号を使用します。
      </p></dd><dt><span class="term">中間者攻撃（<acronym class="acronym">MITM</acronym>）</span></dt><dd><p>データがクライアント・サーバ間で渡されている時に、第三者がそのデータを変更できれば、サーバを装うことができ、従って<span class="emphasis"><em>たとえ暗号化されていても</em></span>データを理解し変更することができます。
第三者はそこで、この攻撃を検出不可能にする接続情報とデータを元のサーバに送ることができます。
これを行う共通した媒介はDNSポイズニングとアドレス乗っ取りを含み、それに従ってクライアントは意図したサーバではなく異なったサーバに誘導されます。
同時に、このことを成し遂げるいくつかの異なった攻撃も存在します。
<acronym class="acronym">SSL</acronym>はクライアントに対しサーバを認証することで、この防止に証明書検証を使用します。
      </p></dd><dt><span class="term">なりすまし</span></dt><dd><p>第三者が認定されたクライアントを装うことができれば、それはアクセスしてはならないデータに簡単にアクセス可能になります。
典型的にこれは心もとないパスワード管理から生じます。
<acronym class="acronym">SSL</acronym>は有効な証明書の所持者のみサーバにアクセスできることを確実にすることで、この防止策としてクライアント証明書を使用します。
      </p></dd></dl></div><p>
  </p><p>信頼できるとされる接続では、SSLの使用を接続確立前に<span class="emphasis"><em>クライアントとサーバの双方において</em></span>設定されなければなりません。
サーバのみに構成されると、クライアントはサーバが高度なセキュリティを必要とすることが判る以前に、（例えばパスワードのような）機密事項を扱う情報を結局送ることになります。
libpqにおいて、<code class="literal">sslmode</code>パラメータを<code class="literal">verify-full</code>または<code class="literal">verify-ca</code>に設定し、そして対象を検証するためルート証明書をシステムに提供することで、安全な接続を確実に行うことができます。
これは暗号化されたweb閲覧に対する<code class="literal">https</code> <acronym class="acronym">URL</acronym>の使用とよく似ています。
  </p><p>一度サーバが認証されると、クライアントは機密事項を扱うデータを送ることができます。
この意味は、これまでクライアントは認証に証明書が使われているかどうかを知る必要がなく、サーバ構成においてのみこのことを指定しても安全だと言うことです。
  </p><p>すべての<acronym class="acronym">SSL</acronym>オプションでは暗号化の形式と鍵交換といったオーバヘッドがかかります。
このため性能と安全性との間で決定されるべきトレードオフがあります。
<a class="xref" href="libpq-ssl.html#LIBPQ-SSL-SSLMODE-STATEMENTS" title="Table 33.1. SSLモードの説明">Table 33.1</a>は異なる<code class="literal">sslmode</code>値が防御する危険性と、安全性とオーバヘッドに対する声明を示したものです。
  </p><div class="table" id="LIBPQ-SSL-SSLMODE-STATEMENTS"><p class="title"><strong>Table 33.1. SSLモードの説明</strong></p><div class="table-contents"><table class="table" summary="SSLモードの説明" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th><code class="literal">sslmode</code></th><th>盗聴防止</th><th><acronym class="acronym">MITM</acronym>防止</th><th>声明</th></tr></thead><tbody><tr><td><code class="literal">disable</code></td><td>いいえ</td><td>いいえ</td><td>セキュリティはどうでもよく、暗号化の負荷を払いたくない
      </td></tr><tr><td><code class="literal">allow</code></td><td>たぶん</td><td>いいえ</td><td>セキュリティはどうでもよいが、サーバがそれを強く要求するのであれば暗号化のオーバヘッドを払ってもよい
      </td></tr><tr><td><code class="literal">prefer</code></td><td>たぶん</td><td>いいえ</td><td>セキュリティはどうでもよいが、サーバがそれをサポートするのであれば暗号化のオーバヘッドを払ってもよい
      </td></tr><tr><td><code class="literal">require</code></td><td>はい</td><td>いいえ</td><td>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。意図したサーバに常に接続することをネットワークが確実にしてくれると信用する
      </td></tr><tr><td><code class="literal">verify-ca</code></td><td>はい</td><td><code class="literal">CA</code>の規定に<code class="literal">依存</code></td><td>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。信頼するサーバに確実に接続したい
      </td></tr><tr><td><code class="literal">verify-full</code></td><td>はい</td><td>はい</td><td>データを暗号化して欲しい。そしてオーバヘッドも受け入れる。信頼するサーバに接続すること、そのサーバが指定したものであることを確実にしたい
       </td></tr></tbody></table></div></div><br class="table-break" /><p><code class="literal">verify-ca</code>と<code class="literal">verify-full</code>の差異はルート<acronym class="acronym">CA</acronym>の規定に依存します。
公的な<acronym class="acronym">CA</acronym>が使用されるとき、<code class="literal">verify-ca</code>はその<acronym class="acronym">CA</acronym>で<span class="emphasis"><em>他の誰か</em></span>が登録したかもしれないサーバへの接続を許可します。
この場合、<code class="literal">verify-full</code>が常に使用されなければなりません。
独自<acronym class="acronym">CA</acronym>が使用されるとき、または自己署名証明書であったとしても<code class="literal">verify-ca</code>は十分な防御策を提供します。
  </p><p><code class="literal">sslmode</code>のデフォルト値は<code class="literal">prefer</code>です。
表で示したように、これはセキュリティの視点では意味がなく、可能であれば性能上のオーバヘッドを保証するだけです。
これは後方互換性を提供するためのみにデフォルトとなっているもので、安全性確保の観点からは推奨されません。
  </p></div><div class="sect2" id="LIBPQ-SSL-FILEUSAGE"><div class="titlepage"><div><div><h3 class="title">33.18.4. SSLクライアントファイル使用方法</h3></div></div></div><p><a class="xref" href="libpq-ssl.html#LIBPQ-SSL-FILE-USAGE" title="Table 33.2. libpq/クライアントにおけるSSLファイルの使用方法">Table 33.2</a>にクライアントにおけるSSL設定に関連するファイルをまとめます。
  </p><div class="table" id="LIBPQ-SSL-FILE-USAGE"><p class="title"><strong>Table 33.2. libpq/クライアントにおけるSSLファイルの使用方法</strong></p><div class="table-contents"><table class="table" summary="libpq/クライアントにおけるSSLファイルの使用方法" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>ファイル</th><th>内容</th><th>効果</th></tr></thead><tbody><tr><td><code class="filename">~/.postgresql/postgresql.crt</code></td><td>クライアント証明書</td><td>サーバにより要求されます</td></tr><tr><td><code class="filename">~/.postgresql/postgresql.key</code></td><td>クライアントの秘密キー</td><td>所有者により送信されるクライアント証明書を証明します。証明書の所有者が信頼できることを意味していません。</td></tr><tr><td><code class="filename">~/.postgresql/root.crt</code></td><td>信頼できる認証局</td><td>サーバ証明書が信頼できる認証局により署名されたか検査します。</td></tr><tr><td><code class="filename">~/.postgresql/root.crl</code></td><td>認証局により失効された証明書</td><td>サーバ証明書はこのリストにあってはいけません</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LIBPQ-SSL-INITIALIZE"><div class="titlepage"><div><div><h3 class="title">33.18.5. SSLライブラリの初期化</h3></div></div></div><p>   
使用するアプリケーションが<code class="literal">libssl</code>と<code class="literal">libcrypto</code>の両方またはいずれか一方のライブラリを初期化し、<span class="application">libpq</span>が<acronym class="acronym">SSL</acronym>サポート付きで構築された場合、<code class="literal">libssl</code>と<code class="literal">libcrypto</code>の両方またはいずれか一方のライブラリはアプリケーションによって初期化されたことを<span class="application">libpq</span>に伝えるため<code class="function">PQinitOpenSSL</code>を呼び出さなければなりません。
これにより、<span class="application">libpq</span>はこれらのライブラリを初期化しなくなります。
SSL APIの詳細は<a class="ulink" href="http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html" target="_top">http://h71000.www7.hp.com/doc/83final/ba554_90007/ch04.html</a>を参照してください。
  </p><p>   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQINITOPENSSL"><span class="term">      <code class="function">PQinitOpenSSL</code>
      <a id="id-1.7.3.25.9.3.1.1.1.2" class="indexterm"></a>
     </span></dt><dd><p>アプリケーションがどのセキュリティライブラリを初期化するか選択することができます。
</p><pre class="synopsis">void PQinitOpenSSL(int do_ssl, int do_crypto);</pre><p>
      </p><p><em class="parameter"><code>do_ssl</code></em>が非ゼロの時、<span class="application">libpq</span>は最初のデータベース接続を開始する以前に<span class="application">OpenSSL</span>ライブラリを初期化します。
<em class="parameter"><code>do_crypto</code></em>が非ゼロの時、<code class="literal">libcrypto</code>ライブラリが初期化されます。
デフォルトでは（<code class="function">PQinitOpenSSL</code>が呼ばれない場合）、両方のライブラリが初期化されます。
SSLサポートがコンパイルされていない場合、この関数は存在しますが何もしません。
      </p><p>使用するアプリケーションが<span class="application">OpenSSL</span>またはその基礎をなす<code class="literal">libcrypto</code>ライブラリのいずれかを使用し、そして初期化するのであれば、最初のデータベース接続開始以前に、適切なパラメータをゼロにしてこの関数を呼び出さなければ<span class="emphasis"><em>なりません</em></span>。
同時に、データベース接続開始前に初期化を行ったことの確認をしてください。
      </p></dd><dt id="LIBPQ-PQINITSSL"><span class="term">      <code class="function">PQinitSSL</code>
      <a id="id-1.7.3.25.9.3.1.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>アプリケーションがどのセキュリティライブラリを初期化するか選択することができます。
</p><pre class="synopsis">void PQinitSSL(int do_ssl);</pre><p>
      </p><p>この関数は<code class="literal">PQinitOpenSSL(do_ssl, do_ssl)</code>と等価です。
<span class="application">OpenSSL</span>および<code class="literal">libcrypto</code>の両方を初期化する、もしくは両方ともしないアプリケーションにとっては（この関数で）十分です。
      </p><p><span class="productname">PostgreSQL</span> 8.0以降、<code class="function">PQinitSSL</code>は含まれていますが、<code class="function">PQinitOpenSSL</code>は<span class="productname">PostgreSQL</span> 8.4で追加されました。
従って、旧バージョンの<span class="application">libpq</span>で動かす必要があるアプリケーションでは<code class="function">PQinitSSL</code>の方が好ましいかもしれません。
      </p></dd></dl></div><p>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-ldap.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-threading.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">33.17. 接続パラメータのLDAP検索 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 33.19. スレッド化プログラムの振舞い</td></tr></table></div></body></html>