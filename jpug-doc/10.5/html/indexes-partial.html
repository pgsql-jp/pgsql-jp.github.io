<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.8. 部分インデックス</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-expressional.html" title="11.7. 式に対するインデックス" /><link rel="next" href="indexes-opclass.html" title="11.9. 演算子クラスと演算子族" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.8. 部分インデックス</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-expressional.html" title="11.7. 式に対するインデックス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="Chapter 11. インデックス">Up</a></td><th width="60%" align="center">Chapter 11. インデックス</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-opclass.html" title="11.9. 演算子クラスと演算子族">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-PARTIAL"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.8. 部分インデックス</h2></div></div></div><a id="id-1.5.10.11.2" class="indexterm"></a><p><em class="firstterm">部分インデックス</em>とは、テーブルの部分集合に構築されるインデックスです。
部分集合は、（部分インデックスの<em class="firstterm">述語</em>と呼ばれる）条件式で定義されます。
部分インデックスには、その述語を満たすテーブル行のみに対するエントリが含まれます。
部分インデックスは特別な機能です。
しかし、これらが有用となる状況が複数あります。
  </p><p>部分インデックスを利用する主な目的は、頻出値に対してインデックスを作成しないようにすることです。
（テーブル全体の行のうち、数パーセント以上を占める）頻出値を検索する問い合わせでは、いかなる場合でもインデックスを使用しないため、インデックスにそれらの行を持ち続けることは全く意味がありません。
これによりインデックスのサイズが小さくなりますので、インデックスを使用する問い合わせが速くなります。
また、インデックスを更新する必要のないケースも生じるため、テーブルを更新する作業の多くも速くなります。
<a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX1" title="Example 11.1. 頻出値を除外するための部分インデックスの作成">Example 11.1</a>にこの概念に基づいた用例を示します。
  </p><div class="example" id="INDEXES-PARTIAL-EX1"><p class="title"><strong>Example 11.1. 頻出値を除外するための部分インデックスの作成</strong></p><div class="example-contents"><p>ウェブサーバのアクセスログをデータベースに格納しているとします。
多くのアクセスは、社内のIPアドレスの範囲内から発信されています。
しかし、範囲外のアドレス（例えば、社員がダイアルアップ接続している場所）からの発信もあります。
主に範囲外からのアクセスをIPアドレスで検索する場合、社内のサブネットに該当するIPアドレスの範囲にインデックスを作成する必要はないでしょう。
   </p><p>以下のようなテーブルがあると想定します。
</p><pre class="programlisting">CREATE TABLE access_log (
    url varchar,
    client_ip inet,
    ...
);</pre><p>
   </p><p>この例に適する部分インデックスを作成するには、以下のようなコマンドを使用します。
</p><pre class="programlisting">CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)
WHERE NOT (client_ip &gt; inet '192.168.100.0' AND
           client_ip &lt; inet '192.168.100.255');</pre><p>
   </p><p>このインデックスを使用できる問い合わせの典型的な例は、以下のようなものです。
</p><pre class="programlisting">SELECT *
FROM access_log
WHERE url = '/index.html' AND client_ip = inet '212.78.10.32';</pre><p>
また、以下のような問い合わせの場合、このインデックスは使用できません。
</p><pre class="programlisting">SELECT *
FROM access_log
WHERE client_ip = inet '192.168.100.23';</pre><p>
   </p><p>このような部分インデックスを使用するには、あらかじめ頻出値が何であるかを知っている必要があることに注意してください。
値の分布が変わらない場合に、このような部分インデックスが最善です。
データの分布が新しくなった場合はインデックスの再作成によって調整できますが、これはメンテナンス作業を増やしてしまいます。
   </p></div></div><br class="example-break" /><p>部分インデックスを使用する有効な他の方法としては、一般的な問い合わせに必要のない値をインデックスから取り除くことです。
<a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Example 11.2. 必要のない値を除外するための部分インデックスの作成">Example 11.2</a>を参照してください。
この方法の利点は上で示したものと同じです。
ただ、この方法を使用すると、インデックススキャンが適している場合でも、<span class="quote">“<span class="quote">必要のない</span>”</span>値へのインデックスを介したアクセスが防止されてしまいます。
以上のことから明白なように、このようなケースで部分インデックスを作成する際は、細心の注意を払い、十分な検証を行う必要があります。
  </p><div class="example" id="INDEXES-PARTIAL-EX2"><p class="title"><strong>Example 11.2. 必要のない値を除外するための部分インデックスの作成</strong></p><div class="example-contents"><p>請求済み注文書および未請求注文書からなる、１つのテーブルがあるとします。
そして、未請求注文書の方がテーブル全体に対する割合が小さく、かつその部分へのアクセス数が最も多かったとします。
このような場合、未請求の行のみにインデックスを作成することにより、性能を向上させることができます。
インデックスの作成には、以下のようなコマンドを使用します。
</p><pre class="programlisting">CREATE INDEX orders_unbilled_index ON orders (order_nr)
    WHERE billed is not true;</pre><p>
   </p><p>このインデックスを使用する問い合わせの例としては、次のものが考えられます。
</p><pre class="programlisting">SELECT * FROM orders WHERE billed is not true AND order_nr &lt; 10000;</pre><p>
しかし、このインデックスは、<code class="structfield">order_nr</code>をまったく使用しない問い合わせでも使用することができます。
以下は、その例です。
</p><pre class="programlisting">SELECT * FROM orders WHERE billed is not true AND amount &gt; 5000.00;</pre><p>
この問い合わせでは、システムがインデックス全体を検索する必要があるため、<code class="structfield">amount</code>列に部分インデックスを作成した場合ほど効率は良くありません。
しかし、未請求注文書データが比較的少ない場合は、この部分インデックスを未請求注文書を検出するためだけに使用した方が効率が良い可能性があります。
   </p><p>以下の問い合わせでは、このインデックスを使用できないことに注意してください。
</p><pre class="programlisting">SELECT * FROM orders WHERE order_nr = 3501;</pre><p>
注文番号3501は請求済みかもしれませんし、未請求かもしれないからです。
   </p></div></div><br class="example-break" /><p><a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX2" title="Example 11.2. 必要のない値を除外するための部分インデックスの作成">Example 11.2</a>でもわかるように、インデックスが付けられた列名と、述語で使用されている列名は、一致している必要はありません。
<span class="productname">PostgreSQL</span>では、インデックス付けされるテーブルの列だけが含まれているのなら、任意の述語で部分インデックスを使用できます。
しかし、この述語は、インデックスを使用させたい問い合わせの条件と一致する必要があることに留意してください。
正確に言うと、部分インデックスを問い合わせで使用できるのは、インデックスの述語が問い合わせの<code class="literal">WHERE</code>条件に数学的に当てはまるとシステムが判断できる場合のみです。
<span class="productname">PostgreSQL</span>には、異なった形式で記述された述語が数学的に同等のものであると判断できるような、洗練された定理証明機能はありません。
（そのような汎用的な定理証明機能の作成は、非常に困難であるだけではなく、おそらく実際の利用にはあまりにも実行速度が遅過ぎるでしょう。）
システムでは、例えば<span class="quote">“<span class="quote">x &lt; 1</span>”</span>は<span class="quote">“<span class="quote">x &lt; 2</span>”</span>を意味するというような、単純な比較演算子の意味は認識可能です。
しかし、それ以外の場合は、述語条件は問い合わせの<code class="literal">WHERE</code>条件と完全に一致している必要があります。
一致していない場合は、インデックスは使用可能と認識されません。
一致するかどうかは、実行時ではなく、問い合わせ計画作成時に判定されます。
したがって、パラメータ付きの問い合わせでは部分インデックスは動作しません。
たとえば、<span class="quote">“<span class="quote">x &lt; ?</span>”</span>と指定されたパラメータを持つ、プリペアド問い合わせでは、どのようなパラメータ値であっても<span class="quote">“<span class="quote">x &lt; 2</span>”</span>を表しません。
  </p><p>部分インデックスの考えられる３つ目の用法では、問い合わせでインデックスをまったく使用しません。
この考え方は、テーブルの部分集合に一意インデックスを作成するというものです。
<a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="Example 11.3. 一意な部分インデックスの作成">Example 11.3</a>を参照してください。
これにより、インデックスの述語を満たさない行を制約することなく、その述語を満たす行での一意性を強制します。
  </p><div class="example" id="INDEXES-PARTIAL-EX3"><p class="title"><strong>Example 11.3. 一意な部分インデックスの作成</strong></p><div class="example-contents"><p>テストの結果が格納されているテーブルがあるとします。
与えられた件名（subject）および対象（target）の組み合わせに対して、<span class="quote">“<span class="quote">成功</span>”</span>のエントリが確実に1つしかないようにします。
<span class="quote">“<span class="quote">失敗</span>”</span>のエントリは、複数あっても構いません。
以下に、これを実行する一例を示します。
</p><pre class="programlisting">CREATE TABLE tests (
    subject text,
    target text,
    success boolean,
    ...
);

CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</pre><p>
これは、成功するテストが少なく、失敗するテストが多い場合に特に有効な手法です。
   </p></div></div><br class="example-break" /><p>最後に、部分インデックスは、システムの問い合わせ計画の選択を変更するためにも使用できます。
特殊なデータ分布を持つデータ集合では、システムが実際には使用すべきでないインデックスを使用してしまうことがあります。
このような場合、特定の問い合わせでは使用することができないインデックスを設定することができます。
通常、<span class="productname">PostgreSQL</span>はインデックスの使用について適切な選択を行います（例えば、頻出値の検索にはインデックスを使用しませんので、前述の例はインデックスのサイズを実際に小さくするだけのもので、インデックスの使用を制限するためには必要はありません）。
まったく不適切な計画を選択するようであれば、バグとして報告してください。
  </p><p>部分インデックスを作成するには、少なくとも問い合わせプランナと同等の知識を持っていること、特に、インデックスが有益となる状況を理解している必要があることに留意してください。
このような知識を得るためには、<span class="productname">PostgreSQL</span>でインデックスがどのように機能するかを理解し、経験を積むことが必要です。
ほとんどの場合、通常のインデックスと比べて、部分インデックスを使用する利点は微細です。
  </p><p>部分インデックスの詳細については、<a class="xref" href="biblio.html#STON89B">[ston89b]</a>、<a class="xref" href="biblio.html#OLSON93" title="Partial indexing in POSTGRES: research project">[olson93]</a>、および<a class="xref" href="biblio.html#SESHADRI95">[seshadri95]</a>を参照してください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-expressional.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-opclass.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">11.7. 式に対するインデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 11.9. 演算子クラスと演算子族</td></tr></table></div></body></html>