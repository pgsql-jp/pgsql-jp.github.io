<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.6. 関数の変動性分類</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xfunc-overload.html" title="37.5. 関数のオーバーロード" /><link rel="next" href="xfunc-pl.html" title="37.7. 手続き型言語関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.6. 関数の変動性分類</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xfunc-overload.html" title="37.5. 関数のオーバーロード">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc-pl.html" title="37.7. 手続き型言語関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="XFUNC-VOLATILITY"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.6. 関数の変動性分類</h2></div></div></div><a id="id-1.8.3.9.2" class="indexterm"></a><a id="id-1.8.3.9.3" class="indexterm"></a><a id="id-1.8.3.9.4" class="indexterm"></a><a id="id-1.8.3.9.5" class="indexterm"></a><p>すべての関数は<em class="firstterm">変動性</em>区分を持ちます。
取り得る区分は、<code class="literal">VOLATILE</code>、<code class="literal">STABLE</code>、もしくは<code class="literal">IMMUTABLE</code>です。
<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>コマンドで分類の指定がなければデフォルトで<code class="literal">VOLATILE</code>になります。
変動性に関する分類は、その関数の動作に関するオプティマイザへの約束事です。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">VOLATILE</code>関数は、データベースの変更を含む、すべてを行うことができます。
同一引数で続けて呼び出したとしても異なる結果を返すことができます。
オプティマイザはこうした関数の振舞いに対する前提を持ちません。
VOLATILE関数を使用した問い合わせは、その行の値を必要とするすべての行においてその関数を再評価します。
     </p></li><li class="listitem"><p><code class="literal">STABLE</code>関数はデータベースを変更することができません。
また、単一の文内ですべての行に対して同一の引数を渡した場合に同一の結果を返すことが保証されています。
この区分により、オプティマイザは複数の関数の呼び出しを１つの呼び出しに最適化することができます。
特に、インデックススキャン条件内でこうした関数を含んだ式を使用することは安全です。
（インデックススキャンは行ごとに一度ではなく、一度だけ比較値の評価を行いますので、インデックススキャン条件内で<code class="literal">VOLATILE</code>関数を使用することは意味がありません。）
     </p></li><li class="listitem"><p><code class="literal">IMMUTABLE</code>関数はデータベースを変更することができません。
また、同一引数に対する呼び出しは常に同一の結果を返すことが保証されています。
問い合わせが定数の引数でこうした関数を呼び出した場合、オプティマイザはこの関数を事前に評価することができます。
例えば、<code class="literal">SELECT ... WHERE x = 2 + 2</code>といった問い合わせは、<code class="literal">SELECT ... WHERE x = 4</code>のように単純化することができます。
これは、整数加算演算子の基になる関数が<code class="literal">IMMUTABLE</code>として宣言されているためです。
     </p></li></ul></div><p>
   </p><p>最適化の結果を最善にするためには、関数に対して有効かつ最も厳密な変動性区分を付けなければなりません。
   </p><p>副作用を持つ関数はすべて<code class="literal">VOLATILE</code>と付けなければなりません。
こうした関数は最適化することができないためです。
関数が副作用を持たなかったとしても、単一問い合わせ内で値が変動する場合は<code class="literal">VOLATILE</code>と付けなければなりません。
例えば、<code class="literal">random()</code>、<code class="literal">currval()</code>、<code class="literal">timeofday()</code>などです。
   </p><p>その他の重要な例は、<code class="function">current_timestamp</code>系列の関数は、それらの値がトランザクション内で変わらないことから、<code class="literal">STABLE</code>と見なされます。
   </p><p>計画作成を行い、すぐに実行されるような単一の対話式問い合わせを考えた場合、相対的に<code class="literal">STABLE</code>区分と<code class="literal">IMMUTABLE</code>区分との違いはあまりありません。
このような場合、関数が計画作成中に一度実行されるか、問い合わせ実行中に一度実行されるかがあまり問題になりません。
しかし、計画が保存され、後で再利用される場合は大きな違いが現れます。
本来ならば関数が計画作成段階で早めに定数を保持することができない場合に<code class="literal">IMMUTABLE</code>を付けると、その後にこの計画を使用する時に古くて意味のない値が再利用されてしまうことになります。
これは、プリペアド文や計画をキャッシュする関数言語（<span class="application">PL/pgSQL</span>など）を使用する場合は危険です。
   </p><p>SQLもしくは標準手続き言語で作成された関数では、変動性分類で決定される２番目に重要な性質があります。
すなわち、その関数を呼び出すSQLコマンドによりなされてきたすべてのデータ変更の可視性です。
<code class="literal">VOLATILE</code>関数はそのような変更を捕らえますが、<code class="literal">STABLE</code>または<code class="literal">IMMUTABLE</code>関数はそうしません。
この動作はMVCC（<a class="xref" href="mvcc.html" title="Chapter 13. 同時実行制御">Chapter 13</a>を参照）のスナップショット処理の動作を使用して実装されています。
<code class="literal">STABLE</code>と<code class="literal">IMMUTABLE</code>関数は、呼び出す問い合わせの開始時点で成立したスナップショットを使用しますが、<code class="literal">VOLATILE</code>関数はそれぞれの問い合わせの実行開始時点の作りたてのスナップショットを取得します。
   </p><div class="note"><h3 class="title">Note</h3><p>しかし、C言語で作成された関数は、どのようにでもスナップショットを管理することができますが、通常C関数でもこのように動作させることは良い考えです。
    </p></div><p>このスナップショット処理の動作のため、同時実行の問い合わせによって別途変更されている可能性があるテーブルから選択していたとしても、<code class="command">SELECT</code>コマンドのみを含む関数は、安全に<code class="literal">STABLE</code>とすることができます。
<span class="productname">PostgreSQL</span>は、呼び出し元の問い合わせに対して確立されたスナップショットを使用して<code class="literal">STABLE</code>関数のすべてのコマンドを実行します。
したがってその問い合わせの間、データベースに対して固定された視点で値を参照することになります。
   </p><p><code class="literal">IMMUTABLE</code>関数内の<code class="command">SELECT</code>コマンドも同様のスナップショット処理の動作を使用します。
ただし、一般的に、<code class="literal">IMMUTABLE</code>関数内でデータベースのテーブルを検索（SELECT）することは勧められません。
テーブルの内容が変わってしまった場合にその不変性が壊れてしまうためです。
しかし、<span class="productname">PostgreSQL</span>では強制的に検索（SELECT）できないようにはしていません。
   </p><p>よくあるエラーは、設定パラメータに依存する結果となる関数に<code class="literal">IMMUTABLE</code>と付けることです。
例えば、タイムスタンプを操作する関数は、おそらく<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>の設定に依存した結果になります。
こうした関数は、安全のため代わりに<code class="literal">STABLE</code>と付けてください。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>はデータの変更を防ぐために<code class="literal">STABLE</code>関数と<code class="literal">IMMUTABLE</code>関数が<code class="command">SELECT</code>以外のSQLコマンドを含まないことを要求します。
（こうした関数はまだデータベースを変更する<code class="literal">VOLATILE</code>関数を呼び出すことができますので、これは防弾条件として完全ではありません。
これを行うと、<code class="literal">STABLE</code>もしくは<code class="literal">IMMUTABLE</code>関数は、そのスナップショットからそれらが隠されていることから、呼び出した関数によるデータベースの変更に気がつきません。）
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xfunc-overload.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc-pl.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.5. 関数のオーバーロード </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.7. 手続き型言語関数</td></tr></table></div></body></html>