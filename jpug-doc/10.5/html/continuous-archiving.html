<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="backup-file.html" title="25.2. ファイルシステムレベルのバックアップ" /><link rel="next" href="high-availability.html" title="Chapter 26. 高可用性、負荷分散およびレプリケーション" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="backup-file.html" title="25.2. ファイルシステムレベルのバックアップ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="backup.html" title="Chapter 25. バックアップとリストア">Up</a></td><th width="60%" align="center">Chapter 25. バックアップとリストア</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="high-availability.html" title="Chapter 26. 高可用性、負荷分散およびレプリケーション">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="CONTINUOUS-ARCHIVING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-ARCHIVING-WAL">25.3.1. WALアーカイブの設定</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-BASE-BACKUP">25.3.2. ベースバックアップの作成</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP">25.3.3. 低レベルAPIを使用したベースバックアップの作成</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-PITR-RECOVERY">25.3.4. 継続的アーカイブによるバックアップを使用した復旧</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-TIMELINES">25.3.5. タイムライン</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#BACKUP-TIPS">25.3.6. ヒントと例</a></span></dt><dt><span class="sect2"><a href="continuous-archiving.html#CONTINUOUS-ARCHIVING-CAVEATS">25.3.7. 警告</a></span></dt></dl></div><a id="id-1.6.12.7.2" class="indexterm"></a><a id="id-1.6.12.7.3" class="indexterm"></a><a id="id-1.6.12.7.4" class="indexterm"></a><p><span class="productname">PostgreSQL</span>は常に、クラスタのデータディレクトリ以下の<code class="filename">pg_wal/</code>ディレクトリ内で<em class="firstterm">先行書き込みログ</em>（WAL）を管理しています。
このログはデータベースのデータファイルに行われた全ての変更を記録します。
このログは主にクラッシュ時の安全性を目的としています。
システムがクラッシュしたとしても、最後のチェックポイント以降に作成されたログ項目を<span class="quote">“<span class="quote">やり直し</span>”</span>することで、データベースを整合性を維持した状態にリストアすることができます。
しかし、この存在するログファイルを使用して、データベースのバックアップ用の第3の戦略が可能になりました。
ファイルシステムレベルのバックアップとWALファイルのバックアップを組み合わせるという戦略です。
復旧が必要ならば、ファイルシステムバックアップをリストアし、その後にバックアップされたWALファイルを再生することで、システムを最新の状態にできます。
管理者にとって、この方法はこれまで説明した方法よりかなり複雑になりますが、以下のような大きな利点が複数あります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>開始時点のファイルシステムバックアップは完全な整合状態である必要はありません。
そのバックアップ内の内部的な不整合はログのやり直しによって修正されます
（これは、クラッシュからの復旧時に行われることと大きな違いはありません）。
ですので、ファイルシステムのスナップショット機能を必要としません。
単に<span class="application">tar</span>などのアーカイブツールが必要です。
    </p></li><li class="listitem"><p>再生の際にWALファイルの並びを数に制限なく連ねて組み合わせられますので、単にWALファイルのアーカイブを続けることで連続したバックアップを達成できます。
これは、頻繁に完全なバックアップを行うことが困難な、大規模なデータベースでは特に価値があります。
    </p></li><li class="listitem"><p>WAL項目の再生を最後まで行わなければならないということはありません。
やり直しを任意の時点までで停止することができ、それにより、その時点までのデータベースの整合性を持ったスナップショットを得ることができます。
このような技術が<em class="firstterm">ポイントインタイムリカバリ</em>を補助するものであり、元となるベースバックアップの取得時点以降の任意の時点の状態にデータベースをリストアすることが可能になります。
    </p></li><li class="listitem"><p>連続的に一連のWALファイルを、同一のベースバックアップをロードしている別のマシンに配送することで、<em class="firstterm">ウォームスタンバイ</em>システムを保有することができます。
つまり、任意の時点でその2番目のマシンを、ほぼ現時点のデータベースの複製を持った状態で有効にすることができます。
    </p></li></ul></div><p>
  </p><div class="note"><h3 class="title">Note</h3><p><span class="application">pg_dump</span>と<span class="application">pg_dumpall</span>はファイルシステムレベルのバックアップを生成しませんので、継続的アーカイブ方式の一部として使うことはできません。
そのダンプは<span class="emphasis"><em>論理的</em></span>なものであり、WALのやり直しで使うのに十分な情報を含んでいません。
   </p></div><p>通常のファイルシステムバックアップ技術の場合と同様、この方法は、一部ではなく、データベースクラスタ全体のリストア処理のみをサポートできます。
また、アーカイブ用に大量の格納領域を必要とします。
ベースバックアップはかさばる場合があり、また、高負荷なシステムではアーカイブしなければならないWALの流量をメガバイト単位で生成します。
しかし、これは、高信頼性が必要な、多くの状況でむしろ好まれるバックアップ手法です。
  </p><p>継続的アーカイブ（多くのデータベースベンダで<span class="quote">“<span class="quote">オンラインバックアップ</span>”</span>とも呼ばれます）を使用して復旧を成功させるためには、少なくともバックアップの開始時点まで遡る、連続した一連のアーカイブ済みWALファイルが必要です。
ですので、運用するためには、最初のベースバックアップを取得する<span class="emphasis"><em>前</em></span>にWALファイルをアーカイブする手順を設定し試験しなければなりません。
したがって、まずWALファイルのアーカイブ機構について説明します。
  </p><div class="sect2" id="BACKUP-ARCHIVING-WAL"><div class="titlepage"><div><div><h3 class="title">25.3.1. WALアーカイブの設定</h3></div></div></div><p>抽象的な意味では、実行中の<span class="productname">PostgreSQL</span>システムは無限に長い一連のWALレコードを生成します。
システムは物理的にこの並びを、通常1つ16メガバイト（このセグメントサイズは<span class="productname">PostgreSQL</span>の構築時に変更可能です）の、WAL<em class="firstterm">セグメントファイル</em>に分割します。
このセグメントファイルには、概念的なWALの並び内の位置を反映した、数字の名前が付与されます。
WALアーカイブを行わない場合、システムは通常数個のセグメントファイルを生成し、不要となったセグメントファイルの名前をより大きなセグメント番号に変更することでそれを<span class="quote">“<span class="quote">リサイクル</span>”</span>します。
前々回のチェックポイントより前の内容を持つセグメントファイルはもはや重要でなく、リサイクルできると見なされます。
   </p><p>WALデータをアーカイブする場合、完成したセグメントファイルのそれぞれの内容を取り出し、再利用のために回収される前にそのデータをどこかに保存することが必要です。
アプリケーションと利用できるハードウェアに依存しますが、数多くの<span class="quote">“<span class="quote">データをどこかに保存する</span>”</span>方法があります。
例えば、NFSでマウントした他のマシンのディレクトリにセグメントファイルをコピーすること、あるいは、テープ装置に書き出すこと（元々のファイル名を識別する手段があることを確認してください）、それらを一度にまとめてCDに焼くこと、そのほか全く異なったなんらかの方法などです。
柔軟性をデータベース管理者に提供するために、<span class="productname">PostgreSQL</span>は、どのようにアーカイブがなされたかについて一切想定しないようになっています。
その代わりに<span class="productname">PostgreSQL</span>は、管理者に完全なセグメントファイルをどこか必要な場所にコピーするシェルコマンドを指定させます。
このコマンドは単純な<code class="literal">cp</code>でも構いませんし、また、複雑なシェルスクリプトを呼び出しても構いません。
全て管理者に任されています。
   </p><p>WALアーカイブを有効にするには<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>設定パラメータを<code class="literal">replica</code>（またはreplicaより高いパラメータ）に、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>を<code class="literal">on</code>に設定し、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-COMMAND">archive_command</a>設定パラメータで使用するシェルコマンドを指定します。
実行するには、これらの設定を <code class="filename">postgresql.conf</code> ファイルに常に置きます。
<code class="varname">archive_command</code> では、<code class="literal">%p</code>はアーカイブするファイルのパス名に置換され、<code class="literal">%f</code>はファイル名部分のみに置換されます。
（パス名は、サーバの現在の作業用ディレクトリ、つまり、クラスタのデータディレクトリから見て相対的なものです。）
コマンド内に<code class="literal">%</code>文字自体を埋め込む必要があれば<code class="literal">%%</code>を使ってください。
最も簡単でよく使用されるコマンドは以下のようなものになります。
</p><pre class="programlisting">archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</pre><p>
これは、アーカイブ可能なWALセグメントを<code class="literal">/mnt/server/archivedir</code>ディレクトリにコピーします
（これは一例です。
推奨するものではなく、また、全てのプラットフォームで動作しない可能性があります）。
<code class="literal">%p</code>および<code class="literal">%f</code>パラメータが置き換えられたあと、実行された実コマンドは以下のようになります。
</p><pre class="programlisting">test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_wal/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</pre><p>
類似したコマンドがアーカイブされるそれぞれの新規ファイルに生成されます。
   </p><p>このアーカイブ用コマンドは<span class="productname">PostgreSQL</span>サーバを稼動させるユーザと同じ所有権で実行されます。
アーカイブされる一連のWALファイルには、実質、データベース内の全てが含まれていますので、アーカイブしたデータをのぞき見から確実に保護しなければならないでしょう。
例えば、グループや全員に読み込み権限を付与していないディレクトリにデータをアーカイブしてください。
   </p><p>アーカイブ用コマンドが成功した場合のみにゼロという終了ステータスを返すことが重要です。
<span class="productname">PostgreSQL</span>は、ゼロという結果に基づいて、そのファイルのアーカイブが成功したことを想定し、そのファイルを削除したり回収するかもしれません。
しかし、非ゼロのステータスは、<span class="productname">PostgreSQL</span>に対してファイルがアーカイブされなかったことを通知し、成功するまで定期的に再試行させます。
   </p><p>通常アーカイブ用コマンドは既存のアーカイブ済みファイルの上書きを行わないように設計されなければなりません。
これは、管理者のミス（例えば2つの異なるサーバの出力を同一のアーカイブ用ディレクトリに送信してしまうなど）といった場合からアーカイブ状況の整合性を保護するための安全策として重要です。
   </p><p>実際に既存のファイルを上書きしないこと、<span class="emphasis"><em>かつ、その場合に非ゼロのステータスを返すこと</em></span>を確認するために使用するアーカイブ用コマンドを試験することを勧めます。
上のUnix用のコマンド例では、別途<code class="command">test</code>という段階を含めることでこれを確認しています。
いくつかのUnixプラットフォームでは<code class="command">cp</code>コマンドには<code class="option">-i</code> 引数を使うことで煩雑な出力を少なくし使うことができますが、正しい終了コードが返ることを確認せずに使用するべきではありません。
(具体的にはGNUの<code class="command">cp</code>コマンドは<code class="option">-i</code> オプションを使い、ターゲットファイルがすでに存在している場合、ゼロのステータスを返します。これは<span class="emphasis"><em>期待していない</em></span>動作です。）
   </p><p>アーカイブ設定を設計する時には、操作者の介入が必要であったり、アーカイブ場所の容量不足の理由でアーカイブ用コマンドが繰り返し失敗した時にどうなるかを考慮してください。
例えば、これはオートチェンジャ機能のないテープに書き出している場合に発生する可能性があります。
テープが一杯になった場合、テープを交換するまでアーカイブを行うことができなくなります。
こうした状況を相応の早さで解消できるよう、適切に操作者に対しエラーや要求を確実に連絡できるようにしなければなりません。
この状況が解消するまで、WALセグメントファイルは<code class="filename">pg_wal/</code>ディレクトリ内に格納され続けます。
（<code class="filename">pg_wal/</code>を含むファイルシステムがいっぱいになると、<span class="productname">PostgreSQL</span>はパニック停止します。コミットされたトランザクションは失われませんが、データベースはいくらかの容量を開放するまでオフラインのままです。）
   </p><p>サーバのWALデータの生成に要する平均速度に追いついている限り、アーカイブ用コマンドの処理速度は重要ではありません。
アーカイブプロセスが多少遅れたとしても通常の操作は続けられます。
アーカイブ処理がかなり遅くれると、災害時に損失するデータの量が増加することになります。
また、これは<code class="filename">pg_wal/</code>ディレクトリ内に多くのアーカイブ処理待ちのセグメントファイルが格納され、ディスク容量が不足する状況になる可能性があることを意味します。
アーカイブ処理が確実に意図通りに動作しているかを監視することを推奨します。
   </p><p>アーカイブ用コマンドを作成する時、アーカイブされるファイル名は最長64文字までで、ASCII文字と数字とドットのどんな組合せを使用しても構いません。
元の相対パス（<code class="literal">%p</code>）を保存する必要はありませんが、ファイル名（<code class="literal">%f</code>）を保存する必要はあります。
   </p><p>WALアーカイブによって<span class="productname">PostgreSQL</span>データベースでなされた変更は全てリストアすることができますが、設定ファイルはSQL操作ではなく手作業で変更されますので、設定ファイル（<code class="filename">postgresql.conf</code>、<code class="filename">pg_hba.conf</code>、および<code class="filename">pg_ident.conf</code>）になされた変更までリストアしないことに注意してください。
通常のファイルシステムバックアップ手続きでバックアップされる場所に設定ファイルを保持したい場合があります。
設定ファイルの設置場所を変更するには<a class="xref" href="runtime-config-file-locations.html" title="19.2. ファイルの場所">Section 19.2</a>を参照してください。
   </p><p>アーカイブコマンドは完全なWALセグメントに対してのみ呼び出されます。
このため、サーバが少ししかWAL流量がない（処理を行わないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
古い未アーカイブのデータをどうするかについて制限を付けるために、<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT">archive_timeout</a>を設定して、強制的にサーバを新しいWALセグメントにある程度の間隔で切り替えるようにすることができます。
強制切り替えにより早期にアーカイブされたアーカイブ済みファイルは完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<code class="varname">archive_timeout</code>を使用することはお勧めしません。
格納領域を膨張させてしまいます。
通常ならば分単位の<code class="varname">archive_timeout</code>設定が合理的です。
   </p><p>終わったばかりのトランザクションをできるだけ早くアーカイブさせたい場合、<code class="function">pg_switch_xlog</code>を使用して手作業でセグメント切り替えを強制することができます。
この他のWAL管理に関連した関数を<a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="Table 9.79. バックアップ制御関数">Table 9.79</a>に列挙します。
   </p><p><code class="varname">wal_level</code>が<code class="literal">minimal</code>の場合、<a class="xref" href="populate.html#POPULATE-PITR" title="14.4.7. WALアーカイブ処理とストリーミングレプリケーションの無効化">Section 14.4.7</a>に書かれているように、いくつかのSQLコマンドはWALロギングを回避するため最適化されます。
アーカイビングもしくはストリーミングレプリケーションがこれら構文の１つを実行中に作動させられると、アーカイブ復旧のための十分な情報をWALが含まなくなります。（クラッシュ復旧は影響を受けません。）
このことにより、<code class="varname">wal_level</code>はサーバの起動時のみ変更可能です。
とは言っても、<code class="varname">archive_command</code>は構成ファイルを再読み込みすることで変更できます。
一時的にアーカイビングを停止したい場合、１つの方法は<code class="varname">archive_command</code>を空文字列（<code class="literal">''</code>）に設定することです。
このようにすると、動作する<code class="varname">archive_command</code>が再構築されるまでWALファイルは<code class="filename">pg_wal/</code>に蓄積します。
   </p></div><div class="sect2" id="BACKUP-BASE-BACKUP"><div class="titlepage"><div><div><h3 class="title">25.3.2. ベースバックアップの作成</h3></div></div></div><p>ベースバックアップを取得する最も簡単な方法は<a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a> を実行する方法です。
通常のファイルやTAR形式のファイルとしてベースバックアップを取得することができます。
もし、<a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a>より柔軟性が求められる場合は、低レベルなAPIを使ってバックアップを作成することもできます(詳細は <a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP" title="25.3.3. 低レベルAPIを使用したベースバックアップの作成">Section 25.3.3</a>を参照)。
   </p><p>ベースバックアップを取得するための時間を考慮する必要はありません。
しかし、普段、<code class="varname">full_page_writes</code>を無効にして運用している場合、バックアップ取得中は強制的に<code class="varname">full_page_writes</code>が有効になるため、パフォーマンスが落ちていると感じる可能性があります。
   </p><p>バックアップを使用するためには、ファイルシステムのバックアップ取得中、および、その後に生成されるWALセグメントファイル全てが保存されている必要があります。
この目的のために、ベースバックアップの過程で即座にWALアーカイブ領域に<em class="firstterm">バックアップ履歴ファイル</em>が作成されます。
このファイルにはファイルシステムのバックアップに最初に必要とされるWALセグメントの名前が付けられます。
例えば、最初のWALファイルが <code class="literal">0000000100001234000055CD</code>である場合、バックアップ履歴ファイルは<code class="literal">0000000100001234000055CD.007C9330.backup</code>というように名付けられます。
(ファイル名の2番目のパートはWALファイルの厳密な位置が記載されます。通常は無視することができます。)
一旦、安全にファイルシステムのバックアップとそのバックアップ中に使用されたWALセグメントファイル(バックアップ履歴ファイルから特定できます)を取得すると、それより数値の小さな全てのWALアーカイブセグメントはファイルシステムのリカバリには必要が無く、削除することができます。
しかし、データを確実に復旧させるためには数世代のバックアップセットを保持することを考慮すべきです。

   </p><p>バックアップ履歴ファイルは、ほんの小さなテキストファイルです。
これには<a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a>で与えたラベル文字列の他、バックアップの開始、終了時間およびバックアップのWALセグメントが含まれます。
このラベルをバックアップを構成するために使うことで、アーカイブ履歴ファイルはどのバックアップをリストアするべきか間違いなく判断することができます。
   </p><p>最後のベースバックアップ以降のWALアーカイブを保持し続ける必要があるため、通常、ベースバックアップを取得すべき期間は、WALアーカイブを保持するためにどのくらいのストレージを拡張できるかによって決定されます。
また、リカバリが必要になった場合に、どのくらいの時間をリカバリに使うと覚悟するのかも考慮すべきです。—
システムは全てのWALセグメントを適用する必要があるため、もし、最後のベースバックアップを取得してから長い時間が経過している場合、適用に時間を要する可能性があります。
   </p></div><div class="sect2" id="BACKUP-LOWLEVEL-BASE-BACKUP"><div class="titlepage"><div><div><h3 class="title">25.3.3. 低レベルAPIを使用したベースバックアップの作成</h3></div></div></div><p>低レベルのAPIを使ったベースバックアップを取得するには<a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a> を使う方法に加えて数ステップが必要ですが、比較的簡単です。
これらのステップは順番に実行することが重要で、次のステップに進む前にこれらのステップが成功していることを確認する必要があります。
   </p><p>低レベルのベースバックアップは非排他的または排他的な手法で作成することができます。
非排他的な手法が推奨され、排他的な手法は推奨されず、将来的に削除されます。
   </p><div class="sect3" id="BACKUP-LOWLEVEL-BASE-BACKUP-NONEXCLUSIVE"><div class="titlepage"><div><div><h4 class="title">25.3.3.1. 非排他的な低レベルバックアップの作成</h4></div></div></div><p>非排他的な低レベルバックアップは、実行中の（同じバックアップAPIを使用して起動したものと、<a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a>を使用して起動したものいずれも）他の同時バックアップを許可するものです。
    </p><p>  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>WALアーカイブが有効であり、正常に動作することを確認してください。
    </p></li><li class="listitem"><p>pg_start_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてサーバ（どのデータベースでも構いません）に接続し、以下のコマンドを実行してください。
</p><pre class="programlisting">SELECT pg_start_backup('label', false, false);</pre><p>
ここで<code class="literal">label</code>は、バックアップ操作を一意に識別するために使用する任意の文字列です。
<code class="function">pg_start_backup</code>を呼び出す接続は、バックアップの完了まで維持される必要があります。さもなくばバックアップは自動的に中止されます。
    </p><p>デフォルトで、<code class="function">pg_start_backup</code>は終了までに長い時間がかかる場合があります。
その理由はあるチェックポイントを実行し、そのチェックポイントに必要なI/Oはかなりの時間にわたって広がるためです。そして、デフォルトでは設定したチェックポイント間隔の半分です（設定パラメータについては<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a>を参照してください）。
通常これは、問い合わせ処理における影響を極小化するので望ましいことです。
すぐにバックアップを開始したい場合は、第2パラメータを<code class="literal">true</code>にすると、使えるだけのI/Oを使用して即座にチェックポイントを発行します。
    </p><p>第3パラメータの<code class="literal">false</code>は、<code class="function">pg_start_backup</code>が非排他ベースバックアップを開始すること指示します。
    </p></li><li class="listitem"><p>（<span class="application">pg_dump</span>や<span class="application">pg_dumpall</span>ではなく）<span class="application">tar</span>や<span class="application">cpio</span>などの使い慣れた任意のファイルシステムバックアップツールを使用して、バックアップを実行してください。
この作業時に、データベースの通常の操作を停止することは不要ですし、望ましい方法でもありません。
このバックアップの実行中に考慮すべき点は<a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA" title="25.3.3.3. データディレクトリのバックアップ">Section 25.3.3.3</a>を参照してください。
    </p></li><li class="listitem"><p>以前と同じ接続の中で、以下のコマンドを実行します。
</p><pre class="programlisting">SELECT * FROM pg_stop_backup(false, true);</pre><p>
これはバックアップモードを終了し、次のWALセグメントへの自動切換えを行います。
この切換えの理由は、バックアップ期間中に書き出された最後のWALファイルがアーカイブできるよう準備することです。
    </p><p><code class="function">pg_stop_backup</code>は3つの値を含んだ1行を返します。
2番目の値は、バックアップのルートディレクトリ内の<code class="filename">backup_label</code>という名称のファイルを作成の上、値を書き込む必要があります。
3番目の値は、空でない限りは<code class="filename">tablespace_map</code>という名称のファイルを作成の上、値を書き込む必要があります。
これらのファイルは、バックアップの動作にきわめて重要であり、返り値の内容から変更なしに書き込む必要があります。
    </p></li><li class="listitem"><p>バックアップ中に使用されたWALセグメントファイルがアーカイブされれば完了です。
<code class="function">pg_stop_backup</code>の返り値の1番目の値で識別されるファイルは、バックアップファイル一式を完結させるのに必要となる最終セグメントです。
<code class="varname">archive_mode</code>が有効で、かつ<code class="literal">wait_for_archive</code>パラメータが<code class="literal">true</code>であれば、<code class="function">pg_stop_backup</code> は最終セグメントがアーカイブされるまで戻りません。
スタンバイでは、<code class="function">pg_stop_backup</code>がアーカイブ完了を待つためには、<code class="varname">archive_mode</code>は<code class="literal">always</code>でなければなりません。
すでに<code class="varname">archive_command</code>を設定していますので、これらのファイルのアーカイブ操作は自動的に発生します。
ほとんどの場合、これは瞬時に行われます。
しかし、バックアップの完了を確認できるよう、アーカイブシステムを監視し、遅延が無いことの確認をお勧めします。
アーカイブコマンドの失敗によりアーカイブ処理が遅れてしまったとしても、アーカイブが成功し、そしてバックアップが完了するまで再試行を繰り返すようになっています。
<code class="function">pg_stop_backup</code>実行においての時間期限を設けたい場合、適切な<code class="varname">statement_timeout</code>の値を設定できますが、この設定値によって<code class="function">pg_stop_backup</code>が中断したときにバックアップが正当ではない可能性があるということを肝に銘じてください。
    </p><p>バックアップに必要なすべてのWALセグメントファイルのアーカイブが成功したことを、バックアップ作業の中で監視して確認するのであれば、<code class="literal">wait_for_archive</code>パラメータ(デフォルトでtrueです)をfalseに設定し、バックアップレコードがWALに書き込まれたら即座に<code class="function">pg_stop_backup</code>が戻るようにすることができます。
デフォルトでは、<code class="function">pg_stop_backup</code>はすべてのがアーカイブされるのを待つので、少し時間がかかることがあります。
このオプションは慎重に使わなければなりません。
WALのアーカイブを適切に監視していない場合、バックアップにはすべてのWALファイルが含まれず、不完全かもしれません。
そうなると、リストアできません。
    </p></li></ol></div><p>
    </p></div><div class="sect3" id="BACKUP-LOWLEVEL-BASE-BACKUP-EXCLUSIVE"><div class="titlepage"><div><div><h4 class="title">25.3.3.2. 排他的低レベルバックアップの作成</h4></div></div></div><p>排他的バックアップの手順は、ほぼ非排他的バックアップのものと同様ですが、いくつかのキーとなる手順に違いがあります。
バックアップの複数同時実行を許可せず、バックアップ中にクラッシュした場合、サーバ上にいくつかの問題が残ります。
PostgreSQL 9.6より前では唯一利用可能な低レベル手法でしたが、今日では可能であればすべてのユーザが自身のスクリプトを非排他的バックアップを使用するようにアップグレードすることが推奨されています。
    </p><p>  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>WALアーカイブが有効であり、正常に動作することを確認してください。
    </p></li><li class="listitem"><p>pg_start_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてサーバ（どのデータベースでも構いません）に接続し、以下のコマンドを実行してください。
</p><pre class="programlisting">SELECT pg_start_backup('label');</pre><p>
ここで<code class="literal">label</code>は、バックアップ操作を一意に識別するために使用する任意の文字列です。
<code class="function">pg_start_backup</code>は、開始時刻やラベル文字列などのバックアップ情報を持つ<code class="filename">backup_label</code>という名前の<em class="firstterm">バックアップラベル</em>ファイルを、クラスタディレクトリ内に作成します。
この関数は<code class="filename">tablespace_map</code>という名前の<em class="firstterm">テーブル空間マップ</em>ファイルもクラスタディレクトリ内に作ります。
テーブル空間マップファイルには、もしそのようなリンクが1つ以上存在すれば<code class="filename">pg_tblspc/</code>内のテーブル空間シンボリックリンクに関する情報が入っています。
どちらのファイルもバックアップの完全性保持のために重要な意味を持ちますので、バックアップから必ずリストアする必要があるでしょう。
    </p><p>デフォルトで、<code class="function">pg_start_backup</code>は終了までに長い時間がかかる場合があります。
その理由はあるチェックポイントを実行し、そして、デフォルトでは設定したチェックポイント間隔の半分である、そのチェックポイントに必要なI/Oがかなりの時間にわたって広がるためです（設定パラメータについては<a class="xref" href="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET">checkpoint_completion_target</a>を参照してください）。
通常これは、問い合わせ処理における影響を極小化するので望ましいことです。
バックアップをなるべく早く行いたいのであれば、以下を使用します。
</p><pre class="programlisting">SELECT pg_start_backup('label', true);</pre><p>
これはチェックポイントをできる限り早く行うよう強制します。
    </p></li><li class="listitem"><p>(<span class="application">pg_dump</span>や<span class="application">pg_dumpall</span>ではなく)<span class="application">tar</span>や<span class="application">cpio</span>などの使い慣れた任意のファイルシステムバックアップツールを使用して、バックアップを実行してください。
この作業時に、データベースの通常の操作を停止することは不要ですし、望ましい方法でもありません。
このバックアップの実行中に考慮すべき点は<a class="xref" href="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA" title="25.3.3.3. データディレクトリのバックアップ">Section 25.3.3.3</a>を参照してください。
    </p><p>      Note that if the server crashes during the backup it may not be
      possible to restart until the <code class="literal">backup_label</code> file has been
      manually deleted from the <code class="envar">PGDATA</code> directory.
    </p></li><li class="listitem"><p>再度、pg_stop_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてデータベースに接続し、以下のコマンドを実行してください。
</p><pre class="programlisting">SELECT pg_stop_backup();</pre><p>
この関数はバックアップモードを終了し、次のWALセグメントへの自動切換えを行います。
この切換えの理由は、バックアップ期間中に書き出された最後のWALファイルがアーカイブできるよう準備することです。
    </p></li><li class="listitem"><p>バックアップ中で使用されたWALセグメントファイルがアーカイブされれば完了です。
<code class="function">pg_stop_backup</code>の結果で識別されるファイルは、バックアップファイル一式を完結させるのに必要となる最終セグメントです。
<code class="varname">archive_mode</code>が有効であれば<code class="function">pg_stop_backup</code> は最終セグメントがアーカイブされるまで戻りません。
すでに<code class="varname">archive_command</code>を設定していますので、これらのファイルのアーカイブ操作は自動的に発生します。
ほとんどの場合、これは瞬時に行われます。
しかし、バックアップの完了を確認できるよう、アーカイブシステムを監視し、遅延が無いことの確認をお勧めします。
アーカイブコマンドの失敗によりアーカイブ処理が遅れてしまったとしても、アーカイブが成功し、そしてバックアップが完了するまで再試行を繰り返すようになっています。
<code class="function">pg_stop_backup</code>実行においての時間期限を設けたい場合、適切な<code class="varname">statement_timeout</code>の値を設定できますが、この設定値によって<code class="function">pg_stop_backup</code>が中断したときにバックアップが正当ではない可能性があるということを肝に銘じてください。
    </p></li></ol></div><p>
    </p></div><div class="sect3" id="BACKUP-LOWLEVEL-BASE-BACKUP-DATA"><div class="titlepage"><div><div><h4 class="title">25.3.3.3. データディレクトリのバックアップ</h4></div></div></div><p>
ファイルシステムのバックアップツール中には複写している途中でファイルが変更されると警告もしくはエラーを報告するものがあります。
稼働しているデータベースのベースバックアップを取っている場合には、この状況は正常でエラーではありません。
しかし、この種の警告と本当のエラーとを区別できるか確認が必要です。
例えば、<span class="application">rsync</span>のバージョンによっては<span class="quote">“<span class="quote">消滅したソースファイル</span>”</span>に対して別の終了コードを返し、そしてこの終了コードをエラーではないと受け付けるドライバスクリプトを記述することができます。
同時にGNU <span class="application">tar</span>のバージョンによっては、<span class="application">tar</span>がそれを複写していた途中でファイルが切り詰められると、致命的エラーと識別できないエラーコードを返します。
ありがたいことに、GNU <span class="application">tar</span>のバージョン1.16もしくはそれ以降では、バックアップ中にファイルが変更されると1で、それ以外のエラーの時は2でプログラムから抜けます。
GNUの <span class="application">tar</span>で1.23以降のバージョンを使用しているのであれば、<code class="literal">--warning=no-file-changed --warning=no-file-removed</code>オプションをつけることで関連する警告メッセージを隠すオプションを使用することができます。
   </p><p>バックアップに、データベースクラスタディレクトリ（例えば<code class="filename">/usr/local/pgsql/data</code>）以下にある全てのファイルが含まれていることを確認してください。
このディレクトリ以下に存在しないテーブル空間を使用している場合、注意して、同様にそれらを含めてください
（そして、バックアップがリンクとしてシンボリックリンクをアーカイブしていることを確認してください。
さもないとリストアはテーブル空間を壊してしまいます）。
   </p><p>しかし、クラスタの<code class="filename">pg_wal/</code>サブディレクトリにあるファイルをバックアップから省いてください。
このちょっとした調整は、リストア処理中の失敗の危険性を低減できますので、行う価値があります。
<code class="filename">pg_wal/</code>がクラスタディレクトリ外のどこかを指し示すシンボリックリンクの場合は調整が簡単です。
これは性能上の理由でよく使用される設定です。
また、いずれこのバックアップを使う<span class="application">postmaster</span>ではなく、今起動している<span class="application">postmaster</span>の情報を記録している<code class="filename">postmaster.pid</code>と<code class="filename">postmaster.opts</code>も除外できます。
(これらのファイルは<span class="application">pg_ctl</span>を誤作動させる可能性があります。)
   </p><p>マスター上に存在するレプリケーションスロットがバックアップに含まれないようにするために、クラスタの中の<code class="filename">pg_replslot/</code>ディレクトリをバックアップから除くのもしばしば良い考えです。
もし、スタンバイを作成するためのバックアップを続けて使用すると、スタンバイのWALファイルの保持を無制限に保留する結果になり、ホットスタンバイからのフィードバックを有効にしている場合、マスターのWALを膨張させます。
これは、これらのレプリケーションスロットを使っているクライアントはまだ、スタンバイではなく、マスターのスロットを接続し続け、更新しているからです。
バックアップが新しいマスターを作成するためだけに作成されたとしても、レプリケーションスロットをコピーすることは特に有益であるとは考えられません。
このようにバックアップにレプリケーションスロットを含むことは、新しいマスターがオンラインになったときにはスロットの内容が期限切れしており、有害である可能性があります。
   </p><p>ディレクトリ<code class="filename">pg_dynshmem/</code>、<code class="filename">pg_notify/</code>、<code class="filename">pg_serial/</code>、<code class="filename">pg_snapshots/</code>、<code class="filename">pg_stat_tmp/</code>、<code class="filename">pg_subtrans/</code>の中身はバックアップから除外できます。（ただし、ディレクトリ自体は除外できません。）
というのも、postmaster起動時に初期化されるからです。
<a class="xref" href="runtime-config-statistics.html#GUC-STATS-TEMP-DIRECTORY">stats_temp_directory</a>が設定されていて、それがデータディレクトリの下にあるのであれば、そのディレクトリの中身も除外できます。
   </p><p><code class="filename">pgsql_tmp</code>で始まるすべてのファイルとディレクトリはバックアップから除外できます。
これらのファイルはpostmasterの起動時に削除されますし、ディレクトリも必要なら再作成されます。
   </p><p>バックアップラベルファイルには、<code class="function">pg_start_backup</code>に付与したラベル文字列と<code class="function">pg_start_backup</code>が実行された時刻、最初のWALファイルの名前が含まれます。
したがって、当惑した時にバックアップファイルの中身を検索し、そのダンプファイルがどのバックアップセッションに由来したものかを確認することができます。
テーブル空間マップファイルにはディレクトリ<code class="filename">pg_tblspc/</code>に存在するシンボリックリンク名と各シンボリックリンクのフルパスが含まれています。
このファイルはあなたのためだけの情報ではありません。
その存在と内容はシステムのリカバリプロセスが適切に動作するために非常に重要です。
   </p><p>サーバが停止している時にバックアップを作成することも可能です。
この場合、わかりきったことですが、<code class="function">pg_start_backup</code>や<code class="function">pg_stop_backup</code>を使用することができません。
そのため、どのバックアップが、どのWALファイルと関連し、どこまで戻せばよいかを独自の方法で残さなければなりません。
通常は、上述の継続的アーカイブ手順に従う方をお勧めします。
   </p></div></div><div class="sect2" id="BACKUP-PITR-RECOVERY"><div class="titlepage"><div><div><h3 class="title">25.3.4. 継続的アーカイブによるバックアップを使用した復旧</h3></div></div></div><p>さて、最悪の事態が発生し、バックアップから復旧する必要が出てきたものとします。
以下にその手順を説明します。
  </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>もし稼動しているのであればサーバを停止してください。
    </p></li><li class="listitem"><p>もし容量があるのであれば、後で必要になる場合に備えてクラスタデータディレクトリ全体とテーブル空間を全て一時的な場所にコピーしてください。
この予防措置は、既存のデータベースを2つ分保持できるだけの空き領域を必要とします。
十分な領域がない場合でも、少なくともクラスタの<code class="filename">pg_wal</code>サブディレクトリの内容は保存すべきです。
ここには、システムが停止する前にアーカイブされなかったログファイルが含まれているかも知れないからです。
    </p></li><li class="listitem"><p>クラスタデータディレクトリ以下、および、使用中のテーブル空間の最上位ディレクトリ以下にある既存の全てのファイルとサブディレクトリを削除してください。
    </p></li><li class="listitem"><p>ファイルシステムバックアップからデータベースファイルをリストアします。
ファイルが正しい所有権（<code class="literal">root</code>ではなくデータベースシステムユーザです！）でリストアされていることを確認してください。
テーブル空間を使用している場合は、<code class="filename">pg_tblspc/</code>内のシンボリックリンクが正しくリストアされていることを検証する必要があります。
    </p></li><li class="listitem"><p><code class="filename">pg_wal/</code>内にあるファイルをすべて削除してください。
これらはファイルシステムバックアップから生成されたものであり、おそらく現在のものより古く使用できないものです。
<code class="filename">pg_wal/</code>をまったくアーカイブしていなければ、適切な権限で再作成してください。
以前シンボリックリンクとして設定していたのであれば、そのように確実に再構築するように注意してください。
    </p></li><li class="listitem"><p>手順2で退避させた未アーカイブのWALセグメントファイルがあるのであれば、<code class="filename">pg_wal/</code>にコピーしてください。
（問題が発生し、初めからやり直さなければならない場合に未変更のファイルが残るように、移動させるのではなくコピーすることが最善です。）
    </p></li><li class="listitem"><p>復旧コマンドファイル<code class="filename">recovery.conf</code>（<a class="xref" href="recovery-config.html" title="Chapter 27. リカバリの設定">Chapter 27</a>を参照）をクラスタデータディレクトリに作成してください。
また、一時的に<code class="filename">pg_hba.conf</code>を編集し、復旧の成功を確認できるまで一般ユーザが接続できないようにする必要があるかもしれません。
    </p></li><li class="listitem"><p>サーバを起動してください。
サーバは復旧モードに入り、必要なアーカイブ済みWALファイル群の読み込みを行います。
外部的なエラーにより復旧が中断したら、サーバを単に再起動させて、復旧処理を継続してください。
復旧処理が完了したら、（誤って後で復旧モードに再度入らないように）postmasterは<code class="filename">recovery.conf</code>の名前を<code class="filename">recovery.done</code>に変更します。
その後通常のデータベース操作を開始します。
    </p></li><li class="listitem"><p>データベースの内容を検査し、希望する状態まで復旧できていることを確認してください。
復旧できなかった場合は手順1に戻ってください。
全て問題なければ、ユーザが接続できるように<code class="filename">pg_hba.conf</code>を正常状態に戻してください。
    </p></li></ol></div><p>
   </p><p>ここで重要となるのは、復旧設定ファイルを設定することです。
このファイルで、どのように復旧させたいのかやどこまで復旧させたいかを記述します。
<code class="filename">recovery.conf.sample</code>（通常はインストレーションの<code class="filename">share/</code>ディレクトリに格納されています）を手本として使用することができます。
<code class="filename">recovery.conf</code>で絶対に指定しなければならないことは、アーカイブ済みWALファイルセグメントをどのように戻すかを<span class="productname">PostgreSQL</span>に通知する<code class="varname">restore_command</code>です。
<code class="varname">archive_command</code>同様、これはシェルコマンド文字列です。
ここには、対象のログファイルの名前で置換される<code class="literal">%f</code>やログファイルのコピー先を示すパスで置換される<code class="literal">%p</code>を含めることができます。
（パス名は現在の作業用ディレクトリ、つまり、クラスタのデータディレクトリから見た相対パスです。）
コマンド内に<code class="literal">%</code>文字自体を埋め込む必要があれば<code class="literal">%%</code>と記載してください。
最も簡単でよく使われるコマンドは以下のようなものです。
</p><pre class="programlisting">restore_command = 'cp /mnt/server/archivedir/%f %p'</pre><p>
これは事前にアーカイブされたWALセグメントを<code class="filename">/mnt/server/archivedir</code>ディレクトリからコピーします。
当然ながら、もっと複雑なものを使用することができます。
例えば、操作者に適切なテープをマウントさせることを要求するようなシェルスクリプトでさえ可能です。
   </p><p>このコマンドが失敗した時に非ゼロの終了ステータスを返すことが重要です。
このコマンドは、アーカイブに存在しないファイルを要求する<span class="emphasis"><em>かもしれません</em></span>が、その場合でも非ゼロを返さなければなりません。
これはエラー状態ではありません。
例外は、コマンドがシグナルによって中断された場合(データベースの停止に使用される<span class="systemitem">SIGTERM</span>以外)か、シェルによるエラー(コマンドが見つかりませんなど)でリカバリが中断され、サーバが起動しない場合です。
   </p><p>要求されるファイルはWALセグメントファイルだけではありません。
<code class="literal">.history</code>が付いているファイルが要求されることも想定しなければなりません。
同時に、<code class="literal">%p</code>パスのファイル名部分は<code class="literal">%f</code>と異なることに注意してください。
これらが相互に置き換え可能であるとは考えないでください。
   </p><p>アーカイブ場所で見つけられなかったWALセグメントは<code class="filename">pg_wal/</code>から検索されます。
これにより、最近の未アーカイブのセグメントを使用することができます。
しかし、アーカイブ場所から利用できるセグメントは<code class="filename">pg_wal/</code>内のファイルよりも優先的に使用されます。
   </p><p>通常は利用可能な全てのWALセグメントを使用して復旧処理が行われます。
その結果、データベースを現時点まで（もしくは、利用可能なWALセグメントで得られる限り現在に近い時点まで）リストアします。
従って、通常の復旧は<span class="quote">“<span class="quote">file not found</span>”</span>メッセージで終了します。
エラーメッセージの正確な文言は<code class="varname">restore_command</code>の選択によります。
また、復旧の開始時点で<code class="filename">00000001.history</code>のようなファイル名のエラーメッセージが出ることがあります。
これも単純な復旧作業では不具合を意味するものでなく正常です。
論議については<a class="xref" href="continuous-archiving.html#BACKUP-TIMELINES" title="25.3.5. タイムライン">Section 25.3.5</a>を参照してください。
   </p><p>もし以前のある時点まで復旧させたい場合（例えば、経験不足のデータベース管理者が主トランザクションテーブルを消去した直前）、<code class="filename">recovery.conf</code>に要求する<a class="link" href="recovery-target-settings.html" title="27.2. リカバリ対象の設定">停止時点</a>を指定するだけです。
停止時点は、<span class="quote">“<span class="quote">recovery target</span>”</span>として既知の停止時点で指定することも、日付と時刻で指定することも、リストアポイントか完了した特定のトランザクションIDで指定することもできます。
本ドキュメントの執筆時点では使用するトランザクションIDの識別を補助するツールがありませんので、ほとんどの場合は日付と時刻による指定のみを使用することになるでしょう。
   </p><div class="note"><h3 class="title">Note</h3><p>停止時点はバックアップの終了時刻、つまり、<code class="function">pg_stop_backup</code>の最終時刻より後の時点でなければなりません。
バックアップを行っている最中のある時点までベースバックアップを使用して復旧させることはできません
（こうした時点まで復旧させるには、その前のベースバックアップまで戻って、そこからロールフォワードしてください）。
     </p></div><p>復旧時にWALデータの破損がわかると、復旧はその時点で止まり、サーバは起動しません。
こうした場合、<span class="quote">“<span class="quote">復旧対象</span>”</span>に破損時点より前の時点を指定することで、復旧処理が正常に完了できるよう、復旧プロセスを初めからやり直すことができます。
システムクラッシュなど外的理由により復旧処理が失敗した場合やWALアーカイブがアクセスできなくなった場合、復旧処理を単に再起動させることができます。
この場合は失敗した時点とほぼ同じところから再開します。
復旧処理の再起動は、次のような通常操作時のチェックポイント処理とほぼ同様に動作します。
サーバは定期的にすべての状態をディスクに強制し、再度スキャンする必要がない処理済みのWALデータを示す<code class="filename">pg_control</code>ファイルを更新します。
   </p></div><div class="sect2" id="BACKUP-TIMELINES"><div class="titlepage"><div><div><h3 class="title">25.3.5. タイムライン</h3></div></div></div><a id="id-1.6.12.7.13.2" class="indexterm"></a><p>過去のある時点までデータベースを復旧できる機能は、タイムトラベルやパラレルユニバースといったSFの物語に類似した、多少の複雑性があります。
例えば、データベースの元の履歴で、火曜日の夕方5:15PMに重要なテーブルを削除し、水曜日のお昼まで手違いに気が付かなかったとします。
慌てずに、バックアップを取り出して、火曜日の夕方5:14PMの時点にリストアし、データベースを起動させます。
データベース世界の<span class="emphasis"><em>この</em></span>履歴では、そのテーブルを削除していません。
しかし、後になって、これは大した問題ではなかったことが分かり、元の履歴における水曜日に朝の何時かにまで戻したいと考えたと仮定しましょう。
データベースは既に起動していますので、元に戻したい時点に至るWALセグメントファイルの一部は上書きされていて、戻すことはできないかもしれません。
ですので、このことを避けるために、ポイントインタイムで復旧させた後に生成された一連のWAL記録と元のデータベースの履歴において生成されたWAL記録とを区別する必要があります。
   </p><p>こうした問題を扱うために<span class="productname">PostgreSQL</span>には<em class="firstterm">タイムライン</em>という概念があります。
アーカイブ復旧が完了したときはいつでも、その復旧後に生成されたWAL記録を識別するための新しいタイムラインが生成されます。
タイムラインID番号はWALセグメントファイル名の一部です。
ですので、新しいタイムラインはこれまでのタイムラインで生成されたWALデータを上書きしません。
実際、多くの異なるタイムラインをアーカイブすることができます。
不要な機能と考えるかもしれませんが、命綱になることがしばしばあります。
どの時点まで復旧すればよいか確実でないといった状況を考えてみてください。
その時は、過去の履歴からの分岐点として最善の時点を見つけるために、試行錯誤して何度もポイントインタイムの復旧を行う必要があるでしょう。
タイムラインがないと、この手続きはすぐに管理不能な混乱を招いてしまいます。
タイムラインを使用して、以前捨てたタイムライン分岐における状態を含む、過去の<span class="emphasis"><em>任意</em></span>の状態に復旧させることができます。
   </p><p>新しいタイムラインが生成される度に、<span class="productname">PostgreSQL</span>は、どのタイムラインがいつどこから分岐したかを示す<span class="quote">“<span class="quote">タイムライン履歴</span>”</span>ファイルを作成します。
この履歴ファイルは、複数のタイムラインを含むアーカイブ場所から復旧する時にシステムが正しいWALセグメントファイルを選択できるようにするために必要です。
したがって、履歴ファイルは、WALセグメントファイル同様にWALアーカイブ領域にアーカイブされます。
履歴ファイルは（巨大になるセグメントファイルとは異なり）単なる小さなテキストファイルですので、安価かつ適切に無期限で保管できます。
必要ならば、履歴ファイルにコメントを追加し、この特定のタイムラインがどのように、なぜ生成されたかについて独自の注釈を付与することができます。
特にこうしたコメントは、実験の結果いくつものタイムラインのもつれがある場合に有用です。
   </p><p>復旧処理のデフォルトは、ベースバックアップが取得された時点のタイムラインと同一のタイムラインに沿った復旧です。
別の子タイムラインに沿って復旧させたい（つまり、復旧試行以降に生成されたある状態に戻りたい）場合は<code class="filename">recovery.conf</code>で対象のタイムラインIDを指定しなければなりません。
ベースバックアップより前に分岐したタイムラインに沿って復旧することはできません。
   </p></div><div class="sect2" id="BACKUP-TIPS"><div class="titlepage"><div><div><h3 class="title">25.3.6. ヒントと例</h3></div></div></div><p>継続的アーカイブを構成するいくつかのヒントを以下にあげます。
   </p><div class="sect3" id="BACKUP-STANDALONE"><div class="titlepage"><div><div><h4 class="title">25.3.6.1. スタンドアローンホットバックアップ</h4></div></div></div><p>スタンドアローンホットバックアップを形成するため<span class="productname">PostgreSQL</span>のバックアップ基盤を使用することができます。
これらのバックアップはポイントインタイムリカバリに使用することはできないのですが、<span class="application">pg_dump</span>によるダンプよりバックアップとリストアが概してより速く行われます。
（同時に<span class="application">pg_dump</span>のダンプより大きくなるので、場合によっては速度による利点が打ち消されるかもしれません。）
     </p><p>ベースバックアップと同様に、スタンドアローンホットバックアップを作成する最も簡単な方法は <a class="xref" href="app-pgbasebackup.html" title="pg_basebackup"><span class="refentrytitle">pg_basebackup</span></a>ツールを使用する方法です。
実行時に<code class="literal">-X</code>オプションをつけることでバックアップに必要な全ての先行書き込みログを自動的にバックアップに含めることができ、リストアするときには特に特別な作業を行う必要がありません。
     </p><p>バックアップファイルをコピーするのにより柔軟性が必要な場合、スタンドアローンホットバックアップのために低レベルのプロセスを使うこともできます。
低レベルのスタンドアローンホットバックアップを準備するために、次のことを確実に行ってください。
<code class="varname">wal_level</code>を<code class="literal">replica</code>以上にセットし、<code class="varname">archive_mode</code>を<code class="literal">on</code>にセットし、<span class="emphasis"><em>switch ファイル</em></span>が存在する時のみに実行される<code class="varname">archive_command</code>をセットします。
例：
</p><pre class="programlisting">archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'</pre><p>
このコマンドは<code class="filename">/var/lib/pgsql/backup_in_progress</code> が存在する時のみ実行され、存在しない時は単に0の終了コードを返します(<span class="productname">PostgreSQL</span>に必要の無いWALファイルを再利用することを許可します)。
     </p><p>この準備によって、バックアップは以下のようなスクリプトを使用して取得されます。
</p><pre class="programlisting">touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/</pre><p>
完全なWALファイルのアーカイブが行われるように、スイッチファイル、<code class="filename">/var/lib/pgsql/backup_in_progress</code>が最初に作成されます。
バックアップの後、スイッチファイルは削除されます。
その後、ベースバックアップとすべての必要なWALファイルが共に同じ<span class="application">tar</span>ファイルの一部になるよう、アーカイブされたWALファイルはバックアップに追加されます。
バックアップスクリプトにエラー処理を加えておくことを忘れないでください。
     </p></div><div class="sect3" id="COMPRESSED-ARCHIVE-LOGS"><div class="titlepage"><div><div><h4 class="title">25.3.6.2. 圧縮アーカイブログ</h4></div></div></div><p>もし、アーカイブのストレージ容量に懸念がある場合、アーカイブファイルを圧縮するために<span class="application">gzip</span>を使用することもできます。

</p><pre class="programlisting">archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'</pre><p>
リカバリ中は <span class="application">gunzip</span>を使う必要があります。
</p><pre class="programlisting">restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'</pre><p>
     </p></div><div class="sect3" id="BACKUP-SCRIPTS"><div class="titlepage"><div><div><h4 class="title">25.3.6.3. <code class="varname">archive_command</code>スクリプト</h4></div></div></div><p><code class="filename">postgresql.conf</code>の記入事項が以下のように簡素となるため、多くの人が<code class="varname">archive_command</code>の定義にスクリプトの使用を選択します。
</p><pre class="programlisting">archive_command = 'local_backup_script.sh "%p" "%f"'</pre><p>
アーカイブ処理手順において単一ではなくそれ以上の数のコマンドを使用したい場合はいつでも、別のスクリプトファイルの使用が推奨されます。
そうするとスクリプト内で全ての複雑性が管理されます。
スクリプトは<span class="application">bash</span>または<span class="application">perl</span>のようなよくあるスクリプト言語で記載できます。
     </p><p>スクリプト内で解決される要件の例として以下があります。
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>セキュアなオフサイトデータストレージへのデータのコピー
        </p></li><li class="listitem"><p>一回に全てではなく３時間毎に転送されるようにWALファイルのバッチ
        </p></li><li class="listitem"><p>その他のバックアップとリカバリーソフトウェアとのインターフェイス
        </p></li><li class="listitem"><p>エラー報告を行う監視ソフトとのインターフェイス
        </p></li></ul></div><p>
     </p><div class="tip"><h3 class="title">Tip</h3><p><code class="varname">archive_command</code>スクリプトを使うときは<a class="xref" href="runtime-config-logging.html#GUC-LOGGING-COLLECTOR">logging_collector</a>を使えるようにすることが望ましい方法です。
そのスクリプトはメッセージを<span class="systemitem">stderr</span>で書き出し、それはデータベースのサーバーログとして書かれます。
このためスクリプトでエラーが発生した時に簡単に検知するための細かな設定を行なうことができるからです。
      </p></div></div></div><div class="sect2" id="CONTINUOUS-ARCHIVING-CAVEATS"><div class="titlepage"><div><div><h3 class="title">25.3.7. 警告</h3></div></div></div><p>本ドキュメント作成時点では、継続的アーカイブ技術にいくつかの制限があります。
将来のリリースでは修正されるはずです。

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>もしもベースバックアップが行われている時、<a class="xref" href="sql-createdatabase.html" title="CREATE DATABASE"><span class="refentrytitle">CREATE DATABASE</span></a>コマンドが実行され、ベースバックアップが処理を実行している期間に<code class="command">CREATE DATABASE</code>がコピーしているtemplateデータベースが変更されると、復旧処理はこれらの変更を作成されたデータベースにも同時に伝播させることは確実です。
もちろん、これは望まれる事ではありません。
この危険を回避するには、ベースバックアップ期間中にはすべてのtemplateデータベースを変更しないことが一番です。
    </p></li><li class="listitem"><p><a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>コマンドはリテラルの絶対パス付でWALにログが記録され、したがって、同じ絶対パスでのテーブル空間作成の時に再生されます。
これは、もしログが異なったマシン上で再生される場合には好ましくありません。
ログ再生がたとえ同一のマシンであっても、新規のデータディレクトリであれば危険です。
なぜなら、再生は元のテーブル空間の内容を上書きし続けるからです。
この種の潜在的な振舞いを防ぐためには、テーブル空間を作成もしくは削除後に新規ベースバックアップを行うのが最良の手段です。
    </p></li></ul></div><p>
   </p><p>また、デフォルトの<acronym class="acronym">WAL</acronym>フォーマットは数多くのディスクページのスナップショットを含んでいるため、かなりかさばるものになってしまっていることに触れておくべきでしょう。
これらのページスナップショットは、クラッシュから回復のために設計されています。
それというのも、回復処理の際には不完全に書き込まれているディスクページを修復しなければならないことがあるからです。
システムのハードウェアやソフトウェアによっては、不完全なディスクページの書き込みが起きてしまう危険性は無視してもよい程微小です。
この場合<a class="xref" href="runtime-config-wal.html#GUC-FULL-PAGE-WRITES">full_page_writes</a>パラメータを設定してページスナップショットを無効にすることで、アーカイブされたログの総容量を大幅に縮小できます
（実際に設定を行う前に、<a class="xref" href="wal.html" title="Chapter 30. 信頼性とログ先行書き込み">Chapter 30</a>の注意事項と警告を読んでください）。
ページスナップショットを無効にしても PITR処理の際にログが使用できなくなることはありません。
将来の課題は、<code class="varname">full_page_writes</code>がたとえオンになっている場合であっても不要なページを取り除き、アーカイブ済みWALデータの圧縮を行うことでしょう。
差し当たり管理者は、可能な限りチェックポイント間隔パラメータを大きくすることによって、WALに含まれるページスナップショットの数を削減することができます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-file.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="backup.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="high-availability.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">25.2. ファイルシステムレベルのバックアップ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 26. 高可用性、負荷分散およびレプリケーション</td></tr></table></div></body></html>