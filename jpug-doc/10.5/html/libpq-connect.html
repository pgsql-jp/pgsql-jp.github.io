<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>33.1. データベース接続制御関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq.html" title="Chapter 33. libpq - C ライブラリ" /><link rel="next" href="libpq-status.html" title="33.2. 接続状態関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">33.1. データベース接続制御関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Up</a></td><th width="60%" align="center">Chapter 33. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C ライブラリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-status.html" title="33.2. 接続状態関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LIBPQ-CONNECT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">33.1. データベース接続制御関数</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="libpq-connect.html#LIBPQ-CONNSTRING">33.1.1. 接続文字列</a></span></dt><dt><span class="sect2"><a href="libpq-connect.html#LIBPQ-PARAMKEYWORDS">33.1.2. パラメータキーワード</a></span></dt></dl></div><p><span class="productname">PostgreSQL</span>のバックエンドサーバとの接続を作成するには、以下の関数を使用します。
アプリケーションプログラムはバックエンドとの接続を一度に複数個開くことができます。
（1つの理由として、複数のデータベースへのアクセスが挙げられます。）
個々の接続は、<code class="function">PQconnectdb</code>、<code class="function">PQconnectdbParams</code>または<code class="function">PQsetdbLogin</code>関数を呼び出すことで得られる<code class="structname">PGconn</code><a id="id-1.7.3.8.2.6" class="indexterm"></a>オブジェクトによって表されます。
なお、これらの関数は、<code class="structname">PGconn</code>オブジェクトに割り当てるほんのわずかなメモリの余裕さえもない場合を除き、NULLではなく常にオブジェクトのポインタを返します。
また、この接続オブジェクトを通じて問い合わせを送る前に、<code class="function">PQstatus</code>関数を呼び出して、データベースとの接続に成功したか戻り値を検査しなければなりません。

   </p><div class="warning"><h3 class="title">Warning</h3><p>信頼できないユーザが、<a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.8.6. 使用パターン">安全なスキーマ使用パターン</a>を適用していないデータベースへアクセスする際には、セッション開始時に<code class="varname">search_path</code>から、第三者が書き込みができるスキーマを削除してください。
これは<code class="literal">options</code>パラメータキーワードに値<code class="literal">-csearch_path=</code>を設定することで可能となります。
別の方法としては、接続後に<code class="literal">PQexec(<em class="replaceable"><code>conn</code></em>, "SELECT pg_catalog.set_config('search_path', '', false)")</code>を発行しても構いません。
このような配慮は、<span class="application">libpq</span>に限ったことではありません。
任意のSQLコマンドを実行するすべてのインタフェースに当てはまります。
    </p></div><p>

   </p><div class="warning"><h3 class="title">Warning</h3><p>Unix上で、libpq接続を開いたプロセスのフォークは、親と子のプロセスが同じソケットとオペレーティングシステムの資源を共有するため、予期せぬ結果を招くことがあります。
この理由により、新規実行形式を子プロセスが読み込むため<code class="function">exec</code>を行うことが安全と言っても、このような使用方法は推奨されません。
    </p></div><p>

   </p><div class="note"><h3 class="title">Note</h3><p>Windowsでは、単一のデータベース接続が反復して開始と終了を繰り返す場合、性能を向上させる方法があります。
内部的には、接続開始と終了に対して、libpqはそれぞれ<code class="function">WSAStartup()</code>と<code class="function">WSACleanup()</code>を呼び出します。
<code class="function">WSAStartup()</code>は<code class="function">WSACleanup()</code>で値が減少させられた内部Windowsライブラリ参照カウントを増加させます。
参照カウントがたった１の場合、<code class="function">WSACleanup()</code>呼び出しはすべてのリソースを解放し、すべてのDLLはアンロードされます。
これは高価な操作です。
これを回避するには、最後のデータベース接続が閉じられる時、リソースが解放されないようにアプリケーションが手動で<code class="function">WSAStartup()</code>を呼び出すことができます。
    </p></div><p>

   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCONNECTDBPARAMS"><span class="term"><code class="function">PQconnectdbParams</code><a id="id-1.7.3.8.2.12.1.1.2" class="indexterm"></a></span></dt><dd><p>新たにデータベースサーバへの接続を作成します。

</p><pre class="synopsis">PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);</pre><p>
      </p><p>この関数は、2つの<code class="symbol">NULL</code>終端の配列から取得したパラメータを使用して、データベースとの接続を新たに1つ確立します。
1つ目は文字列配列として定義される<code class="literal">keywords</code>で、それぞれがキーワードとなります。
2つ目は<code class="literal">values</code>で、各キーワードの値を提供します。
後述の<code class="function">PQsetdbLogin</code>とは異なり、関数のシグネチャを変更せずにパラメータ集合を拡張できますので、アプリケーションプログラムを新たに作成する際には、この関数(もしくは非ブロックモードでよく似た処理をする<code class="function">PQconnectStartParams</code>と<code class="function">PQconnectPoll</code>)を使用することをお勧めします。
      </p><p>現在有効なパラメータキーワードを<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. パラメータキーワード">Section 33.1.2</a>に示します。
      </p><p><code class="literal">expand_dbname</code>が非ゼロの場合、<em class="parameter"><code>dbname</code></em>キーワードの値を接続文字列として認識させることができます。
最初に出現した<em class="parameter"><code>dbname</code></em>だけがこのように展開され、後続の<em class="parameter"><code>dbname</code></em>値は通常のデータベース名として処理されます。
接続文字列の取り得る書式に関する詳細については<a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="33.1.1. 接続文字列">Section 33.1.1</a>を参照してください。
      </p><p>空の配列を渡してすべてデフォルトパラメータを使用することができます。
また渡される配列に1つ以上のパラメータ設定を持たせることもできます。
これらの長さは一致しなければなりません。
<code class="literal">keywords</code>配列の最初の<code class="symbol">NULL</code>要素で処理は停止します。
      </p><p>パラメータが<code class="symbol">NULL</code>や空文字列の場合には、対応する環境変数（<a class="xref" href="libpq-envars.html" title="33.14. 環境変数">Section 33.14</a>参照）が検査されます。
環境変数も設定されていない場合は、組み込みのデフォルト値が使用されます。
      </p><p>一般的にキーワードはこれらの配列の先頭からインデックス順で処理されます。
この影響はキーワードが繰り返された場合で、最後に処理された値が残ることになります。
このため、<em class="parameter"><code>dbname</code></em>キーワードの記述場所に注意することで、<em class="parameter"><code>conninfo</code></em>文字列により何が上書きされるか、何が上書きされないかを決定することができます。
      </p></dd><dt id="LIBPQ-PQCONNECTDB"><span class="term"><code class="function">PQconnectdb</code><a id="id-1.7.3.8.2.12.2.1.2" class="indexterm"></a></span></dt><dd><p>新たにデータベースサーバへの接続を作成します。

</p><pre class="synopsis">PGconn *PQconnectdb(const char *conninfo);</pre><p>
      </p><p>この関数は<code class="literal">conninfo</code>文字列から取得されるパラメータを使用して、新しいデータベース接続を開きます。
      </p><p>空の文字列を渡してすべてデフォルトパラメータを使用することができます。
また空白文字で区切ることで1つ以上のパラメータ設定を持たせることもできます。
さらに<acronym class="acronym">URI</acronym>を含めることができます。
詳細については<a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="33.1.1. 接続文字列">Section 33.1.1</a>を参照してください。
     </p></dd><dt id="LIBPQ-PQSETDBLOGIN"><span class="term"><code class="function">PQsetdbLogin</code><a id="id-1.7.3.8.2.12.3.1.2" class="indexterm"></a></span></dt><dd><p>新たにデータベースサーバへの接続を作成します。
</p><pre class="synopsis">PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);</pre><p>
       </p><p>これはパラメータ群を固定した<code class="function">PQconnectdb</code>の前身です。
設定できないパラメータが常にデフォルト値になる点を除き、同一の機能を持ちます。
固定のパラメータに対して<code class="symbol">NULL</code>もしくは空文字列とすると、それはデフォルトを使用することになります。
      </p><p><em class="parameter"><code>dbName</code></em>内に<code class="symbol">=</code>記号が含まれる場合、または有効な接続<acronym class="acronym">URI</acronym>接頭辞を持つ場合、<code class="function">PQconnectdb</code>に渡された場合とまったく同じ扱いで<em class="parameter"><code>conninfo</code></em>文字列として扱われます。
その後残りのパラメータが<code class="function">PQconnectdbParams</code>の指定のように適用されます。
      </p></dd><dt id="LIBPQ-PQSETDB"><span class="term"><code class="function">PQsetdb</code><a id="id-1.7.3.8.2.12.4.1.2" class="indexterm"></a></span></dt><dd><p>新たにデータベースサーバへの接続を作成します。
</p><pre class="synopsis">PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);</pre><p>
     </p><p>これは、<em class="parameter"><code>login</code></em>と<em class="parameter"><code>pwd</code></em>にNULLポインタを設定する<code class="function">PQsetdbLogin</code>を呼び出すマクロです。
非常に古いプログラムへの後方互換性のために提供されています。
     </p></dd><dt id="LIBPQ-PQCONNECTSTARTPARAMS"><span class="term"><code class="function">PQconnectStartParams</code><a id="id-1.7.3.8.2.12.5.1.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectStart</code><a id="id-1.7.3.8.2.12.5.2.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQconnectPoll</code><a id="id-1.7.3.8.2.12.5.3.2" class="indexterm"></a></span></dt><dd><p>       <a id="id-1.7.3.8.2.12.5.4.1.1" class="indexterm"></a>
ブロックしない方法で、データベースサーバへの接続を作成します。

</p><pre class="synopsis">PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);</pre><p>
      </p><p>これら3つの関数は、リモートI/Oの実行時にアプリケーションスレッドの実行がブロックされないようなデータベースサーバへの接続を作成するために使われます。
この手法の利点は、I/Oの終了待ちが<code class="function">PQconnectdbParams</code>または<code class="function">PQconnectdb</code>内部ではなく、アプリケーションプログラムのメインループでできることにあります。
これによって、アプリケーションは他の処理と並行してこの処理を管理することができます。
      </p><p><code class="function">PQconnectStartParams</code>では、上で<code class="function">PQconnectdbParams</code>で説明したように、データベース接続は<code class="literal">keywords</code>および<code class="literal">values</code>配列から取得され、<code class="literal">expand_dbname</code>によって制御されたパラメータを使用して確立します。
      </p><p><code class="function">PQconnectStart</code>では、上で<code class="function">PQconnectdb</code>で説明したように、<code class="literal">conninfo</code>文字列から取得されたパラメータを使用してデータベース接続を確立します。
      </p><p><code class="function">PQconnectStartParams</code>、<code class="function">PQconnectStart</code>と<code class="function">PQconnectPoll</code>のどちらも以下の制限に適合する場合ブロックしません。
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">hostaddr</code>と<code class="literal">host</code>パラメータは、ホスト名からのIPアドレス検索やホスト名の逆引きが起こらないように適切に使用されなければいけません。
詳細に付いては<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. パラメータキーワード">Section 33.1.2</a>内のパラメータ説明を参照してください。
         </p></li><li class="listitem"><p><code class="function">PQtrace</code>を呼び出す場合は、トレースに使用するストリームオブジェクトがブロックされないことが保証されていなくてはなりません。
         </p></li><li class="listitem"><p>プログラマ自身が、後に示すように、<code class="function">PQconnectPoll</code>を呼び出す前にソケットが適切な状態にあることを保証しなくてはいけません。
         </p></li></ul></div><p>
      </p><p>注意：<code class="function">PQconnectStartParams</code>の使用は後述の<code class="function">PQconnectStart</code>と類似しています。
      </p><p>非ブロック接続要求を始めるにはまず、<code class="literal">conn=PQconnectStart("<em class="replaceable"><code>connection_info_string</code></em>")</code>を呼び出します。
<code class="varname">conn</code>がNULLの場合、<span class="application">libpq</span>が新たに<code class="structname">PGconn</code>構造体を割り当てられなかったことを表します。
そうでない場合は、適切な<code class="structname">PGconn</code>へのポインタが返されます
（ただし、データベースに正しく接続されていることを表しているわけではありません）。
<code class="function">PQconnectStart</code>から値が返ってきた段階で、<code class="literal">status=PQstatus(conn)</code>を呼び出します。
もし、<code class="varname">status</code>が<code class="symbol">CONNECTION_BAD</code>と等しい場合には、<code class="function">PQconnectStart</code>が失敗しています。
      </p><p><code class="function">PQconnectStart</code>が成功したら、次は接続シーケンスを進めるために、<span class="application">libpq</span>をポーリングします。
データベース接続の背後にあるソケットの記述子を取り出すには、<code class="function">PQsocket(conn)</code>を使用します。
以下の繰り返しです。
直前の<code class="function">PQconnectPoll(conn)</code>が<code class="symbol">PGRES_POLLING_READING</code>の場合、ソケットの読み込み準備が整うまで待機します。
（<code class="function">select()</code>や<code class="function">poll()</code>などのシステム関数で示されます。）
そして、再度<code class="function">PQconnectPoll(conn)</code>を呼び出します。
反対に直前の<code class="function">PQconnectPoll(conn)</code>が<code class="symbol">PGRES_POLLING_WRITING</code>の場合、ソケットの書き込み準備が整うまで待機し、その後、<code class="function">PQconnectPoll(conn)</code>を再度呼び出します。
まだ<code class="function">PQconnectPoll</code>を呼び出していない場合、つまり、<code class="function">PQconnectStart</code>の呼び出し直後では、直前が<code class="symbol">PGRES_POLLING_WRITING</code>であった場合と同様の処理を行ないます。
この繰り返しを<code class="function">PQconnectPoll(conn)</code>が、接続手続きの失敗を示す<code class="symbol">PGRES_POLLING_FAILED</code>、もしくは、接続確立に成功したことを示す<code class="symbol">PGRES_POLLING_OK</code>を返すまで継続します。
      </p><p>接続している間は、いつでも<code class="function">PQstatus</code>を呼び出すことで、接続の状態を検査することができます。
この関数呼び出しが<code class="symbol">CONNECTION_BAD</code>を返す場合、接続手続きは失敗しており、<code class="symbol">CONNECTION_OK</code>を返す場合、接続が確立しています。
上述のように、このいずれの状態も、<code class="function">PQconnectPoll</code>の戻り値から同様に検出できます。
これ以外の状態は、非同期の接続手続きの間（のみに）現れることがあります。
これらは、接続手続きの現在の段階を示すものであり、例えばユーザへのフィードバックを提供することに使用できます。
以下の状態があります。

       </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-CONNECTION-STARTED"><span class="term"><code class="symbol">CONNECTION_STARTED</code></span></dt><dd><p>接続の確立待ち状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-MADE"><span class="term"><code class="symbol">CONNECTION_MADE</code></span></dt><dd><p>接続はOKです。送信待ち状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-AWAITING-RESPONSE"><span class="term"><code class="symbol">CONNECTION_AWAITING_RESPONSE</code></span></dt><dd><p>サーバからの応答待ち状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-AUTH-OK"><span class="term"><code class="symbol">CONNECTION_AUTH_OK</code></span></dt><dd><p>        認証済みです。バックエンドの起動待ち状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-SSL-STARTUP"><span class="term"><code class="symbol">CONNECTION_SSL_STARTUP</code></span></dt><dd><p>SSL暗号化の調停状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-SETENV"><span class="term"><code class="symbol">CONNECTION_SETENV</code></span></dt><dd><p>環境が提供するパラメータ設定の調停状態です。
          </p></dd><dt id="LIBPQ-CONNECTION-CHECK-WRITABLE"><span class="term"><code class="symbol">CONNECTION_CHECK_WRITABLE</code></span></dt><dd><p>接続が書き込みトランザクションを扱えるかどうかを調べています。
          </p></dd><dt id="LIBPQ-CONNECTION-CONSUME"><span class="term"><code class="symbol">CONNECTION_CONSUME</code></span></dt><dd><p>接続の残りの応答メッセージを消費しています。
          </p></dd></dl></div><p>

これらの定数は（互換性を保つため）なくなることはありませんが、アプリケーションは、これらが特定の順で出現したり、本書に書いてある値のどれかに必ずステータス値が該当するということを決して当てにしてはいけません。
アプリケーションは、以下に示すようにするべきです。

</p><pre class="programlisting">switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}</pre><p>
      </p><p><code class="function">PQconnectPoll</code>を使用する場合、<code class="literal">connect_timeout</code>接続パラメータは無視されます。
経過時間が長過ぎるかどうかの判定はアプリケーションの責任で行ないます。
さもないと、<code class="function">PQconnectStart</code>の後の<code class="function">PQconnectPoll</code>の繰り返しが<code class="function">PQconnectdb</code>と同じになります。
      </p><p><code class="function">PQconnectStart</code>が非NULLポインタを返した場合、処理を終了する際には、構造体や関連するメモリブロックを始末するために、<code class="function">PQfinish</code>を呼び出さなくてはならないことに注意してください。
この処理は、接続試行が失敗した場合やその試行を中断する場合にも、必ず実行されなければいけません。
      </p></dd><dt id="LIBPQ-PQCONNDEFAULTS"><span class="term"><code class="function">PQconndefaults</code><a id="id-1.7.3.8.2.12.6.1.2" class="indexterm"></a></span></dt><dd><p>デフォルトの接続オプションを返します。
</p><pre class="synopsis">PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* このオプションのキーワード */
    char   *envvar;    /* 代替となる環境変数の名前 */
    char   *compiled;  /* 代替となるコンパイル時に組み込まれたデフォルト値 */
    char   *val;       /* オプションの現在値、もしくは、NULL */
    char   *label;     /* 接続ダイアログ内の当該フィールドのラベル */
    char   *dispchar;  /* 接続ダイアログ内の当該フィールドをどのように表示するかの指示
                          値:
                          ""        入力された値をそのまま表示
                          "*"       値を隠すパスワードフィールド用
                          "D"       デバッグオプション。デフォルトで何も表示しません */
    int     dispsize;  /* ダイアログ用のフィールドの大きさ(文字数単位) */
} PQconninfoOption;</pre><p>
      </p><p>接続オプションの配列を返します。
これは、使用可能な<code class="function">PQconnectdb</code>用オプションのすべてや、その時点でのデフォルト値を決定するために使用することができます。
戻り値は、<code class="structname">PQconninfoOption</code>構造体の配列へのポインタで、<code class="structfield">keyword</code>ポインタがヌルとなる項目が配列の末尾にきます。
メモリが確保できなかった場合にはヌルポインタを返します。
現在のデフォルト値(<code class="structfield">val</code> フィールド）は、環境変数や他のコンテキストに依存します。
呼び出し側では、接続オプションの情報は、読み込み専用として取り扱わなければいけません。
      </p><p>オプションの配列を処理した後は、それを<code class="function">PQconninfoFree</code>に渡して解放します。
この処理をしないと、<code class="function">PQconndefaults</code>が呼び出されるたびに少しずつメモリリークが発生します。
      </p></dd><dt id="LIBPQ-PQCONNINFO"><span class="term"><code class="function">PQconninfo</code><a id="id-1.7.3.8.2.12.7.1.2" class="indexterm"></a></span></dt><dd><p>所在する接続で使用される接続オプションを返します。
</p><pre class="synopsis">PQconninfoOption *PQconninfo(PGconn *conn);</pre><p>
      </p><p>接続オプション配列を返します。これは全ての可能性のある<code class="function">PQconnectdb</code>オプションとサーバに接続するのに使用される値を確定するために使用することができます。
返り値は<code class="structname">PQconninfoOption</code>構造体の配列を指し示します。それはnull <code class="structfield">keyword</code> ポインタを持つ項目で終結します。<code class="function">PQconndefaults</code>に対する上記の全ての注釈はまた<code class="function">PQconninfo</code>の結果に適用されます。
      </p></dd><dt id="LIBPQ-PQCONNINFOPARSE"><span class="term"><code class="function">PQconninfoParse</code><a id="id-1.7.3.8.2.12.8.1.2" class="indexterm"></a></span></dt><dd><p>提供された接続文字列から構文解析された接続オプションを返します。

</p><pre class="synopsis">PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);</pre><p>
      </p><p>接続文字列の構文解析を行い、配列として結果オプションを返すか、または接続文字列に問題があった場合に<code class="symbol">NULL</code>を返します。
この関数を提供された接続文字列の中の<code class="function">PQconnectdb</code>オプションを取り出すために使用することができます。
戻り値は<code class="structname">PQconninfoOption</code>構造体の配列を指し示し、それはヌルの<code class="structfield">keyword</code>ポインタを持つ項目で終結します。
      </p><p>正規なオプションはすべて、結果配列内に現れます。
しかし接続文字列内に現れない、何らかのオプション用の<code class="literal">PQconninfoOption</code>は<code class="literal">NULL</code>に設定された<code class="literal">val</code>を持ちます。
デフォルトは挿入されません。
      </p><p><code class="literal">errmsg</code>が非<code class="symbol">NULL</code>であれば、成功した場合<code class="literal">*errmsg</code>は<code class="symbol">NULL</code>に設定され、そうでなければ、問題を説明した<code class="function">malloc</code>されたエラー文字列になります。
（<code class="literal">*errmsg</code>が<code class="symbol">NULL</code>に設定され、かつ、この関数が<code class="symbol">NULL</code>を返すこともあり得ます。
これはメモリ不足状態を意味します。）
      </p><p>オプション配列を処理した後、それを<code class="function">PQconninfoFree</code>に渡して解放してください。
これが行われない場合、<code class="function">PQconninfoParse</code>へのそれぞれの呼び出しに対してメモリーリークが起こります。
反対に、エラーが起こり、そして<code class="literal">errmsg</code>が非<code class="symbol">NULL</code>であれば、<code class="function">PQfreemem</code>を使用してエラー文字列を必ず解放してください。
      </p></dd><dt id="LIBPQ-PQFINISH"><span class="term"><code class="function">PQfinish</code><a id="id-1.7.3.8.2.12.9.1.2" class="indexterm"></a></span></dt><dd><p>サーバとの接続を閉ざします。
また、<code class="structname">PGconn</code>オブジェクトが占めるメモリも解放します。
</p><pre class="synopsis">void PQfinish(PGconn *conn);</pre><p>
      </p><p>たとえサーバへの接続試行が失敗しても（<code class="function">PQstatus</code>で調べます）、アプリケーションは<code class="function">PQfinish</code>を呼び出し<code class="structname">PGconn</code>オブジェクトが占めるメモリを解放するべきです。
そして<code class="function">PQfinish</code>を呼び出したら、もう<code class="structname">PGconn</code>へのポインタを使ってはいけません。
      </p></dd><dt id="LIBPQ-PQRESET"><span class="term"><code class="function">PQreset</code><a id="id-1.7.3.8.2.12.10.1.2" class="indexterm"></a></span></dt><dd><p>サーバへの通信チャンネルをリセットします。
</p><pre class="synopsis">void PQreset(PGconn *conn);</pre><p>
      </p><p>この関数はサーバへの接続を閉じ、以前使用したパラメータをすべて使用して、同一のサーバへ新しく接続を確立します。
これは、作業中の接続が失われた場合のエラーの修復に役立つでしょう。
      </p></dd><dt id="LIBPQ-PQRESETSTART"><span class="term"><code class="function">PQresetStart</code><a id="id-1.7.3.8.2.12.11.1.2" class="indexterm"></a><br /></span><span class="term"><code class="function">PQresetPoll</code><a id="id-1.7.3.8.2.12.11.2.2" class="indexterm"></a></span></dt><dd><p>非ブロッキング方式で、サーバへの接続チャンネルをリセットします。

</p><pre class="synopsis">int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);</pre><p>
      </p><p>これらの関数はサーバへの接続を閉じ、それから再度、以前使用したパラメータをすべて使用して、同じサーバと新たな接続を確立しようとします。
これらは作業中の接続が失われた場合のエラー修復に役立つでしょう。
<code class="function">PQreset</code>（前述）との違いは、この2つの関数が非ブロック方式で動作することです。
また、これらの関数は<code class="function">PQconnectStartParams</code>、<code class="function">PQconnectStart</code>および<code class="function">PQconnectPoll</code>と同じ制限を受けます。
      </p><p>接続のリセットを始めるためには<code class="function">PQresetStart</code>を呼び出します。
この関数がゼロを返す場合、リセットに失敗しています。
戻り値が1ならば、<code class="function">PQconnectPoll</code>を使って接続を確立した時とまったく同じに、<code class="function">PQresetPoll</code>を使用してリセットのポーリングを行います。
      </p></dd><dt id="LIBPQ-PQPINGPARAMS"><span class="term"><code class="function">PQpingParams</code><a id="id-1.7.3.8.2.12.12.1.2" class="indexterm"></a></span></dt><dd><p><code class="function">PQpingParams</code>はサーバの状態を報告します。
この関数は上述の<code class="function">PQconnectdbParams</code>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

</p><pre class="synopsis">PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);</pre><p>

このサーバは以下の値のいずれかを返します。

       </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQPINGPARAMS-PQPING-OK"><span class="term"><code class="literal">PQPING_OK</code></span></dt><dd><p>サーバは稼動中で、接続を受け付けているようです。
          </p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING-REJECT"><span class="term"><code class="literal">PQPING_REJECT</code></span></dt><dd><p>サーバは稼動中ですが、接続を許可しない状態（起動処理中、停止処理中、クラッシュリカバリ中）です。
          </p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING-NO-RESPONSE"><span class="term"><code class="literal">PQPING_NO_RESPONSE</code></span></dt><dd><p>サーバと通信できません。
これは、サーバが稼動中ではない、指定した接続パラメータの何か（例えばポート番号の間違い）が間違っている、ネットワーク接続性の問題（例えば接続要求をブロックするファイアウォール）があることを示しているかもしれません。
          </p></dd><dt id="LIBPQ-PQPINGPARAMS-PQPING-NO-ATTEMPT"><span class="term"><code class="literal">PQPING_NO_ATTEMPT</code></span></dt><dd><p>指定されたパラメータが明らかに間違っている、または、（メモリ不足など）クライアント側の問題があったため、サーバとの通信を試行しませんでした。
          </p></dd></dl></div><p>

      </p></dd><dt id="LIBPQ-PQPING"><span class="term"><code class="function">PQping</code><a id="id-1.7.3.8.2.12.13.1.2" class="indexterm"></a></span></dt><dd><p><code class="function">PQping</code>はサーバの状態を報告します。
この関数は上述の<code class="function">PQconnectdb</code>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

</p><pre class="synopsis">PGPing PQping(const char *conninfo);</pre><p>
      </p><p>戻り値は<code class="function">PQpingParams</code>と同じです。
      </p></dd></dl></div><p>
  </p><div class="sect2" id="LIBPQ-CONNSTRING"><div class="titlepage"><div><div><h3 class="title">33.1.1. 接続文字列</h3></div></div></div><a id="id-1.7.3.8.3.2" class="indexterm"></a><a id="id-1.7.3.8.3.3" class="indexterm"></a><p>複数の<span class="application">libpq</span>関数は、接続パラメータを得るためにユーザが指定した文字列の解析を行います。
この文字列として、単純な<code class="literal">keyword = value</code>文字列とURIという２種類の書式が受け付けられます。
URIは通常<a class="ulink" href="https://tools.ietf.org/html/rfc3986" target="_top">RFC3986</a>に従いますが、以下で詳細を説明する複数ホスト接続文字列が使用できるところが例外です。
   </p><div class="sect3" id="id-1.7.3.8.3.5"><div class="titlepage"><div><div><h4 class="title">33.1.1.1. キーワード/値形式の接続文字列</h4></div></div></div><p>最初の書式では、各パラメータ設定は<code class="literal">keyword = value</code>という形式です。
等号記号の前後の空白文字は省略可能です。
空の値を書く、または空白文字を含む値を書くためには、<code class="literal">keyword = 'a value'</code>のように単一引用符で値を括ります。
値内部の単一引用符とバックスラッシュはバックスラッシュでエスケープしなければなりません。
つまり<code class="literal">\'</code>と<code class="literal">\\</code>です。
   </p><p>以下に例を示します。
</p><pre class="programlisting">host=localhost port=5432 dbname=mydb connect_timeout=10</pre><p>
   </p><p>有効なパラメータキーワードを<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. パラメータキーワード">Section 33.1.2</a>に示します。
   </p></div><div class="sect3" id="id-1.7.3.8.3.6"><div class="titlepage"><div><div><h4 class="title">33.1.1.2. 接続URI</h4></div></div></div><p>接続<acronym class="acronym">URI</acronym>の一般的な形式を以下に示します。
</p><pre class="synopsis">postgresql://[user[:password]@][netloc][:port][,...][/dbname][?param1=value1&amp;...]</pre><p>
   </p><p><acronym class="acronym">URI</acronym>スキーム指示子は<code class="literal">postgresql://</code>または<code class="literal">postgres://</code>のいずれかを取ることができます。
個々の<acronym class="acronym">URI</acronym>部品は省略可能です。
以下の例で有効な<acronym class="acronym">URI</acronym>構文の使用例を示します。
</p><pre class="programlisting">postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp
postgresql://host1:123,host2:456/somedb?target_session_attrs=any&amp;application_name=myapp</pre><p>
<acronym class="acronym">URI</acronym>の階層部品の要素をパラメータとして与えることができます。
以下に例を示します。
</p><pre class="programlisting">postgresql:///mydb?host=localhost&amp;port=5433</pre><p>
   </p><p>パーセント符号化を使用して、<acronym class="acronym">URI</acronym>部品のいずれかに特殊な意味を持つ記号を含めることができます。
たとえば<code class="literal">=</code>を<code class="literal">%3D</code>で置き換えます。
   </p><p><a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. パラメータキーワード">Section 33.1.2</a>に示されたキーワードに対応しない接続パラメータは無視され、これに関する警告メッセージが<code class="filename">stderr</code>に書き出されます。
   </p><p>JDBCの接続<acronym class="acronym">URI</acronym>構文との互換性を高めるために、<code class="literal">ssl=true</code>パラメータインスタンスは<code class="literal">sslmode=require</code>に変換されます。
   </p><p>ホスト部分にはホスト名またはIPアドレスを書くことができます。
IPv6ホストアドレスを指定するためには角括弧で括ります。
</p><pre class="synopsis">postgresql://[2001:db8::1234]/database</pre><p>
   </p><p>ホスト要素は<a class="xref" href="libpq-connect.html#LIBPQ-CONNECT-HOST">host</a>で説明したように解釈されます。
具体的には、ホスト部品が空またはスラッシュで始まる場合Unixドメインソケット接続が選択され、さもなければTCP/IP接続で初期化されます。
しかしURIの階層部ではスラッシュが予約された文字であることに注意してください。
このため、標準以外のUnixドメインソケットディレクトリを指定するためには、URIからホスト指定を省き、パラメータとしてホストを指定するか、URIのホスト要素内のパスをパーセントエスケープするかどちらかを行ってください。
</p><pre class="programlisting">postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</pre><p>
   </p><p>単一のURIの中に、オプションのポート要素を伴う複数のホスト要素を指定することができます。
<code class="literal">postgresql://host1:port1,host2:port2,host3:port3/</code>という形式のURIは、<code class="literal">host=host1,host2,host3 port=port1,port2,port3</code>という形式の接続文字列と同じです。
接続の確立に成功するまで、各々のホストが順番に試されます。
   </p></div><div class="sect3" id="LIBPQ-MULTIPLE-HOSTS"><div class="titlepage"><div><div><h4 class="title">33.1.1.3. 複数ホストの指定</h4></div></div></div><p>接続先に複数のホストを指定することができ、指定された順に試されます。
キーワード/値形式では、<code class="literal">host</code>、<code class="literal">hostaddr</code>、<code class="literal">port</code>オプションは、カンマで区切った値のリストを受け付けます。
各々のオプションでは、同じ数の要素を与えなければなりません。
たとえば、最初の<code class="literal">hostaddr</code>は最初のホスト名に関連付けられ、二番目の<code class="literal">hostaddr</code>は二番目のホスト名に関連付けられる、という具合です。
例外として、一つの<code class="literal">port</code>だけが指定された場合には、すべてのホストにそれが適用されます。
     </p><p>接続URI形式では、<code class="literal">host</code>要素中にカンマで区切って複数の<code class="literal">host:port</code>ペアを指定できます。
いずれの形式においても、単一のホスト名は複数のネットワークアドレスに変換されることがあります。
よくある例としては、ホストがIPv4とIPv6アドレスの両方を持つ場合です。
     </p><p>複数のホスト名が指定された場合、あるいは単一のホスト名が複数のアドレスに変換された場合、そのうちの一つが成功するまで、すべてのホストとアドレスがその順に試されます。
どのホストも到達可能でなければ、接続は失敗します。
接続の確立に成功しても、認証に失敗すると、リスト中の残りのホストは試されません。
     </p><p>パスワードファイルが使用される場合は、異なるホストに対して異なるパスワードを使用できます。
他の接続オプションは、リスト中のすべてのホストで同じです。
たとえば、異なるユーザ名を異なるホストに指定することはできません。
     </p></div></div><div class="sect2" id="LIBPQ-PARAMKEYWORDS"><div class="titlepage"><div><div><h3 class="title">33.1.2. パラメータキーワード</h3></div></div></div><p>現時点で有効なパラメータのキーワードは以下に示す通りです。

    </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-CONNECT-HOST"><span class="term"><code class="literal">host</code></span></dt><dd><p>接続するホスト名を指定します。
<a id="id-1.7.3.8.4.2.1.1.2.1.1" class="indexterm"></a> ホスト名がスラッシュで始まるならば、TCP/IPによる通信ではなく、Unixドメインの通信を明示することになります。
その場合、この値はソケットファイルを格納するディレクトリの名前になります。
複数のホスト名が指定されると、指定された順に各々が試されます。
<code class="literal">host</code>が指定されなかった場合や、空の場合のデフォルトは、<code class="filename">/tmp</code>にあるUnixドメインのソケットに接続することです。
<a id="id-1.7.3.8.4.2.1.1.2.1.4" class="indexterm"></a> （または、<span class="productname">PostgreSQL</span>の構築時に指定した別のディレクトリにあるソケットです。）
Unixドメインソケットを持たないマシンにおけるデフォルトは、<code class="literal">localhost</code>に接続することです。
       </p><p>カンマで区切ったホスト名も受け付けます。
この場合、リスト中のホスト名が順に試されます。
リスト中の空の項目には、上で説明したデフォルトの挙動が適用されます。
詳細は<a class="xref" href="libpq-connect.html#LIBPQ-MULTIPLE-HOSTS" title="33.1.1.3. 複数ホストの指定">Section 33.1.1.3</a>をご覧ください。
       </p></dd><dt id="LIBPQ-CONNECT-HOSTADDR"><span class="term"><code class="literal">hostaddr</code></span></dt><dd><p>接続するホストのIPアドレスを指定します。
これは、<code class="literal">172.28.40.9</code>といった標準的なIPv4アドレス書式でなければなりません。
使用するマシンでIPv6をサポートする場合は、そのアドレスを使用することもできます。
このパラメータに空以外の文字列が指定されると、TCP/IP通信が常に使用されます。
       </p><p><code class="literal">host</code>の代わりに<code class="literal">hostaddr</code>を使用することで、アプリケーションがホスト名の検索を行なわずに済みます。
特に時間的制約があるアプリケーションでは重要になるでしょう。
しかし、GSSAP、SSPI認証方式では、ホスト名が必要になります。
<code class="literal">verify-full</code>SSL証明書検証を行う場合も同様です。
以下の規則が使用されます。
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">hostaddr</code>を使わずに<code class="literal">host</code>を指定した場合は、ホスト名の検索が発生します。
          </p></li><li class="listitem"><p><code class="literal">host</code>を使わずに<code class="literal">hostaddr</code>を指定した場合、<code class="literal">hostaddr</code>の値はサーバのネットワークアドレスとなります。
認証方式がホスト名を必要する場合は接続試行が失敗します。
          </p></li><li class="listitem"><p><code class="literal">host</code>と<code class="literal">hostaddr</code>の両方を指定した場合、<code class="literal">hostaddr</code>がサーバのネットワークアドレスとなります。
<code class="literal">host</code>の値は認証方式で必要とされない限り無視され、必要とされる場合にはホスト名として使用されます。
          </p></li></ul></div><p>
<code class="literal">host</code>が<code class="literal">hostaddr</code>ネットワークアドレスに対応するマシンの名前と一致しない場合は、認証に失敗する可能性があるので注意してください。
また、<code class="literal">host</code>と<code class="literal">hostaddr</code>の両方が指定されると、<code class="literal">host</code>がパスワードファイル(<a class="xref" href="libpq-pgpass.html" title="33.15. パスワードファイル">Section 33.15</a>を参照)での接続の識別に使用されます。
       </p><p>カンマ区切りの<code class="literal">hostaddrs</code>値のリストも受け付けます。
この場合、リスト中のホストが順に試されます。
リスト中の空の項目には、対応するホスト名が使用されます。
そのホスト名も空の場合は、デフォルトのホスト名が使用されます。
詳細は<a class="xref" href="libpq-connect.html#LIBPQ-MULTIPLE-HOSTS" title="33.1.1.3. 複数ホストの指定">Section 33.1.1.3</a>をご覧ください。
       </p><p>ホスト名もホストのアドレスも用いない場合、<span class="application">libpq</span>はローカルのUnixドメインソケットを使用して接続します。
ただし、Unixドメインソケットを持たないマシンでは、<code class="literal">localhost</code>への接続を試みます。
       </p></dd><dt id="LIBPQ-CONNECT-PORT"><span class="term"><code class="literal">port</code></span></dt><dd><p>サーバホストでの接続用のポート番号、または、Unixドメイン接続の場合は、ソケットファイルの拡張子を指定します。
<a id="id-1.7.3.8.4.2.1.3.2.1.1" class="indexterm"></a>
もし複数のホストが<code class="literal">host</code>あるいは<code class="literal">hostaddr</code>パラメータで与えられると、このパラメータで同じ長さのポートのリストを与えることができます。
あるいは、一つのポート番号をすべてのホストに指定することもできます。
空文字、あるいはカンマ区切りリスト中の空の項目は、<span class="productname">PostgreSQL</span>が構築されたときに設定されたデフォルトポート番号を指定します。
       </p></dd><dt id="LIBPQ-CONNECT-DBNAME"><span class="term"><code class="literal">dbname</code></span></dt><dd><p>データベース名を指定します。
デフォルトはユーザ名と同じです。
特定の文脈では、この値は拡張書式で検査されます。
詳細については<a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="33.1.1. 接続文字列">Section 33.1.1</a>を参照してください。
      </p></dd><dt id="LIBPQ-CONNECT-USER"><span class="term"><code class="literal">user</code></span></dt><dd><p>データベースへ接続する<span class="productname">PostgreSQL</span>ユーザ名を指定します。
デフォルトは、そのアプリケーションを実行しているユーザのオペレーティングシステム上の名前と同じです。
      </p></dd><dt id="LIBPQ-CONNECT-PASSWORD"><span class="term"><code class="literal">password</code></span></dt><dd><p>サーバがパスワードによる認証を必要とした場合に使用されるパスワードを指定します。
      </p></dd><dt id="LIBPQ-CONNECT-PASSFILE"><span class="term"><code class="literal">passfile</code></span></dt><dd><p>パスワードを格納するファイル名を指定します。（<a class="xref" href="libpq-pgpass.html" title="33.15. パスワードファイル">Section 33.15</a>参照。）
デフォルトは<code class="filename">~/.pgpass</code>または、Microsoft Windowsでは<code class="filename">%APPDATA%\postgresql\pgpass.conf</code>です。
（このファイルが存在しなくてもエラーは報告されません。）
      </p></dd><dt id="LIBPQ-CONNECT-CONNECT-TIMEOUT"><span class="term"><code class="literal">connect_timeout</code></span></dt><dd><p>接続用の最大待機時間を秒単位(10進数整数で表した文字列として記述してください)で指定します。
ゼロもしくは未設定は、無限時間の待機を意味します。
2秒未満の待機時間を使用することは勧めません。
      </p></dd><dt id="LIBPQ-CONNECT-CLIENT-ENCODING"><span class="term"><code class="literal">client_encoding</code></span></dt><dd><p>接続用の<code class="varname">client_encoding</code>設定パラメータを設定します。
対応するサーバオプションで受け付けられる値の他に、クライアントにおける現在のロケール（Unixシステムの場合は<code class="envar">LC_CTYPE</code>環境変数）から正しい符号化方式を決定する<code class="literal">auto</code>を使用することができます。
      </p></dd><dt id="LIBPQ-CONNECT-OPTIONS"><span class="term"><code class="literal">options</code></span></dt><dd><p>接続開始時にサーバに送信するコマンドラインオプションを指定します。
例えば、これを<code class="literal">-c geqo=off</code>に設定すると、<code class="varname">geqo</code>パラメータのセッション値は<code class="literal">off</code>になります。
この文字列中の空白はバックスラッシュ(<code class="literal">\</code>)でエスケープされていなければコマンド行引数の区切りであるとみなされます。
リテラルのバックスラッシュを表すには<code class="literal">\\</code>と書いて下さい。
利用可能なオプションに関する詳細については<a class="xref" href="runtime-config.html" title="Chapter 19. サーバの設定">Chapter 19</a>を参照してください。
       </p></dd><dt id="LIBPQ-CONNECT-APPLICATION-NAME"><span class="term"><code class="literal">application_name</code></span></dt><dd><p><a class="xref" href="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</a>設定パラメータの値を指定します。
       </p></dd><dt id="LIBPQ-CONNECT-FALLBACK-APPLICATION-NAME"><span class="term"><code class="literal">fallback_application_name</code></span></dt><dd><p><a class="xref" href="runtime-config-logging.html#GUC-APPLICATION-NAME">application_name</a>設定パラメータの予備値を指定します。
接続パラメータまたは<code class="envar">PGAPPNAME</code>環境変数により<code class="literal">application_name</code>の値が指定されない場合に、この値が使用されます。
予備の名前を指定することは、デフォルトのアプリケーション名を設定したいが、ユーザにもそれを上書きできるようにしておきたい、一般的なユーティリティプログラムで有用です。
       </p></dd><dt id="LIBPQ-KEEPALIVES"><span class="term"><code class="literal">keepalives</code></span></dt><dd><p>クライアント側におけるTCPキープアライブの使用を制御します。
デフォルト値は1であり、有効であることを意味します。
しかしキープアライブを望まない場合は、無効であることを意味するゼロに設定することができます。
このパラメータはUnixドメインソケット経由の接続では無視されます。
       </p></dd><dt id="LIBPQ-KEEPALIVES-IDLE"><span class="term"><code class="literal">keepalives_idle</code></span></dt><dd><p>TCPがサーバにキープアライブメッセージを送信した後に活動を行わない期間を秒単位で制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合もしくはキープアライブが無効な場合、このパラメータは無視されます。
これは<code class="symbol">TCP_KEEPIDLE</code>または同等のソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </p></dd><dt id="LIBPQ-KEEPALIVES-INTERVAL"><span class="term"><code class="literal">keepalives_interval</code></span></dt><dd><p>TCPキープアライブメッセージに対する応答がサーバからない場合に、何秒後に再送を行うかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<code class="symbol">TCP_KEEPINTVL</code>または同等のソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </p></dd><dt id="LIBPQ-KEEPALIVES-COUNT"><span class="term"><code class="literal">keepalives_count</code></span></dt><dd><p>サーバへのクライアント接続が不要になったとみなすまで、何回キープアライブの欠落を認めるかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<code class="symbol">TCP_KEEPCNT</code>または同等のソケットオプションが利用できるシステムでのみサポートされます。
他のシステムでは効果がありません。
       </p></dd><dt id="LIBPQ-CONNECT-TTY"><span class="term"><code class="literal">tty</code></span></dt><dd><p>無視されます(以前は、これはサーバデバッグ出力を送信する場所を指定するものでした)。
      </p></dd><dt id="LIBPQ-CONNECT-SSLMODE"><span class="term"><code class="literal">sslmode</code></span></dt><dd><p>このオプションは、どの<acronym class="acronym">SSL</acronym>による安全なTCP/IP接続の優先度でサーバと調停するかを決定します。
6つのモードがあります。

        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">disable</code></span></dt><dd><p>非<acronym class="acronym">SSL</acronym>接続のみ試行
           </p></dd><dt><span class="term"><code class="literal">allow</code></span></dt><dd><p>最初に非<acronym class="acronym">SSL</acronym>接続を試行し、失敗したら、<acronym class="acronym">SSL</acronym>接続を試行
           </p></dd><dt><span class="term"><code class="literal">prefer</code> （デフォルト）</span></dt><dd><p>最初に<acronym class="acronym">SSL</acronym>接続を試行し、失敗したら、非<acronym class="acronym">SSL</acronym>接続を試行
           </p></dd><dt><span class="term"><code class="literal">require</code></span></dt><dd><p><acronym class="acronym">SSL</acronym>接続のみ試行。
ルートCAファイルが存在する場合、<code class="literal">verify-ca</code>が指定された場合と同じ方法で証明書が検証されます。
           </p></dd><dt><span class="term"><code class="literal">verify-ca</code></span></dt><dd><p><acronym class="acronym">SSL</acronym>接続のみ試行し、サーバ証明書が信用された認証局（<acronym class="acronym">CA</acronym>）から発行されたかを検証
           </p></dd><dt><span class="term"><code class="literal">verify-full</code></span></dt><dd><p><acronym class="acronym">SSL</acronym>接続のみ試行し、サーバ証明書が信用された<acronym class="acronym">CA</acronym>から発行されたか、およびそのサーバホスト名が証明書内のものと一致するかを検証
           </p></dd></dl></div><p>

これらのオプションがどのように動くのかについては<a class="xref" href="libpq-ssl.html" title="33.18. SSLサポート">Section 33.18</a>を参照してください。
       </p><p><code class="literal">sslmode</code>はUnixドメインソケット通信では無視されます。
SSLサポートなしで<span class="productname">PostgreSQL</span>がコンパイルされた場合に、<code class="literal">require</code>、<code class="literal">verify-ca</code>、<code class="literal">verify-full</code>を使用するとエラーになります。
一方、<code class="literal">allow</code>と<code class="literal">prefer</code>は使用できますが、実際に<span class="application">libpq</span>は<acronym class="acronym">SSL</acronym>接続を受け付けません。
<a id="id-1.7.3.8.4.2.1.18.2.2.10" class="indexterm"></a>
       </p></dd><dt id="LIBPQ-CONNECT-REQUIRESSL"><span class="term"><code class="literal">requiressl</code></span></dt><dd><p>このオプションは<code class="literal">sslmode</code>設定を支持する観点から廃止予定になっています。
       </p><p>1に設定することで、サーバへの<acronym class="acronym">SSL</acronym>接続が必要になります
(これは<code class="literal">sslmode</code>の<code class="literal">require</code>と同じです)。
サーバが<acronym class="acronym">SSL</acronym>接続を受け付けない場合、<span class="application">libpq</span>は接続を拒絶します。
0(デフォルト)に設定することで、サーバと接続形式の調停を行います。
(<code class="literal">sslmode</code>の<code class="literal">prefer</code>と同じです。)
SSLサポート付きで<span class="productname">PostgreSQL</span>をコンパイルした場合にのみ、このオプションが利用できます。
       </p></dd><dt id="LIBPQ-CONNECT-SSLCOMPRESSION"><span class="term"><code class="literal">sslcompression</code></span></dt><dd><p>１（デフォルト）に設定することで、SSL接続越えで送信されるデータは圧縮されます（これには<span class="productname">OpenSSL</span>バージョン0.9.8以降が必要です）。
０に設定すると、圧縮が無効になります（これには<span class="productname">OpenSSL</span>1.0.0以降が必要です）。
このパラメータはSSLが確立していない接続や使用される<span class="productname">OpenSSL</span>がサポートしていない場合は無視されます。
       </p><p>圧縮はCPU処理時間を使用しますが、ネットワークが問題である場合はスループットを改良することができます。
CPU性能が制約要因であれば、圧縮を無効にすることで、応答時間やスループットを改良することができます。
       </p></dd><dt id="LIBPQ-CONNECT-SSLCERT"><span class="term"><code class="literal">sslcert</code></span></dt><dd><p>このパラメータは、<code class="filename">~/.postgresql/postgresql.crt</code>というデフォルトを置き換えるクライアントSSL証明書のファイル名を指定します。
このパラメータはSSL接続が確立していない場合は無視されます。
       </p></dd><dt id="LIBPQ-CONNECT-SSLKEY"><span class="term"><code class="literal">sslkey</code></span></dt><dd><p>このパラメータはクライアント証明書に対して使用される秘密鍵の場所を指定します。
デフォルトの<code class="filename">~/.postgresql/postgresql.key</code>の代わりに使用されるファイル名、または外部<span class="quote">“<span class="quote">エンジン</span>”</span>（エンジンとは<span class="productname">OpenSSL</span>ロード可能なモジュール）から得られるキーを指定することも可能です。
外部エンジンの指定にはコロンで区切ったエンジン名とエンジン特有の鍵識別子を含んでいなければなりません。
SSL接続が確立していない場合このパラメータは無視されます。
       </p></dd><dt id="LIBPQ-CONNECT-SSLROOTCERT"><span class="term"><code class="literal">sslrootcert</code></span></dt><dd><p>このパラメータはSSL認証局(<acronym class="acronym">CA</acronym>)の証明書のファイル名を指定します。
このファイルが存在する場合、サーバ証明書はこれらの認証局の1つで署名されているかどうか検証されます。
デフォルトは<code class="filename">~/.postgresql/root.crt</code>です。
       </p></dd><dt id="LIBPQ-CONNECT-SSLCRL"><span class="term"><code class="literal">sslcrl</code></span></dt><dd><p>このパラメータはSSL証明書失効リスト（CRL）のファイル名を指定します。
このファイルに列挙された証明書が存在した場合、それはサーバ証明書を承認しようとする時に拒絶されます。
デフォルトは<code class="filename">~/.postgresql/root.crl</code>です。
       </p></dd><dt id="LIBPQ-CONNECT-REQUIREPEER"><span class="term"><code class="literal">requirepeer</code></span></dt><dd><p>このパラメータは、例えば<code class="literal">requirepeer=postgres</code>のようにサーバのオペレーティングシステムのユーザ名を指定します。
Unixドメインソケット接続を確立する時に、このパラメータが設定された場合、クライアントは接続開始時にサーバプロセスが指定されたユーザ名で稼動しているか検査し、稼動していない場合は接続をエラーとして中断します。
このパラメータは、TCP/IP接続においてSSL証明書で実現するようなサーバ認証を実現するために使用することができます。
（Unixドメインソケットが<code class="filename">/tmp</code>などの誰にでも書き込むことができる場所にある場合、誰でもそこで接続を監視するサーバを起動できることに注意してください。
信頼できるユーザが起動したサーバに接続することを確実に行うために、このパラメータを使用してください。）
このオプションは<code class="literal">peer</code>認証方式が実装されたプラットフォームでのみでサポートされます。
<a class="xref" href="auth-methods.html#AUTH-PEER" title="20.3.6. Peer認証">Section 20.3.6</a>を参照してください。
       </p></dd><dt id="LIBPQ-CONNECT-KRBSRVNAME"><span class="term"><code class="literal">krbsrvname</code></span></dt><dd><p>GSSAPIの認証時に使われるKerberosサービス名です。
成功するためには、これはサーバのKerberos認証設定のサービス名と一致していなければなりません。
(<a class="xref" href="auth-methods.html#GSSAPI-AUTH" title="20.3.3. GSSAPI認証">Section 20.3.3</a>も参照してください。)
       </p></dd><dt id="LIBPQ-CONNECT-GSSLIB"><span class="term"><code class="literal">gsslib</code></span></dt><dd><p>GSSAPI認証で使用されるGSSライブラリです。
Windows上のみで使用されます。
libpqの認証がデフォルトのSSPIではなく、強制的にGSSAPIライブラリを使用させるには<code class="literal">gssapi</code>を設定してください。
       </p></dd><dt id="LIBPQ-CONNECT-SERVICE"><span class="term"><code class="literal">service</code></span></dt><dd><p>追加のパラメータ用に使用されるサービス名です。
<code class="filename">pg_service.conf</code>内の追加的な接続パラメータを保持するサービス名を指定します。
これによりアプリケーションはサービス名だけを指定でき、接続パラメータを集中的に保守できるようになります。
<a class="xref" href="libpq-pgservice.html" title="33.16. 接続サービスファイル">Section 33.16</a>を参照してください。
       </p></dd><dt id="LIBPQ-CONNECT-TARGET-SESSION-ATTRS"><span class="term"><code class="literal">target_session_attrs</code></span></dt><dd><p>このパラメータが<code class="literal">read-write</code>なら、読み書きトランザクションがデフォルトで許容される接続だけが受付可能になります。
接続に成功すると、問合せ<code class="literal">SHOW transaction_read_only</code>が送られ、<code class="literal">on</code>が返ると接続は閉じられます。
接続文字列で複数のホストが指定されている場合は、あたかも接続の試みが失敗したかのように、残りのサーバが試されます。
このパラメータのデフォルト値は<code class="literal">any</code>で、すべての接続が受付可能であると見なされます。
      </p></dd></dl></div><p>
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-status.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 33. <span class="application">libpq</span> - C ライブラリ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 33.2. 接続状態関数</td></tr></table></div></body></html>