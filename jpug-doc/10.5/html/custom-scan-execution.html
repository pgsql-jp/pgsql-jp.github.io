<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>58.3. カスタムスキャンの実行</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="custom-scan-plan.html" title="58.2. カスタムスキャン計画の作成" /><link rel="next" href="geqo.html" title="Chapter 59. 遺伝的問い合わせ最適化" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">58.3. カスタムスキャンの実行</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="custom-scan-plan.html" title="58.2. カスタムスキャン計画の作成">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="custom-scan.html" title="Chapter 58. カスタムスキャンプロバイダの作成">Up</a></td><th width="60%" align="center">Chapter 58. カスタムスキャンプロバイダの作成</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="geqo.html" title="Chapter 59. 遺伝的問い合わせ最適化">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="CUSTOM-SCAN-EXECUTION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">58.3. カスタムスキャンの実行</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="custom-scan-execution.html#CUSTOM-SCAN-EXECUTION-CALLBACKS">58.3.1. カスタムスキャン実行のコールバック</a></span></dt></dl></div><p><code class="structfield">CustomScan</code>が実行されるとき、その実行状態は<code class="structfield">CustomScanState</code>で表現されます。
これは次のように宣言されています。
</p><pre class="programlisting">typedef struct CustomScanState
{
    ScanState ss;
    uint32    flags;
    const CustomExecMethods *methods;
} CustomScanState;</pre><p>
  </p><p><code class="structfield">ss</code>は他のすべてのスキャン状態と同じく初期化されますが、スキャンがベースリレーションではなく結合を対象にしているときは例外で、<code class="literal">ss.ss_currentRelation</code>はNULLのままになります。
<code class="structfield">flags</code>は<code class="structname">CustomPath</code>および<code class="structname">CustomScan</code>と同じ意味のビットマスクです。
<code class="structfield">methods</code>は必要なカスタムスキャン状態のメソッドを実装するオブジェクト（通常は静的に割り当てられる）を指していなければなりません。
これについては以下で詳しく説明します。
<code class="structname">CustomScanState</code>は<code class="function">copyObject</code>をサポートしなくてもよく、典型的には上記を先頭のメンバーとして組み込んだより大きな構造体になっています。
  </p><div class="sect2" id="CUSTOM-SCAN-EXECUTION-CALLBACKS"><div class="titlepage"><div><div><h3 class="title">58.3.1. カスタムスキャン実行のコールバック</h3></div></div></div><pre class="programlisting">void (*BeginCustomScan) (CustomScanState *node,
                         EState *estate,
                         int eflags);</pre><p>
提供された<code class="structname">CustomScanState</code>の初期化を完了します。
標準的なフィールドは<code class="function">ExecInitCustomScan</code>で初期化が済んでいますが、プライベートフィールドはここで初期化されます。
   </p><pre class="programlisting">TupleTableSlot *(*ExecCustomScan) (CustomScanState *node);</pre><p>
次のスキャンタプルをフェッチします。
タプルが残っている場合は、現在のスキャン方向で次にあるタプルを<code class="literal">ps_ResultTupleSlot</code>に入れます。
タプルが残っていないときは、<code class="literal">NULL</code>または空のスロットが戻されます。
   </p><pre class="programlisting">void (*EndCustomScan) (CustomScanState *node);</pre><p>
<code class="literal">CustomScanState</code>に関連付けられたプライベートデータを整理します。
このメソッドは必須ですが、関連付けられたデータがない場合、あるいはそれが自動的に整理される場合は、このメソッドは何もする必要はありません。
   </p><pre class="programlisting">void (*ReScanCustomScan) (CustomScanState *node);</pre><p>
現在のスキャンを先頭まで巻き戻し、リレーションの再スキャンの準備をします。
   </p><pre class="programlisting">void (*MarkPosCustomScan) (CustomScanState *node);</pre><p>
現在のスキャン位置を保存し、後で<code class="function">RestrPosCustomScan</code>コールバックでリストアできるようにします。
このコールバックは必須ではなく、<code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>フラグがセットされている場合にのみ、提供する必要があります。
   </p><pre class="programlisting">void (*RestrPosCustomScan) (CustomScanState *node);</pre><p>
<code class="function">MarkPosCustomScan</code>コールバックで保存された以前のスキャン位置をリストアします。
このコールバックは必須ではなく、<code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>フラグがセットされている場合にのみ、提供する必要があります。
   </p><pre class="programlisting">Size (*EstimateDSMCustomScan) (CustomScanState *node,
                               ParallelContext *pcxt);</pre><p>
並列操作に要求される動的共有メモリの使用量を予測します。
使用を予測される量よりも多い量の結果が返しても良いですが、少なく返してはいけません。
返り値の単位はバイトとなります。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </p><pre class="programlisting">void (*InitializeDSMCustomScan) (CustomScanState *node,
                                 ParallelContext *pcxt,
                                 void *coordinate);</pre><p>
並列操作に要求される動的共有メモリを初期化します。
<code class="literal">coordinate</code>は、<code class="function">EstimateDSMCustomScan</code>の返り値と大きさが一致する動的共有メモリ領域を指します。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </p><pre class="programlisting">void (*ReInitializeDSMCustomScan) (CustomScanState *node,
                                   ParallelContext *pcxt,
                                   void *coordinate);</pre><p>
カスタムスキャンプランノードが再スキャンしようとするときに、並列操作に必要な動的共有メモリを再初期化します。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
推奨する使い方としては、<code class="function">ReScanCustomScan</code>コールバックはローカル状態だけをリセットし、このコールバックは共有状態だけをリセットするようにします。
今のところ、このコールバックは<code class="function">ReScanCustomScan</code>の前に呼ばれますが、この順序関係には依存しない方が良いです。
   </p><pre class="programlisting">void (*InitializeWorkerCustomScan) (CustomScanState *node,
                                    shm_toc *toc,
                                    void *coordinate);</pre><p>
<code class="literal">InitializeDSMCustomScan</code>によりリーダーにて設定された共有状態を元に、並列ワーカーのローカル状態を初期化します。
このコールバックは必須ではなく、カスタムスキャンプロバイダが並列実行をサポートする場合にのみ提供される必要があります。
   </p><pre class="programlisting">void (*ShutdownCustomScan) (CustomScanState *node);</pre><p>
ノードが実行を完了しないと思われるときに、リソースを解放します。
これはすべての場合に呼ばれるわけではありません。
ときには、この関数がまず呼ばれることなしに、<code class="literal">EndCustomScan</code>が呼ばれるかもしれません。
パラレルクエリで使用されるDSMセグメントは、このコールバックが呼ばれた直後に削除されるので、DSMセグメントが削除される前に何らかのアクションを起こしたいカスタムスキャンプロバイダは、このメソッドを実装すべきです。
   </p><pre class="programlisting">void (*ExplainCustomScan) (CustomScanState *node,
                           List *ancestors,
                           ExplainState *es);</pre><p>
カスタムスキャンの計画ノードの<code class="command">EXPLAIN</code>について追加情報を出力します。
このコールバックは必須ではありません。
対象のリストやスキャンのリレーションなど<code class="structname">ScanState</code>に格納される共通データは、このコールバックがなくても表示されますが、このコールバックにより、追加のプライベートな状態が表示できるようになります。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-scan-plan.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="custom-scan.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="geqo.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">58.2. カスタムスキャン計画の作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 59. 遺伝的問い合わせ最適化</td></tr></table></div></body></html>