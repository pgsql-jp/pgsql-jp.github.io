<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>37.9. C言語関数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="xfunc-internal.html" title="37.8. 内部関数" /><link rel="next" href="xaggr.html" title="37.10. ユーザ定義の集約" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">37.9. C言語関数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="xfunc-internal.html" title="37.8. 内部関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="Chapter 37. SQLの拡張">Up</a></td><th width="60%" align="center">Chapter 37. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>の拡張</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="xaggr.html" title="37.10. ユーザ定義の集約">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="XFUNC-C"><div class="titlepage"><div><div><h2 class="title" style="clear: both">37.9. C言語関数</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="xfunc-c.html#XFUNC-C-DYNLOAD">37.9.1. 動的ロード</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#XFUNC-C-BASETYPE">37.9.2. C言語関数における基本型</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.7">37.9.3. Version 1 呼び出し規約</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.8">37.9.4. コードの作成</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#DFUNC">37.9.5. 動的にロードされる関数のコンパイルとリンク</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.10">37.9.6. 複合型引数</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.11">37.9.7. 行（複合型）を返す</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#XFUNC-C-RETURN-SET">37.9.8. 集合を返す</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.13">37.9.9. 引数と戻り値の多様性</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#XFUNC-TRANSFORM-FUNCTIONS">37.9.10. 変形関数</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#id-1.8.3.12.15">37.9.11. 共有メモリとLWLocks</a></span></dt><dt><span class="sect2"><a href="xfunc-c.html#EXTEND-CPP">37.9.12. 拡張へのC++の利用</a></span></dt></dl></div><a id="id-1.8.3.12.2" class="indexterm"></a><p>ユーザ定義の関数はC（もしくはC++のようなCと互換性のある言語）で作成することができます。
そのような関数は動的ロード可能オブジェクト（共有ライブラリとも呼ばれます）としてコンパイルされ、必要に応じてサーバにロードされます。
動的ロード機能が、<span class="quote">“<span class="quote">C言語</span>”</span>関数を<span class="quote">“<span class="quote">内部</span>”</span>関数と区別するものです。
コーディング方法は基本的に両方とも同じです。
（したがって、標準内部関数ライブラリはユーザ定義のC関数のコーディング例の豊富な情報源となります。）
   </p><p>現在、1つの呼び出し規約だけがC関数で使用されています(<span class="quote">“<span class="quote">version 1</span>”</span>)。
その呼び出し規約をサポートしていることは、以下に示すように、その関数用に呼び出しマクロ<code class="literal">PG_FUNCTION_INFO_V1()</code>を書くことで示されます。
   </p><div class="sect2" id="XFUNC-C-DYNLOAD"><div class="titlepage"><div><div><h3 class="title">37.9.1. 動的ロード</h3></div></div></div><a id="id-1.8.3.12.5.2" class="indexterm"></a><p>特定のロード可能オブジェクト内のユーザ定義の関数がセッションで最初に呼び出されると、動的ローダは、その関数を呼び出すことができるように、オブジェクトファイルをメモリ内に読み込みます。
そのため、ユーザ定義のC関数用の<code class="command">CREATE FUNCTION</code>はその関数について、ロード可能オブジェクトファイルの名前とオブジェクトファイル中の呼び出される特定の関数のC名称（リンクシンボル）という2つの情報を指定しなければなりません。
C名称が明示的に指定されなかった場合、SQLにおける関数名と同じものと仮定されます。
   </p><p><code class="command">CREATE FUNCTION</code>コマンドで与えられた名前に基づいて、共有オブジェクトファイルの場所を見つける際に以下のアルゴリズムが使用されます。

    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>名前が絶対パスの場合、指定されたファイルが読み込まれます。
      </p></li><li class="listitem"><p>名前が<code class="literal">$libdir</code>という文字列から始まる場合、その部分は<span class="productname">PostgreSQL</span>パッケージのライブラリディレクトリで置き換えられます。
このディレクトリはビルド時に決定されます。
<a id="id-1.8.3.12.5.4.2.2.1.3" class="indexterm"></a>
      </p></li><li class="listitem"><p>名前にディレクトリ部分がない場合、そのファイルは<a class="xref" href="runtime-config-client.html#GUC-DYNAMIC-LIBRARY-PATH">dynamic_library_path</a>設定変数で指定されたパス内から検索されます。
<a id="id-1.8.3.12.5.4.2.3.1.2" class="indexterm"></a>
      </p></li><li class="listitem"><p>上記以外の場合（ファイルがパス内に存在しない場合や相対ディレクトリ部分を持つ場合）、動的ローダは指定された名前をそのまま使用し、ほとんどの場合は失敗します。
（これは現在の作業ディレクトリに依存するため信頼できません。）
      </p></li></ol></div><p>

ここまでの流れがうまくいかなかった場合、プラットフォーム独自の共有ライブラリファイル拡張子（多くの場合<code class="filename">.so</code>）が指定された名前に追加され、再度この流れを試みます。
同様に失敗した場合は、読み込みは失敗します。
   </p><p>共有ライブラリを<code class="literal">$libdir</code>から相対的に、もしくは動的ライブラリパスの通った所に配置することを推奨します。
異なる場所に新しいインストレーションを配置する場合にバージョンアップを簡単にします。
<code class="literal">$libdir</code>が示す実際のディレクトリは<code class="literal">pg_config --pkglibdir</code>コマンドを使用することでわかります。
   </p><p><span class="productname">PostgreSQL</span>サーバの実効ユーザIDはロード予定のファイルのパスまで到達できなければなりません。
よくある失敗として、<span class="systemitem">postgres</span>ユーザに対して読み込み、実行、または両方の権限がそのファイルとその上位ディレクトリに与えられていないことがあります。
   </p><p>どの場合でも、<code class="command">CREATE FUNCTION</code>コマンドに与えたファイル名はそのままシステムカタログに保存されます。
ですので、もしそのファイルを再度読み込む必要がある場合、同じ処理が適用されます。
   </p><div class="note"><h3 class="title">Note</h3><p><span class="productname">PostgreSQL</span>はC関数を自動的にコンパイルしません。
<code class="command">CREATE FUNCTION</code>コマンドで参照する前に、そのオブジェクトファイルはコンパイルされていなければなりません。
さらなる情報については<a class="xref" href="xfunc-c.html#DFUNC" title="37.9.5. 動的にロードされる関数のコンパイルとリンク">Section 37.9.5</a>を参照してください。
    </p></div><a id="id-1.8.3.12.5.9" class="indexterm"></a><p>確実に、動的にロードされるモジュールが互換性がないサーバにロードされないように、<span class="productname">PostgreSQL</span>は、そのファイルに適切な内容を持つ<span class="quote">“<span class="quote">マジックブロック</span>”</span>が含まれているかどうか検査します。
これによりサーバは、メジャーバージョンが異なる<span class="productname">PostgreSQL</span>用にコンパイルされたモジュールなど、明確に互換性がないことを検知することができます。
マジックブロックは<span class="productname">PostgreSQL</span> 8.2から要求されています。
マジックブロックを含めるためには、以下をモジュールのソースファイルに一度（一度だけ）、<code class="filename">fmgr.h</code>ヘッダファイルをincludeさせた後で、記述してください。

</p><pre class="programlisting">#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif</pre><p>

そのコードをリリース8.2より前の<span class="productname">PostgreSQL</span>用にコンパイルする必要がなければ、<code class="literal">#ifdef</code>テストを省略することができます。
   </p><p>最初に使用された後も、動的にロードされたオブジェクトファイルはメモリ内に保持されます。
同一セッションにおいてそのファイル内の関数をその後に呼び出した場合、シンボルテーブルの検索に要する小さなオーバーヘッドしかかかりません。
例えば再コンパイルした後など、そのオブジェクトファイルを強制的に再度読み込ませる必要がある場合は、新しいセッションを開始してください。
   </p><a id="id-1.8.3.12.5.12" class="indexterm"></a><a id="id-1.8.3.12.5.13" class="indexterm"></a><a id="id-1.8.3.12.5.14" class="indexterm"></a><a id="id-1.8.3.12.5.15" class="indexterm"></a><p>省略することもできますが、動的にロードされるファイルに初期化処理関数と最終処理関数を含めることができます。
<code class="function">_PG_init</code>という関数がファイルに存在すると、この関数はファイルがロードされた直後に呼び出されます。
この関数は引数を取らずvoid型を返さなければなりません。
<code class="function">_PG_fini</code>という関数がファイルに存在すると、この関数はファイルがアンロードされる直前に呼び出されます。
この関数も同様に引数を取らずvoid型を返さなければなりません。
<code class="function">_PG_fini</code>がファイルのアンロード時にのみ呼び出されるものであり、処理の終了時に呼び出されるものではないことに注意してください。
（現在、アンロードは無効となっていますので、決して発生しません。将来変更される可能性があります。）
   </p></div><div class="sect2" id="XFUNC-C-BASETYPE"><div class="titlepage"><div><div><h3 class="title">37.9.2. C言語関数における基本型</h3></div></div></div><a id="id-1.8.3.12.6.2" class="indexterm"></a><p>C言語関数の作成方法を理解するためには、<span class="productname">PostgreSQL</span>が基本データ型を内部でどのように表現し、どのようにそれらを関数とやり取りしているかを理解する必要があります。
内部的に<span class="productname">PostgreSQL</span>は基本型を<span class="quote">“<span class="quote">メモリの小さな塊</span>”</span>とみなします。
ある型を定義するユーザ定義関数は、言い換えると、<span class="productname">PostgreSQL</span>がそれを操作できる方法を定義します。
つまり、<span class="productname">PostgreSQL</span>はデータの格納、ディスクからの取り出しのみを行い、データの入力や処理、出力にはユーザ定義関数を使用します。
    </p><p>基本型は下記の3つのいずれかの内部書式を使用しています。

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>固定長の値渡し
       </p></li><li class="listitem"><p>固定長の参照渡し
       </p></li><li class="listitem"><p>可変長の参照渡し
       </p></li></ul></div><p>
    </p><p>値渡しは、1、2、4バイト長の型のみで使用することができます（使用するマシンの<code class="literal">sizeof(Datum)</code>が8の場合は8バイトも使用できます）。
データ型を定義する際、その型がすべてのアーキテクチャにおいて同一の大きさ（バイト数）となるように定義するように注意してください。
例えば、<code class="literal">long</code>型はマシンによっては4バイトであったり、8バイトであったりして危険ですが、<code class="type">int</code>型はほとんどのUnixマシンでは4バイトです。
Unixマシンにおける<code class="type">int4</code>の理論的な実装は以下のようになります。

</p><pre class="programlisting">/* 4 バイト整数、値渡し */
typedef int int4;</pre><p>

（実際のPostgreSQLのCコードではこの型を<code class="type">int32</code>と呼びます。
<code class="type">int<em class="replaceable"><code>XX</code></em></code>が<em class="replaceable"><code>XX</code></em> <span class="emphasis"><em>ビット</em></span>であることはCにおける規約だからです。
したがって<code class="type">int8</code>というCの型のサイズは１バイトであることに注意してください。
<code class="type">int8</code>というSQLの型はCでは<code class="type">int64</code>と呼ばれます。
<a class="xref" href="xfunc-c.html#XFUNC-C-TYPE-TABLE" title="Table 37.1. 組み込みSQL型に相当するCの型">Table 37.1</a>も参照してください。）
    </p><p>一方、任意の大きさの固定長の型は参照として引き渡すことができます。
例として以下に<span class="productname">PostgreSQL</span>の型の実装サンプルを示します。

</p><pre class="programlisting">/* 16 バイト構造体、参照渡し */
typedef struct
{
    double  x, y;
} Point;</pre><p>

それらの型のポインタのみが<span class="productname">PostgreSQL</span>関数の入出力時に使用できます。
それらの型の値を返すためには、<code class="literal">palloc()</code>を使用して正しい大きさのメモリ領域を割り当て、そのメモリ領域に値を入力し、それのポインタを返します。
（また、入力引数の1つと同じ型かつ同じ値を返したいのであれば、<code class="literal">palloc</code>を行う手間を省くことができます。
この場合は入力値へのポインタを単に返してください。）
    </p><p>最後に、すべての可変長型は参照として引き渡す必要があります。
また、すべての可変長型は正確に4バイトの不透明なlengthフィールドから始まる必要があります。
このフィールドは<code class="symbol">SET_VARSIZE</code>で設定されます。決して直接このフィールドを設定してはいけません。
その型に格納されるすべてのデータはlengthフィールドのすぐ後のメモリ領域に置かれる必要があります。
lengthフィールドにはその構造体の総長が格納されます。つまり、lengthフィールドそのものもその大きさに含まれます。
    </p><p>この他の重要な点は、データ型の値の中で初期化されていないビットを残さないことです。
例えば、構造体内に存在する可能性がある整列用のパディングバイトを注意してすべてゼロクリアしてください。
こうしないと、独自データ型の論理的に等価な定数がプランナにより一致しないものと判断され、（不正確ではありませんが）非効率的な計画をもたらすかもしれません。
    </p><div class="warning"><h3 class="title">Warning</h3><p>参照渡しの入力値の内容を<span class="emphasis"><em>決して</em></span>変更しないでください。
指定したポインタがディスクバッファを直接指し示している可能性がよくありますので、変更すると、ディスク上のデータを破壊してしまうかもしれません。
この規則の唯一の例外について<a class="xref" href="xaggr.html" title="37.10. ユーザ定義の集約">Section 37.10</a>で説明します。
     </p></div><p>例えば、<code class="type">text</code>型を定義するには、下記のように行えます。

</p><pre class="programlisting">typedef struct {
    int32 length;
    char data[FLEXIBLE_ARRAY_MEMBER];
} text;</pre><p>

<code class="literal">[FLEXIBLE_ARRAY_MEMBER]</code>表記は、データ部分の実際の長さはこの宣言では指定されないことを意味します。
    </p><p>可変長型を操作する時、正確な大きさのメモリを割り当て、lengthフィールドを正確に設定することに注意する必要があります。
例えば、40バイトを<code class="structname">text</code>構造体に保持させたい場合、下記のようなコードを使用します。

</p><pre class="programlisting">#include "postgres.h"
...
char buffer[40]; /* 私たちの元のデータ */
...
text *destination = (text *) palloc(VARHDRSZ + 40);
SET_VARSIZE(destination, VARHDRSZ + 40);
memcpy(destination-&gt;data, buffer, 40);
...</pre><p>

<code class="literal">VARHDRSZ</code>は<code class="literal">sizeof(int32)</code>と同一ですが、可変長型のオーバーヘッド分の大きさを参照する時には、<code class="literal">VARHDRSZ</code>マクロを使用する方が好ましい形式とみなされています。
また長さフィールドを単なる代入ではなく<code class="literal">SET_VARSIZE</code>マクロを使用して設定<span class="emphasis"><em>しなければなりません</em></span>。
    </p><p><a class="xref" href="xfunc-c.html#XFUNC-C-TYPE-TABLE" title="Table 37.1. 組み込みSQL型に相当するCの型">Table 37.1</a>は、<span class="productname">PostgreSQL</span>の組み込み型を使用するC言語関数を作成する時の、Cの型とSQL型との対応を規定したものです。
<span class="quote">“<span class="quote">定義場所</span>”</span>列では、型定義を取り出すためにインクルードしなければならないヘッダファイルを示しています。
（実際の定義は一覧中のファイルからインクルードされた、別のファイルであるかもしれません。
ユーザは定義されたインタフェースを厳守することを推奨されています。）
<code class="filename">postgres.h</code>には必ず必要になる多くのものが宣言されていますので、ソースファイルの中で必ず初めにこのファイルをインクルードしなければならないことに注意してください。
    </p><div class="table" id="XFUNC-C-TYPE-TABLE"><p class="title"><strong>Table 37.1. 組み込みSQL型に相当するCの型</strong></p><div class="table-contents"><table class="table" summary="組み込みSQL型に相当するCの型" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>SQL型
         </th><th>C 言語型
         </th><th>定義場所
         </th></tr></thead><tbody><tr><td><code class="type">abstime</code></td><td><code class="type">AbsoluteTime</code></td><td><code class="filename">utils/nabstime.h</code></td></tr><tr><td><code class="type">bigint</code> (<code class="type">int8</code>)</td><td><code class="type">int64</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">boolean</code></td><td><code class="type">bool</code></td><td><code class="filename">postgres.h</code>（コンパイラで組み込み済みの可能性があります）</td></tr><tr><td><code class="type">box</code></td><td><code class="type">BOX*</code></td><td><code class="filename">utils/geo_decls.h</code></td></tr><tr><td><code class="type">bytea</code></td><td><code class="type">bytea*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">"char"</code></td><td><code class="type">char</code></td><td>（コンパイラで組み込み済み）</td></tr><tr><td><code class="type">character</code></td><td><code class="type">BpChar*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">cid</code></td><td><code class="type">CommandId</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">date</code></td><td><code class="type">DateADT</code></td><td><code class="filename">utils/date.h</code></td></tr><tr><td><code class="type">smallint</code> (<code class="type">int2</code>)</td><td><code class="type">int16</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">int2vector</code></td><td><code class="type">int2vector*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">integer</code> (<code class="type">int4</code>)</td><td><code class="type">int32</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">real</code> (<code class="type">float4</code>)</td><td><code class="type">float4*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">double precision</code> (<code class="type">float8</code>)</td><td><code class="type">float8*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">interval</code></td><td><code class="type">Interval*</code></td><td><code class="filename">datatype/timestamp.h</code></td></tr><tr><td><code class="type">lseg</code></td><td><code class="type">LSEG*</code></td><td><code class="filename">utils/geo_decls.h</code></td></tr><tr><td><code class="type">name</code></td><td><code class="type">Name</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">oid</code></td><td><code class="type">Oid</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">oidvector</code></td><td><code class="type">oidvector*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">path</code></td><td><code class="type">PATH*</code></td><td><code class="filename">utils/geo_decls.h</code></td></tr><tr><td><code class="type">point</code></td><td><code class="type">POINT*</code></td><td><code class="filename">utils/geo_decls.h</code></td></tr><tr><td><code class="type">regproc</code></td><td><code class="type">regproc</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">reltime</code></td><td><code class="type">RelativeTime</code></td><td><code class="filename">utils/nabstime.h</code></td></tr><tr><td><code class="type">text</code></td><td><code class="type">text*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">tid</code></td><td><code class="type">ItemPointer</code></td><td><code class="filename">storage/itemptr.h</code></td></tr><tr><td><code class="type">time</code></td><td><code class="type">TimeADT</code></td><td><code class="filename">utils/date.h</code></td></tr><tr><td><code class="type">time with time zone</code></td><td><code class="type">TimeTzADT</code></td><td><code class="filename">utils/date.h</code></td></tr><tr><td><code class="type">timestamp</code></td><td><code class="type">Timestamp*</code></td><td><code class="filename">datatype/timestamp.h</code></td></tr><tr><td><code class="type">tinterval</code></td><td><code class="type">TimeInterval</code></td><td><code class="filename">utils/nabstime.h</code></td></tr><tr><td><code class="type">varchar</code></td><td><code class="type">VarChar*</code></td><td><code class="filename">postgres.h</code></td></tr><tr><td><code class="type">xid</code></td><td><code class="type">TransactionId</code></td><td><code class="filename">postgres.h</code></td></tr></tbody></table></div></div><br class="table-break" /><p>ここまでで基本型に関してあり得る構造体のすべてを記述しましたので、実際の関数の例をいくつか示すことができます。
    </p></div><div class="sect2" id="id-1.8.3.12.7"><div class="titlepage"><div><div><h3 class="title">37.9.3. Version 1 呼び出し規約</h3></div></div></div><p>Version-1呼び出し規約では、引数と結果の引き渡しの複雑さをなくすためにマクロを使用しています。
Version-1関数のC言語宣言は必ず下記のように行います。
</p><pre class="programlisting">Datum funcname(PG_FUNCTION_ARGS)</pre><p>
     さらに、マクロ呼び出し
</p><pre class="programlisting">PG_FUNCTION_INFO_V1(funcname);</pre><p>
が同じソースファイルに書かれている必要があります。
（一般には、関数の直前に書かれます。）
<span class="productname">PostgreSQL</span>ではすべての内部関数はVersion-1であると認識するので、このマクロの呼び出しは<code class="literal">internal</code>言語関数では必要ありません。
しかし、動的にロードされる関数では必要です。
    </p><p>Version-1関数では、それぞれの実引数は、引数のデータ型に合った<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>()</code>マクロを使用して取り出されます。
厳格でない関数では、<code class="function">PG_ARGNULL_<em class="replaceable"><code>xxx</code></em>()</code>を使って引数がNULLかどうか事前に確認することが必要です。
結果は戻り値の型に合った<code class="function">PG_RETURN_<em class="replaceable"><code>xxx</code></em>()</code>マクロを使用して返されます。
<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>()</code>は、その引数として、取り出す関数引数の番号（ゼロから始まります）を取ります。
<code class="function">PG_RETURN_<em class="replaceable"><code>xxx</code></em>()</code>は、その引数として、実際に返す値を取ります。
    </p><p>Version-1呼出し規約を使った例をいくつか以下に示します。
    </p><pre class="programlisting">#include "postgres.h"
#include &lt;string.h&gt;
#include "fmgr.h"
#include "utils/geo_decls.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

/* 値渡し */

PG_FUNCTION_INFO_V1(add_one);

Datum
add_one(PG_FUNCTION_ARGS)
{
    int32   arg = PG_GETARG_INT32(0);

    PG_RETURN_INT32(arg + 1);
}

/* 固定長の参照渡し */

PG_FUNCTION_INFO_V1(add_one_float8);

Datum
add_one_float8(PG_FUNCTION_ARGS)
{
    /* FLOAT8用のマクロは参照渡しという性質を隠します */
    float8   arg = PG_GETARG_FLOAT8(0);

    PG_RETURN_FLOAT8(arg + 1.0);
}

PG_FUNCTION_INFO_V1(makepoint);

Datum
makepoint(PG_FUNCTION_ARGS)
{
    /* ここのPoint型の参照渡しという性質は隠されていません */
    Point     *pointx = PG_GETARG_POINT_P(0);
    Point     *pointy = PG_GETARG_POINT_P(1);
    Point     *new_point = (Point *) palloc(sizeof(Point));

    new_point-&gt;x = pointx-&gt;x;
    new_point-&gt;y = pointy-&gt;y;

    PG_RETURN_POINT_P(new_point);
}

/* 可変長の参照渡し */

PG_FUNCTION_INFO_V1(copytext);

Datum
copytext(PG_FUNCTION_ARGS)
{
    text     *t = PG_GETARG_TEXT_PP(0);

    /*
     * VARSIZEは、そのヘッダのVARHDRSZまたはVARHDRSZ_SHORTを引いた
     * 構造体の総長をバイト数で表したものです。
     * 完全な長さのヘッダと合わせたコピーを作成します。
     */
    text     *new_t = (text *) palloc(VARSIZE_ANY_EXHDR(t) + VARHDRSZ);
    SET_VARSIZE(new_t, VARSIZE_ANY_EXHDR(t) + VARHDRSZ);

    /*
     * VARDATAは新しい構造体のデータ領域へのポインタです。
     * コピー元はshortデータかもしれませんので、VARDATA_ANYでデータを取り出します。
     */
    memcpy((void *) VARDATA(new_t), /* コピー先 */
           (void *) VARDATA_ANY(t), /* コピー元 */
           VARSIZE_ANY_EXHDR(t));   /* バイト数 */
    PG_RETURN_TEXT_P(new_t);
}

PG_FUNCTION_INFO_V1(concat_text);

Datum
concat_text(PG_FUNCTION_ARGS)
{
    text  *arg1 = PG_GETARG_TEXT_PP(0);
    text  *arg2 = PG_GETARG_TEXT_PP(1);
    int32 arg1_size = VARSIZE_ANY_EXHDR(arg1);
    int32 arg2_size = VARSIZE_ANY_EXHDR(arg2);
    int32 new_text_size = arg1_size + arg2_size + VARHDRSZ;
    text *new_text = (text *) palloc(new_text_size);

    SET_VARSIZE(new_text, new_text_size);
    memcpy(VARDATA(new_text), VARDATA_ANY(arg1), arg1_size);
    memcpy(VARDATA(new_text) + arg1_size, VARDATA_ANY(arg2), arg2_size);
    PG_RETURN_TEXT_P(new_text);
}</pre><p>上のコードがファイル<code class="filename">funcs.c</code>に用意されていて、共有オブジェクトにコンパイルされているとしたら、以下のように<span class="productname">PostgreSQL</span>にコマンドで関数を定義できます。
    </p><pre class="programlisting">CREATE FUNCTION add_one(integer) RETURNS integer
     AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'add_one'
     LANGUAGE C STRICT;

-- SQL関数名"add_one"のオーバーロードに注意
CREATE FUNCTION add_one(double precision) RETURNS double precision
     AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'add_one_float8'
     LANGUAGE C STRICT;

CREATE FUNCTION makepoint(point, point) RETURNS point
     AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'makepoint'
     LANGUAGE C STRICT;

CREATE FUNCTION copytext(text) RETURNS text
     AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'copytext'
     LANGUAGE C STRICT;

CREATE FUNCTION concat_text(text, text) RETURNS text
     AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'concat_text'
     LANGUAGE C STRICT;</pre><p>ここでは、<em class="replaceable"><code>DIRECTORY</code></em>は共有ライブラリファイルのディレクトリ(例えば<span class="productname">PostgreSQL</span>のチュートリアルのディレクトリ、そこにはこの節で使われている例のコードがあります)を表しています。
(<em class="replaceable"><code>DIRECTORY</code></em>を検索パスに追加した後に<code class="literal">AS</code>句で<code class="literal">'funcs'</code>だけを使うのがより良いやり方でしょう。
どの場合でも、共有ライブラリを表すシステムに特有の拡張子、普通は<code class="literal">.so</code>を省略できます。)
    </p><p>関数を<span class="quote">“<span class="quote">strict</span>”</span>と指定したことに注意してください。これは入力値のいずれかがNULLだった場合、システムが自動的に結果をNULLと決めてしまうことを意味します。
こうすることで、関数のコード内でNULLの入力を確認しなければならないことを避けています。
これがなければ、<code class="function">PG_ARGISNULL()</code>を使ってNULL値を明示的に確認しなければなりません。
    </p><p>一見、Version-1のコーディング規約は無意味なもの、普通の<code class="literal">C</code>の呼出し規約の使い過ぎに見えるかもしれません。
しかし、<code class="literal">NULL</code>になりうる引数や戻り値、<span class="quote">“<span class="quote">TOASTされた</span>”</span>（圧縮または行外）値を扱うことができます。
    </p><p><code class="function">PG_ARGISNULL(<em class="replaceable"><code>n</code></em>)</code>マクロにより関数は各入力がNULLであるかどうかの検査を行うことができます。
（もちろんこれは、<span class="quote">“<span class="quote">厳密</span>”</span>と宣言されていない関数でのみ必要です。）
<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>()</code>マクロと同様、入力引数の番号はゼロから始まります。
引数がNULLでないことを確認するまでは、<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>()</code>の実行は控えなければなりません。
結果としてNULLを返す場合は、<code class="function">PG_RETURN_NULL()</code>を実行します。
これは、厳密な関数と厳密でない関数の両方で使用可能です。
    </p><p>Version 1のインタフェースでは、その他のオプションとして<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>()</code>マクロの変形を2つ提供しています。
1つ目の<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>_COPY()</code>によって、安全に書き込むことができる指定引数のコピーが確実に返されます。
（通常のマクロは、物理的にテーブルに格納されている値へのポインタを返すことがあるので、書き込んではなりません。
<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>_COPY()</code>マクロの結果は書き込み可能であることが保証されています。）
2つ目の変形は、引数を3つ取る<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em>_SLICE()</code>マクロからなります。
1つ目は関数の引数の番号（上記の通り）です。
2つ目と3つ目は、オフセットと返されるセグメントの長さです。
オフセットはゼロから始まり、負の長さは残りの値を返すことを要求します。
これらのマクロを使用すると、ストレージ種類が<span class="quote">“<span class="quote">external</span>”</span>（外部）である大きな値の一部へアクセスする際に非常に効果的です。
（列のストレージ種類は<code class="literal">ALTER TABLE <em class="replaceable"><code>tablename</code></em> ALTER COLUMN <em class="replaceable"><code>colname</code></em> SET STORAGE <em class="replaceable"><code>storagetype</code></em></code>を使用して指定できます。
<em class="replaceable"><code>storagetype</code></em>は、<code class="literal">plain</code>、<code class="literal">external</code>、<code class="literal">extended</code>、または<code class="literal">main</code>のいずれかです。）
    </p><p>最後に、Version-1関数呼び出し規約では、結果集合（<a class="xref" href="xfunc-c.html#XFUNC-C-RETURN-SET" title="37.9.8. 集合を返す">Section 37.9.8</a>）を返すこと、およびトリガ関数（<a class="xref" href="triggers.html" title="Chapter 38. トリガ">Chapter 38</a>）と手続型言語の呼び出しハンドラ（<a class="xref" href="plhandler.html" title="Chapter 55. 手続き言語ハンドラの作成">Chapter 55</a>）を実装することができます。
詳細についてはソース配布物内の<code class="filename">src/backend/utils/fmgr/README</code>を参照してください。
    </p></div><div class="sect2" id="id-1.8.3.12.8"><div class="titlepage"><div><div><h3 class="title">37.9.4. コードの作成</h3></div></div></div><p>より先進的な話題に入る前に、<span class="productname">PostgreSQL</span> C言語関数のコーディングについての規則をいくつか説明します。
C言語以外の言語で記述した関数を<span class="productname">PostgreSQL</span>に組み込みむことは可能であるかもしれませんが、例えばC++、FORTRANやPascalといった言語はC言語と同じ呼び出し規約に従いませんので、多くの場合、（可能であったとしても）困難です。
それはつまり、他の言語では同じ方法で関数に引数を渡したり、関数から結果を返すことを行わないということです。
このため、C言語関数は実際にC言語で書かれているものと仮定します。
    </p><p>C関数の作成と構築の基本規則を以下に示します。

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">pg_config --includedir-server</code>を使用して、使用中のシステム（もしくはユーザが実行するシステム）にて<span class="productname">PostgreSQL</span>サーバのヘッダファイルがインストールされた場所を見つけます。
<a id="id-1.8.3.12.8.3.1.1.1.3" class="indexterm"></a>
       </p></li><li class="listitem"><p><span class="productname">PostgreSQL</span>に動的にロードできるように独自コードをコンパイル/リンクする時には常に、特別なフラグが必要となります。
特定のオペレーティングシステムにおけるコンパイル/リンク方法については<a class="xref" href="xfunc-c.html#DFUNC" title="37.9.5. 動的にロードされる関数のコンパイルとリンク">Section 37.9.5</a>を参照してください。
       </p></li><li class="listitem"><p>忘れずに<a class="xref" href="xfunc-c.html#XFUNC-C-DYNLOAD" title="37.9.1. 動的ロード">Section 37.9.1</a>で説明した<span class="quote">“<span class="quote">マジックブロック</span>”</span>を共有ライブラリで定義してください。
       </p></li><li class="listitem"><p>メモリを割り当てる際、Cライブラリの<code class="function">malloc</code>と<code class="function">free</code>ではなく、<span class="productname">PostgreSQL</span>の<code class="function">palloc</code>と<code class="function">pfree</code>を使用してください。
<a id="id-1.8.3.12.8.3.1.4.1.6" class="indexterm"></a><a id="id-1.8.3.12.8.3.1.4.1.7" class="indexterm"></a>
<code class="function">palloc</code>で割り当てられたメモリは各トランザクションの終わりに自動的に解放され、メモリリークを防ぎます。
       </p></li><li class="listitem"><p><code class="function">memset</code>を使用して、構造体を必ずゼロクリアしてください（または最初の段階で<code class="function">palloc0</code>を用いて割り当ててください）。
構造体の各フィールドを割り当てたとしても、ゴミの値を持つ整列用のパディング（構造体内の穴）があるかもしれません。
こうしないと、ハッシュインデックスやハッシュ結合をサポートすることが困難です。
ハッシュを計算するには、データ構造体内の有意なビットのみを取り出す必要があるためです。
プランナはまた時折ビット単位の等価性を用いて定数の比較を行います。
このため論理的にな値がビット単位で等価でない場合に望まない計画になってしまう可能性があります。
       </p></li><li class="listitem"><p>ほとんどの<span class="productname">PostgreSQL</span>の内部型は<code class="filename">postgres.h</code>に宣言されています。
一方、関数管理インタフェース（<code class="symbol">PG_FUNCTION_ARGS</code>など）は<code class="filename">fmgr.h</code>で宣言されています。
したがって、少なくともこの2つのファイルをインクルードする必要があります。
移植性に関する理由により、<code class="filename">postgres.h</code>をその他のシステムヘッダファイル、ユーザヘッダファイルよりも<span class="emphasis"><em>先に</em></span>インクルードしておくことが最善です。
<code class="filename">postgres.h</code>をインクルードすることは<code class="filename">elog.h</code>、<code class="filename">palloc.h</code>もインクルードすることになります。
       </p></li><li class="listitem"><p>オブジェクトファイルで定義されているシンボル名は、互いに、または<span class="productname">PostgreSQL</span>サーバの実行ファイルで定義されているものと異なっている必要があります。
これに関するエラーが表示される場合は、関数名または変数名を変更する必要があります。
       </p></li></ul></div><p>
    </p></div><div class="sect2" id="DFUNC"><div class="titlepage"><div><div><h3 class="title">37.9.5. 動的にロードされる関数のコンパイルとリンク</h3></div></div></div><p>Cで書かれた<span class="productname">PostgreSQL</span>の拡張関数を使うためには、サーバが動的にロードできるように特別な方法でコンパイルとリンクを行う必要があります。
正確には<em class="firstterm">共有ライブラリ</em>を作る必要があります。
<a id="id-1.8.3.12.9.2.3" class="indexterm"></a>

 </p><p>本節の説明以上の詳しい情報はオペレーティングシステムのドキュメント、特にCコンパイラ<code class="command">cc</code>とリンクエディタ<code class="command">ld</code>のマニュアルページを参照してください。
さらに、<span class="productname">PostgreSQL</span>のソースコードの<code class="filename">contrib</code>ディレクトリにいくつか実例があります。
しかし、もしこれらの例に頼ると<span class="productname">PostgreSQL</span>ソースコードが利用できることに依存したモジュールが作られてしまいます。
 </p><p>共有ライブラリの作成は一般的に実行プログラムのリンクに類似しています。
まずソースファイルがオブジェクトファイルにコンパイルされ、そのオブジェクトファイル同士がリンクされます。
これらのオブジェクトファイルは<em class="firstterm">位置独立なコード</em>（<acronym class="acronym">PIC</acronym>）として作られる必要があります。
<a id="id-1.8.3.12.9.4.3" class="indexterm"></a>
それは概念的には、実行プログラムから呼び出される時にメモリの適当な場所に置くことができるということです
（実行プログラム用として作られたオブジェクトファイルはそのようにはコンパイルされません）。
共有ライブラリをリンクするコマンドは実行プログラムのリンクと区別するための特別なフラグがあります（少なくとも理論上ではそのようになっています。システムによってはもっと醜い実際が見受けられます)。
 </p><p>次の例ではソースコードは<code class="filename">foo.c</code>ファイルにあると仮定し、<code class="filename">foo.so</code>という共有ライブラリを作るとします。
中間のオブジェクトファイルは特別な記述がない限り<code class="filename">foo.o</code>と呼ばれます。
共有ライブラリは1つ以上のオブジェクトファイルを持つことができますが、ここでは1つしか使いません。
 </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">     <span class="systemitem">FreeBSD</span>
     <a id="id-1.8.3.12.9.6.1.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作るためのコンパイラフラグは<code class="option">-fPIC</code>です。
共有ライブラリを作るコンパイラフラグは<code class="option">-shared</code>です。
</p><pre class="programlisting">gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o</pre><p>
これは<span class="systemitem">FreeBSD</span>のバージョン3.0に適用されます。
     </p></dd><dt><span class="term">     <span class="systemitem">HP-UX</span>
     <a id="id-1.8.3.12.9.6.2.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作るためのシステムコンパイラのコンパイラフラグは<code class="option">+z</code>です。
<span class="application">GCC</span>を使う場合は<code class="option">-fPIC</code>です。
共有ライブラリのためのリンカフラグは<code class="option">-b</code>です。
したがって、以下のようになります。
</p><pre class="programlisting">cc +z -c foo.c</pre><p>
または
</p><pre class="programlisting">gcc -fPIC -c foo.c</pre><p>
そして
</p><pre class="programlisting">ld -b -o foo.sl foo.o</pre><p>
<span class="systemitem">HP-UX</span>は他のほとんどのシステムと異なり共有ライブラリに<code class="filename">.sl</code>という拡張子を使います。
     </p></dd><dt><span class="term">     <span class="systemitem">Linux</span>
     <a id="id-1.8.3.12.9.6.3.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作るためのコンパイラフラグは<code class="option">-fPIC</code>です。
共有ライブラリを作るコンパイラフラグは<code class="option">-shared</code>です。
完全な例は下記のようになります。
</p><pre class="programlisting">cc -fPIC -c foo.c
cc -shared -o foo.so foo.o</pre><p>
     </p></dd><dt><span class="term">     <span class="systemitem">macOS</span>
     <a id="id-1.8.3.12.9.6.4.1.2" class="indexterm"></a>
    </span></dt><dd><p>例を以下に示します。
開発者用ツールがインストールされていることが前提です。
</p><pre class="programlisting">cc -c foo.c
cc -bundle -flat_namespace -undefined suppress -o foo.so foo.o</pre><p>
     </p></dd><dt><span class="term">     <span class="systemitem">NetBSD</span>
     <a id="id-1.8.3.12.9.6.5.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作るためのコンパイラフラグは<code class="option">-fPIC</code>です。
<acronym class="acronym">ELF</acronym>システムでは<code class="option">-shared</code>コンパイラフラグを使用して共有ライブラリをリンクします。
より古い非ELFシステムでは<code class="literal">ld -Bshareable</code>が使われます。
</p><pre class="programlisting">gcc -fPIC -c foo.c
gcc -shared -o foo.so foo.o</pre><p>
     </p></dd><dt><span class="term">     <span class="systemitem">OpenBSD</span>
     <a id="id-1.8.3.12.9.6.6.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作成するためのコンパイラフラグは<code class="option">-fPIC</code>です。
共有ライブラリをリンクするには<code class="literal">ld -Bshareable</code>を使用します。
</p><pre class="programlisting">gcc -fPIC -c foo.c
ld -Bshareable -o foo.so foo.o</pre><p>
     </p></dd><dt><span class="term">     <span class="systemitem">Solaris</span>
     <a id="id-1.8.3.12.9.6.7.1.2" class="indexterm"></a>
    </span></dt><dd><p><acronym class="acronym">PIC</acronym>を作るためのコンパイラフラグはSunコンパイラでは<code class="option">-KPIC</code>で、<span class="application">GCC</span>では<code class="option">-fPIC</code>です。
共有ライブラリをリンクするためには、どちらのコンパイラでもコンパイラオプションは<code class="option">-G</code>で、<span class="application">GCC</span>の場合、代わりに<code class="option">-shared</code>オプションを使うこともできます。
</p><pre class="programlisting">cc -KPIC -c foo.c
cc -G -o foo.so foo.o</pre><p>
もしくは
</p><pre class="programlisting">gcc -fPIC -c foo.c
gcc -G -o foo.so foo.o</pre><p>
     </p></dd></dl></div><div class="tip"><h3 class="title">Tip</h3><p>これがあまりに難しいようであれば、<a class="ulink" href="http://www.gnu.org/software/libtool/" target="_top"><span class="productname">GNU Libtool</span></a>の使用を検討すべきです。
これはプラットフォームの違いを、統一されたインタフェースで判らないようにします。
  </p></div><p>これで完成した共有ライブラリファイルは<span class="productname">PostgreSQL</span>にロードすることができます。
<code class="command">CREATE FUNCTION</code>コマンドにファイル名を指定する時には、中間オブジェクトファイルではなく共有ライブラリファイルの名前を与えてください。
システムの標準共有ライブラリ用の拡張子（通常<code class="literal">.so</code>あるいは<code class="literal">.sl</code>）は<code class="command">CREATE FUNCTION</code>で省略することができ、そして移植性を最も高くするため通常は省略されます。
 </p><p>サーバがライブラリファイルをどこに見つけるかに関しては<a class="xref" href="xfunc-c.html#XFUNC-C-DYNLOAD" title="37.9.1. 動的ロード">Section 37.9.1</a>を見直してください。
 </p></div><div class="sect2" id="id-1.8.3.12.10"><div class="titlepage"><div><div><h3 class="title">37.9.6. 複合型引数</h3></div></div></div><p>複合型ではCの構造体のような固定のレイアウトがありません。
複合型のインスタンスはNULLフィールドを持つことができます。
さらに、複合型で継承階層の一部であるものは、同じ継承階層の他のメンバとは異なるフィールドを持つこともできます。
そのため、<span class="productname">PostgreSQL</span>はC言語から複合型のフィールドにアクセスするための関数インタフェースを提供します。
    </p><p>以下のような問い合わせに答える関数を書こうとしていると仮定します。

</p><pre class="programlisting">SELECT name, c_overpaid(emp, 1500) AS overpaid
    FROM emp
    WHERE name = 'Bill' OR name = 'Sam';</pre><p>

Version 1呼び出し規約を使用すると、<code class="function">c_overpaid</code>は以下のように定義できます。

</p><pre class="programlisting">#include "postgres.h"
#include "executor/executor.h"  /* GetAttributeByName()用 */

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(c_overpaid);

Datum
c_overpaid(PG_FUNCTION_ARGS)
{
    HeapTupleHeader  t = PG_GETARG_HEAPTUPLEHEADER(0);
    int32            limit = PG_GETARG_INT32(1);
    bool isnull;
    Datum salary;

    salary = GetAttributeByName(t, "salary", &amp;isnull);
    if (isnull)
        PG_RETURN_BOOL(false);
    /* この他、salaryがNULLの場合用にPG_RETURN_NULL()を行った方が良いでしょう */

    PG_RETURN_BOOL(DatumGetInt32(salary) &gt; limit);
}</pre><p>
    </p><p><code class="function">GetAttributeByName</code>は、指定された行から属性を返す、<span class="productname">PostgreSQL</span>システム関数です。
これには3つの引数があります。
それらは、関数に渡された<code class="type">HeapTupleHeader</code>型の引数、求められた属性の名前、属性がNULLであるかどうかを通知する返りパラメータです。
<code class="function">GetAttributeByName</code>は適切な<code class="function">DatumGet<em class="replaceable"><code>XXX</code></em>()</code>マクロを使用して適切なデータ型に変換可能な<code class="type">Datum</code>型の値を返します。
このNULLフラグが設定されている場合、戻り値の意味がないことに注意し、この結果で何かを行おうとする前に常に、NULLフラグを検査してください。
    </p><p>対象列を名前ではなく列番号で選択する<code class="function">GetAttributeByNum</code>もあります。
    </p><p>下記のコマンドで<code class="function">c_overpaid</code>関数をSQLで宣言します。

</p><pre class="programlisting">CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean
    AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'c_overpaid'
    LANGUAGE C STRICT;</pre><p>

入力引数がNULLかどうかを検査する必要がないように<code class="literal">STRICT</code>を使用していることに注意してください。
    </p></div><div class="sect2" id="id-1.8.3.12.11"><div class="titlepage"><div><div><h3 class="title">37.9.7. 行（複合型）を返す</h3></div></div></div><p>C言語関数から行もしくは複合型の値を返すために、複合型の複雑な作成のほとんどを隠蔽するマクロや関数を提供する、特別なAPIを使用することができます。
このAPIを使用するためには、ソースファイルで以下をインクルードする必要があります。
</p><pre class="programlisting">#include "funcapi.h"</pre><p>
    </p><p>複合型のデータ値（以降<span class="quote">“<span class="quote">タプル</span>”</span>と記す）を作成する2つの方法があります。
Datum値の配列から作成する方法、もしくはタプルのある列の型の入力変換関数に渡すことができるC文字列の配列から作成することです。
どちらの方法でも、まずタプル構造体用の<code class="structname">TupleDesc</code>記述子を入手、あるいは作成しなければなりません。
Datumを使用する場合は、<code class="structname">TupleDesc</code>を<code class="function">BlessTupleDesc</code>に渡し、各行に対して<code class="function">heap_form_tuple</code>を呼び出します。
C文字列を使用する場合は、<code class="structname">TupleDesc</code> を<code class="function">TupleDescGetAttInMetadata</code>に渡し、各行に対して <code class="function">BuildTupleFromCStrings</code>を呼び出します。
タプルの集合を返す関数の場合、この設定段階を最初の関数呼び出しで一度にまとめて行うことができます。
    </p><p>必要な<code class="structname">TupleDesc</code>の設定用の補助用関数がいくつかあります。
ほとんどの複合型を返す関数での推奨方法は、以下の関数を呼び出し、呼び出し元の関数自身に渡される<code class="literal">fcinfo</code>構造体と同じものを渡すことです。
</p><pre class="programlisting">TypeFuncClass get_call_result_type(FunctionCallInfo fcinfo,
                                   Oid *resultTypeId,
                                   TupleDesc *resultTupleDesc)</pre><p>
（これにはもちろん、version 1呼び出し規約を使用していることが必要です。）
<code class="varname">resultTypeId</code>を<code class="literal">NULL</code>とすることも、ローカル変数のアドレスを指定して関数の戻り値型のOIDを受け取ることができます。
<code class="varname">resultTupleDesc</code>はローカルな<code class="structname">TupleDesc</code>変数のアドレスでなければなりません。
結果が<code class="literal">TYPEFUNC_COMPOSITE</code>かどうかを確認してください。
<code class="literal">TYPEFUNC_COMPOSITE</code>であった場合、<code class="varname">resultTupleDesc</code>には必要な<code class="structname">TupleDesc</code>が格納されています。
（<code class="literal">TYPEFUNC_COMPOSITE</code>ではなかった場合、<span class="quote">“<span class="quote">レコード型を受け付けない文脈でレコードを返す関数が呼び出されました</span>”</span>というエラーを報告することができます。）
    </p><div class="tip"><h3 class="title">Tip</h3><p><code class="function">get_call_result_type</code>は、多様性関数の結果の実際の型を解決することができます。
ですので、複合型を返す関数だけではなく、スカラの多様結果を返す関数でも有意です。
<code class="varname">resultTypeId</code>出力は主にスカラの多様結果を返す関数で有意です。
     </p></div><div class="note"><h3 class="title">Note</h3><p><code class="function">get_call_result_type</code>は、<code class="function">get_expr_result_type</code>と似たような関数で、関数呼び出しで想定される出力型を式のツリー構造として解決します。
関数自身以外から結果型を決定したい場合に、これを使用することができます。
また、<code class="function">get_func_result_type</code>という関数もあります。
これは関数のOIDが利用できる場合にのみ使用することができます。
しかし、これらの関数は、<code class="structname">record</code>型を返すものと宣言された関数では使用できません。
また、<code class="function">get_func_result_type</code>は多様型を解決することができません。
したがって、優先して<code class="function">get_call_result_type</code>を使用すべきです。
     </p></div><p>古く、廃止予定の<code class="structname">TupleDesc</code>を入手するための関数を以下に示します。
</p><pre class="programlisting">TupleDesc RelationNameGetTupleDesc(const char *relname)</pre><p>
これを指名したリレーションの行型用の<code class="structname">TupleDesc</code>を取り出すために使用してください。
また、
</p><pre class="programlisting">TupleDesc TypeGetTupleDesc(Oid typeoid, List *colaliases)</pre><p>
これを型のOIDに基づいて<code class="structname">TupleDesc</code>を取り出すために使用してください。
これは、基本型もしくは複合型の<code class="structname">TupleDesc</code>を取り出すために使用可能です。
これは<code class="structname">record</code>を返す関数ではうまく動作しません。
また、多様型を解決することもできません。
    </p><p><code class="structname">TupleDesc</code>を獲得した後に、Datumを使用する場合は以下を呼び出してください。
</p><pre class="programlisting">TupleDesc BlessTupleDesc(TupleDesc tupdesc)</pre><p>
C文字列を使用する場合は以下を呼び出してください。
</p><pre class="programlisting">AttInMetadata *TupleDescGetAttInMetadata(TupleDesc tupdesc)</pre><p>
集合を返す関数を作成する場合は、これらの関数の結果を<code class="structname">FuncCallContext</code>構造体に格納してください。
それぞれ<code class="structfield">tuple_desc</code>と<code class="structfield">attinmeta</code>を使用します。
    </p><p>Datumを使用する場合は、ユーザデータをDatum形式に格納した<code class="structname">HeapTuple</code>を構築するために以下を使用します。
</p><pre class="programlisting">HeapTuple heap_form_tuple(TupleDesc tupdesc, Datum *values, bool *isnull)</pre><p>
    </p><p>C文字列を使用する場合は、ユーザデータをC文字列形式に格納した<code class="structname">HeapTuple</code>を構築するために以下を使用します。
</p><pre class="programlisting">HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values)</pre><p>
<code class="literal">values</code>は行の各属性を1要素としたC文字列の配列です。
各C文字列は、属性のデータ型用の入力関数が受け付け可能な形式でなければなりません。
属性の値をNULL値として返すためには、<em class="parameter"><code>values</code></em>配列の対応するポインタに<code class="symbol">NULL</code>を設定してください。
この関数は返す行それぞれに対して繰り返し呼び出す必要があります。
    </p><p>関数から返すタプルを構築し終わったら、それを<code class="type">Datum</code>に変換しなければなりません。
以下を使用して、<code class="structname">HeapTuple</code>を有効なDatumに変換してください。
</p><pre class="programlisting">HeapTupleGetDatum(HeapTuple tuple)</pre><p>
単一行のみを返すのであれば、この<code class="type">Datum</code>を直接返すことができます。
さもなくば、集合を返す関数における現在の戻り値として使用することができます。
    </p><p>次節に例を示します。
    </p></div><div class="sect2" id="XFUNC-C-RETURN-SET"><div class="titlepage"><div><div><h3 class="title">37.9.8. 集合を返す</h3></div></div></div><p>C言語関数から集合（複数行）を返す機能のために特殊なAPIが用意されています。
集合を返す関数は、Version 1呼び出し規約に従う必要があります。
また、ソースファイルは上述の通り<code class="filename">funcapi.h</code>をインクルードする必要があります。
    </p><p>集合を返す関数（<acronym class="acronym">SRF</acronym>）は返される項目ごとに呼び出されます。
そのため、<acronym class="acronym">SRF</acronym>は、過去の操作を記憶して呼び出しの度に次の項目を返すために十分な状態を保っている必要があります。
この処理を制御を補助するための<code class="structname">FuncCallContext</code>構造体が備わっています。
関数内では、複数の呼び出しにまたがる<code class="structname">FuncCallContext</code>へのポインタを保持するには、<code class="literal">fcinfo-&gt;flinfo-&gt;fn_extra</code>を使用します。
</p><pre class="programlisting">typedef struct FuncCallContext
{
    /*
     * 既に行われた呼び出しの回数。
     *
     * SRF_FIRSTCALL_INIT()によってcall_cntrが0に初期化され、
     * SRF_RETURN_NEXT()が呼び出される度に増分されます。
     */
    uint64 call_cntr;

    /*
     * 省略可能 : 呼び出しの最大数
     *
     * max_callsは、便宜上用意されているだけで、設定は省略可能です。
     * 設定されていなければ、関数が終了したことを知るための別の方法を
     * 用意する必要があります。
     */
    uint64 max_calls;

    /*
     * 省略可能 : 結果スロットへのポインタ
     *
     * これは廃止され、後方互換性、すなわち非推奨のTupleDescGetSlot()を使用する
     * ユーザ定義のSRFのためにだけ存在します。
     */
    TupleTableSlot *slot;

    /*
     * 省略可能 : 様々なユーザによるコンテキスト情報へのポインタ
     *
     * user_fctxは、関数の呼び出し間の任意のコンテキスト情報を
     * 取得するためのユーザ独自の構造へのポインタとして使用されます。
     */
    void *user_fctx;

    /*
     * 省略可能 : 属性型入力メタ情報を含んだ構造体へのポインタ
     *
     * attinmeta はタプル（つまり複合データ型）を返す際に使用され、
     * 基本データ型を返す場合には必要ありません。
     * BuildTupleFromCStrings()を使用して返されるタプルを作成する場合にのみ必要です。
     */
    AttInMetadata *attinmeta;

    /*
     *  複数の呼び出しで必要とされる構造体に使われるメモリコンテキスト
     *
     * multi_call_memory_ctxは、SRF_FIRSTCALL_INIT()によってに設定され、
     * SRF_RETURN_DONE()がクリーンアップの際に使用します。
     * これはSRFの複数呼び出しで再利用される全てのメモリ用に最も適切なメモリコンテキストです。
     */
    MemoryContext multi_call_memory_ctx;

    /*
     * 省略可能: タプル説明を含む構造体へのポインタ。
     * tuple_descはタプル（つまり複合データ型）を返す場合に使用され、BuildTupleFromCStrings()
     * ではなくheap_form_tuple()を使用してタプルを作成する場合にのみ必要です。
     * 通常ここに格納されるTupleDescは最初にBlessTupleDesc()を最初に実行したものでなければなり
     * ません。
     */
    TupleDesc tuple_desc;

} FuncCallContext;</pre><p>
    </p><p><acronym class="acronym">SRF</acronym>はいくつかの関数およびマクロを使用して<code class="structname">FuncCallContext</code>構造体を自動的に操作します（また<code class="literal">fn_extra</code>で検索することを想定します)。
</p><pre class="programlisting">SRF_IS_FIRSTCALL()</pre><p>
を使用して、その関数呼び出しが初回のものであるか、2回目以降であるかを判断します。
最初の呼び出し（のみ）で、
</p><pre class="programlisting">SRF_FIRSTCALL_INIT()</pre><p>
を使用して、<code class="structname">FuncCallContext</code>を初期化します。
最初の呼び出しを含むすべての呼び出しで、
</p><pre class="programlisting">SRF_PERCALL_SETUP()</pre><p>
を使用して、<code class="structname">FuncCallContext</code>を使用するための適切な設定を行い、以前の受け渡しから残っている結果データを消去します。
    </p><p>関数で返すべきデータがある場合は、
</p><pre class="programlisting">SRF_RETURN_NEXT(funcctx, result)</pre><p>
を使用して、そのデータを呼び出し側に返します。
（先に説明した通り <code class="literal">result</code>は<code class="type">Datum</code>型、つまり1つの値またはタプルである必要があります。）
最後に、関数がデータを返し終わったら、
</p><pre class="programlisting">SRF_RETURN_DONE(funcctx)</pre><p>
を使用して<acronym class="acronym">SRF</acronym>を片付け、終了します。
    </p><p><acronym class="acronym">SRF</acronym>の呼び出し時に現行になっているメモリコンテキストは一時的なコンテキストで、各呼び出しの間に消去されます。
つまり<code class="function">palloc</code>を使用して割り当てたもののすべてを<code class="function">pfree</code>する必要はありません。
これらはいずれ消去されるものだからです。
しかし、データ構造体を複数の呼び出しに渡って使用するように割り当てる場合は、どこか別の場所に置いておく必要があります。
<code class="structfield">multi_call_memory_ctx</code>によって参照されるメモリコンテキストは、<acronym class="acronym">SRF</acronym>の実行が終わるまで使用可能にしなければならないデータの保管場所として適しています。
つまり、ほとんどの場合、最初の呼び出しのセットアップ中に<code class="structfield">multi_call_memory_ctx</code>へ切り替える必要があるということです。
    </p><div class="warning"><h3 class="title">Warning</h3><p>関数の実引数は呼出しの間変わらないままですが、一時的なコンテキストで引数の値をTOAST解除した場合には(これは通常、<code class="function">PG_GETARG_<em class="replaceable"><code>xxx</code></em></code>マクロにより透過的に行なわれます)、TOAST解除されたコピーが各サイクルで解放されます。
従って、<code class="structfield">user_fctx</code>内のその値への参照を保持する場合には、TOAST解除した後に<code class="structfield">multi_call_memory_ctx</code>にそれらをコピーするか、その値をTOAST解除するのはそのコンテキストの中だけであること確実にしなければなりません。
     </p></div><p>     完全な疑似コードの例を示します。
</p><pre class="programlisting">Datum
my_set_returning_function(PG_FUNCTION_ARGS)
{
    FuncCallContext  *funcctx;
    Datum             result;
    <em class="replaceable"><code>further declarations as needed</code></em>

    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext oldcontext;

        funcctx = SRF_FIRSTCALL_INIT();
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);
        /* 一度限りのセットアップコードがここに入ります: */
        <em class="replaceable"><code>user code</code></em>
        <em class="replaceable"><code>if returning composite</code></em>
            <em class="replaceable"><code>build TupleDesc, and perhaps AttInMetadata</code></em>
        <em class="replaceable"><code>endif returning composite</code></em>
        <em class="replaceable"><code>user code</code></em>
        MemoryContextSwitchTo(oldcontext);
    }

    /* 毎回実行するセットアップコードがここに入ります: */
    <em class="replaceable"><code>user code</code></em>
    funcctx = SRF_PERCALL_SETUP();
    <em class="replaceable"><code>user code</code></em>

    /* これは、終了したかどうかをテストする方法の1つです: */
    if (funcctx-&gt;call_cntr &lt; funcctx-&gt;max_calls)
    {
        /* ここで、別の項目を返します: */
        <em class="replaceable"><code>user code</code></em>
        <em class="replaceable"><code>obtain result Datum</code></em>
        SRF_RETURN_NEXT(funcctx, result);
    }
    else
    {
        /* これで項目を返し終わりました。 後はクリーンアップするだけです。 */
        <em class="replaceable"><code>user code</code></em>
        SRF_RETURN_DONE(funcctx);
    }
}</pre><p>
    </p><p>複合型を返す単純な<acronym class="acronym">SRF</acronym>の完全な例は以下の通りです。
</p><pre class="programlisting">PG_FUNCTION_INFO_V1(retcomposite);

Datum
retcomposite(PG_FUNCTION_ARGS)
{
    FuncCallContext     *funcctx;
    int                  call_cntr;
    int                  max_calls;
    TupleDesc            tupdesc;
    AttInMetadata       *attinmeta;

     /* 関数の最初の呼び出し時にのみ実行 */
    if (SRF_IS_FIRSTCALL())
    {
        MemoryContext   oldcontext;

        /* 呼び出し間で永続化する関数コンテキストを作成 */
        funcctx = SRF_FIRSTCALL_INIT();

        /* 複数関数呼び出しに適切なメモリコンテキストへの切り替え */
        oldcontext = MemoryContextSwitchTo(funcctx-&gt;multi_call_memory_ctx);

        /* 返されるタプルの合計数 */
        funcctx-&gt;max_calls = PG_GETARG_UINT32(0);

        /*  結果型用のタプル記述子を作成 */
        if (get_call_result_type(fcinfo, NULL, &amp;tupdesc) != TYPEFUNC_COMPOSITE)
            ereport(ERROR,
                    (errcode(ERRCODE_FEATURE_NOT_SUPPORTED),
                     errmsg("function returning record called in context "
                            "that cannot accept type record")));

        /*
         * 後で未加工のC文字列からタプルを作成するために必要となる
         * 属性メタデータの生成
         */
        attinmeta = TupleDescGetAttInMetadata(tupdesc);
        funcctx-&gt;attinmeta = attinmeta;

        MemoryContextSwitchTo(oldcontext);
    }

    /* 全ての関数呼び出しで実行 */
    funcctx = SRF_PERCALL_SETUP();

    call_cntr = funcctx-&gt;call_cntr;
    max_calls = funcctx-&gt;max_calls;
    attinmeta = funcctx-&gt;attinmeta;

    if (call_cntr &lt; max_calls)    /* 他にも送るものがある場合  */
    {
        char       **values;
        HeapTuple    tuple;
        Datum        result;

        /*
         * 返すタプルを構築するためのvalues配列を用意します。
         * これは、後で適切な入力関数で処理される
         * C文字列の配列でなければなりません。
         */
        values = (char **) palloc(3 * sizeof(char *));
        values[0] = (char *) palloc(16 * sizeof(char));
        values[1] = (char *) palloc(16 * sizeof(char));
        values[2] = (char *) palloc(16 * sizeof(char));

        snprintf(values[0], 16, "%d", 1 * PG_GETARG_INT32(1));
        snprintf(values[1], 16, "%d", 2 * PG_GETARG_INT32(1));
        snprintf(values[2], 16, "%d", 3 * PG_GETARG_INT32(1));

        /* タプルの作成 */
        tuple = BuildTupleFromCStrings(attinmeta, values);

        /* タプルをdatumに変換 */
        result = HeapTupleGetDatum(tuple);

        /* クリーンアップ（これは必須ではありません） */
        pfree(values[0]);
        pfree(values[1]);
        pfree(values[2]);
        pfree(values);

        SRF_RETURN_NEXT(funcctx, result);
    }
    else    /* 何も残っていない場合 */
    {
        SRF_RETURN_DONE(funcctx);
    }
}</pre><p>

以下にこの関数をSQLで宣言する一例を示します。
</p><pre class="programlisting">CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);

CREATE OR REPLACE FUNCTION retcomposite(integer, integer)
    RETURNS SETOF __retcomposite
    AS '<em class="replaceable"><code>filename</code></em>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</pre><p>
他にも以下のようにOUTパラメータを使用する方法もあります。
</p><pre class="programlisting">CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,
    OUT f1 integer, OUT f2 integer, OUT f3 integer)
    RETURNS SETOF record
    AS '<em class="replaceable"><code>filename</code></em>', 'retcomposite'
    LANGUAGE C IMMUTABLE STRICT;</pre><p>
この方法では、関数の出力型は形式上無名の<code class="structname">record</code>型になることに注意してください。
    </p><p>ソース配布物内の<a class="link" href="tablefunc.html" title="F.39. tablefunc"><code class="filename">contrib/tablefunc</code></a>モジュールのディレクトリには、集合を返す関数のより多くの例があります。
    </p></div><div class="sect2" id="id-1.8.3.12.13"><div class="titlepage"><div><div><h3 class="title">37.9.9. 引数と戻り値の多様性</h3></div></div></div><p>C言語関数は、<code class="type">anyelement</code>、<code class="type">anyarray</code>、<code class="type">anynonarray</code>、<code class="type">anyenum</code>および<code class="type">anyrange</code>多様型を受け付ける、または返すように宣言することができます。
多様関数の詳細な説明は<a class="xref" href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC" title="37.2.5. 多様型">Section 37.2.5</a>を参照してください。
関数の引数もしくは戻り値が多様型として定義される時、関数の作成者は前もって呼び出しにおけるデータ型や返すべきデータ型が何であるかを知ることはできません。
Version-1 C関数で引数の実データ型と、返すべきと想定された型を発見できるための2つのルーチンが<code class="filename">fmgr.h</code>に用意されています。
このルーチンは<code class="literal">get_fn_expr_rettype(FmgrInfo *flinfo)</code>と<code class="literal">get_fn_expr_argtype(FmgrInfo *flinfo, int argnum)</code>という名前です。
これらは結果もしくは引数型のOIDを返します。
ただし、もし情報が利用できなければ<code class="symbol">InvalidOid</code>を返します。
<code class="literal">flinfo</code>構造体は通常<code class="literal">fcinfo-&gt;flinfo</code>としてアクセスされます。
<code class="literal">argnum</code>パラメータは0から始まります。
また、<code class="function">get_fn_expr_rettype</code>の代わりに<code class="function">get_call_result_type</code>を使用することもできます。
また、variadic変数が配列に吸収されたかどうかを判定するために使用できる<code class="function">get_fn_expr_variadic</code>があります。
そのような吸収はvariadic関数が普通の配列型をとる場合に必ず起こりますので、これは特に<code class="literal">VARIADIC "any"</code>の場合に有用です。
    </p><p>例えば、任意の型の単一要素を受け付け、その型の1次元配列を返す関数を考えてみます。

</p><pre class="programlisting">PG_FUNCTION_INFO_V1(make_array);
Datum
make_array(PG_FUNCTION_ARGS)
{
    ArrayType  *result;
    Oid         element_type = get_fn_expr_argtype(fcinfo-&gt;flinfo, 0);
    Datum       element;
    bool        isnull;
    int16       typlen;
    bool        typbyval;
    char        typalign;
    int         ndims;
    int         dims[MAXDIM];
    int         lbs[MAXDIM];

    if (!OidIsValid(element_type))
        elog(ERROR, "could not determine data type of input");

    /* 与えられた要素がNULLかどうか注意しつつ、要素を取り出します。*/
    isnull = PG_ARGISNULL(0);
    if (isnull)
        element = (Datum) 0;
    else
        element = PG_GETARG_DATUM(0);

    /* 次元数は1 */
    ndims = 1;
    /* 要素を1つ */
    dims[0] = 1;
    /* 下限は1 */
    lbs[0] = 1;

    /* この要素型に関する必要情報を取り出す。 */
    get_typlenbyvalalign(element_type, &amp;typlen, &amp;typbyval, &amp;typalign);

    /* ここで配列を作成 */
    result = construct_md_array(&amp;element, &amp;isnull, ndims, dims, lbs,
                                element_type, typlen, typbyval, typalign);

    PG_RETURN_ARRAYTYPE_P(result);
}</pre><p>
    </p><p>以下のコマンドはSQLで<code class="function">make_array</code>関数を宣言します。

</p><pre class="programlisting">CREATE FUNCTION make_array(anyelement) RETURNS anyarray
    AS '<em class="replaceable"><code>DIRECTORY</code></em>/funcs', 'make_array'
    LANGUAGE C IMMUTABLE;</pre><p>
    </p><p>C言語関数でのみ使用できる多様性の変異体があります。
<code class="literal">"any"</code>型のパラメータを取るように宣言できます。
（この型名は、SQL予約語でもあるため二重引用符で括らなくてはならないことに注意してください。）
これは、他の<code class="literal">"any"</code>引数が同じ型になることを強要することも、関数の結果型の決定を支援することもない点を除いて、<code class="type">anyelement</code>のように動作します。
C言語関数は最終パラメータが<code class="literal">VARIADIC "any"</code>であるように宣言可能です。
これは任意の型の１つ以上の実引数と一致します（同じ型である必要はありません）。
これらの引数は、通常のvariadic関数で起こったように、配列の中にまとめ<span class="emphasis"><em>られません</em></span>。
それらは単に別々に関数に渡されるだけです。
<code class="function">PG_NARGS()</code>マクロと上に記載したメソッドは、この機能を使用するときに実際の引数とその型を決定するため使用されなければなりません。
また、こうした関数のユーザは、その関数呼び出しにおいて、関数が配列要素を分離した引数として扱うだろうという予想のもとで<code class="literal">VARIADIC</code>キーワードを良く使用するかもしれません。
関数自身は必要ならば、<code class="function">get_fn_expr_variadic</code>を実行した後で、実引数が<code class="literal">VARIADIC</code>付きであることを検出した場合に、その動作を実装しなければなりません。
    </p></div><div class="sect2" id="XFUNC-TRANSFORM-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">37.9.10. 変形関数</h3></div></div></div><p>一部の関数呼び出しでは、関数固有の属性に基づいて計画作成を単純化できます。
例えば、<code class="literal">int4mul(n, 1)</code>は<code class="literal">n</code>だけに単純化することができます。
こうした関数固有の最適化を定義するためには、<em class="firstterm">変形関数</em>を作成し、そのOIDを主関数の<code class="structname">pg_proc</code>項目の<code class="structfield">protransform</code>フィールドに格納します。
変形関数は<code class="literal">protransform(internal) RETURNS internal</code>というSQLシグネチャを持たなければなりません。
引数、実際は<code class="type">FuncExpr *</code>は、主関数の呼び出しを表すダミーノードです。
変形関数の式ツリー学習によって、式ツリーで表されるすべての可能性がある実際の呼び出しを単純化した式ツリーで置き換えられることが証明された場合、単純化した式を構築し返します。
さもなければ、(SQLのNULLでは<span class="emphasis"><em>なく</em></span>)<code class="literal">NULL</code>ポインタを返します。
    </p><p><span class="productname">PostgreSQL</span>が変形関数によって単純化できる場合に主関数を呼び出さないことは保証されません。
単純化した式と実際の主関数の呼び出しとで、厳密に等価であることを確実にしてください。
    </p><p>現在、セキュリティ上の懸念から、この機能がSQLレベルでユーザに見えることはありません。
このため、これは組み込み関数の最適化での使用のみで実用的です。
    </p></div><div class="sect2" id="id-1.8.3.12.15"><div class="titlepage"><div><div><h3 class="title">37.9.11. 共有メモリとLWLocks</h3></div></div></div><p>アドインはLWLocks（軽量ロック）とサーバ起動時に共有メモリの割り当てを保持することができます。
<a class="xref" href="runtime-config-client.html#GUC-SHARED-PRELOAD-LIBRARIES">shared_preload_libraries</a><a id="id-1.8.3.12.15.2.2" class="indexterm"></a>で指定して、こうしたアドインの共有ライブラリを事前にロードしなければなりません。
共有メモリは、その<code class="function">_PG_init</code>関数で以下を呼び出すことで保持されます。
</p><pre class="programlisting">void RequestAddinShmemSpace(int size)</pre><p>
    </p><p>LWLocksはその<code class="function">_PG_init</code>関数で以下を呼び出すことで保持されます。
</p><pre class="programlisting">void RequestNamedLWLockTranche(const char *tranche_name, int num_lwlocks)</pre><p>
<code class="literal">num_lwlocks</code>個のLWLockの配列が<code class="literal">tranche_name</code>という名前で確実に利用できるようにします。
この配列へのポインタを得るには<code class="function">GetNamedLWLockTranche</code>を使ってください。
    </p><p>競合状態の可能性を防止するために、割り当てられた共有メモリへの接続やその初期化時に、以下のように各バックエンドで<code class="function">AddinShmemInitLock</code>軽量ロックを使用しなければなりません。
</p><pre class="programlisting">static mystruct *ptr = NULL;

if (!ptr)
{
        bool    found;

        LWLockAcquire(AddinShmemInitLock, LW_EXCLUSIVE);
        ptr = ShmemInitStruct("my struct name", size, &amp;found);
        if (!found)
        {
                initialize contents of shmem area;
                acquire any requested LWLocks using:
                ptr-&gt;locks = GetNamedLWLockTranche("my tranche name");
        }
        LWLockRelease(AddinShmemInitLock);
}</pre><p>
    </p></div><div class="sect2" id="EXTEND-CPP"><div class="titlepage"><div><div><h3 class="title">37.9.12. 拡張へのC++の利用</h3></div></div></div><a id="id-1.8.3.12.16.2" class="indexterm"></a><p>以下のガイドラインに従うことで、<span class="productname">PostgreSQL</span>の拡張を構築するためC++モードのコンパイラを利用できます。

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>バックエンドからアクセスされる関数はすべてバックエンドに対してCインタフェースを提供しなければなりません。
このC関数はC++関数を呼びだすことができます。
例えば、バックエンドからアクセスされる関数には<code class="literal">extern C</code>リンクが必要です。
これはバックエンドとC++コードの間でポインタとして渡される関数にも必要です。
       </p></li><li class="listitem"><p>適切な解放メソッドを使ってメモリを解放してください。
例えば、ほとんどのバックエンドメモリは<code class="function">palloc()</code>で確保されますので、<code class="function">pfree()</code>を使って解放してください。
この場合にC++の<code class="function">delete()</code>を使うと失敗するでしょう。
       </p></li><li class="listitem"><p>例外がCコードへ伝播しないようにしてください（<code class="literal">extern C</code>関数すべての最上位ですべての例外を捕捉するブロックを使ってください）。
メモリ不足のようなイベントにより例外が発生する可能性がありますので、C++コードが何も例外を発生させない場合であっても、これは必要です。
例外はすべて捕捉しなければなりません。
そして適切なエラーをCインタフェースに渡してください。
可能であれば、例外を完全に除去できるように<code class="option">-fno-exceptions</code>を付けてC++をコンパイルしてください。
その場合、例えば<code class="function">new()</code>で返されるNULLの検査など、C++コード内で失敗の検査を行わなければなりません。
       </p></li><li class="listitem"><p>C++コードからバックエンド関数を呼び出す場合には、C++呼び出しスタック内にC言語互換構造体（<acronym class="acronym">POD</acronym>）のみが含まれていることを確認してください。
バックエンドのエラーは、非PODオブジェクトを持つC++呼び出しスタックを適切に戻すことができない、長距離<code class="function">longjmp()</code>を生成しますので、これは必要です。
       </p></li></ul></div><p>
    </p><p>まとめると、バックエンドとやりとりするための壁の役割を担う<code class="literal">extern C</code>関数の背後にC++コードを配置して、例外、メモリ、呼び出しスタックそれぞれの漏れを避けるのが最善です。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="xfunc-internal.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="xaggr.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">37.8. 内部関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 37.10. ユーザ定義の集約</td></tr></table></div></body></html>