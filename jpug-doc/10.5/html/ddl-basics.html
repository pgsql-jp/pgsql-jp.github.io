<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.1. テーブルの基本</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="ddl.html" title="Chapter 5. データ定義" /><link rel="next" href="ddl-default.html" title="5.2. デフォルト値" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">5.1. テーブルの基本</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="ddl.html" title="Chapter 5. データ定義">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="ddl.html" title="Chapter 5. データ定義">Up</a></td><th width="60%" align="center">Chapter 5. データ定義</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="ddl-default.html" title="5.2. デフォルト値">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="DDL-BASICS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.1. テーブルの基本</h2></div></div></div><a id="id-1.5.4.3.2" class="indexterm"></a><a id="id-1.5.4.3.3" class="indexterm"></a><a id="id-1.5.4.3.4" class="indexterm"></a><p>リレーショナルデータベースのテーブルは、紙に書く表によく似ています。
テーブルは行と列からできています。
列の数と順序は固定されており、それぞれの列に名前が付けられています。
行の数は可変です。
つまり行の数とは、その時点でどれだけのデータが格納されているのかを示すものです。
SQLではテーブル内の行の順序は保証されません。
テーブルを読み込むと、明示的に並び替えが要求されない限り、行は不特定な順序で返されます。
これについては<a class="xref" href="queries.html" title="Chapter 7. 問い合わせ">Chapter 7</a>を参照してください。
さらに、SQLでは行に固有の識別子が割り当てられないので、テーブル内にまったく同一の行がいくつも存在することがあり得ます。
これは、SQLの基礎をなす数学的モデルの帰結ですが、通常は好ましいことではありません。
この問題の対処法については、本章で後述します。
  </p><p>それぞれの列にデータ型があります。
データ型によって、列に割り当てられる値が制限されます。
また、列に格納されているデータに意味が割り当てられ、データを計算に使用できるようになります。
例えば、数値型と宣言された列は任意のテキスト文字列は受け付けません。
そして、数値型の列に格納されているデータは算術計算に使用できます。
これに対して、文字列型と宣言された列はほとんど全ての種類のデータを受け付けます。
しかし、文字列の結合といった演算には使用できますが、算術計算には使用できません。
  </p><p><span class="productname">PostgreSQL</span>には、様々なアプリケーションに対応した多数のデータ型の集合が組み込まれています。
またユーザが独自のデータ型を定義することも可能です。
組み込みデータ型のほとんどにはわかりやすい名前と意味が付けれられているので、詳しい説明はここでは行わず、<a class="xref" href="datatype.html" title="Chapter 8. データ型">Chapter 8</a>で行います。
よく使用されるデータ型としては、整数を表す<code class="type">integer</code>、小数も表すことができる<code class="type">numeric</code>、文字列を表す<code class="type">text</code>、日付を表す<code class="type">date</code>、時刻を表す<code class="type">time</code>、そして日付と時刻の両方を含む<code class="type">timestamp</code>があります。
  </p><a id="id-1.5.4.3.8" class="indexterm"></a><p>テーブルを作成するには、その名の通り<a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>コマンドを使用します。
このコマンドで最低限指定する必要があるのは、新規テーブル名、列名、各列のデータ型です。
例を示します。
</p><pre class="programlisting">CREATE TABLE my_first_table (
    first_column text,
    second_column integer
);</pre><p>
これで2列からなる<code class="literal">my_first_table</code>という名前のテーブルが作成されます。
最初の列の名前は<code class="literal">first_column</code>で、そのデータ型は<code class="type">text</code>です。
2番目の列の名前は<code class="literal">second_column</code>で、そのデータ型は<code class="type">integer</code>です。
テーブル名および列名は、<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS" title="4.1.1. 識別子とキーワード">Section 4.1.1</a>で説明した識別子の構文に従います。
型名も通常は識別子ですが、例外もあります。
列リストはカンマで区切り、括弧で囲むことに注意してください。
  </p><p>先ほどの例は、説明が目的であるため現実的ではありません。
通常、テーブルおよび列の名前は、どのようなデータが格納されているかわかるような名前にします。
以下に、より現実的な例を示します。
</p><pre class="programlisting">CREATE TABLE products (
    product_no integer,
    name text,
    price numeric
);</pre><p>
（<code class="type">numeric</code>型は小数を格納することができ、金額を扱う場合はこれが一般的です。）
  </p><div class="tip"><h3 class="title">Tip</h3><p>相関するテーブルを数多く作成する場合は、テーブルと列の命名規則を一貫させるのが賢明です。
例えば、テーブル名に単数形あるいは複数形どちらの名詞を使用するかという選択肢があります（これは論者によって好みが分かれています）。
   </p></div><p>テーブルに含めることができる列の数には制限があります。
制限は、列の型に応じて250〜1600の間となります。
しかし、これほど多くの列を使用することは稀ですし、そのような場合は設計に問題があることも多いのです。
  </p><a id="id-1.5.4.3.13" class="indexterm"></a><p>必要のないテーブルができた場合は、<a class="xref" href="sql-droptable.html" title="DROP TABLE"><span class="refentrytitle">DROP TABLE</span></a>コマンドを使用してそのテーブルを削除できます。
例を示します。
</p><pre class="programlisting">DROP TABLE my_first_table;
DROP TABLE products;</pre><p>
存在しないテーブルを削除しようとすると、エラーになります。
もっともテーブルが存在するかどうか関係なくスクリプト全体を動作させることができるように、テーブルを作成する前に、エラーメッセージを無視して無条件に削除操作を行うことは、SQLスクリプトファイルではよく行われることです。
（この操作を行いたければ、エラーメッセージの出力を防ぐ<code class="literal">DROP TABLE IF EXISTS</code>という構文を使用することができます。
しかし、これは標準SQLではありません。）
  </p><p>既に存在するテーブルを変更する方法については、本章で後述する<a class="xref" href="ddl-alter.html" title="5.5. テーブルの変更">Section 5.5</a>を参照してください。
  </p><p>これまでに説明したツールを使用して、十分に機能するテーブルを作成できます。
本章の残りでは、テーブル定義に機能を追加して、データの整合性、安全性、利便性を確実にする方法について述べていきます。
この時点でテーブルにデータを入力したければ、本章の残りを後回しにして<a class="xref" href="dml.html" title="Chapter 6. データ操作">Chapter 6</a>に進んでも構いません。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ddl.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ddl.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ddl-default.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 5. データ定義 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.2. デフォルト値</td></tr></table></div></body></html>