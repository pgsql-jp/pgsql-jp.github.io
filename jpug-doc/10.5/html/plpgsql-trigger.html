<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>42.9. トリガプロシージャ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="plpgsql-errors-and-messages.html" title="42.8. エラーとメッセージ" /><link rel="next" href="plpgsql-implementation.html" title="42.10. PL/pgSQLの秘訣" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">42.9. トリガプロシージャ</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="plpgsql-errors-and-messages.html" title="42.8. エラーとメッセージ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="plpgsql.html" title="Chapter 42. PL/pgSQL - SQL手続き言語">Up</a></td><th width="60%" align="center">Chapter 42. <span xmlns="http://www.w3.org/1999/xhtml" class="application">PL/pgSQL</span> - <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>手続き言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="plpgsql-implementation.html" title="42.10. PL/pgSQLの秘訣">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="PLPGSQL-TRIGGER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">42.9. トリガプロシージャ</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="plpgsql-trigger.html#PLPGSQL-DML-TRIGGER">42.9.1. データ変更によるトリガ</a></span></dt><dt><span class="sect2"><a href="plpgsql-trigger.html#PLPGSQL-EVENT-TRIGGER">42.9.2. イベントによるトリガ</a></span></dt></dl></div><a id="id-1.8.8.11.2" class="indexterm"></a><p><span class="application">PL/pgSQL</span>はデータ変更やデータベースのイベントによるトリガプロシージャの定義に使用できます。
トリガプロシージャは、<code class="command">CREATE FUNCTION</code>コマンドを使って、(データ変更トリガには)<code class="type">trigger</code>、(データベースイベントトリガには)<code class="type">event_trigger</code>という戻り値の型を持った引数のない関数として作成されます。
その呼出しのトリガの原因となった条件を記述するため、<code class="varname">TG_<em class="replaceable"><code>something</code></em></code>という名前の特別な局所変数が自動的に定義されます。
  </p><div class="sect2" id="PLPGSQL-DML-TRIGGER"><div class="titlepage"><div><div><h3 class="title">42.9.1. データ変更によるトリガ</h3></div></div></div><p><a class="link" href="triggers.html" title="Chapter 38. トリガ">データ変更トリガ</a>は<code class="type">trigger</code>という戻り値の型を持った引数のない関数として宣言されます。
その関数は、たとえ、<code class="command">CREATE TRIGGER</code>にて引数を取るものとしていたとしても、引数を持たないものと宣言しなければならないことに注意してください。
トリガの引数は、後述する通り、<code class="varname">TG_ARGV</code>経由で渡されます。
  </p><p><span class="application">PL/pgSQL</span>関数がトリガとして呼び出された場合、いくつかの特殊な変数が自動的に最上位レベルのブロックで作成されます。
それらを以下に示します。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">NEW</code></span></dt><dd><p><code class="type">RECORD</code>データ型。
この変数は行レベルのトリガでの<code class="command">INSERT</code>/<code class="command">UPDATE</code>操作によって更新された、新しいデータベースの行を保持します。
この変数は、文レベルのトリガおよび<code class="command">DELETE</code>操作では、割り当てられていません。
      </p></dd><dt><span class="term"><code class="varname">OLD</code></span></dt><dd><p><code class="type">RECORD</code>データ型。
この変数は、行レベルのトリガでの<code class="command">UPDATE</code>/<code class="command">DELETE</code>操作によって更新される前のデータベースの行を保持します。
この変数は、文レベルのトリガおよび<code class="command">INSERT</code>操作では、割り当てられていません。
      </p></dd><dt><span class="term"><code class="varname">TG_NAME</code></span></dt><dd><p><code class="type">name</code>データ型。
実際に発行されたトリガの名前を持つ変数。
      </p></dd><dt><span class="term"><code class="varname">TG_WHEN</code></span></dt><dd><p><code class="type">text</code>データ型。
トリガの定義に依存した<code class="literal">BEFORE</code>、<code class="literal">AFTER</code>、または<code class="literal">INSTEAD OF</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_LEVEL</code></span></dt><dd><p><code class="type">text</code>データ型。
トリガの定義に依存した<code class="literal">ROW</code> または <code class="literal">STATEMENT</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_OP</code></span></dt><dd><p><code class="type">text</code>データ型。
トリガを起動した操作を示す、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、または<code class="literal">TRUNCATE</code>という文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_RELID</code></span></dt><dd><p><code class="type">oid</code>データ型。
このトリガの呼び出し元になるテーブルのオブジェクトID。
      </p></dd><dt><span class="term"><code class="varname">TG_RELNAME</code></span></dt><dd><p><code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルの名前。
将来これは廃止されそうです。
代わりに<code class="literal">TG_TABLE_NAME</code>を使用してください。
      </p></dd><dt><span class="term"><code class="varname">TG_TABLE_NAME</code></span></dt><dd><p><code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルの名前。
      </p></dd><dt><span class="term"><code class="varname">TG_TABLE_SCHEMA</code></span></dt><dd><p><code class="type">name</code>データ型。
このトリガの呼び出し元になるテーブルのスキーマ名。
      </p></dd><dt><span class="term"><code class="varname">TG_NARGS</code></span></dt><dd><p><code class="type">integer</code>型。
<code class="command">CREATE TRIGGER</code>文におけるトリガプロシージャに与えられる引数の数。
      </p></dd><dt><span class="term"><code class="varname">TG_ARGV[]</code></span></dt><dd><p><code class="type">text</code>型の配列型。
<code class="command">CREATE TRIGGER</code>文での引数。
このインデックスは0から始まります。
無効なインデックス（0未満や<code class="varname">tg_nargs</code>以上）は、NULL値という結果になります。
      </p></dd></dl></div><p>
  </p><p>トリガ関数はNULLまたは、トリガの発行元になったテーブルの構造を正確に持ったレコード/行を返さなければなりません。
   </p><p><code class="literal">BEFORE</code>として発行された行レベルトリガがNULLを返す場合には、トリガマネージャに実際の行への操作を取りやめるように通知します
（つまり、その後にトリガが発行されず、その<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>はその行に対して実行されません）。
非NULL値を返す場合には、その操作はその行値で処理されます。
元の<code class="varname">NEW</code>の値と異なる行値を返すことは、挿入、更新される値を変更します。
したがってトリガ関数が行値を変更せずにトリガ処理を普通に成功させたい場合は、<code class="varname">NEW</code>(またはその等価な値)を返さなければなりません。
格納する行を変更するために、<code class="varname">NEW</code>の個々の値を直接置き換え、変更した<code class="varname">NEW</code>を返すことも、新しいレコード/行を完全に作成して返すことも可能です。
<code class="command">DELETE</code>に対するBEFOREトリガの場合、返される値は直接的な影響を与えませんが、トリガ動作を継続させるためには非NULLを返さなければなりません。
<code class="command">DELETE</code>トリガでは<code class="varname">NEW</code>がNULLであり、これを返すことは通常無意味であることに注意して下さい。
<code class="command">DELETE</code>トリガにおける通常の慣例は<code class="varname">OLD</code>を返すことです。
   </p><p><code class="literal">INSTEAD OF</code>トリガ（これは常に行レベルトリガであり、ビューに対してのみ使用可能です）は、まったく更新を行わなかったためにこの行に対する残りの操作を飛ばさなければならない（つまり後続のトリガは発行されず、 トリガの発生元の<code class="command">INSERT</code>/<code class="command">UPDATE</code>/<code class="command">DELETE</code>において影響を受けた行数として数えられない）ことを通知するNULLを返すことができます。
この他の場合は、トリガが要求された操作を実行したことを通知するために、非NULLの値を返さなければなりません。
<code class="command">INSERT</code>および<code class="command">UPDATE</code>操作では、戻り値は、トリガ関数が<code class="command">INSERT RETURNING</code>および<code class="command">UPDATE RETURNING</code>をサポートするために変更しているかもしれない、<code class="varname">NEW</code>となるはずです
（これは後続のトリガ、または、<code class="literal">ON CONFLICT DO UPDATE</code>句を伴う<code class="command">INSERT</code>文の中で特別な<code class="varname">EXCLUDED</code>別名参照に渡される行値にも影響します）。
<code class="command">DELETE</code>操作では、戻り値は<code class="varname">OLD</code>となるはずです。
   </p><p>行レベルの<code class="literal">AFTER</code>トリガ、文レベルの<code class="literal">BEFORE</code>または<code class="literal">AFTER</code>トリガの戻り値は常に無視されます。
NULLとしても構いません。
しかし、これらの種類のトリガでも、エラーを発生させることで操作全体を中断させることが可能です。
   </p><p><a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-EXAMPLE" title="Example 42.3. PL/pgSQLトリガプロシージャ">Example 42.3</a>に<span class="application">PL/pgSQL</span>のトリガプロシージャの例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-EXAMPLE"><p class="title"><strong>Example 42.3. <span class="application">PL/pgSQL</span>トリガプロシージャ</strong></p><div class="example-contents"><p>このトリガの例では、テーブルの行が挿入または更新された時には必ず、現在のユーザ名と時刻がその行に入っていることを確実にします。
そして、従業員名が与えられていることとその給料が正の値であることを確認します。
    </p><pre class="programlisting">CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- empnameとsalaryが与えられていることをチェック
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'empname cannot be null';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION '% cannot have null salary', NEW.empname;
        END IF;

        -- 支払時に問題が起こらないように
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;
        END IF;

        -- 誰がいつ変更したかを記録
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();</pre></div></div><br class="example-break" /><p>テーブルにおける変更のログを取る他の方法は、挿入、更新または削除の各々に対する行を保有する新テーブルを作成することです。
この方法はテーブルにおける変更の監査と考えることができます。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE" title="Example 42.4. PL/pgSQLによる監査用のトリガプロシージャ">Example 42.4</a>は<span class="application">PL/pgSQL</span>による監査用トリガプロシージャの一例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-AUDIT-EXAMPLE"><p class="title"><strong>Example 42.4. <span class="application">PL/pgSQL</span>による監査用のトリガプロシージャ</strong></p><div class="example-contents"><p>このトリガの例では、<code class="literal">emp</code>テーブルにおける行の挿入、更新または削除のどれもがemp_auditテーブルの中へ確実に記録（すなわち監査）されます。
現在時刻とユーザ名は、行った操作の種類とともに<code class="literal">emp_audit</code>の行の中に記録されます。
    </p><pre class="programlisting">CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- empで行った操作を反映する行をemp_auditに作成
        -- 操作の種類を決定するために、特殊な変数TG_OPを活用
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
        END IF;
        RETURN NULL; -- AFTERトリガですので、結果は無視されます
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();</pre></div></div><br class="example-break" /><p>前例の変形では、各エントリが最終修正された時を表示するため、主テーブルを監査テーブルに結合したビューを使用します。
この方法でもテーブルの変化の監査証跡を全て記録できますが、監査証跡から抽出した各エントリの最終修正のタイムスタンプ表示することにより、監査証跡の簡単なビューを表示することにもなります。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-VIEW-TRIGGER-AUDIT-EXAMPLE" title="Example 42.5. 監査のためのPL/pgSQLビュートリガプロシージャ">Example 42.5</a>で示すものは、<span class="application">PL/pgSQL</span>を用いたビューの監査トリガの例です。
   </p><div class="example" id="PLPGSQL-VIEW-TRIGGER-AUDIT-EXAMPLE"><p class="title"><strong>Example 42.5. 監査のための<span class="application">PL/pgSQL</span>ビュートリガプロシージャ</strong></p><div class="example-contents"><p>この例では、ビューを更新可能とし、その行の挿入、更新、削除を<code class="literal">emp_audit</code>テーブルに確実に記録（つまり監査）するためにビューに対するトリガを使用します。
現在時刻とユーザ名が実行された操作種類と一緒に記録されます。
ビューは各行の最終更新時間を表示します。
    </p><pre class="programlisting">CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- 要求された操作を emp に実行し
        -- emp_audit に行を作成し
        -- emp の変化を反映する
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();</pre></div></div><br class="example-break" /><p>トリガの使用目的の1つは、あるテーブルのサマリテーブルを維持することです。
結果のサマリテーブルは、元のテーブルに代わって、ある種の問い合わせに対して使用でき、しばしば実行時間を大幅に縮小します。
通常この手法は、計測または観測データ（ファクトテーブルと言います）が非常に大きくなるかもしれない、データウェアハウスに使用されます。
データウェアハウス内のファクトテーブルに対してサマリテーブルを維持する<span class="application">PL/pgSQL</span>のトリガプロシージャの例を<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-SUMMARY-EXAMPLE" title="Example 42.6. サマリテーブルを維持するためのPL/pgSQLトリガプロシージャ">Example 42.6</a>に示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-SUMMARY-EXAMPLE"><p class="title"><strong>Example 42.6. サマリテーブルを維持するための<span class="application">PL/pgSQL</span>トリガプロシージャ</strong></p><div class="example-contents"><p>ここに述べるスキーマの一部はRalph Kimballによる<span class="emphasis"><em>The Data Warehouse Toolkit</em></span>の<span class="emphasis"><em>Grocery Store</em></span>の例に基づいています。
    </p><pre class="programlisting">--
-- time dimensionとsales factの主テーブル
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- sales by timeのサマリテーブル
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- 更新、挿入および削除によりサマリテーブルの列を修正する関数とトリガ
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- 増加または減少量を算出
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- time_keyを変更する更新を禁止します
            -- （削除 + 挿入の方法により大部分の変更を行うため
            -- それほど厄介ではありません）。
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Update of time_key : % -&gt; % not allowed',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- サマリテーブルの行を挿入または新しい値で更新します。
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- 何もしません
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;</pre></div></div><br class="example-break" /><p><code class="literal">AFTER</code>トリガは、トリガ文により変更された行の集合全体を調べるために<em class="firstterm">遷移テーブル</em>を使うこともできます。
<code class="command">CREATE TRIGGER</code>コマンドで名前を1つまたは2つの遷移テーブルに割り当てると、関数はその名前を読み込み専用の一時テーブルであるかのように参照できます。
<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-TRANSITION-EXAMPLE" title="Example 42.7. 遷移テーブルでの監査">Example 42.7</a>に例を示します。
   </p><div class="example" id="PLPGSQL-TRIGGER-AUDIT-TRANSITION-EXAMPLE"><p class="title"><strong>Example 42.7. 遷移テーブルでの監査</strong></p><div class="example-contents"><p>この例は<a class="xref" href="plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE" title="Example 42.4. PL/pgSQLによる監査用のトリガプロシージャ">Example 42.4</a>と同じ結果になりますが、行毎に起動するトリガを使う代わりに、関係のある情報を遷移テーブルに集めた後に文毎に1回起動するトリガを使っています。
これは、呼び出された文が多くの行を変更する場合には行トリガの方法よりとても速くなる場合があります。
<code class="literal">REFERENCING</code>句はそれぞれの場合で異ならなければなりませんので、それぞれの種類のイベントに対して別々のトリガ宣言をしなければならないことに注意してください。
ですが、もし選ぶのなら、このために単一のトリガ関数が使えなくなることはありません。
(実際には、3つに別れた関数を使い、実行時の<code class="varname">TG_OP</code>の確認を避ける方が良いでしょう。)
    </p><pre class="programlisting">CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- empで実行された操作を反映するためにemp_auditに行を作り、
        -- 操作を完了するために特殊な変数TG_OPを使う。
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit
                SELECT 'D', now(), user, o.* FROM old_table o;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit
                SELECT 'U', now(), user, n.* FROM new_table n;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit
                SELECT 'I', now(), user, n.* FROM new_table n;
        END IF;
        RETURN NULL; -- これはAFTERトリガなので結果は無視される
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit_ins
    AFTER INSERT ON emp
    REFERENCING NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();
CREATE TRIGGER emp_audit_upd
    AFTER UPDATE ON emp
    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table
    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();
CREATE TRIGGER emp_audit_del
    AFTER DELETE ON emp
    REFERENCING OLD TABLE AS old_table
    FOR EACH STATEMENT EXECUTE PROCEDURE process_emp_audit();</pre></div></div><br class="example-break" /></div><div class="sect2" id="PLPGSQL-EVENT-TRIGGER"><div class="titlepage"><div><div><h3 class="title">42.9.2. イベントによるトリガ</h3></div></div></div><p><span class="application">PL/pgSQL</span>は<a class="link" href="event-triggers.html" title="Chapter 39. イベントトリガ">イベントトリガ</a>の定義に使用できます。
イベントトリガとして呼び出されるプロシージャは、引数のない関数として宣言され、戻り値の型は<code class="literal">event_trigger</code>となることが<span class="productname">PostgreSQL</span>では必須です。
   </p><p><span class="application">PL/pgSQL</span>関数がイベントトリガとして呼び出された場合、数個の特別な変数が最高レベルのブロックで自動的に作成されます。
以下に示します。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">TG_EVENT</code></span></dt><dd><p><code class="type">text</code>データ型。
トリガが発行されたイベントを示す文字列。
      </p></dd><dt><span class="term"><code class="varname">TG_TAG</code></span></dt><dd><p><code class="type">text</code>データ型。
トリガが発行されたコマンドタグを含む変数。
      </p></dd></dl></div><p>
  </p><p><a class="xref" href="plpgsql-trigger.html#PLPGSQL-EVENT-TRIGGER-EXAMPLE" title="Example 42.8. PL/pgSQLイベントトリガプロシージャ">Example 42.8</a>は<span class="application">PL/pgSQL</span>におけるイベントトリガプロシージャの一例を示します。
   </p><div class="example" id="PLPGSQL-EVENT-TRIGGER-EXAMPLE"><p class="title"><strong>Example 42.8. <span class="application">PL/pgSQL</span>イベントトリガプロシージャ</strong></p><div class="example-contents"><p>以下の例では、サポートされたコマンドが実行されたとき、トリガは<code class="literal">NOTICE</code>を発生させるだけです。
    </p><pre class="programlisting">CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();</pre></div></div><br class="example-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-errors-and-messages.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-implementation.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">42.8. エラーとメッセージ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 42.10. <span class="application">PL/pgSQL</span>の秘訣</td></tr></table></div></body></html>