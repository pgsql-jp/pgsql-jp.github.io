<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>33.4. 非同期コマンドの処理</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="libpq-exec.html" title="33.3. コマンド実行関数" /><link rel="next" href="libpq-single-row-mode.html" title="33.5. １行１行問い合わせ結果を受け取る" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">33.4. 非同期コマンドの処理</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="libpq-exec.html" title="33.3. コマンド実行関数">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="libpq.html" title="Chapter 33. libpq - C ライブラリ">Up</a></td><th width="60%" align="center">Chapter 33. <span xmlns="http://www.w3.org/1999/xhtml" class="application">libpq</span> - C ライブラリ</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="libpq-single-row-mode.html" title="33.5. １行１行問い合わせ結果を受け取る">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="LIBPQ-ASYNC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">33.4. 非同期コマンドの処理</h2></div></div></div><a id="id-1.7.3.11.2" class="indexterm"></a><p><code class="function">PQexec</code>関数は普通の同期処理のアプリケーションにおけるコマンドの送信に適したものです。
しかし、一部のユーザにとって重要な問題となり得る、数個の問題があります。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="function">PQexec</code> はコマンドが完了するまで待機します。
アプリケーションによっては(例えばユーザインタフェースの調整処理など)他に行うべき作業があります。
この場合は応答待ちでブロックさせたくはありません。
     </p></li><li class="listitem"><p>クライアントアプリケーションの実行が結果を待っている間停止されるため、アプリケーションで送信したコマンドをキャンセルさせる指示を行うことは困難です。
(シグナルハンドラを使って達成することができますが、他の方法はありません。)
     </p></li><li class="listitem"><p><code class="function">PQexec</code>が返すことができる<code class="structname">PGresult</code>構造体は1つだけです。
もし送信した問い合わせ文字列が複数の<acronym class="acronym">SQL</acronym>コマンドを含んでいる場合、<code class="function">PQexec</code>は最後のものだけを除いて、残りすべての<code class="structname">PGresult</code>を破棄してしまいます。
     </p></li><li class="listitem"><p><code class="function">PQexec</code>は常にコマンドの結果全体を収集し、１つの<code class="structname">PGresult</code>内に保管します。
アプリケーションにおけるエラー処理を簡単にしますが、多くの行になる結果では非現実的になるかもしれません。
     </p></li></ul></div><p>
  </p><p>アプリケーションにとってこのような制限が望ましくない場合は、代わりに<code class="function">PQexec</code>を構成する関数<code class="function">PQsendQuery</code>と<code class="function">PQgetResult</code>を使用してください。
また、<code class="function">PQsendQueryParams</code>と<code class="function">PQsendPrepare</code>、<code class="function">PQsendQueryPrepared</code>、<code class="function">PQsendDescribePrepared</code>、<code class="function">PQsendDescribePortal</code>もあり、<code class="function">PQgetResult</code>を使用して、それぞれ<code class="function">PQexecParams</code>と<code class="function">PQprepare</code>、<code class="function">PQexecPrepared</code>、<code class="function">PQdescribePrepared</code>、<code class="function">PQdescribePortal</code>と同等の機能を行うことができます。

   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSENDQUERY"><span class="term">      <code class="function">PQsendQuery</code>
      <a id="id-1.7.3.11.4.15.1.1.2" class="indexterm"></a>
     </span></dt><dd><p>結果を待つことなく、サーバにコマンドを発行します。
コマンドの登録に成功した場合1が、失敗した場合0が返されます。
(後者の場合、<code class="function">PQerrorMessage</code>を使用して失敗についてのより多くの情報を取り出してください。)
</p><pre class="synopsis">int PQsendQuery(PGconn *conn, const char *command);</pre><p>

<code class="function">PQsendQuery</code>呼び出しが成功したら、<code class="function">PQgetResult</code>を繰り返し呼び出して、実行結果を取得します。
<code class="function">PQgetResult</code>がヌルポインタを返し、コマンドが完了したことを示すまでは、(同じ接続で)<code class="function">PQsendQuery</code>を再度呼び出すことはできません。
      </p></dd><dt id="LIBPQ-PQSENDQUERYPARAMS"><span class="term">      <code class="function">PQsendQueryParams</code>
      <a id="id-1.7.3.11.4.15.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>結果を待つことなく、サーバにコマンドとパラメータとを分けて発行します。
</p><pre class="synopsis">int PQsendQueryParams(PGconn *conn,
                      const char *command,
                      int nParams,
                      const Oid *paramTypes,
                      const char * const *paramValues,
                      const int *paramLengths,
                      const int *paramFormats,
                      int resultFormat);</pre><p>

これは、問い合わせのパラメータが問い合わせ文字列と分けて指定できる点を除き、<code class="function">PQsendQuery</code>と同じです。
この関数のパラメータは<code class="function">PQexecParams</code>と同様に扱われます。
<code class="function">PQexecParams</code>同様、これは2.0プロトコルでは動作しませんし、問い合わせ文字列には1つのコマンドしか指定できません。
      </p></dd><dt id="LIBPQ-PQSENDPREPARE"><span class="term">      <code class="function">PQsendPrepare</code>
      <a id="id-1.7.3.11.4.15.3.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定パラメータを持つプリペアド文の作成要求を送信します。
その完了を待ちません。
</p><pre class="synopsis">int PQsendPrepare(PGconn *conn,
                  const char *stmtName,
                  const char *query,
                  int nParams,
                  const Oid *paramTypes);</pre><p>

これは<code class="function">PQprepare</code>の非同期版です。
要求の登録に成功した場合1が、失敗した場合0が返されます。
呼び出しの成功の後、サーバがプリペアド文の生成に成功したかを確認するためには<code class="function">PQgetResult</code>を呼び出してください。
この関数のパラメータは<code class="function">PQprepare</code>と同様に扱われます。
<code class="function">PQprepare</code>同様、これは2.0プロトコルの接続では動作しません。
      </p></dd><dt id="LIBPQ-PQSENDQUERYPREPARED"><span class="term">      <code class="function">PQsendQueryPrepared</code>
      <a id="id-1.7.3.11.4.15.4.1.2" class="indexterm"></a>
     </span></dt><dd><p>結果を待つことなく、指定したパラメータでプリペアド文の実行要求を送信します。
</p><pre class="synopsis">int PQsendQueryPrepared(PGconn *conn,
                        const char *stmtName,
                        int nParams,
                        const char * const *paramValues,
                        const int *paramLengths,
                        const int *paramFormats,
                        int resultFormat);</pre><p>

これは<code class="function">PQsendQueryParams</code>と似ていますが、実行されるコマンドは問い合わせ文字列ではなく、事前に準備された文の名前で指定されます。
この関数のパラメータは<code class="function">PQexecPrepared</code>と同様に扱われます。
<code class="function">PQexecPrepared</code>同様、これは2.0プロトコルでは動作しません。
      </p></dd><dt id="LIBPQ-PQSENDDESCRIBEPREPARED"><span class="term">      <code class="function">PQsendDescribePrepared</code>
      <a id="id-1.7.3.11.4.15.5.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定したプリペアド文に関する情報入手要求を送ります。
入手完了まで待機しません。
</p><pre class="synopsis">int PQsendDescribePrepared(PGconn *conn, const char *stmtName);</pre><p>

これは<code class="function">PQdescribePrepared</code>の非同期版です。
要求の受付けが可能であれば1が返されます。不可能であれば0が返されます。
呼び出しに成功した後、<code class="function">PQgetResult</code>を呼び出して結果を入手してください。
この関数のパラメータは<code class="function">PQdescribePrepared</code>と同じように扱われます。
<code class="function">PQdescribePrepared</code>同様、2.0プロトコル接続では動作しません。
      </p></dd><dt id="LIBPQ-PQSENDDESCRIBEPORTAL"><span class="term">      <code class="function">PQsendDescribePortal</code>
      <a id="id-1.7.3.11.4.15.6.1.2" class="indexterm"></a>
     </span></dt><dd><p>指定したポータルに関する情報入手要求を送信します。
完了まで待機しません。
</p><pre class="synopsis">int PQsendDescribePortal(PGconn *conn, const char *portalName);</pre><p>

これは<code class="function">PQdescribePortal</code>の非同期版です。
要求の受付けが可能であれば1が返されます。不可能であれば0が返されます。
呼び出しに成功した後、<code class="function">PQgetResult</code>を呼び出して結果を入手してください。
この関数のパラメータは<code class="function">PQdescribePortal</code>と同じように扱われます。
<code class="function">PQdescribePortal</code>同様、2.0プロトコル接続では動作しません。
      </p></dd><dt id="LIBPQ-PQGETRESULT"><span class="term">      <code class="function">PQgetResult</code>
      <a id="id-1.7.3.11.4.15.7.1.2" class="indexterm"></a>
     </span></dt><dd><p>以前に呼び出した<code class="function">PQsendQuery</code>、<code class="function">PQsendQueryParams</code>、<code class="function">PQsendPrepare</code>、<code class="function">PQsendQueryPrepared</code>、<code class="function">PQsendDescribePrepared</code>、<code class="function">PQsendDescribePortal</code>から次の結果を待ち、その結果を返します。
コマンドが完了し、これ以上結果がない場合は、ヌルポインタが返されます。
</p><pre class="synopsis">PGresult *PQgetResult(PGconn *conn);</pre><p>
      </p><p><code class="function">PQgetResult</code>は、コマンドの完了を示すヌルポインタが返るまで、繰り返し呼び出さなければなりません。
(コマンド実行中以外での呼び出しでは、<code class="function">PQgetResult</code>は単にヌルポインタを返します。)
<code class="function">PQgetResult</code>の非ヌルの結果はそれぞれ前述と同じ<code class="structname">PGresult</code>アクセス用関数を使用して処理されなければなりません。
各結果オブジェクトに対する処理が終わったら、そのオブジェクトを<code class="function">PQclear</code>を使用して解放することを忘れないでください。
コマンドが活動中、かつ、必要な応答データがまだ<code class="function">PQconsumeInput</code>で読み込まれていない場合にのみ、<code class="function">PQgetResult</code>がブロックすることに注意してください。
      </p><div class="note"><h3 class="title">Note</h3><p><code class="function">PQresultStatus</code>が致命的なエラーを示した場合であっても、<span class="application">libpq</span>がエラー情報を完全に処理できるようにヌルポインタが返されるまで<code class="function">PQgetResult</code>を呼び出さなければなりません。
       </p></div></dd></dl></div><p>
  </p><p><code class="function">PQsendQuery</code>と<code class="function">PQgetResult</code>を使うことで<code class="function">PQexec</code>の問題は1つ解決します。
つまり、コマンドが複数の<acronym class="acronym">SQL</acronym>コマンドを含んでいる場合でも、これらのコマンドの結果を個々に得ることができるわけです
（これは多重処理を単純な形で実現します。
単一のコマンド文字列に含まれる複数の問い合わせの内、後ろのものが処理中でもフロントエンドは先に完了した結果から扱うことができるからです）。
  </p><p><code class="function">PQsendQuery</code>および<code class="function">PQgetResult</code>で得られる、その他のよく望まれる機能は多くの問い合わせ結果を一度に1行受け取ることです。
これについては<a class="xref" href="libpq-single-row-mode.html" title="33.5. １行１行問い合わせ結果を受け取る">Section 33.5</a>で説明します。
  </p><p>サーバが次の<acronym class="acronym">SQL</acronym>コマンドの処理に入ると、それが完了するまでやはり<code class="function">PQgetResult</code>の呼び出しがフロントエンドをブロックしてしまいます。
さらに以下の2つの関数をうまく使用してこれを防ぐことができます。

   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQCONSUMEINPUT"><span class="term">      <code class="function">PQconsumeInput</code>
      <a id="id-1.7.3.11.7.3.1.1.2" class="indexterm"></a>
     </span></dt><dd><p>サーバからの入力が可能になった場合、それを吸い取ります。
</p><pre class="synopsis">int PQconsumeInput(PGconn *conn);</pre><p>
      </p><p><code class="function">PQconsumeInput</code>は通常、<span class="quote">“<span class="quote">エラーなし</span>”</span>を示す1を返しますが、何らかの障害があると0を返します（この場合は、<code class="function">PQerrorMessage</code>を参考にしてください）。
この結果は、何らかの入力データが実際に収集されたかどうかを示しているのではないことに注意してください。
<code class="function">PQconsumeInput</code>の呼び出し後、アプリケーションは<code class="function">PQisBusy</code>、または必要があれば<code class="function">PQnotifies</code>を呼び出して状態に変化がないか調べることができます。
      </p><p><code class="function">PQconsumeInput</code>は、結果や通知を扱うようにまだ準備していないアプリケーションからでも呼び出すことができます。
この関数は有効なデータを読み込んでバッファに保存し、結果として<code class="function">select</code>による読み込み準備完了の通知をリセットします。
従ってアプリケーションは<code class="function">PQconsumeInput</code>を使うと<code class="function">select()</code>の検査条件をただちに満たすことができますから、あとはゆっくりと結果を調べてやればいいわけです。
      </p></dd><dt id="LIBPQ-PQISBUSY"><span class="term">      <code class="function">PQisBusy</code>
      <a id="id-1.7.3.11.7.3.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>この関数が1を返したのであれば、問い合わせは処理の最中で、<code class="function">PQgetResult</code>も入力を待ったままブロック状態になってしまうでしょう。
0が返ったのであれば、<code class="function">PQgetResult</code>を呼び出してもブロックされないことが保証されます。
</p><pre class="synopsis">int PQisBusy(PGconn *conn);</pre><p>
      </p><p><code class="function">PQisBusy</code>自身はサーバからデータを読み込む操作をしません。
ですから、まず最初に<code class="function">PQconsumeInput</code>を呼び出す必要があります。
そうしないとビジー状態がいつまでも続きます。
      </p></dd></dl></div><p>
  </p><p>これら3関数を使用するアプリケーションは通常、<code class="function">select()</code>もしくは<code class="function">poll()</code>を使用するメインループを持ち、対応しなければならないすべての状態を待機しています。
その内の1つの条件は、サーバからの利用可能な入力となるでしょう。
これは、<code class="function">select()</code>の見地からは、<code class="function">PQsocket</code>で識別されるファイル記述子上で読み込み可能なデータがあることを意味します。
メインループが入力準備完了を検出すると、その入力を読み込むために<code class="function">PQconsumeInput</code>を呼び出さなければなりません。
そして、<code class="function">PQisBusy</code>を、更に<code class="function">PQisBusy</code>が偽(0)を返す場合に<code class="function">PQgetResult</code>も呼び出すことができます。
また、<code class="function">PQnotifies</code>を呼び出して、<code class="command">NOTIFY</code>メッセージ( <a class="xref" href="libpq-notify.html" title="33.8. 非同期通知">Section 33.8</a>を参照)を検出することもできます。
  </p><p>また、<code class="function">PQsendQuery</code>/<code class="function">PQgetResult</code>を使用するクライアントは、サーバで処理中のコマンドに対してキャンセルを試行することができます。
<a class="xref" href="libpq-cancel.html" title="33.6. 処理中の問い合わせのキャンセル">Section 33.6</a>を参照してください。
しかし、<code class="function">PQcancel</code>の戻り値と関係なく、アプリケーションは<code class="function">PQgetResult</code>を使用した通常の結果読み取り手順を続けなければなりません。
キャンセル手続きの成功は単に、そのコマンドを通常よりも早めに終わらせるだけです。
  </p><p>上述の関数を使用して、データベースサーバからの入力待ちのためのブロックを行わずに済みます。
しかしまだ、サーバへの出力送信を待つためにアプリケーションはブロックする可能性があります。
これは比較的あまり発生しませんが、非常に長いSQLコマンドやデータ値が送信される場合に発生することがあります。
(しかし、アプリケーションが<code class="command">COPY IN</code>経由でデータを送信する場合よく発生します。)
この発生を防ぎ、完全な非ブロックのデータベース操作を行うためには、さらに以下の関数を使用してください。

   </p><div class="variablelist"><dl class="variablelist"><dt id="LIBPQ-PQSETNONBLOCKING"><span class="term">      <code class="function">PQsetnonblocking</code>
      <a id="id-1.7.3.11.10.2.1.1.2" class="indexterm"></a>
     </span></dt><dd><p>接続の非ブロック状態を設定します。
</p><pre class="synopsis">int PQsetnonblocking(PGconn *conn, int arg);</pre><p>
      </p><p><em class="parameter"><code>arg</code></em>が1の場合、接続状態を非ブロックに設定します。
<em class="parameter"><code>arg</code></em>が0の場合はブロックに設定します。
問題がなければ0が、エラー時は-1が返ります。
      </p><p>非ブロック状態では<code class="function">PQsendQuery</code>、<code class="function">PQputline</code>、<code class="function">PQputnbytes</code>、<code class="function">PQputCopyData</code>および<code class="function">PQendcopy</code>の呼び出しはブロックされませんが、再度呼び出さなければならない場合、エラーが返ります。
      </p><p><code class="function">PQexec</code>は非ブロックモードにはしたがわないことに注意してください。
この関数の呼び出しは、必ずブロック方式で動作します。
      </p></dd><dt id="LIBPQ-PQISNONBLOCKING"><span class="term">      <code class="function">PQisnonblocking</code>
      <a id="id-1.7.3.11.10.2.2.1.2" class="indexterm"></a>
     </span></dt><dd><p>データベース接続のブロック状態を返します。
</p><pre class="synopsis">int PQisnonblocking(const PGconn *conn);</pre><p>
      </p><p>接続が非ブロック状態の場合は1が、ブロック状態の場合は0が返ります。
      </p></dd><dt id="LIBPQ-PQFLUSH"><span class="term">      <code class="function">PQflush</code>
       <a id="id-1.7.3.11.10.2.3.1.2" class="indexterm"></a>
      </span></dt><dd><p>キューに蓄えられたサーバへの出力データの吐き出しを行います。
成功時(および送信キューが空の場合)は0が返ります。
何らかの原因で失敗した場合は-1が、送信キュー内のデータをすべて送信できなかった場合は1が返ります。
(これは接続が非ブロックの場合にのみ発生します。)
</p><pre class="synopsis">int PQflush(PGconn *conn);</pre><p>
      </p></dd></dl></div><p>
  </p><p>非ブロック接続時にはコマンドやデータを送信した後に、<code class="function">PQflush</code>を呼び出してください。
1が返った場合、ソケットの読み込みまたは書き込み準備ができるまで待ってください。
書き込み準備ができたら、<code class="function">PQflush</code>を再度呼び出してください。
読み込み準備ができたら、<code class="function">PQconsumeInput</code>を呼び出してから、<code class="function">PQflush</code>を再度呼び出してください。
これを<code class="function">PQflush</code>が0を返すまで繰り返してください。
(例えばNOTICEメッセージのように、こちらがそのデータを読むまで、サーバがデータを送ろうとするのを妨げ、こちらのデータを読もうとしないことがありますので、読み込み準備ができたことを確認して<code class="function">PQconsumeInput</code>で入力をすべて抜き取ることが必要です。)
<code class="function">PQflush</code>が0を返した後は、ソケットの読み込み準備が整うまで待ち、上述のように応答を読み取ってください。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="libpq-exec.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="libpq.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="libpq-single-row-mode.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">33.3. コマンド実行関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 33.5. １行１行問い合わせ結果を受け取る</td></tr></table></div></body></html>