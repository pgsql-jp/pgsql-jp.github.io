<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.3. データベースサーバの起動</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="creating-cluster.html" title="18.2. データベースクラスタの作成" /><link rel="next" href="kernel-resources.html" title="18.4. カーネルリソースの管理" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">18.3. データベースサーバの起動</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="creating-cluster.html" title="18.2. データベースクラスタの作成">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="Chapter 18. サーバの準備と運用">Up</a></td><th width="60%" align="center">Chapter 18. サーバの準備と運用</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="kernel-resources.html" title="18.4. カーネルリソースの管理">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="SERVER-START"><div class="titlepage"><div><div><h2 class="title" style="clear: both">18.3. データベースサーバの起動</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="server-start.html#SERVER-START-FAILURES">18.3.1. サーバ起動の失敗</a></span></dt><dt><span class="sect2"><a href="server-start.html#CLIENT-CONNECTION-PROBLEMS">18.3.2. クライアント接続の問題</a></span></dt></dl></div><p>データベースにアクセスするためには、まずデータベースサーバを起動しなくてはいけません。
データベースサーバプログラムは<code class="command">postgres</code>という名前です。
<a id="id-1.6.5.5.2.2" class="indexterm"></a>
<code class="command">postgres</code>プログラムは自分が使用するデータがどこにあるのかを知っている必要があります。
これは<code class="option">-D</code>オプションで指定されます。
したがって、サーバを起動する一番簡単な方法は、以下のようなコマンドとなります。
</p><pre class="screen">$ <strong class="userinput"><code>postgres -D /usr/local/pgsql/data</code></strong></pre><p>
上記のコマンドはサーバをフォアグラウンドで実行させます。
これは、<span class="productname">PostgreSQL</span>ユーザアカウントにログインして実行されなくてはいけません。
<code class="option">-D</code>オプションが指定されていない場合、サーバは<code class="envar">PGDATA</code>環境変数で指定されたデータディレクトリを使用しようと試みます。
どちらの変数も指定されていなければ失敗します。
  </p><p>通常はバックグラウンドで<code class="command">postgres</code>を起動することをお勧めします。
そのためには以下のように通常のUnixシェルの構文を使います。
</p><pre class="screen">$ <strong class="userinput"><code>postgres -D /usr/local/pgsql/data &gt;logfile 2&gt;&amp;1 &amp;</code></strong></pre><p>
この例のように、サーバの<span class="systemitem">標準出力</span>と<span class="systemitem">標準エラー</span>出力をどこかに保管しておくことが重要です。
これは追跡記録的な目的と問題の原因究明に役立ちます。
（ログファイルの取り扱いについての全体的な説明については<a class="xref" href="logfile-maintenance.html" title="24.3. ログファイルの保守">Section 24.3</a>を参照してください。）
  </p><p><code class="command">postgres</code>プログラムには、この他にも多くのコマンドラインオプションを指定することができます。
詳細は<a class="xref" href="app-postgres.html" title="postgres"><span class="refentrytitle"><span class="application">postgres</span></span></a>マニュアルページと後述の<a class="xref" href="runtime-config.html" title="Chapter 19. サーバの設定">Chapter 19</a>を参照してください。
  </p><p>こうしたシェル構文は長くなりがちです。そのため、
<a class="xref" href="app-pg-ctl.html" title="pg_ctl"><span class="refentrytitle"><span class="application">pg_ctl</span></span></a><a id="id-1.6.5.5.5.2" class="indexterm"></a>
ラッパプログラムが提供されていて、いくつかのタスクを単純化しています。
以下に例を示します。
</p><pre class="programlisting">pg_ctl start -l logfile</pre><p>
これは、サーバをバックグラウンドで起動し、出力を指定されたログファイルに書き出します。
<code class="option">-D</code>オプションは、ここでも<code class="command">postgres</code>の場合と同じ意味を持ちます。
<code class="command">pg_ctl</code>によってサーバを停止させることもできます。
  </p><p>通常、コンピュータが起動された時にデータベースサーバも一緒に起動したい場合が多いと思われます。
   <a id="id-1.6.5.5.6.1" class="indexterm"></a>
自動起動スクリプトはオペレーティングシステム固有のものです。
いくつかは<span class="productname">PostgreSQL</span>の<code class="filename">/contrib/start-scripts</code>ディレクトリに同梱されています。
このインストールにはおそらくroot権限が必要となります。
  </p><p>起動時にデーモンを開始する方法はシステムによって異なります。
多くのシステムには<code class="filename">/etc/rc.local</code>ファイルや<code class="filename">/etc/rc.d/rc.local</code>ファイルがあります。
他のシステムでは<code class="filename">init.d</code>や<code class="filename">rc.d</code>ディレクトリが使用されます。
何を実行するにしても、サーバは<span class="productname">PostgreSQL</span>ユーザアカウントで起動させなければなりません。
<span class="emphasis"><em>rootであってはいけません</em></span>し、他のユーザでもいけません。
したがって、<code class="literal">su postgres -c '...'</code>を使用してコマンドを実行する必要があるでしょう。
以下に例を示します。
</p><pre class="programlisting">su postgres -c 'pg_ctl start -D /usr/local/pgsql/data -l serverlog'</pre><p>
  </p><p>さらにいくつかのオペレーティングシステム固有の提案を挙げます。
（ここでは一般的な値で説明していますので、各項目において適切なインストールディレクトリとユーザ名に置き換えて読んでください。）

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="productname">FreeBSD</span>では、<span class="productname">PostgreSQL</span>のソース配布物の中にある<code class="filename">contrib/start-scripts/freebsd</code>ファイルを参照してください。
<a id="id-1.6.5.5.8.1.1.1.4" class="indexterm"></a>
     </p></li><li class="listitem"><p><span class="productname">OpenBSD</span>では、以下の数行を<code class="filename">/etc/rc.local</code>ファイルに追加してください。
<a id="id-1.6.5.5.8.1.2.1.3" class="indexterm"></a>
</p><pre class="programlisting">if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postgres ]; then
    su -l postgres -c '/usr/local/pgsql/bin/pg_ctl start -s -l /var/postgresql/log -D /usr/local/pgsql/data'
    echo -n ' postgresql'
fi</pre><p>
     </p></li><li class="listitem"><p><span class="productname">Linux</span>システムでは、
<a id="id-1.6.5.5.8.1.3.1.2" class="indexterm"></a>
</p><pre class="programlisting">/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data</pre><p>
を<code class="filename">/etc/rc.d/rc.local</code>や<code class="filename">/etc/rc.local</code>に追加してください。
または、<span class="productname">PostgreSQL</span>のソース配布物の中にある<code class="filename">contrib/start-scripts/linux</code>ファイルを参照してください。
     </p><p><span class="application">systemd</span>を使用する場合は以下のサービスユニットファイルを（例えば<code class="filename">/etc/systemd/system/postgresql.service</code>として）使用できます。
</p><pre class="programlisting">[Unit]
Description=PostgreSQL database server
Documentation=man:postgres(1)

[Service]
Type=notify
User=postgres
ExecStart=/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data
ExecReload=/bin/kill -HUP $MAINPID
KillMode=mixed
KillSignal=SIGINT
TimeoutSec=0

[Install]
WantedBy=multi-user.target</pre><p>
<code class="literal">Type=notify</code>を使うには、サーバのバイナリが<code class="literal">configure --with-systemd</code>でビルドされている必要があります。
     </p><p>タイムアウトの設定について注意深く考えてみましょう。
この文書を書いている時点で、<span class="application">systemd</span>のデフォルトのタイムアウトは90秒で、その時間内に準備ができたことを通知しないプロセスは終了させられます。
しかし、<span class="productname">PostgreSQL</span>サーバは起動時にクラッシュリカバリを実行せねばならないことがあり、準備ができるまでにそれよりずっと長い時間を要することがあります。
ここで提案されている0という値は、そのタイムアウトの仕組みを無効にします。
     </p></li><li class="listitem"><p><span class="productname">NetBSD</span>では、<span class="productname">FreeBSD</span>か<span class="productname">Linux</span>の好きな方の起動スクリプトを使用してください。
<a id="id-1.6.5.5.8.1.4.1.4" class="indexterm"></a>
     </p></li><li class="listitem"><p><span class="productname">Solaris</span>では、<code class="filename">/etc/init.d/postgresql</code>というファイルを作成し、そこに以下の1行を記述してください。
<a id="id-1.6.5.5.8.1.5.1.3" class="indexterm"></a>
</p><pre class="programlisting">su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l logfile -D /usr/local/pgsql/data"</pre><p>
そして、<code class="filename">/etc/rc3.d</code>以下に<code class="filename">S99postgresql</code>としてそのファイルに対するシンボリックリンクを作成してください。
     </p></li></ul></div><p>

  </p><p>サーバが実行している間は、その<acronym class="acronym">PID</acronym>はデータディレクトリの中の<code class="filename">postmaster.pid</code>ファイルに記述されています。
これは同じデータディレクトリで複数のサーバインスタンスが実行されるのを防止し、また、サーバの停止にも使うことができます。
   </p><div class="sect2" id="SERVER-START-FAILURES"><div class="titlepage"><div><div><h3 class="title">18.3.1. サーバ起動の失敗</h3></div></div></div><p>サーバの起動が失敗する理由として代表的なものがいくつかあります。
サーバのログファイルを点検するか、（標準出力や標準エラーをリダイレクトせずに）手動で起動して、どのようなエラーメッセージが出ているか確認してください。
以下に、よく発生するエラーメッセージのいくつかをより詳細に説明します。
    </p><pre class="screen">LOG:  could not bind IPv4 address "127.0.0.1": Address already in use
HINT:  Is another postmaster already running on port 5432? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</pre><p>
これはたいていの場合メッセージが示す通りの意味です。
既にサーバが動いているポートで別のサーバを起動しようとしたことを示しています。
しかし、カーネルエラーメッセージが<code class="computeroutput">Address already in use</code>やそれに類似したものではない場合は、別の問題の可能性もあります。
例えば、予約済みのポート番号でサーバを起動しようとすると下記のようなメッセージが出るかもしれません。
</p><pre class="screen">$ <strong class="userinput"><code>postgres -p 666</code></strong>
LOG:  could not bind IPv4 address "127.0.0.1": Permission denied
HINT:  Is another postmaster already running on port 666? If not, wait a few seconds and retry.
FATAL:  could not create any TCP/IP sockets</pre><p>
    </p><p>次のようなメッセージが表示された場合、
</p><pre class="screen">FATAL:  could not create shared memory segment: Invalid argument
DETAIL:  Failed system call was shmget(key=5440001, size=4011376640, 03600).</pre><p>
これは、おそらくカーネルによる共有メモリのサイズの上限が<span class="productname">PostgreSQL</span>が作ろうとしている作業領域（この例では4011376640バイト）よりも小さいことを示しています。
または、System V方式の共有メモリサポートがカーネルにまったく設定されていない可能性もあります。
一時的な策として、サーバを通常よりも少ないバッファ数（<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>）で起動することもできます。
しかし最終的には、カーネルを再設定し、使用可能な共有メモリサイズを増やした方が良いでしょう。
このメッセージは、同じマシン上で複数のサーバを起動しようとした時に、要求された領域の合計がカーネルの上限を超えた場合にも表示されます。
    </p><p>下記のようなエラーの場合:
</p><pre class="screen">FATAL:  could not create semaphores: No space left on device
DETAIL:  Failed system call was semget(5440126, 17, 03600).</pre><p>
ディスクの空き容量がなくなったということを示しているわけでは<span class="emphasis"><em>ありません</em></span>。
これはカーネルの<span class="systemitem">System V</span>セマフォの上限が、<span class="productname">PostgreSQL</span>が作成しようとしている数よりも小さいということを意味しています。
上記のように、許可される接続の数（<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>）を減らしてサーバを起動させることで問題は回避できるかもしれませんが、最終的にはカーネルの設定を変えてセマフォの上限を増やした方が良いでしょう。
    </p><p><span class="quote">“<span class="quote">不正なシステムコール</span>”</span>のエラーが発生した場合は、使用しているカーネルでは共有メモリやセマフォがまったくサポートされていない可能性があります。
その場合、これらの機能を使えるようにカーネルを設定し直すことが唯一の選択肢となります。
    </p><p><span class="systemitem">System V</span> <acronym class="acronym">IPC</acronym>設備の設定についての詳細は<a class="xref" href="kernel-resources.html#SYSVIPC" title="18.4.1. 共有メモリとセマフォ">Section 18.4.1</a>を参照してください。
    </p></div><div class="sect2" id="CLIENT-CONNECTION-PROBLEMS"><div class="titlepage"><div><div><h3 class="title">18.3.2. クライアント接続の問題</h3></div></div></div><p>クライアント側で起こり得るエラー状態はきわめて多様で、アプリケーションに依存します。
その中のいくつかはサーバが起動された方法と直接関係するかもしれません。
以下で説明する以外の状態については各々のクライアントアプリケーションの資料を参照してください。
    </p><pre class="screen">psql: could not connect to server: Connection refused
        Is the server running on host "server.joe.com" and accepting
        TCP/IP connections on port 5432?</pre><p>
これは一般的な<span class="quote">“<span class="quote">接続するサーバが見つけられませんでした</span>”</span>という失敗です。
TCP/IP通信を試みた時に上記のように表示されます。
よくある間違いはサーバにTCP/IPを許可する設定を忘れていることです。
    </p><p>代わりに、ローカルのサーバにUnixソケット通信を試みると下記のような表示が出ます。
</p><pre class="screen">psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?</pre><p>
    </p><p>最後の行は、クライアントが正しいところに接続しようとしていることを実証するのに役立ちます。
もしそこに動いているサーバがない場合、典型的なカーネルエラーメッセージは、表示されているように<code class="computeroutput">Connection refused</code>もしくは<code class="computeroutput">No such file or directory</code>となります。
（この場合の<code class="computeroutput">Connection refused</code>はサーバが接続要求を受け付けた後に拒否したわけでは<span class="emphasis"><em>ない</em></span>ということを理解しておくことが大切です。
もしそうだった場合は<a class="xref" href="client-authentication-problems.html" title="20.4. 認証における問題点">Section 20.4</a>で示されるような別のメッセージが表示されます。）
<code class="computeroutput">Connection timed out</code>のような他のメッセージは、例えばネットワーク接続の欠如のようなもっと根本的な問題を表しています。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="creating-cluster.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="kernel-resources.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">18.2. データベースクラスタの作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 18.4. カーネルリソースの管理</td></tr></table></div></body></html>