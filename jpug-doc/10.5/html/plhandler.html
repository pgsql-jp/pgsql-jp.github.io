<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 55. 手続き言語ハンドラの作成</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="nls-programmer.html" title="54.2. プログラマへ" /><link rel="next" href="fdwhandler.html" title="Chapter 56. 外部データラッパの作成" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">Chapter 55. 手続き言語ハンドラの作成</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="nls-programmer.html" title="54.2. プログラマへ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="internals.html" title="Part VII. 内部情報">Up</a></td><th width="60%" align="center">Part VII. 内部情報</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="fdwhandler.html" title="Chapter 56. 外部データラッパの作成">Next</a></td></tr></table><hr></hr></div><div class="chapter" id="PLHANDLER"><div class="titlepage"><div><div><h2 class="title">Chapter 55. 手続き言語ハンドラの作成</h2></div></div></div><a id="id-1.10.8.2" class="indexterm"></a><p>現在のコンパイル言語用<span class="quote">“<span class="quote">Version-1</span>”</span>インタフェース以外のある言語で作成された関数の呼び出しはすべて、特定の言語用の<em class="firstterm">呼び出しハンドラ</em>を経由します
（これには、ユーザ定義手続き言語で作成された関数、SQLで作成された関数が含まれます）。
提供されたソーステキストを解釈するなどによって、関数の実行を意味のある方法で行うことは、呼び出しハンドラの責任です。
本章では、どのように新しい手続き言語の呼び出しハンドラを作成できるかについて概要を示します。
   </p><p>手続き言語用の呼び出しハンドラは<span class="quote">“<span class="quote">通常</span>”</span>の関数で、Cなどのコンパイル言語で作成し、Version-1インタフェースを使用し、引数を取らずに<code class="type">language_handler</code>を返すものとして<span class="productname">PostgreSQL</span>に登録しなければなりません。
この特殊な仮想型は、その関数を呼び出しハンドラとして識別し、SQLコマンド内で直接その関数が呼び出されることを防止します。
C言語の呼び出し規約と動的ロードについては<a class="xref" href="xfunc-c.html" title="37.9. C言語関数">Section 37.9</a>を参照してください。
   </p><p>呼び出しハンドラは、他の関数と同じ方法で呼び出されます。
引数値と呼び出された関数についての情報を含む<code class="structname">FunctionCallInfoData</code> <code class="type">struct</code>のポインタを受け取り、<code class="type">Datum</code>型の結果を返すもの（そして、SQLのNULLという結果を返そうとする場合に、<code class="structname">FunctionCallInfoData</code>構造体の<code class="structfield">isnull</code>フィールドを設定するかもしれないもの）と想定されています。
呼び出しハンドラと通常の呼び出される関数との違いは、<code class="structname">FunctionCallInfoData</code>構造体の<code class="structfield">flinfo-&gt;fn_oid</code>に、呼び出しハンドラ自身ではなく、実際に呼び出される関数のOIDが含まれるという点です。
呼び出しハンドラはこのフィールドを使用して、どの関数を呼び出すのかを決定しなければなりません。
また、渡された引数リストは、呼び出しハンドラの宣言ではなく、目的とする関数の宣言に従うよう設定されています。
   </p><p><code class="classname">pg_proc</code>システムカタログから関数のエントリを取り出し、呼び出される関数の引数と戻り値の型を解析するまでを呼び出しハンドラが行います。
関数の<code class="command">CREATE FUNCTION</code>コマンドの<code class="literal">AS</code>句は、<code class="classname">pg_proc</code>の行の<code class="literal">prosrc</code>列にあります。
これは通常、手続き言語自体で作成されたソーステキストですが、理論上はファイルへのパス名や、何らかの呼び出しハンドラに詳細に何をすべきかを通知するものとすることもできます。
   </p><p>1つのSQL文で同じ関数が何回も呼び出されることがよくあります。
呼び出しハンドラは、<code class="structfield">flinfo-&gt;fn_extra</code>フィールドを使用して、呼び出す関数に関する情報を繰り返し検索することを防ぐことができます。
これは初期状態では<code class="symbol">NULL</code>ですが、呼び出しハンドラによって呼び出す関数の情報を指すように設定することもできます。
その後の呼び出しでは、<code class="structfield">flinfo-&gt;fn_extra</code>が非<code class="symbol">NULL</code>であれば、それを使用して、情報検索の段階を省略することができます。
呼び出しハンドラは<code class="structfield">flinfo-&gt;fn_extra</code>が少なくとも現在の問い合わせの終了まで有効なメモリを指しているかどうかを確認しなければなりません。
<code class="structname">FmgrInfo</code>データ構造体は長く保持される可能性があるからです。
この方法の1つとして、<code class="structfield">flinfo-&gt;fn_mcxt</code>で指定されたメモリコンテキスト内に余分なデータを割り当てることです。
このデータは通常<code class="structname">FmgrInfo</code>自身と同期間有効です。
しかし、ハンドラはまた、長時間メモリコンテキストにあるものを使用するかどうかを選ぶこともできます。
これにより関数定義情報を、問い合わせをまたいでキャッシュすることができます。
   </p><p>手続き言語関数がトリガとして呼び出された場合、引数は通常の方法では渡されず、<code class="structname">FunctionCallInfoData</code>の<code class="structfield">context</code>フィールドが、普通の関数呼び出しのように<code class="symbol">NULL</code>にはならずに、<code class="structname">TriggerData</code>構造体を指しています。
呼び出しハンドラは、手続き言語に対しトリガ情報を取り出す機構を提供しなければなりません。
   </p><p>以下は、Cで作成した手続き言語ハンドラの雛型です。
</p><pre class="programlisting">#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * トリガ関数として呼び出された
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&gt;context;

        retval = ...
    }
    else
    {
        /*
         * 関数として呼び出された
         */

        retval = ...
    }

    return retval;
}</pre><p>
数千行のコードを上のドットの代わりに追加するだけで、呼び出しハンドラを完成することができます。
   </p><p>ハンドラ関数を動的ロード可能なモジュールにコンパイル（<a class="xref" href="xfunc-c.html#DFUNC" title="37.9.5. 動的にロードされる関数のコンパイルとリンク">Section 37.9.5</a>を参照してください）した後、以下のコマンドでサンプルの手続き言語を登録することができます。
</p><pre class="programlisting">CREATE FUNCTION plsample_call_handler() RETURNS language_handler
    AS '<em class="replaceable"><code>filename</code></em>'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;</pre><p>
   </p><p>最低限の手続き言語を作成する場合には呼び出しハンドラを提供するだけで十分ですが、他にも省略可能ですが、その言語の利用をより簡便にするために提供できる2つの関数があります。
これらは<em class="firstterm">有効性検証関数</em>と<em class="firstterm">インラインハンドラ</em>です。
有効性検証関数を提供して、<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>時に言語固有の検査を行うことができます。
インラインハンドラを提供して、言語に<a class="xref" href="sql-do.html" title="DO"><span class="refentrytitle">DO</span></a>コマンド経由の匿名コードブロック実行をサポートさせることができます。
   </p><p>有効性検証関数が手続き言語により提供される場合、<code class="type">oid</code>型の単一パラメータを取る関数として宣言しなければなりません。
有効性検証関数の結果は無視されます。
そのためよく<code class="type">void</code>を返すものと宣言されます。
有効性検証関数はその手続き言語で関数を作成または置換する<code class="command">CREATE FUNCTION</code>の最後に呼び出されます。
渡されるOIDは関数の<code class="classname">pg_proc</code>行のOIDです。
有効性検証関数は通常の方法でこの行を取り出さなければならず、そして適切な検査を実行します。
まずユーザが<code class="command">CREATE FUNCTION</code>で到達できない有効性検証関数への明示的な呼び出しを診断するため、<code class="function">CheckFunctionValidatorAccess()</code>を呼び出します。
典型的な検査として、さらに関数引数および結果の型がその言語でサポートされているかや関数本体がその言語において文法的に正しいかどうかを検証することが挙げられます。
有効性検証関数がその関数に問題がないことを判定したら、単に戻ります。
エラーがあることを判定したら、通常の<code class="function">ereport()</code>エラー報告機構を使用して報告しなければなりません。
エラーを返すことで、強制的にトランザクションはロールバックされ、不正な関数定義がコミットされることを防ぎます。
   </p><p>有効性検証関数は通常<a class="xref" href="runtime-config-client.html#GUC-CHECK-FUNCTION-BODIES">check_function_bodies</a>パラメータを遵守しなければなりません。
これが無効な場合、高価な、または文脈次第の検査を飛ばさなければなりません。
言語がコンパイル時のコード実行を提供するのであれば、有効性検証関数はそのような実行を引き起こす検査を抑制しなければなりません。
特にこのパラメータは、副作用や関数本体の他のデータベースオブジェクトへの依存を心配することなく手続き言語関数をロードできるように、<span class="application">pg_dump</span>により無効にされます。
(この仕様のため呼び出しハンドラは有効性検証関数が完全にその関数を検査したことを前提としてはいけません。
有効性検証関数を持つ目的は、呼び出しハンドラが検査を省略できることではなく、明確なエラーが<code class="command">CREATE FUNCTION</code>コマンド内に存在する場合、それを即座にユーザに通知することです。)
厳密に何を検査すべきかの選択は主として有効性検査関数の裁量に委ねられていますが、<code class="varname">check_function_bodies</code>が有効な場合には<code class="command">CREATE FUNCTION</code>の中心となるコードは関数に関連づけられた<code class="literal">SET</code>句を実行するだけですので注意して下さい。
そのため、その結果がGUCパラメータの影響を受ける検査は、ダンプをリロードする時の偽の失敗を避けるために、<code class="varname">check_function_bodies</code>が無効な場合には確実に飛ばさなければなりません。
   </p><p>インラインハンドラが手続き言語により提供される場合、その関数は<code class="type">internal</code>型の単一パラメータを取るものとして宣言されなければなりません。
インラインハンドラの結果は無視されます。
そのためよく<code class="type">void</code>を返すものと宣言されます。
インラインハンドラは特定の手続き言語で<code class="command">DO</code>文が実行された時に呼び出されます。
実際に渡されるパラメータは<code class="structname">InlineCodeBlock</code>構造体のポインタです。
ここには<code class="command">DO</code>文のパラメータ、具体的には実行される匿名コードブロックのテキスト、に関する情報が含まれています。
インラインハンドラはこのコードを実行し、戻らなければなりません。
   </p><p>簡単な<code class="command">CREATE EXTENSION</code>コマンドで言語をインストールすることが十分にできるように、これらの関数宣言と<code class="command">CREATE LANGUAGE</code>コマンド自身を<em class="firstterm">拡張</em>としてまとめることを勧めます。
拡張の作成方法については<a class="xref" href="extend-extensions.html" title="37.15. 関連するオブジェクトを拡張としてパッケージ化">Section 37.15</a>を参照してください。
   </p><p>独自の言語ハンドラを作成する際、標準配布物に含まれる手続き言語は優れたリファレンスです。
ソースツリーの<code class="filename">src/pl</code>サブディレクトリを調べてください。
<a class="xref" href="sql-createlanguage.html" title="CREATE LANGUAGE"><span class="refentrytitle">CREATE LANGUAGE</span></a>マニュアルページもまた有用な情報を含みます。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="nls-programmer.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="internals.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="fdwhandler.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">54.2. プログラマへ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 56. 外部データラッパの作成</td></tr></table></div></body></html>