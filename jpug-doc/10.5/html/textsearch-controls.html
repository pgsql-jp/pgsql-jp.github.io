<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.3. テキスト検索の制御</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="textsearch-tables.html" title="12.2. テーブルとインデックス" /><link rel="next" href="textsearch-features.html" title="12.4. 追加機能" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">12.3. テキスト検索の制御</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="textsearch-tables.html" title="12.2. テーブルとインデックス">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="textsearch.html" title="Chapter 12. 全文検索">Up</a></td><th width="60%" align="center">Chapter 12. 全文検索</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="textsearch-features.html" title="12.4. 追加機能">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TEXTSEARCH-CONTROLS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.3. テキスト検索の制御</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS">12.3.1. 文書のパース</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES">12.3.2. 問い合わせのパース</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-RANKING">12.3.3. 検索結果のランキング</a></span></dt><dt><span class="sect2"><a href="textsearch-controls.html#TEXTSEARCH-HEADLINE">12.3.4. 結果の強調</a></span></dt></dl></div><p>全文検索を実装するためには、文書から<code class="type">tsvector</code>を、そしてユーザの問い合わせから<code class="type">tsquery</code>を作成する関数が存在しなければなりません。また、結果を意味のある順で返す必要があります。そこで、問い合わせとの関連性で文書を比較する関数も必要になってきます。結果を体裁良く表示できることも重要です。<span class="productname">PostgreSQL</span>はこれらすべての機能を提供しています。
  </p><div class="sect2" id="TEXTSEARCH-PARSING-DOCUMENTS"><div class="titlepage"><div><div><h3 class="title">12.3.1. 文書のパース</h3></div></div></div><p><span class="productname">PostgreSQL</span>は、文書を<code class="type">tsvector</code>データ型に変換する<code class="function">to_tsvector</code>関数を提供しています。
   </p><a id="id-1.5.11.6.3.3" class="indexterm"></a><pre class="synopsis">to_tsvector([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>document</code></em> <code class="type">text</code>) returns <code class="type">tsvector</code></pre><p><code class="function">to_tsvector</code>は、テキスト文書をパースしてトークンにし、トークンを語彙素に変換、文書中の位置とともに語彙素をリストとして持つ<code class="type">tsvector</code>を返します。文書は、指定したものか、あるいはデフォルトのテキスト検索設定にしたがって処理されます。単純な例を示します。

</p><pre class="screen">SELECT to_tsvector('english', 'a fat  cat sat on a mat - it ate a fat rats');
                  to_tsvector
-----------------------------------------------------
 'ate':9 'cat':3 'fat':2,11 'mat':7 'rat':12 'sat':4</pre><p>
   </p><p>上に示す例では、結果の<code class="type">tsvector</code>で、<code class="literal">a</code>、<code class="literal">on</code>、<code class="literal">it</code>という単語が含まれないこと、<code class="literal">rats</code>という単語が<code class="literal">rat</code>になっていること、句読点記号<code class="literal">-</code>が無視されていることがわかります。
   </p><p><code class="function">to_tsvector</code>関数は、文書をトークンに分解して、そのトークンに型を割り当てるパーサを内部的に呼び出しています。それぞれのトークンに対して辞書(<a class="xref" href="textsearch-dictionaries.html" title="12.6. 辞書">Section 12.6</a>)のリストが検索されます。ここで、辞書のリストはトークンの型によって異なります。最初の辞書は、トークンを<em class="firstterm">認識</em>し、トークンを表現する一つ以上の正規化された<em class="firstterm">語彙素</em>を出力します。例えば、ある辞書は<code class="literal">rats</code>は<code class="literal">rat</code>の複数形であることを認識しているので、<code class="literal">rats</code>は<code class="literal">rat</code>になります。
ある単語は<em class="firstterm">ストップワード</em>(<a class="xref" href="textsearch-dictionaries.html#TEXTSEARCH-STOPWORDS" title="12.6.1. ストップワード">Section 12.6.1</a>)として認識されます。これは、あまりにも多く出現し検索の役に立たないため、無視されるものです。
先の例では、<code class="literal">a</code>、<code class="literal">on</code>、および<code class="literal">it</code>がそれです。
もしリスト中の辞書のどれもがトークンを認識しなければ、そのトークンは無視されます。先の例では、句読点の<code class="literal">-</code>がそうです。なぜなら、実際にはそのトークン型(<code class="literal">Space symbols</code>)に対して辞書が割り当てられておらず、空白トークンは決してインデックス付けされないことを意味します。パーサ、辞書、そしてどのトークンがインデックス付けされるかという選択は、テキスト検索設定(<a class="xref" href="textsearch-configuration.html" title="12.7. 設定例">Section 12.7</a>)によって決められます。同じデータベース中に多くの異なった設定を持つことができ、多くの言語用に定義済の設定が用意されています。先の例では、英語用として、デフォルトの<code class="literal">english</code>設定を使っています。
   </p><p>関数<code class="function">setweight</code>を使って<code class="type">tsvector</code>のエントリに与えられた<em class="firstterm">重み</em>のラベルを与えることができます。ここで重みは、<code class="literal">A</code>, <code class="literal">B</code>, <code class="literal">C</code>, <code class="literal">D</code>のどれかの文字です。重みの典型的な使い方は、文書の各部分がどこから来たのかをマークすることです。たとえば、タイトルから来たのか、本文から来たのかなど。後でこの情報は検索結果のランキングに利用できます。
   </p><p><code class="function">to_tsvector</code>(<code class="literal">NULL</code>)は<code class="literal">NULL</code>を返すので、NULLになる可能性のある列に対しては<code class="function">coalesce</code>を使うことをお勧めします。構造化された文書から<code class="type">tsvector</code>を作るための推奨できる方法を示します。

</p><pre class="programlisting">UPDATE tt SET ti =
    setweight(to_tsvector(coalesce(title,'')), 'A')    ||
    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||
    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||
    setweight(to_tsvector(coalesce(body,'')), 'D');</pre><p>

ここでは、完成した<code class="type">tsvector</code>の語彙素に対して、ラベル付けのために<code class="function">setweight</code>を使っています。そして、<code class="type">tsvector</code>の連結演算子<code class="literal">||</code>を使って、ラベルづけされた<code class="type">tsvector</code>の値をマージします。(詳細は<a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. 文書の操作">Section 12.4.1</a>を参照してください。)
   </p></div><div class="sect2" id="TEXTSEARCH-PARSING-QUERIES"><div class="titlepage"><div><div><h3 class="title">12.3.2. 問い合わせのパース</h3></div></div></div><p><span class="productname">PostgreSQL</span>は、問い合わせを<code class="type">tsquery</code>に変換する関数<code class="function">to_tsquery</code>、<code class="function">plainto_tsquery</code>、<code class="function">phraseto_tsquery</code>を提供しています。
<code class="function">to_tsquery</code>は、<code class="function">plainto_tsquery</code>と<code class="function">phraseto_tsquery</code>のいずれよりも多くの機能を提供していますが、入力のチェックはより厳格です。
   </p><a id="id-1.5.11.6.4.3" class="indexterm"></a><pre class="synopsis">to_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">to_tsquery</code>は、<em class="replaceable"><code>querytext</code></em>から<code class="type">tsquery</code>としての値を生成します。
<em class="replaceable"><code>querytext</code></em>は、<code class="type">tsquery</code>演算子<code class="literal">&amp;</code> (AND), <code class="literal">|</code> (OR)、<code class="literal">!</code> (NOT)、<code class="literal">&lt;-&gt;</code> (FOLLOWED BY)で区切られる単一のトークンから構成されなければなりません。
これらの演算子は括弧でグループ化できます。
言い換えると、<code class="function">to_tsquery</code>の入力は、<a class="xref" href="datatype-textsearch.html#DATATYPE-TSQUERY" title="8.11.2. tsquery">Section 8.11.2</a>で述べられている一般規則にしたがっていなければなりません。
違いは、基本的な<code class="type">tsquery</code>の入力はトークンの表面的な値を受け取るのに対し、<code class="function">to_tsquery</code>は指定した、あるいはデフォルトの設定を使ってトークンを語彙素へと正規化し、設定にしたがって、ストップワードであるようなトークンを破棄します。
例を示します。

</p><pre class="screen">SELECT to_tsquery('english', 'The &amp; Fat &amp; Rats');
  to_tsquery   
---------------
 'fat' &amp; 'rat'</pre><p>

基本的な<code class="type">tsquery</code>の入力では、各々の語彙素に重みを付加することにより、同じ重みを持つ<code class="type">tsvector</code>の語彙素のみに照合するようにすることができます。例を示します。

</p><pre class="screen">SELECT to_tsquery('english', 'Fat | Rats:AB');
    to_tsquery    
------------------
 'fat' | 'rat':AB</pre><p>

また、明示的な前方一致検索のため、<code class="literal">*</code>を語彙素に与えることもできます。

</p><pre class="screen">SELECT to_tsquery('supern:*A &amp; star:A*B');
        to_tsquery        
--------------------------
 'supern':*A &amp; 'star':*AB</pre><p>

このような語彙素は、与えられた文字列で始まる<code class="type">tsvector</code>中のどんな単語にも照合するでしょう。
   </p><p><code class="function">to_tsquery</code>は、単一引用符で囲まれた語句を受け付けることもできます。これは主に、設定の中にそういった語句を持つ同義語辞書を含んでいるときに有用です。以下の例では、ある同義語の中に<code class="literal">supernovae stars : sn</code>という規則が含まれています。

</p><pre class="screen">SELECT to_tsquery('''supernovae stars'' &amp; !crab');
  to_tsquery
---------------
 'sn' &amp; !'crab'</pre><p>

引用符がない場合は、<code class="function">to_tsquery</code>は、AND、ORあるいはFOLLOWED BY演算子で区切られていないトークンに対して構文エラーを引き起こします。
   </p><a id="id-1.5.11.6.4.7" class="indexterm"></a><pre class="synopsis">plainto_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">plainto_tsquery</code>は整形されていないテキスト<em class="replaceable"><code>querytext</code></em>を、<code class="type">tsquery</code>の値に変換します。
テキストはパースされ、<code class="function">to_tsvector</code>としてできる限り正規化されます。
そして、<code class="type">tsquery</code>演算子<code class="literal">&amp;</code> (AND) が存続した単語の間に挿入されます。
   </p><p>例：

</p><pre class="screen">SELECT plainto_tsquery('english', 'The Fat Rats');
 plainto_tsquery 
-----------------
 'fat' &amp; 'rat'</pre><p>

<code class="function">plainto_tsquery</code>は、入力中の<code class="type">tsquery</code>演算子も、重み付けラベルも、前方一致ラベルも認識しないことに注意してください。

</p><pre class="screen">SELECT plainto_tsquery('english', 'The Fat &amp; Rats:C');
   plainto_tsquery   
---------------------
 'fat' &amp; 'rat' &amp; 'c'</pre><p>

ここでは、入力中のすべての句読点がスペース記号に変換された結果、破棄されています。
   </p><a id="id-1.5.11.6.4.11" class="indexterm"></a><pre class="synopsis">phraseto_tsquery([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>querytext</code></em> <code class="type">text</code>) returns <code class="type">tsquery</code></pre><p><code class="function">phraseto_tsquery</code>は<code class="function">plainto_tsquery</code>とほぼ同じ動作をしますが、残った語の間に<code class="literal">&amp;</code> (AND) 演算子ではなく、<code class="literal">&lt;-&gt;</code> (FOLLOWED BY) 演算子を挿入するところが違います。
また、ストップワードを単に無視するのでなく、<code class="literal">&lt;-&gt;</code>演算子の代わりに<code class="literal">&lt;<em class="replaceable"><code>N</code></em>&gt;</code>演算子を挿入することで、意味のあるものとします。
FOLLOWED BY演算子は、単にすべての語彙素が存在することだけでなく、語彙素の順序についても確認するため、この関数は語彙素の正確な順序について検索するときに役立ちます。
   </p><p>例を示します。

</p><pre class="screen">SELECT phraseto_tsquery('english', 'The Fat Rats');
 phraseto_tsquery
------------------
 'fat' &lt;-&gt; 'rat'</pre><p>

<code class="function">plainto_tsquery</code>と同じく、<code class="function">phraseto_tsquery</code>関数もその入力内の<code class="type">tsquery</code>演算子、重み付けラベル、前方一致ラベルを認識しません。

</p><pre class="screen">SELECT phraseto_tsquery('english', 'The Fat &amp; Rats:C');
      phraseto_tsquery
-----------------------------
 'fat' &lt;-&gt; 'rat' &lt;-&gt; 'c'</pre><p>
   </p></div><div class="sect2" id="TEXTSEARCH-RANKING"><div class="titlepage"><div><div><h3 class="title">12.3.3. 検索結果のランキング</h3></div></div></div><p>ランキングはある問い合わせに対して、どの程度文書が関連しているかを計測しようとするものです。合致している文書が多数あるとき、もっとも関連している文書が最初に表示されるようにするためです。
<span class="productname">PostgreSQL</span>は、2つの定義済ランキング関数を提供しています。それらは、辞書情報、近接度情報、構造的情報を加味します。すなわち、問い合わせの用語がどの位の頻度で文書に出現するか、文書中でどの程度それらの用語が近接しているか、どの用語が含まれる文書部位がどの程度重要なのかを考慮します。
しかし、関連度という概念は曖昧で、用途に強く依存します。
異なる用途は、ランキングのために追加の情報を必要とするかも知れません。たとえば、文書の更新時刻など。
組み込みのランキング関数は例に過ぎません。
利用者の目的に応じて、自分用のランキング関数を作ったり、その結果を追加の情報と組み合わせることができます。
   </p><p>今のところ、二種類のランキング関数が利用可能です。

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">       <a id="id-1.5.11.6.5.3.1.1.1.1" class="indexterm"></a>

       <code class="literal">ts_rank([<span class="optional"> <em class="replaceable"><code>weights</code></em> <code class="type">float4[]</code>, </span>] <em class="replaceable"><code>vector</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>normalization</code></em> <code class="type">integer</code> </span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>それらの語彙素にマッチした頻度に基づくベクトルのランク。
       </p></dd><dt><span class="term">      <a id="id-1.5.11.6.5.3.1.2.1.1" class="indexterm"></a>

       <code class="literal">ts_rank_cd([<span class="optional"> <em class="replaceable"><code>weights</code></em> <code class="type">float4[]</code>, </span>] <em class="replaceable"><code>vector</code></em> <code class="type">tsvector</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>normalization</code></em> <code class="type">integer</code> </span>]) returns <code class="type">float4</code></code>
      </span></dt><dd><p>この関数は、1999年の"Information Processing and Management"ジャーナルに掲載されたClarke, Cormack, Tudhopeの"Relevance Ranking for One to Three Term Queries"で述べられている方法で、与えられた文書ベクトルと問い合わせの<em class="firstterm">被覆密度(cover density)</em>ランクを計算します。
被覆密度は互いにマッチする語彙素の近接度を考慮に入れる点を除いて<code class="function">ts_rank</code>のランク付けと似ています。
       </p><p>この関数は、計算を実行するために語彙素の位置情報を必要とします。
ですから、<code class="type">tsvector</code>内の<span class="quote">“<span class="quote">剥き出しの</span>”</span>語彙素は無視します。
入力に剥き出しでない語彙素がなければ、 結果は0です。
(<code class="function">strip</code>関数と<code class="type">tsvector</code>内の位置情報についてのより詳しい情報は<a class="xref" href="textsearch-features.html#TEXTSEARCH-MANIPULATE-TSVECTOR" title="12.4.1. 文書の操作">Section 12.4.1</a>を参照してください。)
       </p></dd></dl></div><p>

   </p><p>これらの関数では、単語がどの程度ラベル付けに依存するかを、単語ごとに指定する機能が<em class="replaceable"><code>weights</code></em>オプションパラメータによって提供されています。
重み配列で、それぞれのカテゴリの単語がどの程度重み付けするかを指定します。その順は以下のようになっています。

</p><pre class="synopsis">{D-weight, C-weight, B-weight, A-weight}</pre><p>

<em class="replaceable"><code>weights</code></em>を与えない場合は、次のデフォルト値が使われます。

</p><pre class="programlisting">{0.1, 0.2, 0.4, 1.0}</pre><p>

重みの典型的な使い方は、文書のタイトルやアブストラクトのような特定の場所にある単語をマーク付けするような使い方です。そうすることにより、文書の本体に比べてそこにある単語がより重要なのか、そうでないのか、扱いを変えることができます。
   </p><p>文書が長ければ、それだけ問い合わせ用語を含む確率が高くなるため、文書のサイズを考慮にいれることは理にかなっています。たとえば、5つの検索語を含む100語の文書は、たぶん5つの検索語を含む1000語の文書よりも関連性が高いでしょう。ランキング関数には、どちらも整数型の<em class="replaceable"><code>正規化</code></em>オプションがあります。これは、文書の長さがランクに影響を与えるのかどうか、与えるとすればどの程度か、ということを指定します。この整数オプションは、いくつかの挙動を制御するので、ビットマスクになっています。複数の挙動を<code class="literal">|</code>で指定できます(例：<code class="literal">2|4</code>)。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>0(デフォルト):文書の長さを無視します
      </p></li><li class="listitem" style="list-style-type: disc"><p>1:ランクを(1 + log(文書の長さ))で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>2:ランクを文書の長さで割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>4:ランクをエクステントの間の調和平均距離で割ります(これは<code class="function">ts_rank_cd</code>のみで実装されています)
      </p></li><li class="listitem" style="list-style-type: disc"><p>8: ランクを文書中の一意の単語の数で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>16: ランクをlog(文書中の一意の単語の数)+1 で割ります
      </p></li><li class="listitem" style="list-style-type: disc"><p>32: ランクをランク自身+1 で割ります
      </p></li></ul></div><p>

2以上のフラグビットが指定された場合には、変換は上記に列挙された順に行われます。
   </p><p>これは重要なことですが、ランキング関数はグローバル情報を一切使わないので、時には必要になる1%から100%までの均一な正規化はできません。正規化オプション32(<code class="literal">rank/(rank+1)</code>)を適用することにより、すべてのランクを0から1に分布させることができます。しかし、もちろんこれは表面的な変更に過ぎません。検索結果のならび順に影響を与えるものではありません。
   </p><p>マッチする順位の高い10位までを選ぶ例を示します。

</p><pre class="screen">SELECT title, ts_rank_cd(textsearch, query) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |   rank
-----------------------------------------------+----------
 Neutrinos in the Sun                          |      3.1
 The Sudbury Neutrino Detector                 |      2.4
 A MACHO View of Galactic Dark Matter          |  2.01317
 Hot Gas and Dark Matter                       |  1.91171
 The Virgo Cluster: Hot Plasma and Dark Matter |  1.90953
 Rafting for Solar Neutrinos                   |      1.9
 NGC 4650A: Strange Galaxy and Dark Matter     |  1.85774
 Hot Gas and Dark Matter                       |   1.6123
 Ice Fishing for Cosmic Neutrinos              |      1.6
 Weak Lensing Distorts the Universe            | 0.818218</pre><p>

同じ例を正規化ランキングを使ったものを示します。

</p><pre class="screen">SELECT title, ts_rank_cd(textsearch, query, 32 /* rank/(rank+1) */ ) AS rank
FROM apod, to_tsquery('neutrino|(dark &amp; matter)') query
WHERE  query @@ textsearch
ORDER BY rank DESC
LIMIT 10;
                     title                     |        rank
-----------------------------------------------+-------------------
 Neutrinos in the Sun                          | 0.756097569485493
 The Sudbury Neutrino Detector                 | 0.705882361190954
 A MACHO View of Galactic Dark Matter          | 0.668123210574724
 Hot Gas and Dark Matter                       |  0.65655958650282
 The Virgo Cluster: Hot Plasma and Dark Matter | 0.656301290640973
 Rafting for Solar Neutrinos                   | 0.655172410958162
 NGC 4650A: Strange Galaxy and Dark Matter     | 0.650072921219637
 Hot Gas and Dark Matter                       | 0.617195790024749
 Ice Fishing for Cosmic Neutrinos              | 0.615384618911517
 Weak Lensing Distorts the Universe            | 0.450010798361481</pre><p>
   </p><p>ランキングは、I/Oに結び付けられていて遅い可能性のある、一致する各文書の<code class="type">tsvector</code>へのアクセスが必要なので、高価な処理であるかもしれません。
不幸なことに、実際の問い合わせでは往々にして大量の検索結果が生じるため、これはほとんど不可避であると言えます。
   </p></div><div class="sect2" id="TEXTSEARCH-HEADLINE"><div class="titlepage"><div><div><h3 class="title">12.3.4. 結果の強調</h3></div></div></div><p>検索結果を表示する際には、文書の該当部分を表示し、どの程度問い合わせと関連しているかを示すのが望ましいです。<span class="productname">PostgreSQL</span>はこの機能を実装した<code class="function">ts_headline</code>関数を提供しています。
   </p><a id="id-1.5.11.6.6.3" class="indexterm"></a><pre class="synopsis">ts_headline([<span class="optional"> <em class="replaceable"><code>config</code></em> <code class="type">regconfig</code>, </span>] <em class="replaceable"><code>document</code></em> <code class="type">text</code>, <em class="replaceable"><code>query</code></em> <code class="type">tsquery</code> [<span class="optional">, <em class="replaceable"><code>options</code></em> <code class="type">text</code> </span>]) returns <code class="type">text</code></pre><p><code class="function">ts_headline</code>は、問い合わせと一緒に文書を受け取り、問い合わせが注目した文書中の語句を抜粋して返します。文書をパースするのに使われる設定を<em class="replaceable"><code>config</code></em>で指定することができます。<em class="replaceable"><code>config</code></em>が省略された場合は、<code class="varname">default_text_search_config</code>設定が使われます。
   </p><p><em class="replaceable"><code>options</code></em>文字列を指定する場合は、一つ以上の<em class="replaceable"><code>option</code></em><code class="literal">=</code><em class="replaceable"><code>value</code></em>のペアをカンマで区切ったものでなければなりません。

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><code class="literal">StartSel</code>, <code class="literal">StopSel</code>: 文書中に現れる問い合わせ単語を区切るこの文字列は、他の抜粋される単語と区別されます。これらの文字列が空白やカンマを含んでいる場合は、二重引用符で囲う必要があります。
      </p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">MaxWords</code>, <code class="literal">MinWords</code>: この数字を使って見出しの最大の長さと最小の長さを指定します。
      </p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">ShortWord</code>: この長さか、それ以下の長さの単語は、見出しの最初と最後から削除されます。デフォルト値の3は、常用される英語の冠詞を取り除きます。
      </p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">HighlightAll</code>: 論理値フラグ; <code class="literal">true</code>なら文書全体が見出しの様にハイライトされ、前の3つのパラメータは無視されます。
      </p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">MaxFragments</code>:表示するテキスト引用句、もしくは断片の最大数です。デフォルト値の0は断片化を起こさない見出しの生成の選択となります。0より大きい場合は断片化を基本とした見出しの生成の選択となります。この方法は、可能な限り多くの検索単語でテキスト断片を探し出し、検索単語周辺のそれらのテキスト断片を広げます。結果として、検索単語が各断片の中央部分近くに位置し、両端に単語を持つことになります。各断片は最大で<code class="literal">MaxWords</code>と同数の単語を持ち、<code class="literal">ShortWord</code>より少ないサイズの単語を断片の両端に持ちません。もし全ての検索単語を文書から見つけられなかった場合は、文書中の最初の<code class="literal">MinWords</code>分の単語数から成る一つの断片が表示されるでしょう。
      </p></li><li class="listitem" style="list-style-type: disc"><p><code class="literal">FragmentDelimiter</code>: 複数の断片が表示される時、その断片はこの文字で区切られます。
      </p></li></ul></div><p>

指定されなかったオプションの値は以下のデフォルトになります。

</p><pre class="programlisting">StartSel=&lt;b&gt;, StopSel=&lt;/b&gt;,
MaxWords=35, MinWords=15, ShortWord=3, HighlightAll=FALSE,
MaxFragments=0, FragmentDelimiter=" ... "</pre><p>
   </p><p>例を示します。

</p><pre class="screen">SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'));
                        ts_headline                         
------------------------------------------------------------
 containing given &lt;b&gt;query&lt;/b&gt; terms
 and return them in order of their &lt;b&gt;similarity&lt;/b&gt; to the
 &lt;b&gt;query&lt;/b&gt;.

SELECT ts_headline('english',
  'The most common type of search
is to find all documents containing given query terms
and return them in order of their similarity to the
query.',
  to_tsquery('query &amp; similarity'),
  'StartSel = &lt;, StopSel = &gt;');
                      ts_headline                      
-------------------------------------------------------
 containing given &lt;query&gt; terms
 and return them in order of their &lt;similarity&gt; to the
 &lt;query&gt;.</pre><p>
   </p><p><code class="function">ts_headline</code>は、<code class="type">tsvector</code>の要約ではなく、元の文書を使います。ですので遅い可能性があり、注意深く使用する必要があります。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-tables.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-features.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">12.2. テーブルとインデックス </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 12.4. 追加機能</td></tr></table></div></body></html>