<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.6. テーブル間を結合</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="tutorial-select.html" title="2.5. テーブルへの問い合わせ" /><link rel="next" href="tutorial-agg.html" title="2.7. 集約関数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">2.6. テーブル間を結合</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="tutorial-select.html" title="2.5. テーブルへの問い合わせ">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="tutorial-sql.html" title="Chapter 2. SQL言語">Up</a></td><th width="60%" align="center">Chapter 2. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym>言語</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="tutorial-agg.html" title="2.7. 集約関数">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="TUTORIAL-JOIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">2.6. テーブル間を結合</h2></div></div></div><a id="id-1.4.4.7.2" class="indexterm"></a><p>ここまでの問い合わせは、一度に1つのテーブルにのみアクセスするものでした。
問い合わせは、一度に複数のテーブルにアクセスすることも、テーブル内の複数の行の処理を同時に行うようなやり方で、１つのテーブルにアクセスすることも可能です。
一度に同一のテーブルまたは異なるテーブルの複数の行にアクセスする問い合わせは、<em class="firstterm">結合</em>問い合わせと呼ばれます。
例として、すべての気象データを関連する都市の位置情報と一緒に表示したい場合が挙げられます。
それを行うためには、<code class="structname">weather</code>テーブルの各行の<code class="structfield">city</code>列を、<code class="structname">cities</code>テーブルの全ての行の<code class="structfield">name</code>列と比較し、両者の値が一致する行の組み合わせを選択しなければなりません。
    </p><div class="note"><h3 class="title">Note</h3><p>これは概念的なモデルでしかありません。
実際の結合は通常、1つひとつの行の組み合わせを比べるよりも、もっと効率的な方法で行われます。
しかし、これはユーザからはわかりません。
     </p></div><p>
これは、以下の問い合わせによって行うことができます。

</p><pre class="programlisting">SELECT *
    FROM weather, cities
    WHERE city = name;</pre><p>

</p><pre class="screen">     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)</pre><p>

   </p><p>この結果について2つのことに注目してください。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Hayward市についての結果行がありません。
これは<code class="structname">cities</code>テーブルにはHaywardに一致する項目がないからで、結合の際に<code class="structname">weather</code>テーブル内の一致されなかった行は無視されるのです。
これをどうしたら解決できるかは、しばらく後で説明します。
      </p></li><li class="listitem"><p>都市名を持つ２つの列があります。
<code class="structname">weather</code>テーブルと<code class="structname">cities</code>テーブルからの列のリストが連結されるため、これは正しい動作です。
しかし実際には、これは望ましい結果ではないため、<code class="literal">*</code>を使わずに、明示的に出力列のリストを指定することになるでしょう。
</p><pre class="programlisting">SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;</pre><p>
      </p></li></ul></div><p>
   </p><p><strong>練習: </strong><code class="literal">WHERE</code>句を省略した場合のこの問い合わせの意味を決定してください。
    </p><p>列がすべて異なる名前だったので、パーサは自動的にどのテーブルの列かを見つけることができました。
2つのテーブルで列名が重複している場合は、以下のようにどちらの列を表示させたいかを示すために列名を<em class="firstterm">修飾</em>しなければなりません。

</p><pre class="programlisting">SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;</pre><p>

結合問い合わせではすべての列名を修飾するのが良いやり方であると一般に考えられています。
そうすれば、テーブルのいずれかに後で重複する名前を持つ列が追加されても、問い合わせが失敗しません。
   </p><p>ここまでに示したような結合問い合わせは、以下のように別の形で表すことができます。

</p><pre class="programlisting">SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);</pre><p>

この構文は先の例よりも一般的に使用されるものではありませんが、以降の話題の理解を助けるためにここで示しています。
   </p><p>    <a id="id-1.4.4.7.8.1" class="indexterm"></a>

ここで、どのようにすればHaywardのレコードを得ることができるようになるのかを明らかにします。
実行したい問い合わせは、<code class="structname">weather</code>をスキャンし、各行に対して、<code class="structname">cities</code>行に一致する行を探すというものです。
一致する行がなかった場合、<code class="structname">cities</code>テーブルの列の部分を何らかの<span class="quote">“<span class="quote">空の値</span>”</span>に置き換えたいのです。
この種の問い合わせは<em class="firstterm">外部結合</em>と呼ばれます
（これまで示してきた結合は内部結合です）。
以下のようなコマンドになります。

</p><pre class="programlisting">SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)</pre><p>

この問い合わせは<em class="firstterm">左外部結合</em>と呼ばれます。
結合演算子の左側に指定したテーブルの各行が最低でも一度出力され、一方で、右側のテーブルでは左側のテーブルの行に一致するもののみが出力されるからです。
右側のテーブルに一致するものがない、左側のテーブルの行を出力する時、右側のテーブルの列は空の値（NULL）で置換されます。
   </p><p><strong>練習: </strong>右外部結合や完全外部結合も存在します。
これらが何を行うかを考えてください。
    </p><p>    <a id="id-1.4.4.7.10.1" class="indexterm"></a>
    <a id="id-1.4.4.7.10.2" class="indexterm"></a>

テーブルを自分自身に対して結合させることができます。
これは<em class="firstterm">自己結合</em>と呼ばれます。
例として、他の気象データの気温範囲内にある気象データを全て取り出すことを考えます。
<code class="structname">weather</code>各行の<code class="structfield">temp_lo</code>と<code class="structfield">temp_hi</code>を、他の<code class="structname">weather</code>行の<code class="structfield">temp_lo</code>と<code class="structfield">temp_hi</code>列とを比較しなければなりません。
以下の問い合わせを使用して行うことができます。

</p><pre class="programlisting">SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo &lt; W2.temp_lo
    AND W1.temp_hi &gt; W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)</pre><p>

ここで、結合の左側と右側を区別することができるように、weatherテーブルに<code class="literal">W1</code>と<code class="literal">W2</code>というラベルを付けています。
また、入力量を省くために、他の問い合わせでもこの種の別名を使用することができます。
以下に例を示します。
</p><pre class="programlisting">SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;</pre><p>
こういった形の省略はかなりよく行われます。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="tutorial-select.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="tutorial-sql.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="tutorial-agg.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2.5. テーブルへの問い合わせ </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 2.7. 集約関数</td></tr></table></div></body></html>