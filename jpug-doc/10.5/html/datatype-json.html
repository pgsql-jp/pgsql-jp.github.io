<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.14. JSONデータ型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="datatype-xml.html" title="8.13. XML型" /><link rel="next" href="arrays.html" title="8.15. 配列" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.14. <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">JSON</acronym>データ型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-xml.html" title="8.13. XML型">Prev</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="Chapter 8. データ型">Up</a></td><th width="60%" align="center">Chapter 8. データ型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 10.5文書">Home</a></td><td width="10%" align="right"> <a accesskey="n" href="arrays.html" title="8.15. 配列">Next</a></td></tr></table><hr></hr></div><div class="sect1" id="DATATYPE-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.14. <acronym class="acronym">JSON</acronym>データ型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-json.html#JSON-KEYS-ELEMENTS">8.14.1. JSONの入出力構文</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-DOC-DESIGN">8.14.2. 効果的なJSONドキュメントの設計</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-CONTAINMENT">8.14.3. <code class="type">jsonb</code>型用包含演算子と存在演算子</a></span></dt><dt><span class="sect2"><a href="datatype-json.html#JSON-INDEXING">8.14.4. <code class="type">jsonb</code> インデックス</a></span></dt></dl></div><a id="id-1.5.7.22.2" class="indexterm"></a><a id="id-1.5.7.22.3" class="indexterm"></a><p>JSONデータ型はJSON(JavaScript Object Notation)データを格納するためのものです。JSONの仕様は<a class="ulink" href="https://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a>に定義されています。
このようなデータは、<code class="type">text</code>型として格納することもできますが、JSONデータ型は、それぞれ格納された値がJSONルールに従って有効に施行されるという利点があります。
これらのデータ型に格納されたデータのために利用可能な各種JSON固有の関数と演算子もあります。
<a class="xref" href="functions-json.html" title="9.15. JSON関数と演算子">Section 9.15</a>を参照してください。
 </p><p>JSONデータ型には<code class="type">json</code>型と<code class="type">jsonb</code>型という2種類のデータ型があります。
それらは <span class="emphasis"><em>ほとんど</em></span> 同一の入力値セットを受け入れます。現実的に主要な違いは効率です。
<code class="type">json</code>データ型は入力テキストの正確なコピーで格納し、処理関数を実行するたびに再解析する必要があります。
<code class="type">jsonb</code>データ型では、分解されたバイナリ形式で格納されます。
格納するときには変換のオーバーヘッドのため少し遅くなりますが、処理するときには、全く再解析が必要とされないので大幅に高速化されます。
また <code class="type">jsonb</code>型の重要な利点はインデックスをサポートしていることです。
 </p><p><code class="type">json</code>型は入力値のコピーを格納しているので、意味的に重要でないトークン間の空白だけでなく、JSONオブジェクト内のキーの順序も維持します。
また、JSONオブジェクト内に同じキーと値が複数含まれていてもすべてのキー/値のペアが保持されます。(この処理関数は最後の値１つを処理させるようすれば済みます。)
これとは対照的に、 <code class="type">jsonb</code>は空白を保持しません。オブジェクトキーの順序を保持せず、重複したオブジェクトキーを保持しません。重複キーを入力で指定された場合は、最後の値が保持されます。
 </p><p>一般的に、ほとんどのアプリケーションではJSONデータ型として<code class="type">jsonb</code>型のほうが望ましいでしょう。ただし、オブジェクトキーを従来のような順序であることを仮定する非常に特殊なニーズが存在するような場合は除きます。
 </p><p><span class="productname">PostgreSQL</span>はデータベースごとに1つの文字セットエンコーディングのみが許可されています。従ってデータベースエンコーディングがUTF8でない限り、厳密にはJSON型がJSON仕様に準拠することはできません。
データベースのエンコーディングで表現できない文字を直接含めようとすると失敗します。逆に、UTF8で許可されずにデータベースのエンコーディングで許可される文字が許されてしまいます。
 </p><p> RFC 7159 では、JSON文字列はUnicodeエスケープシーケンス <code class="literal">\u<em class="replaceable"><code>XXXX</code></em></code> を許可するように記述されています。
 <code class="type">json</code>型の入力関数は、データベースエンコーディング方式に関係なくUnicodeエスケープが許可されています。それは、構文上の正しさ(つまり<code class="literal">\u</code>に続けて16進数が4桁)だけをチェックしています。
 しかし、<code class="type">jsonb</code>の入力関数はより厳しくなります。
 データベースのエンコードがUTF8でない限り、Unicodeは非ASCII文字（<code class="literal">U+007F</code>より上位の文字）に対してエスケープを禁止します。
<code class="type">jsonb</code>型は<code class="literal">\u0000</code>も許可しません。(なぜなら<span class="productname">PostgreSQL</span>の<code class="type">text</code>型で表現できないためです）。
また、Unicode基本多言語面以外の文字はUnicodeのサロゲートペアに直すことが要求されています。
有効なUnicodeエスケープは、同等のASCIIまたはUTF8文字に変換されて格納されます。これはサロゲートペアを単一の文字に変換する処理も含まれています。
 </p><div class="note"><h3 class="title">Note</h3><p><a class="xref" href="functions-json.html" title="9.15. JSON関数と演算子">Section 9.15</a>で説明されているJSONの処理関数の多くは、Unicodeエスケープを通常の文字に変換します。
そして、それらの入力は<code class="type">jsonb</code>でない<code class="type">json</code>の場合でも記載された同じ種類のエラーになります。
<code class="type">json</code>入力関数は歴史的経緯によりこれらのチェックをしないため、非UTF8のデータベースエンコーディングで、JSON Unicodeエスケープされた文字を単に格納(処理を必要としない場合)できてしまいます。
一般的には、可能であれば非UTF8のデータベースエンコーディングではUnicodeのJSONエスケープを混在させないようにすることをお勧めします。
  </p></div><p>原文のJSONが<code class="type">jsonb</code>型に変換されるときには、<acronym class="acronym">RFC</acronym> 7159に記載されているプリミティブ型を<a class="xref" href="datatype-json.html#JSON-TYPE-MAPPING-TABLE" title="Table 8.23. JSONプリミティブ型とPostgreSQL型の対応表">Table 8.23</a>に記されているように<span class="productname">PostgreSQL</span>のネイティブな型に変換されます。
そのため、<code class="type">jsonb</code>データ型には、<code class="type">json</code>型になく、また理論上JSONにはないマイナーな制約があります。それは基礎となるデータ型に付随する制限によって表されます。
特に<code class="type">jsonb</code>型は、<span class="productname">PostgreSQL</span>の<code class="type">numeric</code>型の範囲外の数を拒否します。このような処理系で定義される制限は<acronym class="acronym">RFC</acronym> 7159で許可されています。
 しかし、それは IEEE 754 倍精度浮動小数点がJSONの<code class="type">number</code>プリミティブ型を表すのが一般的であるように、実際には他の実装でこのような問題が発生することの方がはるかに可能性が高いです(<acronym class="acronym">RFC</acronym> 7159が明示的に予測して、許可しています）。
 このようなシステムと<span class="productname">PostgreSQL</span>で交換フォーマットとしてJSONを使用する場合は、数値精度を失う危険性があることを把握しておく必要があります。
 </p><p> 逆に、表に示すようにJSONプリミティブ型の入力フォーマットには、対応する<span class="productname">PostgreSQL</span>型と適合しない、いくつかのマイナーな制限があります。
 </p><div class="table" id="JSON-TYPE-MAPPING-TABLE"><p class="title"><strong>Table 8.23. JSONプリミティブ型と<span class="productname">PostgreSQL</span>型の対応表</strong></p><div class="table-contents"><table class="table" summary="JSONプリミティブ型とPostgreSQL型の対応表" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>JSON プリミティブ型</th><th><span class="productname">PostgreSQL</span>型</th><th>注釈</th></tr></thead><tbody><tr><td><code class="type">string</code></td><td><code class="type">text</code></td><td><code class="literal">\u0000</code>は許可されません。
またデータベースエンコーディングがUTF8でない場合、非アスキーのユニコードエスケープも許可されません。</td></tr><tr><td><code class="type">number</code></td><td><code class="type">numeric</code></td><td><code class="literal">NaN</code> と <code class="literal">infinity</code> 値は許可されません</td></tr><tr><td><code class="type">boolean</code></td><td><code class="type">boolean</code></td><td>小文字の<code class="literal">true</code> と <code class="literal">false</code> という綴りのみ許可されます</td></tr><tr><td><code class="type">null</code></td><td>(none)</td><td>SQLの<code class="literal">NULL</code>とは概念が異なります</td></tr></tbody></table></div></div><br class="table-break" /><div class="sect2" id="JSON-KEYS-ELEMENTS"><div class="titlepage"><div><div><h3 class="title">8.14.1. JSONの入出力構文</h3></div></div></div><p> JSON型の入出力構文の仕様は<acronym class="acronym">RFC</acronym> 7159 に規定されています。
  </p><p>以下は、すべて有効な<code class="type">json</code>型(または <code class="type">jsonb</code>型)の式です。
</p><pre class="programlisting">--- シンプルなスカラ/プリミティブ値
--- プリミティブ値は、数値、引用符で括られた文字列、true、 false、またはnullです。
SELECT '5'::json;

--- 0個以上の要素の配列（要素は同じ型である必要はありません)。
SELECT '[1, 2, "foo", null]'::json;

--- キーと値のペアを含むオブジェクト
--- オブジェクトキーは常に引用符で括られた文字列でなければならないことに注意してください。
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

--- 配列とオブジェクトは任意に入れ子にすることができます。
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</pre><p>
  </p><p>先に述べたようにJSONの値が入力されたときに、その後、追加の処理を行わずに表示する場合、<code class="type">json</code>は入力と同じテキストが出力されます、<code class="type">jsonb</code>では、空白のような意味を持たない情報を保持しません。
例を示します。ここでは相違点に注意してください。
</p><pre class="programlisting">SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json                       
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb                       
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)</pre><p>
もう一つ注目に値するのは、<code class="type">jsonb</code>では、数値は<code class="type">numeric</code>型の動作に応じて表示され、意味を持たない情報を保持しません。実際には数字は<code class="literal">E</code>表記なしで表示されることを意味します。
例を示します。
</p><pre class="programlisting">SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb          
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)</pre><p>
 しかし、この例に見られるように<code class="type">jsonb</code>は小数の末尾のゼロを保持します。それにも関わらず、等しいかチェックする場合等では、意味的に重要ではありません。
  </p></div><div class="sect2" id="JSON-DOC-DESIGN"><div class="titlepage"><div><div><h3 class="title">8.14.2. 効果的なJSONドキュメントの設計</h3></div></div></div><p> JSONデータは従来のリレーショナルデータモデルよりもかなり柔軟に表現することができます。そのため、変わりやすさを求められる環境では説得力があります。
 そして、それは同じアプリケーション内で、両方のアプローチが共存し相互に補完することが可能です。
しかし、最大の柔軟性が要求されるアプリケーションのためでもJSONドキュメントには、まだいくらかの固定構造を持つことを推奨します。
構造は（いくつかのビジネスルールを強制することは宣言的に可能であるが）、一般的に強制されないですが、テーブル内の<span class="quote">“<span class="quote">ドキュメント</span>”</span>（データ）セットをまとめて予測可能な構造にすることで、簡単に問い合わせを記述することができます。
  </p><p> JSONデータはテーブルに格納するとき、他のデータ型と同一の同時実行制御の対象となります。大きな文章を保存することは実行可能ですが、すべての更新が行レベルロックを取得することに留意してください。
 更新トランザクション間のロックの競合を減少させるために、管理可能なサイズにJSONドキュメントを制限することを検討してください。
 理想的には、JSONドキュメントはビジネス・ルール上、独立して変更することができない単位までデータを分割すべきです。
  </p></div><div class="sect2" id="JSON-CONTAINMENT"><div class="titlepage"><div><div><h3 class="title">8.14.3. <code class="type">jsonb</code>型用包含演算子と存在演算子</h3></div></div></div><a id="id-1.5.7.22.16.2" class="indexterm"></a><a id="id-1.5.7.22.16.3" class="indexterm"></a><p><em class="firstterm">包含演算子</em>のテストはjsonb型の重要な機能です。これらのセットはjson型には全くありません。
<code class="type">jsonb</code>ドキュメントが、その中に指定する値を含むかどうかをテストします。
これらの例は、特に記載がないかぎりtrueを返します。
  </p><pre class="programlisting">--- 単純なスカラ/プリミティブ値は、同一の値が含まれています。
SELECT '"foo"'::jsonb @&gt; '"foo"'::jsonb;

--- 左辺の配列に右辺の配列が含まれています。
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 3]'::jsonb;

--- 配列要素の順序は重要ではありませんので、これもまた真になります。
SELECT '[1, 2, 3]'::jsonb @&gt; '[3, 1]'::jsonb;

--- 配列要素に重複が含まれているかは問題ではありません。
SELECT '[1, 2, 3]'::jsonb @&gt; '[1, 2, 2]'::jsonb;

--- 右辺の単一ペアを持つオブジェクトが左辺のオブジェクト内に含まれています。
SELECT '{"product": "PostgreSQL", "version": 9.4, "jsonb": true}'::jsonb @&gt; '{"version": 9.4}'::jsonb;

-- 右辺の配列は左辺の配列に含まれま<span class="emphasis"><strong>せん</strong></span>、
-- 類似の配列が、その中のネストに含まれているにも関わらず。
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[1, 3]'::jsonb;  -- falseになる

--- しかし、ネストで層を合わせれば含まれるようになります。
SELECT '[1, 2, [1, 3]]'::jsonb @&gt; '[[1, 3]]'::jsonb;

--- 同様に、これも含まれません。
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"bar": "baz"}'::jsonb;  -- falseになる

--- トップレベルのキーと空のオブジェクトが含まれる。
SELECT '{"foo": {"bar": "baz"}}'::jsonb @&gt; '{"foo": {}}'::jsonb;</pre><p> 一般原則では、オブジェクトにオブジェクトが含まれているかを判断するには、いくつかの条件に一致しない配列要素とキー／値のペアを含むオブジェクトを捨てた後に構造とデータを一致させる必要があります。
 しかし、条件に一致するには配列要素の順序は重要ではなく、重複要素は一回のみ有効に評価されることを覚えておく必要があります。
  </p><p>構造が一致しなければならないという一般原則の特別な例外として、配列はプリミティブな値を含めることができます。
  </p><pre class="programlisting">--- この配列はプリミティブな文字列を含みます。
SELECT '["foo", "bar"]'::jsonb @&gt; '"bar"'::jsonb;

--- この例外は相互的ではありません。 -- これは含まれません。
SELECT '"bar"'::jsonb @&gt; '["bar"]'::jsonb;  -- falseになる</pre><p> <code class="type">jsonb</code>型は、また<em class="firstterm">存在</em>演算子を持ちます。包含の変種です。それは文字列(与えられた<code class="type">text</code>値)が、<code class="type">jsonb</code>値のオブジェクトキーまたは配列のトップレベルに存在するかどうかをテストします。
これらの例は、特に記載がないかぎりtrueを返します。
  </p><pre class="programlisting">--- 文字列が配列要素に存在する。
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

--- 文字列がオブジェクトキーに存在する。
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

--- オブジェクト値は考慮されません。
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- falseになる

--- オブジェクトはトップレベルから一致するように存在する必要があります。
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- falseになる

--- 文字列はJSONプリミティブ文字列と一致させることができます。
SELECT '"foo"'::jsonb ? 'foo';</pre><p> JSONオブジェクトは、関係するキーや要素が多く存在する場合、含むかどうかまたは存在するかどうかのテストに適しています。なぜなら配列とは異なり、リニア検索をする必要がなく、内部的に検索に最適化されています。
  </p><div class="tip"><h3 class="title">Tip</h3><p>JSONでは包含がネストされるので、適切な問い合わせではサブオブジェクトの明示的な選択を省略することが出来ます。
例を挙げます。
<code class="structfield">doc</code>列にトップレベルのオブジェクトがあります。
このオブジェクトには、<code class="literal">tags</code>フィールドが含まれ、このフィールドにサブオブジェクトの配列が多く含まれているとします。
以下の問い合わせは、サブオブジェクトが<code class="literal">"term":"paris"</code>と<code class="literal">"term":"food"</code>の両方を含むエントリを探します。
そのとき<code class="literal">tags</code>配列の外側にある、それらのキーは無視されます。
</p><pre class="programlisting">SELECT doc-&gt;'site_name' FROM websites
  WHERE doc @&gt; '{"tags":[{"term":"paris"}, {"term":"food"}]}';</pre><p>
同じことを達成することは出来ます。例えば、
</p><pre class="programlisting">SELECT doc-&gt;'site_name' FROM websites
  WHERE doc-&gt;'tags' @&gt; '[{"term":"paris"}, {"term":"food"}]';</pre><p>
しかし、そのアプローチは柔軟性に欠け、効率も落ちます。
   </p><p>一方、JSONの存在演算子は、ネストしていません。
JSONの値の最上位に指定されたキーまたは配列要素のみを探します。
   </p></div><p> JSONの様々な包含演算子や存在演算子、他のすべてのJSON演算子と関数は <a class="xref" href="functions-json.html" title="9.15. JSON関数と演算子">Section 9.15</a>に記載されています。
  </p></div><div class="sect2" id="JSON-INDEXING"><div class="titlepage"><div><div><h3 class="title">8.14.4. <code class="type">jsonb</code> インデックス</h3></div></div></div><a id="id-1.5.7.22.17.2" class="indexterm"></a><p> GINインデックスは、多数の<code class="type">jsonb</code>ドキュメント(データ)のキーやキー／値ペアを効率的に検索するときに用いることができます。
 異なるパフォーマンスと柔軟性のトレードオフを持つ、2つのGIN <span class="quote">“<span class="quote">演算子クラス</span>”</span> が提供されています。
  </p><p><code class="type">jsonb</code>型の問い合わせでサポートしているデフォルトのGIN演算子クラスは、トップレベルのキーが存在するかの演算子として<code class="literal">?</code>、<code class="literal">?&amp;</code>、<code class="literal">?|</code>があり、パス／値が存在するかの演算子として<code class="literal">@&gt;</code>があります。
（これらの演算子の意味の詳細は、<a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="Table 9.44. 追加jsonb演算子">Table 9.44</a>を参照してください。）
この演算子クラスのインデックスを作成する例。
</p><pre class="programlisting">CREATE INDEX idxgin ON api USING GIN (jdoc);</pre><p>
デフォルトでないGIN演算子クラスは、<code class="literal">@&gt;</code>演算子のみサポートする<code class="literal">jsonb_path_ops</code>があります。
この演算子クラスのインデックスを作成する例。
</p><pre class="programlisting">CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);</pre><p>
  </p><p> サードパーティのWebサービスから、ドキュメント化されたスキーマ定義を持つJSONドキュメントを取得し、格納するテーブルの例を考えてみましょう。
 典型的なドキュメントは、次のとおりです。
</p><pre class="programlisting">{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}</pre><p>
 テーブル名 <code class="structname">api</code>に<code class="type">jsonb</code>型で<code class="structfield">jdoc</code>をカラム名として格納します。
 このカラムにGINインデックスを作成した場合、以下のような問い合わせがインデックスを利用することができます。
</p><pre class="programlisting">--- "company"キー が "Magnafone"値であるものを見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"company": "Magnafone"}';</pre><p>
 しかし 次のような問い合わせはインデックスを使用しません。なぜなら、<code class="literal">?</code>演算子はインデックス可能ですが、<code class="structfield">jdoc</code>カラムのインデックスが直接適用されていないためです。
</p><pre class="programlisting">--- キー "tags" の配列要素に "qui"が含まれているか見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc -&gt; 'tags' ? 'qui';</pre><p>
 それでも、上記の問い合わせは、式インデックスを適切に使用することでインデックスを使用することができます。一般的な <code class="literal">"tags"</code>キーから特定の項目を照会する場合、このようなインデックスを定義すると良いかもしれません。
</p><pre class="programlisting">CREATE INDEX idxgintags ON api USING GIN ((jdoc -&gt; 'tags'));</pre><p>
 さて、 <code class="literal">WHERE</code>句の <code class="literal">jdoc -&gt; 'tags' ? 'qui'</code>は、インデックス式では 、<code class="literal">?</code>演算子はインデックス可能として認識されます。
（式インデックスに関する詳細情報は<a class="xref" href="indexes-expressional.html" title="11.7. 式に対するインデックス">Section 11.7</a>を参照してください。）
  </p><p>別のアプローチとして包含を利用する問い合わせがあります。例を示します。
</p><pre class="programlisting">--- キー "tags"に 要素"qui"が含まれるかどうか見つける
SELECT jdoc-&gt;'guid', jdoc-&gt;'name' FROM api WHERE jdoc @&gt; '{"tags": ["qui"]}';</pre><p>
 <code class="structfield">jdoc</code>カラムのシンプルなGINインデックスは、この問い合わせをサポートすることができます。
しかし、前の例では、<code class="literal">tags</code>キーの下にあるデータのみをインデックスに格納していたのに対して、そのようなインデックスは、<code class="structfield">jdoc</code>のすべてのキーと値のコピーを保存しますので、注意が必要です。
シンプルなインデックスアプローチは（それが全てのキーについての問い合わせをサポートしているため）はるかに柔軟ですが、ターゲット式インデックスは単純なインデックスより小さく、検索のときに高速である可能性が高くなります。
  </p><p> <code class="literal">jsonb_path_ops</code>演算子クラスは、<code class="literal">@&gt;</code>演算子をサポートしているだけですが、デフォルト演算子クラスの<code class="literal">jsonb_ops</code>よりも顕著なパフォーマンス上の利点があります。
 <code class="literal">jsonb_path_ops</code>インデックスは、通常同じデータの<code class="literal">jsonb_ops</code>インデックスよりもはるかに小さく、データの中で頻繁に表示されるキーを含む場合のような特別な検索には、より良くなります。
 そのため、デフォルトの演算子クラスよりも検索操作よくなります。
  </p><p> <code class="literal">jsonb_ops</code>と<code class="literal">jsonb_path_ops</code>のGINインデックスの技術的差異は、前者はデータのキーと値のための独立したインデックスを作成しますが、後者は、データの値に対してのみインデックスを作成します。
    <a href="#ftn.id-1.5.7.22.17.8.3" class="footnote"><sup class="footnote" id="id-1.5.7.22.17.8.3">[6]</sup></a>
 基本的に、<code class="literal">jsonb_path_ops</code>インデックス項目は、値とキーのハッシュです。例えば、<code class="literal">{"foo": {"bar": "baz"}}</code>のインデックスはハッシュ値に<code class="literal">foo</code>、<code class="literal">bar</code>、 <code class="literal">baz</code>すべてを組み込んで作成されます。したがって、包含問い合わせのためのインデックス検索は、非常に特定の構造を返すようになっています。 しかしfooがキーとして表示されるかどうかを調べるには全く方法はありません。
一方、jsonb_opsインデックスは個別にはfoo、bar、bazを表す3つのインデックス項目を作成します。その後、包含問い合わせをおこなうには、これらの項目の3つすべてを含む行を探します。
GINインデックスは、かなり効率的に検索することができますが、特に3つの索引項目のいずれかで、非常に多数の行が単一の場合に、同等のjsonb_path_ops検索よりも遅くなります。
  </p><p> <code class="literal">jsonb_path_ops</code>アプローチの欠点は、<code class="literal">{"a": {}}</code>のような、任意の値を含まないJSON構造のためのインデックスエントリを生成しません。このような構造を含むドキュメントの検索が要求された場合、それは、フルインデックススキャンを必要とします。それは非常に遅くなります。そのため、<code class="literal">jsonb_path_ops</code>は、多くの場合、そのような検索を実行するのには不適当です。
  </p><p> <code class="type">jsonb</code>型は、<code class="literal">btree</code> と <code class="literal">hash</code> インデックスもサポートします。これらは通常、JSONドキュメントの完全性をチェックすることが重要な場合のみ有用です。
<code class="type">jsonb</code>のための<code class="literal">btree</code>順序には、興味深いことはほとんどありませんが、しかし、完全さのために次に示します。
</p><pre class="synopsis"><em class="replaceable"><code>Object</code></em> &gt; <em class="replaceable"><code>Array</code></em> &gt; <em class="replaceable"><code>Boolean</code></em> &gt; <em class="replaceable"><code>Number</code></em> &gt; <em class="replaceable"><code>String</code></em> &gt; <em class="replaceable"><code>Null</code></em>

<em class="replaceable"><code>Object with n pairs</code></em> &gt; <em class="replaceable"><code>object with n - 1 pairs</code></em>

<em class="replaceable"><code>Array with n elements</code></em> &gt; <em class="replaceable"><code>array with n - 1 elements</code></em></pre><p>
 ペアの同じ番号を持つオブジェクトは、順に比較されます。
</p><pre class="synopsis"><em class="replaceable"><code>key-1</code></em>, <em class="replaceable"><code>value-1</code></em>, <em class="replaceable"><code>key-2</code></em> ...</pre><p>
そのオブジェクトのキーは、その格納順に比較されることに注意してください。
短いキーは長いキーの前に格納されているため、特にこれは、次のような直感的でない結果に結果につながるかもしれません。
</p><pre class="programlisting">{ "aa": 1, "c": 1} &gt; {"b": 1, "d": 1}</pre><p>
 同様に、配列と同じ番号を持つ要素を比較する順番。
</p><pre class="synopsis"><em class="replaceable"><code>element-1</code></em>, <em class="replaceable"><code>element-2</code></em> ...</pre><p>
 JSONプリミティブ値は基本的に<span class="productname">PostgreSQL</span>データ型と同じルールで比較されます。文字列は、デフォルトのデータベース照合を使用して比較されます
  </p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.7.22.17.8.3" class="footnote"><p><a href="#id-1.5.7.22.17.8.3" class="para"><sup class="para">[6] </sup></a> この目的のために、<span class="quote">“<span class="quote">値</span>”</span> という用語は配列の要素を含みますが、JSONの専門用語では、オブジェクト内の値と配列の要素が時々違うことがあります。
     </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-xml.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="arrays.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.13. <acronym class="acronym">XML</acronym>型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 8.15. 配列</td></tr></table></div></body></html>