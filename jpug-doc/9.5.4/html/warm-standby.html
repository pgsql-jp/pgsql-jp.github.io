<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.2. ログシッピングスタンバイサーバ</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.5.4文書" /><link rel="up" href="high-availability.html" title="第25章 高可用性、負荷分散およびレプリケーション" /><link rel="prev" href="different-replication-solutions.html" title="25.1. 様々な解法の比較" /><link rel="next" href="warm-standby-failover.html" title="25.3. フェールオーバ" /><link rel="copyright" href="legalnotice.html" title="法的告知" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.5.4文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.5.4 warm-standby.html">誤訳等の報告</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="different-replication-solutions.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="high-availability.html">上へ</a></td><td width="60%" align="center">25.2. ログシッピングスタンバイサーバ</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="warm-standby-failover.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="warm-standby"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.2. ログシッピングスタンバイサーバ</h2></div></div></div><span class="original">
 &lt;title&gt;Log-Shipping Standby Servers&lt;/title&gt;
</span><p><span class="original">
   Continuous archiving can be used to create a &lt;firstterm&gt;high
   availability&lt;/&gt; (HA) cluster configuration with one or more
   &lt;firstterm&gt;standby servers&lt;/&gt; ready to take over operations if the
   primary server fails. This capability is widely referred to as
   &lt;firstterm&gt;warm standby&lt;/&gt; or &lt;firstterm&gt;log shipping&lt;/&gt;.
</span>継続的なアーカイブ処理を使用して、プライマリサーバが失敗した場合に操作を引き継ぐ準備がなされた、1つ以上の<em class="firstterm">スタンバイサーバ</em>を持つ<em class="firstterm">高可用性</em>(HA)クラスタ構成を作成することができます。
この機能は<em class="firstterm">ウォームスタンバイ</em>または<em class="firstterm">ログシッピング</em>として広く知られています。
  </p><p><span class="original">
   The primary and standby server work together to provide this capability,
   though the servers are only loosely coupled. The primary server operates
   in continuous archiving mode, while each standby server operates in
   continuous recovery mode, reading the WAL files from the primary. No
   changes to the database tables are required to enable this capability,
   so it offers low administration overhead compared to some other
   replication solutions. This configuration also has relatively low
   performance impact on the primary server.
</span>プライマリサーバとスタンバイサーバは、この機能を提供するために共同して稼動しますが、サーバとサーバはゆるく結合しています。
プライマリサーバは継続的アーカイブモードで動作し、各スタンバイサーバはプライマリからWALファイルを読み取る、継続的リカバリモードで動作します。
この機能を可能にするために、データベースのテーブル変更は不要です。
したがって、他のレプリケーションの解法に比べて、管理にかかるオーバーヘッドが減少します。
この構成はプライマリサーバの性能への影響も相対的に減少させます。
  </p><p><span class="original">
   Directly moving WAL records from one database server to another
   is typically described as log shipping. &lt;productname&gt;PostgreSQL&lt;/&gt;
   implements file-based log shipping by transferring WAL records
   one file (WAL segment) at a time. WAL files (16MB) can be
   shipped easily and cheaply over any distance, whether it be to an
   adjacent system, another system at the same site, or another system on
   the far side of the globe. The bandwidth required for this technique
   varies according to the transaction rate of the primary server.
   Record-based log shipping is more granular and streams WAL changes
   incrementally over a network connection (see &lt;xref
   linkend="streaming-replication"&gt;).
</span>あるデータベースサーバから他へ直接WALレコードを移動することは通常、ログシッピングと説明されます。
<span class="productname">PostgreSQL</span>はファイルベースのログシッピングを実装します。
つまりWALレコードはある時点で1つのファイル(WALセグメント)として送信されることを意味します。
WALファイル(16MB)は隣り合うシステム、同じサイトの別システム、地球の裏側のシステムなど距離に関わらず、簡単かつ安価に送付することができます。
この技法に必要な帯域幅はプライマリサーバのトランザクションの頻度に応じて変動します。
レコードベースのログシッピングはより粒度を細かくしたもので、ネットワーク接続を介してWALの変更を増分的に流します（<a class="xref" href="warm-standby.html#streaming-replication" title="25.2.5. ストリーミングレプリケーション">25.2.5. ストリーミングレプリケーション</a>参照）。
  </p><p><span class="original">
   It should be noted that log shipping is asynchronous, i.e., the WAL
   records are shipped after transaction commit. As a result, there is a
   window for data loss should the primary server suffer a catastrophic
   failure; transactions not yet shipped will be lost.  The size of the
   data loss window in file-based log shipping can be limited by use of the
   &lt;varname&gt;archive_timeout&lt;/varname&gt; parameter, which can be set as low
   as a few seconds.  However such a low setting will
   substantially increase the bandwidth required for file shipping.
   Streaming replication (see &lt;xref linkend="streaming-replication"&gt;)
   allows a much smaller window of data loss.
</span>ログシッピングが非同期であることに注意しなければなりません。
つまり、WALレコードはトランザクションがコミットした後に転送されます。
結果として、プライマリサーバが災害などの致命的な失敗をうけた場合、送信されていないトランザクションが失われますので、データを損失する空白期間があります。
ファイルベースのログシッピングにおけるデータ損失の空白期間量を<code class="varname">archive_timeout</code>パラメータを用いて制限することができます。
これは数秒程度まで小さく設定することができます。
しかし、低く設定するとファイル転送に必要な帯域幅が増大します。
ストリーミングレプリケーション（<a class="xref" href="warm-standby.html#streaming-replication" title="25.2.5. ストリーミングレプリケーション">25.2.5. ストリーミングレプリケーション</a>参照）により、データを損失する期間を非常に小さくすることができます。
  </p><p><span class="original">
   Recovery performance is sufficiently good that the standby will
   typically be only moments away from full
   availability once it has been activated. As a result, this is called
   a warm standby configuration which offers high
   availability. Restoring a server from an archived base backup and
   rollforward will take considerably longer, so that technique only
   offers a solution for disaster recovery, not high availability.
   A standby server can also be used for read-only queries, in which case
   it is called a Hot Standby server. See &lt;xref linkend="hot-standby"&gt; for
   more information.
</span>リカバリ処理の性能は十分よく、一度実施されれば、スタンバイサーバが完全な状態から逸脱するのは一時的にしかすぎません。
結果としてこれは、高可用性を提供するウォームスタンバイ構成と呼ばれます。
保管されたベースバックアップからサーバをリストアし、ロールフォワードを行うことはおそらく長時間かかりますので、これは高可用性のための解法とはいえず、災害からのリカバリのための解法です。
スタンバイサーバは読み取り専用の問い合わせに使用することもできます。
この場合ホットスタンバイサーバと呼ばれます。
詳細については<a class="xref" href="hot-standby.html" title="25.5. ホットスタンバイ">25.5. ホットスタンバイ</a>を参照してください。
  </p><a id="idp77855760" class="indexterm"></a><a id="idp77859056" class="indexterm"></a><a id="idp77860320" class="indexterm"></a><a id="idp77861584" class="indexterm"></a><a id="idp77862848" class="indexterm"></a><a id="idp77864096" class="indexterm"></a><div class="sect2" id="standby-planning"><div class="titlepage"><div><div><h3 class="title">25.2.1. 計画</h3></div></div></div><span class="original">
   &lt;title&gt;Planning&lt;/title&gt;
</span><p><span class="original">
    It is usually wise to create the primary and standby servers
    so that they are as similar as possible, at least from the
    perspective of the database server.  In particular, the path names
    associated with tablespaces will be passed across unmodified, so both
    primary and standby servers must have the same mount paths for
    tablespaces if that feature is used.  Keep in mind that if
    &lt;xref linkend="sql-createtablespace"&gt;
    is executed on the primary, any new mount point needed for it must
    be created on the primary and all standby servers before the command
    is executed. Hardware need not be exactly the same, but experience shows
    that maintaining two identical systems is easier than maintaining two
    dissimilar ones over the lifetime of the application and system.
    In any case the hardware architecture must be the same &amp;mdash; shipping
    from, say, a 32-bit to a 64-bit system will not work.
</span>プライマリサーバとスタンバイサーバを、少なくともデータベースサーバという見地でできる限り同じになるように作成することを通常勧めます。
具体的には、テーブル空間に関連するパス名はそのまま渡されますので、テーブル空間機能を使用する場合には、プライマリとスタンバイサーバの両方でテーブル空間用のマウントパスを同じにしておかなければなりません。
<a class="xref" href="sql-createtablespace.html" title="CREATE TABLESPACE"><span class="refentrytitle">CREATE TABLESPACE</span></a>をプライマリで実行する場合、そのコマンドを実行する前に必要な新しいマウントポイントをプライマリとすべてのスタンバイサーバで作成しなければならないことに注意してください。
ハードウェアをまったく同じにする必要はありませんが、経験上アプリケーションとシステムの運用期間に渡って2つの同じシステムを管理する方が、異なる2つのシステムを管理するよりも簡単です。
いずれにしてもハードウェアアーキテクチャは必ず同じでなければなりません。
例えば32ビットシステムから64ビットシステムへのシッピングは動作しません。
   </p><p><span class="original">
    In general, log shipping between servers running different major
    &lt;productname&gt;PostgreSQL&lt;/&gt; release
    levels is not possible. It is the policy of the PostgreSQL Global
    Development Group not to make changes to disk formats during minor release
    upgrades, so it is likely that running different minor release levels
    on primary and standby servers will work successfully. However, no
    formal support for that is offered and you are advised to keep primary
    and standby servers at the same release level as much as possible.
    When updating to a new minor release, the safest policy is to update
    the standby servers first &amp;mdash; a new minor release is more likely
    to be able to read WAL files from a previous minor release than vice
    versa.
</span>マイナーリリースの更新ではディスク書式を変更しないというのがPostgreSQLグローバル開発グループの方針ですので、プライマリサーバとスタンバイサーバとの間でマイナーリリースレベルの違いがあってもうまく動作するはずです。
しかし、この場合、公的なサポートは提供されません。
できる限りプライマリサーバとスタンバイサーバとで同じリリースレベルを使用してください。
新しいマイナーリリースに更新する場合、もっとも安全な方針はスタンバイサーバを先に更新することです。
新しいマイナーリリースは以前のマイナーリリースのWALファイルを読み込むことはできますが、逆はできないかもしれません。
   </p></div><div class="sect2" id="standby-server-operation"><div class="titlepage"><div><div><h3 class="title">25.2.2. スタンバイサーバの動作</h3></div></div></div><span class="original">
   &lt;title&gt;Standby Server Operation&lt;/title&gt;
</span><p><span class="original">
    In standby mode, the server continuously applies WAL received from the
    master server. The standby server can read WAL from a WAL archive
    (see &lt;xref linkend="restore-command"&gt;) or directly from the master
    over a TCP connection (streaming replication). The standby server will
    also attempt to restore any WAL found in the standby cluster's
    &lt;filename&gt;pg_xlog&lt;/&gt; directory. That typically happens after a server
    restart, when the standby replays again WAL that was streamed from the
    master before the restart, but you can also manually copy files to
    &lt;filename&gt;pg_xlog&lt;/&gt; at any time to have them replayed.
</span>スタンバイモードでは、サーバは継続的にマスタサーバから受け取ったWALを適用します。
スタンバイサーバはWALアーカイブ(<a class="xref" href="archive-recovery-settings.html#restore-command">restore_command</a>参照)から、または直接TCP接続(ストリーミングレプリケーション)を介してマスタサーバから、WALを読み取ることができます。
またスタンバイサーバはスタンバイクラスタの<code class="filename">pg_xlog</code>ディレクトリにあるすべてのWALをリストアしようと試みます。
これはよくサーバの再起動後、スタンバイが再起動前にマスタから流れ込んだWALを再生する時に発生します。
しかしまたファイルを再生する任意の時点で、手作業で<code class="filename">pg_xlog</code>にコピーすることもできます。
   </p><p><span class="original">
    At startup, the standby begins by restoring all WAL available in the
    archive location, calling &lt;varname&gt;restore_command&lt;/&gt;. Once it
    reaches the end of WAL available there and &lt;varname&gt;restore_command&lt;/&gt;
    fails, it tries to restore any WAL available in the &lt;filename&gt;pg_xlog&lt;/&gt; directory.
    If that fails, and streaming replication has been configured, the
    standby tries to connect to the primary server and start streaming WAL
    from the last valid record found in archive or &lt;filename&gt;pg_xlog&lt;/&gt;. If that fails
    or streaming replication is not configured, or if the connection is
    later disconnected, the standby goes back to step 1 and tries to
    restore the file from the archive again. This loop of retries from the
    archive, &lt;filename&gt;pg_xlog&lt;/&gt;, and via streaming replication goes on until the server
    is stopped or failover is triggered by a trigger file.
</span>起動時、スタンバイサーバは<code class="varname">restore_command</code>を呼び出して、アーカイブ場所にある利用可能なすべてのWALをリストアすることから始めます。
そこで利用可能なWALの終端に達し、<code class="varname">restore_command</code>が失敗すると、<code class="filename">pg_xlog</code>ディレクトリにある利用可能な任意のWALのリストアを試みます。
ストリーミングレプリケーションが設定されている場合、これに失敗すると、スタンバイはプライマリサーバへの接続を試み、アーカイブまたは<code class="filename">pg_xlog</code>内に存在した最終の有効レコードからWALのストリーミングを開始します。
ストリーミングレプリケーションが未設定時にこれに失敗する場合、または、接続が後で切断される場合、スタンバイは最初に戻り、アーカイブからのファイルのリストアを繰り返し行います。
このアーカイブ、<code class="filename">pg_xlog</code>、ストリーミングレプリケーションからという再試行の繰り返しはサーバが停止する、あるいはトリガファイルによるフェールオーバが発行されるまで続きます。
   </p><p><span class="original">
    Standby mode is exited and the server switches to normal operation
    when &lt;command&gt;pg_ctl promote&lt;/&gt; is run or a trigger file is found
    (&lt;varname&gt;trigger_file&lt;/&gt;). Before failover,
    any WAL immediately available in the archive or in &lt;filename&gt;pg_xlog&lt;/&gt; will be
    restored, but no attempt is made to connect to the master.
</span><code class="command">pg_ctl promote</code>が実行された時またはトリガファイル(<code class="varname">trigger_file</code>)が存在する時、スタンバイモードは終了し、サーバは通常の動作に切り替わります。
フェールオーバの前に、アーカイブまたは<code class="filename">pg_xlog</code>内の即座に利用可能なWALをすべてリストアします。
しかし、マスタへの接続を行おうとはしません。
   </p></div><div class="sect2" id="preparing-master-for-standby"><div class="titlepage"><div><div><h3 class="title">25.2.3. スタンバイサーバのためのマスタの準備</h3></div></div></div><span class="original">
   &lt;title&gt;Preparing the Master for Standby Servers&lt;/title&gt;
</span><p><span class="original">
    Set up continuous archiving on the primary to an archive directory
    accessible from the standby, as described
    in &lt;xref linkend="continuous-archiving"&gt;. The archive location should be
    accessible from the standby even when the master is down, i.e. it should
    reside on the standby server itself or another trusted server, not on
    the master server.
</span><a class="xref" href="continuous-archiving.html" title="24.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）">24.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</a>で説明したように、スタンバイからアクセス可能なアーカイブディレクトリに対してプライマリで継続的なアーカイブを設定してください。
このアーカイブ場所はマスタが停止した時であってもスタンバイからアクセス可能でなければなりません。
つまり、マスタサーバ上ではなく、スタンバイサーバ自身上に存在するか、または他の高信頼性サーバ上に存在しなければなりません。
   </p><p><span class="original">
    If you want to use streaming replication, set up authentication on the
    primary server to allow replication connections from the standby
    server(s); that is, create a role and provide a suitable entry or
    entries in &lt;filename&gt;pg_hba.conf&lt;/&gt; with the database field set to
    &lt;literal&gt;replication&lt;/&gt;.  Also ensure &lt;varname&gt;max_wal_senders&lt;/&gt; is set
    to a sufficiently large value in the configuration file of the primary
    server. If replication slots will be used,
    ensure that &lt;varname&gt;max_replication_slots&lt;/varname&gt; is set sufficiently
    high as well.
</span>ストリーミングレプリケーションを使用したい場合、スタンバイサーバ(複数可)からのレプリケーション接続を受け付けるようにプライマリサーバで認証を設定してください。
つまり、ロールを作成し適切な項目を提供、あるいは、そのデータベースフィールドとして<code class="literal">replication</code>を持つ項目を<code class="filename">pg_hba.conf</code>内に設定してください。
また、プライマリサーバの設定ファイルにおいて<code class="varname">max_wal_senders</code>が十分大きな値に設定されていることを確認してください。
レプリケーションスロットを使用している場合は、<code class="varname">max_replication_slots</code>も十分に設定されているか確認してください。
   </p><p><span class="original">
    Take a base backup as described in &lt;xref linkend="backup-base-backup"&gt;
    to bootstrap the standby server.
</span><a class="xref" href="continuous-archiving.html#backup-base-backup" title="24.3.2. ベースバックアップの作成">24.3.2. ベースバックアップの作成</a>に記述したように、スタンバイサーバの再起動のために、ベースバックアップを取得してください。
   </p></div><div class="sect2" id="standby-server-setup"><div class="titlepage"><div><div><h3 class="title">25.2.4. スタンバイサーバの設定</h3></div></div></div><span class="original">
   &lt;title&gt;Setting Up a Standby Server&lt;/title&gt;
</span><p><span class="original">
    To set up the standby server, restore the base backup taken from primary
    server (see &lt;xref linkend="backup-pitr-recovery"&gt;). Create a recovery
    command file &lt;filename&gt;recovery.conf&lt;/&gt; in the standby's cluster data
    directory, and turn on &lt;varname&gt;standby_mode&lt;/&gt;. Set
    &lt;varname&gt;restore_command&lt;/&gt; to a simple command to copy files from
    the WAL archive. If you plan to have multiple standby servers for high
    availability purposes, set &lt;varname&gt;recovery_target_timeline&lt;/&gt; to
    &lt;literal&gt;latest&lt;/&gt;, to make the standby server follow the timeline change
    that occurs at failover to another standby.
</span>スタンバイサーバを設定するためには、プライマリサーバから取得したベースバックアップをリストアしてください(<a class="xref" href="continuous-archiving.html#backup-pitr-recovery" title="24.3.4. 継続的アーカイブによるバックアップを使用した復旧">24.3.4. 継続的アーカイブによるバックアップを使用した復旧</a>参照)。
スタンバイのクラスタデータディレクトリ内に<code class="filename">recovery.conf</code>リカバリコマンドファイルを作成し、<code class="varname">standby_mode</code>を有効にしてください。
WALアーカイブからファイルをコピーする簡単なコマンドを<code class="varname">restore_command</code>に設定してください。
高可用性のために複数のスタンバイサーバを持たせようとしている場合、<code class="varname">recovery_target_timeline</code>を<code class="literal">latest</code>に設定し、スタンバイサーバが他のスタンバイにフェールオーバする時に発生するタイムラインの変更に従うようにします。
   </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><span class="original">
     Do not use pg_standby or similar tools with the built-in standby mode
     described here. &lt;varname&gt;restore_command&lt;/&gt; should return immediately
     if the file does not exist; the server will retry the command again if
     necessary. See &lt;xref linkend="log-shipping-alternative"&gt;
     for using tools like pg_standby.
</span>ここで説明した組込みのスタンバイモードといっしょにpg_standbyや類似ツールを使用しないでください。
<code class="varname">restore_command</code>はファイルが存在しない場合に即座に終了しなければなりません。
サーバが必要に応じてそのコマンドを再度実行します。
pg_standbyのようなツールを使用するためには<a class="xref" href="log-shipping-alternative.html" title="25.4. この他のログシッピングの方法">25.4. この他のログシッピングの方法</a>を参照してください。
    </p></div><p><span class="original">
     If you want to use streaming replication, fill in
     &lt;varname&gt;primary_conninfo&lt;/&gt; with a libpq connection string, including
     the host name (or IP address) and any additional details needed to
     connect to the primary server. If the primary needs a password for
     authentication, the password needs to be specified in
     &lt;varname&gt;primary_conninfo&lt;/&gt; as well.
</span>ストリーミングレプリケーションを使用したい場合には、ホスト名(またはIPアドレス)とプライマリサーバとの接続に必要な追加情報を含む、libpq接続文字列で<code class="varname">primary_conninfo</code>を記述してください。
プライマリで認証用のパスワードが必要な場合は<code class="varname">primary_conninfo</code>にそのパスワードも指定する必要があります。
   </p><p><span class="original">
    If you're setting up the standby server for high availability purposes,
    set up WAL archiving, connections and authentication like the primary
    server, because the standby server will work as a primary server after
    failover.
</span>スタンバイサーバを高可用性を目的に設定しているのであれば、スタンバイサーバはフェールオーバの後プライマリサーバとして動作しますので、プライマリサーバと同様にWALアーカイブ処理、接続、認証を設定してください。
   </p><p><span class="original">
    If you're using a WAL archive, its size can be minimized using the &lt;xref
    linkend="archive-cleanup-command"&gt; parameter to remove files that are no
    longer required by the standby server.
    The &lt;application&gt;pg_archivecleanup&lt;/&gt; utility is designed specifically to
    be used with &lt;varname&gt;archive_cleanup_command&lt;/&gt; in typical single-standby
    configurations, see &lt;xref linkend="pgarchivecleanup"&gt;.
    Note however, that if you're using the archive for backup purposes, you
    need to retain files needed to recover from at least the latest base
    backup, even if they're no longer needed by the standby.
</span>WALアーカイブを使用している場合、<a class="xref" href="archive-recovery-settings.html#archive-cleanup-command">archive_cleanup_command</a>パラメータを使用してスタンバイサーバで不要となったファイルを削除することで、その容量を最小化することができます。
特に<span class="application">pg_archivecleanup</span>ユーティリティは、典型的な単一スタンバイ構成（<a class="xref" href="pgarchivecleanup.html" title="pg_archivecleanup"><span class="refentrytitle"><span class="application">pg_archivecleanup</span></span></a>参照）における<code class="varname">archive_cleanup_command</code>と共に使用されるように設計されています。
しかし、バックアップを目的にアーカイブを使用している場合には、スタンバイから必要とされなくなったファイルであっても、最新のベースバックアップの時点からリカバリするために必要なファイルを保持しなければならないことに注意してください。
   </p><p><span class="original">
    A simple example of a &lt;filename&gt;recovery.conf&lt;/&gt; is:
</span><code class="filename">recovery.conf</code>の簡単な例を以下に示します。
</p><pre class="programlisting">standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
restore_command = 'cp /path/to/archive/%f %p'
archive_cleanup_command = 'pg_archivecleanup /path/to/archive %r'</pre><p>
   </p><p><span class="original">
    You can have any number of standby servers, but if you use streaming
    replication, make sure you set &lt;varname&gt;max_wal_senders&lt;/&gt; high enough in
    the primary to allow them to be connected simultaneously.
</span>スタンバイサーバの台数に制限はありませんが、ストリーミングレプリケーションを使用するなら、プライマリサーバに同時に接続できるように<code class="varname">max_wal_senders</code>を十分な数に設定してください。
   </p></div><div class="sect2" id="streaming-replication"><div class="titlepage"><div><div><h3 class="title">25.2.5. ストリーミングレプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Streaming Replication&lt;/title&gt;
</span><a id="idp77917760" class="indexterm"></a><p><span class="original">
    Streaming replication allows a standby server to stay more up-to-date
    than is possible with file-based log shipping. The standby connects
    to the primary, which streams WAL records to the standby as they're
    generated, without waiting for the WAL file to be filled.
</span>ストリーミングレプリケーションによりスタンバイサーバはファイルベースのログシッピングよりもより最近の状態を維持できるようになります。
スタンバイは、WALレコードが生成された時にWALファイルがいっぱいになるまで待機せずにWALレコードをスタンバイに流し出すプライマリと接続します。
   </p><p><span class="original">
    Streaming replication is asynchronous by default
    (see &lt;xref linkend="synchronous-replication"&gt;), in which case there is
    a small delay between committing a transaction in the primary and the
    changes becoming visible in the standby. This delay is however much
    smaller than with file-based log shipping, typically under one second
    assuming the standby is powerful enough to keep up with the load. With
    streaming replication, &lt;varname&gt;archive_timeout&lt;/&gt; is not required to
    reduce the data loss window.
</span>ストリーミングレプリケーションはデフォルトで非同期で、(<a class="xref" href="warm-standby.html#synchronous-replication" title="25.2.8. 同期レプリケーション">25.2.8. 同期レプリケーション</a>参照)
この場合、プライマリでトランザクションがコミットされてから、その変更がスタンバイ側で参照可能になるまでの間にわずかな遅延がまだあります。
しかし、この遅延はファイルベースのログシッピングよりも非常に小さなもので、負荷に追随できる程度の能力があるスタンバイであれば通常は1秒以下です。
ストリーミングレプリケーションでは、データ損失期間を減らすための<code class="varname">archive_timeout</code>を必要としません。
   </p><p><span class="original">
    If you use streaming replication without file-based continuous
    archiving, the server might recycle old WAL segments before the standby
    has received them.  If this occurs, the standby will need to be
    reinitialized from a new base backup.  You can avoid this by setting
    &lt;varname&gt;wal_keep_segments&lt;/&gt; to a value large enough to ensure that
    WAL segments are not recycled too early, or by configuring a replication
    slot for the standby.  If you set up a WAL archive that's accessible from
    the standby, these solutions are not required, since the standby can
    always use the archive to catch up provided it retains enough segments.
</span>ファイルベースの継続的アーカイブのないストリーミングレプリケーションを使用している場合、スタンバイが受け取る前に古いWALセグメントを再利用するかもしれません。
もし、そうなった場合はスタンバイは新しいベースバックアップから再作成しなければならなくなります。
<code class="varname">wal_keep_segments</code>を十分に大きくしたり、レプリケーションスロットにスタンバイを設定することでWALセグメントがすぐに再利用されることを防ぎ、これを防ぐことができます。WALアーカイブをスタンバイからアクセスできる位置に設定する場合は、スタンバイが常にWALセグメントを追随することができるため、これらの解決策は要求されません。
   </p><p><span class="original">
    To use streaming replication, set up a file-based log-shipping standby
    server as described in &lt;xref linkend="warm-standby"&gt;. The step that
    turns a file-based log-shipping standby into streaming replication
    standby is setting &lt;varname&gt;primary_conninfo&lt;/&gt; setting in the
    &lt;filename&gt;recovery.conf&lt;/&gt; file to point to the primary server. Set
    &lt;xref linkend="guc-listen-addresses"&gt; and authentication options
    (see &lt;filename&gt;pg_hba.conf&lt;/&gt;) on the primary so that the standby server
    can connect to the &lt;literal&gt;replication&lt;/&gt; pseudo-database on the primary
    server (see &lt;xref linkend="streaming-replication-authentication"&gt;).
</span>ストリーミングレプリケーションを使用するためには、<a class="xref" href="warm-standby.html" title="25.2. ログシッピングスタンバイサーバ">25.2. ログシッピングスタンバイサーバ</a>の説明のようにファイルベースのログシッピングを行うスタンバイサーバを設定してください。
ファイルベースのログシッピングを行うスタンバイをストリーミングレプリケーションを行うスタンバイに切り替える手順は、<code class="filename">recovery.conf</code>内の<code class="varname">primary_conninfo</code>設定をプライマリサーバを指し示すように設定することです。
スタンバイサーバがプライマリサーバ上の<code class="literal">replication</code>疑似データベースに接続できる(<a class="xref" href="warm-standby.html#streaming-replication-authentication" title="25.2.5.1. 認証">25.2.5.1. 認証</a>参照)ように、プライマリで<a class="xref" href="runtime-config-connection.html#guc-listen-addresses">listen_addresses</a>と認証オプション(<code class="filename">pg_hba.conf</code>参照)を設定してください。
   </p><p><span class="original">
    On systems that support the keepalive socket option, setting
    &lt;xref linkend="guc-tcp-keepalives-idle"&gt;,
    &lt;xref linkend="guc-tcp-keepalives-interval"&gt; and
    &lt;xref linkend="guc-tcp-keepalives-count"&gt; helps the primary promptly
    notice a broken connection.
</span>キープアライブソケットオプションをサポートするシステムでは、<a class="xref" href="runtime-config-connection.html#guc-tcp-keepalives-idle">tcp_keepalives_idle</a>、<a class="xref" href="runtime-config-connection.html#guc-tcp-keepalives-interval">tcp_keepalives_interval</a>および<a class="xref" href="runtime-config-connection.html#guc-tcp-keepalives-count">tcp_keepalives_count</a>を設定することで、プライマリの接続切断の即時検知に有用です。
   </p><p><span class="original">
    Set the maximum number of concurrent connections from the standby servers
    (see &lt;xref linkend="guc-max-wal-senders"&gt; for details).
</span>スタンバイサーバからの同時接続数の最大値を設定してください（詳細は<a class="xref" href="runtime-config-replication.html#guc-max-wal-senders">max_wal_senders</a>を参照）。
   </p><p><span class="original">
    When the standby is started and &lt;varname&gt;primary_conninfo&lt;/&gt; is set
    correctly, the standby will connect to the primary after replaying all
    WAL files available in the archive. If the connection is established
    successfully, you will see a walreceiver process in the standby, and
    a corresponding walsender process in the primary.
</span>スタンバイが起動し、<code class="varname">primary_conninfo</code>が正しく設定されると、スタンバイはアーカイブ内で利用可能なWALファイルをすべて再生した後にプライマリと接続します。
接続の確立に成功すると、スタンバイでWAL受信プロセスが存在し、プライマリで対応するWAL送信プロセスが存在します。
   </p><div class="sect3" id="streaming-replication-authentication"><div class="titlepage"><div><div><h4 class="title">25.2.5.1. 認証</h4></div></div></div><span class="original">
    &lt;title&gt;Authentication&lt;/title&gt;
</span><p><span class="original">
     It is very important that the access privileges for replication be set up
     so that only trusted users can read the WAL stream, because it is
     easy to extract privileged information from it.  Standby servers must
     authenticate to the primary as a superuser or an account that has the
     &lt;literal&gt;REPLICATION&lt;/&gt; privilege. It is recommended to create a
     dedicated user account with &lt;literal&gt;REPLICATION&lt;/&gt; and &lt;literal&gt;LOGIN&lt;/&gt;
     privileges for replication. While &lt;literal&gt;REPLICATION&lt;/&gt; privilege gives
     very high permissions, it does not allow the user to modify any data on
     the primary system, which the &lt;literal&gt;SUPERUSER&lt;/&gt; privilege does.
</span>信頼できるユーザのみがWALストリームを読み取ることができるように、レプリケーション用のアクセス権限を設定することは非常に重要です。
WALから機密情報を取り出すことは簡単だからです。
スタンバイサーバはプライマリに対してプライマリのスーパーユーザか<code class="literal">REPLICATION</code>権限を持つアカウントとして認証されなければなりません。
レプリケーションのための<code class="literal">REPLICATION</code>権限 と <code class="literal">LOGIN</code>権限を持つ専用のユーザを作成することをお勧めします。
<code class="literal">REPLICATION</code>権限は非常に強力な権限なので、<code class="literal">SUPERUSER</code>のようにプライマリのデータを変更することを許可されていません。
    </p><p><span class="original">
     Client authentication for replication is controlled by a
     &lt;filename&gt;pg_hba.conf&lt;/&gt; record specifying &lt;literal&gt;replication&lt;/&gt; in the
     &lt;replaceable&gt;database&lt;/&gt; field. For example, if the standby is running on
     host IP &lt;literal&gt;192.168.1.100&lt;/&gt; and the account name for replication
     is &lt;literal&gt;foo&lt;/&gt;, the administrator can add the following line to the
     &lt;filename&gt;pg_hba.conf&lt;/&gt; file on the primary:
</span>レプリケーション用のクライアント認証は<code class="filename">pg_hba.conf</code>内でその<em class="replaceable"><code>database</code></em>フィールドに<code class="literal">replication</code>を指定したレコードで制御されます。
例えば、スタンバイがIPアドレス<code class="literal">192.168.1.100</code>のホストで稼動し、レプリケーション用のアカウントの名前が<code class="literal">foo</code>である場合、管理者はプライマリ上の<code class="filename">pg_hba.conf</code>に以下の行を追加することができます。

</p><pre class="programlisting"><span class="original">
# Allow the user "foo" from host 192.168.1.100 to connect to the primary
# as a replication standby if the user's password is correctly supplied.
</span># 利用者 foo のホスト 192.168.1.100 からプライマリサーバへのレプリケーションスタンバイとしての接続を
# 利用者のパスワードが正しく入力されたならば許可する
#
# TYPE  DATABASE        USER            ADDRESS                 METHOD
host    replication     foo             192.168.1.100/32        md5</pre><p>
    </p><p><span class="original">
     The host name and port number of the primary, connection user name,
     and password are specified in the &lt;filename&gt;recovery.conf&lt;/&gt; file.
     The password can also be set in the &lt;filename&gt;~/.pgpass&lt;/&gt; file on the
     standby (specify &lt;literal&gt;replication&lt;/&gt; in the &lt;replaceable&gt;database&lt;/&gt;
     field).
     For example, if the primary is running on host IP &lt;literal&gt;192.168.1.50&lt;/&gt;,
     port &lt;literal&gt;5432&lt;/literal&gt;, the account name for replication is
     &lt;literal&gt;foo&lt;/&gt;, and the password is &lt;literal&gt;foopass&lt;/&gt;, the administrator
     can add the following line to the &lt;filename&gt;recovery.conf&lt;/&gt; file on the
     standby:
</span>プライマリサーバのホスト名とポート番号、接続する利用者名およびパスワードは、<code class="filename">recovery.conf</code>ファイルで指定します。
パスワードはスタンバイサーバの<code class="filename">~/.pgpass</code>ファイルでも設定できます（<em class="replaceable"><code>database</code></em>フィールドの<code class="literal">replication</code>を指定します）。
例えば、プライマリサーバが稼動するホストの IP アドレスが<code class="literal">192.168.1.50</code>でポート番号が<code class="literal">5432</code>であり、レプリケーションのアカウント名が<code class="literal">foo</code>であり、パスワードが<code class="literal">foopass</code>である場合、管理者はスタンバイサーバの<code class="filename">recovery.conf</code>ファイルに次行を追加できます。

</p><pre class="programlisting"><span class="original">
# The standby connects to the primary that is running on host 192.168.1.50
# and port 5432 as the user "foo" whose password is "foopass".
</span># プライマリサーバが 192.168.1.50 のホストの 5432ポートで稼動し
# 利用者名が foo でパスワードが foopass とする
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'</pre><p>
    </p></div><div class="sect3" id="streaming-replication-monitoring"><div class="titlepage"><div><div><h4 class="title">25.2.5.2. 監視</h4></div></div></div><span class="original">
    &lt;title&gt;Monitoring&lt;/title&gt;
</span><p><span class="original">
     An important health indicator of streaming replication is the amount
     of WAL records generated in the primary, but not yet applied in the
     standby. You can calculate this lag by comparing the current WAL write
     location on the primary with the last WAL location received by the
     standby. They can be retrieved using
     &lt;function&gt;pg_current_xlog_location&lt;/&gt; on the primary and the
     &lt;function&gt;pg_last_xlog_receive_location&lt;/&gt; on the standby,
     respectively (see &lt;xref linkend="functions-admin-backup-table"&gt; and
     &lt;xref linkend="functions-recovery-info-table"&gt; for details).
     The last WAL receive location in the standby is also displayed in the
     process status of the WAL receiver process, displayed using the
     &lt;command&gt;ps&lt;/&gt; command (see &lt;xref linkend="monitoring-ps"&gt; for details).
</span>ストリーミングレプリケーションの重要な健全性尺度は、プライマリサーバで生成されたがスタンバイサーバではまだ適用されていないWALレコードの量です。
プライマリサーバの現在のWAL書き込み位置とスタンバイサーバの受理したWALの最終位置を比較すれば、この遅延を計算できます。
これらの位置は、プライマリサーバでは<code class="function">pg_current_xlog_location</code>を、スタンバイサーバでは<code class="function">pg_last_xlog_receive_location</code>を使用すれば検索できます（詳細は<a class="xref" href="functions-admin.html#functions-admin-backup-table" title="表9.68 バックアップ制御関数">表9.68「バックアップ制御関数」</a>および<a class="xref" href="functions-admin.html#functions-recovery-info-table" title="表9.69 リカバリ情報関数">表9.69「リカバリ情報関数」</a>を参照）。
スタンバイサーバの最終位置は、<code class="command">ps</code>コマンドを使用して WAL受信プロセスの状態としても表示できます（詳細は<a class="xref" href="monitoring-ps.html" title="27.1. 標準的なUnixツール">27.1. 標準的なUnixツール</a>を参照）。
    </p><p><span class="original">
     You can retrieve a list of WAL sender processes via the
     &lt;link linkend="monitoring-stats-views-table"&gt;
     &lt;literal&gt;pg_stat_replication&lt;/&gt;&lt;/link&gt; view. Large differences between
     &lt;function&gt;pg_current_xlog_location&lt;/&gt; and &lt;literal&gt;sent_location&lt;/&gt; field
     might indicate that the master server is under heavy load, while
     differences between &lt;literal&gt;sent_location&lt;/&gt; and
     &lt;function&gt;pg_last_xlog_receive_location&lt;/&gt; on the standby might indicate
     network delay, or that the standby is under heavy load.
</span><a class="link" href="monitoring-stats.html#monitoring-stats-views-table" title="表27.2 収集済み統計情報ビュー"><code class="literal">pg_stat_replication</code></a>ビューを介してWAL送信処理プロセスのリストを入手することができます。
<code class="function">pg_current_xlog_location</code>と<code class="literal">sent_location</code>フィールドとの違いが大きい場合、マスタサーバが高負荷状態であることを示している可能性があります。
一方でスタンバイサーバ上の<code class="literal">sent_location</code>と<code class="function">pg_last_xlog_receive_location</code>の値の差異は、ネットワーク遅延、またはスタンバイが高負荷状態であることを示す可能性があります。
    </p></div></div><div class="sect2" id="streaming-replication-slots"><div class="titlepage"><div><div><h3 class="title">25.2.6. レプリケーションスロット</h3></div></div></div><span class="original">
   &lt;title&gt;Replication Slots&lt;/title&gt;
</span><a id="idp77976544" class="indexterm"></a><p><span class="original">
    Replication slots provide an automated way to ensure that the master does
    not remove WAL segments until they have been received by all standbys,
    and that the master does not remove rows which could cause a
    &lt;link linkend="hot-standby-conflict"&gt;recovery conflict&lt;/&gt; even when the
    standby is disconnected.
</span>レプリケーションスロットはマスターが全てのスタンバイがWALセグメントを受け取るまで削除を防止したり、たとえ、スタンバイが接続していなくとも、マスターが行を削除してしまう<a class="link" href="hot-standby.html#hot-standby-conflict" title="25.5.2. 問い合わせコンフリクトの処理">リカバリの競合</a>を自動的に防ぐ機能を提供します。
   </p><p><span class="original">
    In lieu of using replication slots, it is possible to prevent the removal
    of old WAL segments using &lt;xref linkend="guc-wal-keep-segments"&gt;, or by
    storing the segments in an archive using
    &lt;xref linkend="guc-archive-command"&gt;.
    However, these methods often result in retaining more WAL segments than
    required, whereas replication slots retain only the number of segments
    known to be needed.  An advantage of these methods is that they bound
    the space requirement for &lt;literal&gt;pg_xlog&lt;/&gt;; there is currently no way
    to do this using replication slots.
</span>レプリケーションスロットを使用しない場合、古いWALセグメントの削除を防ぐためには、<a class="xref" href="runtime-config-replication.html#guc-wal-keep-segments">wal_keep_segments</a>を使用するか、アーカイブ<a class="xref" href="runtime-config-wal.html#guc-archive-command">archive_command</a>を使用します。
しかし、これらの方法は要求される以上のWALを残すことに対し、レプリケーションスロットは必要と判断されたWALのみを残します。
これらの方法のメリットは<code class="literal">pg_xlog</code>が要求する領域を抑制することです。現時点でレプリケーションスロットを使用する他の目的はありません。
   </p><p><span class="original">
    Similarly, &lt;xref linkend="guc-hot-standby-feedback"&gt;
    and &lt;xref linkend="guc-vacuum-defer-cleanup-age"&gt; provide protection against
    relevant rows being removed by vacuum, but the former provides no
    protection during any time period when the standby is not connected,
    and the latter often needs to be set to a high value to provide adequate
    protection.  Replication slots overcome these disadvantages.
</span>同様に、<a class="xref" href="runtime-config-replication.html#guc-hot-standby-feedback">hot_standby_feedback</a>と<a class="xref" href="runtime-config-replication.html#guc-vacuum-defer-cleanup-age">vacuum_defer_cleanup_age</a>はまだ使用する行がvacuumにより削除されることを防ぐ機能を提供しますが、スタンバイが接続されていない時間の行は保護出来ず、十分に保護するために高い値を設定することがしばしばあります。レプリケーションスロットにはこのような短所がありません。
   </p><div class="sect3" id="streaming-replication-slots-manipulation"><div class="titlepage"><div><div><h4 class="title">25.2.6.1. レプリケーションスロットへの問い合わせと操作</h4></div></div></div><span class="original">
    &lt;title&gt;Querying and manipulating replication slots&lt;/title&gt;
</span><p><span class="original">
     Each replication slot has a name, which can contain lower-case letters,
     numbers, and the underscore character.
</span>いずれのレプリケーションスロットにも小文字、数字、アンダースコアを含む名前があります。
    </p><p><span class="original">
     Existing replication slots and their state can be seen in the
     &lt;link linkend="view-pg-replication-slots"&gt;&lt;structname&gt;pg_replication_slots&lt;/structname&gt;&lt;/link&gt;
     view.
</span>レプリケーションスロットとその状態は<a class="link" href="view-pg-replication-slots.html" title="49.69. pg_replication_slots"><code class="structname">pg_replication_slots</code></a>
ビューより確認できます。
    </p><p><span class="original">
     Slots can be created and dropped either via the streaming replication
     protocol (see &lt;xref linkend="protocol-replication"&gt;) or via SQL
     functions (see &lt;xref linkend="functions-replication"&gt;).
</span>レプリケーションスロットはストリーミングレプリケーションプロトコル( <a class="xref" href="protocol-replication.html" title="50.3. ストリーミングレプリケーションプロトコル">50.3. ストリーミングレプリケーションプロトコル</a>参照)もしくはSQLファンクション(<a class="xref" href="functions-admin.html#functions-replication" title="9.26.6. レプリケーション関数">9.26.6. レプリケーション関数</a>参照)を使用し、作成や削除ができます。
    </p></div><div class="sect3" id="streaming-replication-slots-config"><div class="titlepage"><div><div><h4 class="title">25.2.6.2. 設定の例</h4></div></div></div><span class="original">
    &lt;title&gt;Configuration Example&lt;/title&gt;
</span><p><span class="original">
     You can create a replication slot like this:
</span>以下のような方法でレプリケーションスロットを作成できます。
</p><pre class="programlisting">postgres=# SELECT * FROM pg_create_physical_replication_slot('node_a_slot');
  slot_name  | xlog_position
-------------+---------------
 node_a_slot |

postgres=# SELECT * FROM pg_replication_slots;
  slot_name  | slot_type | datoid | database | active | xmin | restart_lsn
-------------+-----------+--------+----------+--------+------+-------------
 node_a_slot | physical  |        |          | f      |      |
(1 row)</pre><p><span class="original">
     To configure the standby to use this slot, &lt;varname&gt;primary_slot_name&lt;/&gt;
     should be configured in the standby's &lt;filename&gt;recovery.conf&lt;/&gt;.
     Here is a simple example:
</span>
スタンバイのレプリケーションスロットを使用できるように設定するためには、<code class="varname">primary_slot_name</code>をスタンバイ側の<code class="filename">recovery.conf</code>に設定します。
以下は設定例です。：
</p><pre class="programlisting">standby_mode = 'on'
primary_conninfo = 'host=192.168.1.50 port=5432 user=foo password=foopass'
primary_slot_name = 'node_a_slot'</pre><p>
    </p></div></div><div class="sect2" id="cascading-replication"><div class="titlepage"><div><div><h3 class="title">25.2.7. カスケードレプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Cascading Replication&lt;/title&gt;
</span><a id="idp77999120" class="indexterm"></a><p><span class="original">
    The cascading replication feature allows a standby server to accept replication
    connections and stream WAL records to other standbys, acting as a relay.
    This can be used to reduce the number of direct connections to the master
    and also to minimize inter-site bandwidth overheads.
</span>カスケードレプリケーションは、リレーのような振る舞い、つまり、スタンバイサーバから他のスタンバイにレプリケーション接続し、WALレコードを送信することができます。
マスターサーバへ直接の接続を減らしたり、サイト相互の帯域オーバヘッドを最小化するために使用することができます。
   </p><p><span class="original">
    A standby acting as both a receiver and a sender is known as a cascading
    standby.  Standbys that are more directly connected to the master are known
    as upstream servers, while those standby servers further away are downstream
    servers.  Cascading replication does not place limits on the number or
    arrangement of downstream servers, though each standby connects to only
    one upstream server which eventually links to a single master/primary
    server.
</span>カスケードスタンバイとして知られているとおり、スタンバイは受け取り手としても送り手としても振る舞うことができます。
よりマスターサーバに近いスタンバイサーバは上流サーバと呼ばれるのに対し、より遠いスタンバイサーバは下流サーバと呼ばれます。
カスケードレプリケーションには下流サーバの数に制限は設定されていません。しかし、どのスタンバイサーバも最終的には1つのマスター/プライマリサーバに繋がる1つの上流サーバに接続します。
   </p><p><span class="original">
    A cascading standby sends not only WAL records received from the
    master but also those restored from the archive. So even if the replication
    connection in some upstream connection is terminated, streaming replication
    continues downstream for as long as new WAL records are available.
</span>カスケードスタンバイはマスターから受け取ったWALレコードだけでなく、アーカイブからリストアしたWALアーカイブも送信します。
このため、レプリケーション接続が上流サーバで切断しても、ストリーミングレプリケーションは下流サーバへ新しいWAL
レコードがある限り継続します。
   </p><p><span class="original">
    Cascading replication is currently asynchronous. Synchronous replication
    (see &lt;xref linkend="synchronous-replication"&gt;) settings have no effect on
    cascading replication at present.
</span>カスケードレプリケーションは現時点では非同期です。同期レプリケーション（参照<a class="xref" href="warm-standby.html#synchronous-replication" title="25.2.8. 同期レプリケーション">25.2.8. 同期レプリケーション</a>）の設定は現時点でカスケードレプリケーションへは影響を与えません。
   </p><p><span class="original">
    Hot Standby feedback propagates upstream, whatever the cascaded arrangement.
</span>ホットスタンバイがどの様に配置されていても、ホットスタンバイフィードバックは上流に伝播します。
   </p><p><span class="original">
    If an upstream standby server is promoted to become new master, downstream
    servers will continue to stream from the new master if
    &lt;varname&gt;recovery_target_timeline&lt;/&gt; is set to &lt;literal&gt;'latest'&lt;/&gt;.
</span>上流スタンバイサーバが昇格し、新しいマスターサーバになった場合、<code class="varname">recovery_target_timeline</code>が<code class="literal">'latest'</code>に設定されていれば、下流サーバは新マスターサーバからのストリーミングレプリケーションを継続します。
   </p><p><span class="original">
    To use cascading replication, set up the cascading standby so that it can
    accept replication connections (that is, set
    &lt;xref linkend="guc-max-wal-senders"&gt; and &lt;xref linkend="guc-hot-standby"&gt;,
    and configure
    &lt;link linkend="auth-pg-hba-conf"&gt;host-based authentication&lt;/link&gt;).
    You will also need to set &lt;varname&gt;primary_conninfo&lt;/&gt; in the downstream
    standby to point to the cascading standby.
</span>カスケードレプリケーションを使うためには、カスケードスタンバイをセットアップ、つまり、レプリケーション接続を許可してください。(<a class="xref" href="runtime-config-replication.html#guc-max-wal-senders">max_wal_senders</a>と<a class="xref" href="runtime-config-replication.html#guc-hot-standby">hot_standby</a>および、 <a class="link" href="auth-pg-hba-conf.html" title="19.1. pg_hba.confファイル">クライアント認証</a>を設定してください)
また、下流スタンバイがカスケードスタンバイに接続できるために、下流スタンバイでは<code class="varname">primary_conninfo</code>を設定する必要があります。
   </p></div><div class="sect2" id="synchronous-replication"><div class="titlepage"><div><div><h3 class="title">25.2.8. 同期レプリケーション</h3></div></div></div><span class="original">
   &lt;title&gt;Synchronous Replication&lt;/title&gt;
</span><a id="idp78014688" class="indexterm"></a><p><span class="original">
    &lt;productname&gt;PostgreSQL&lt;/&gt; streaming replication is asynchronous by
    default. If the primary server
    crashes then some transactions that were committed may not have been
    replicated to the standby server, causing data loss. The amount
    of data loss is proportional to the replication delay at the time of
    failover.
</span><span class="productname">PostgreSQL</span>のストリーミングレプリケーションはデフォルトで非同期です。
プライマリサーバがクラッシュした場合、コミットされた一部のトランザクションがスタンバイサーバに複製されず、データ損失を引き起こす可能性があります。
データ損失量はフェールオーバ時点のレプリケーション遅延に比例します。
   </p><p><span class="original">
    Synchronous replication offers the ability to confirm that all changes
    made by a transaction have been transferred to one synchronous standby
    server. This extends the standard level of durability
    offered by a transaction commit. This level of protection is referred
    to as 2-safe replication in computer science theory.
</span>同期レプリケーションは、あるトランザクションでなされた変更はすべて、１つの同期スタンバイサーバに転送されていることを確実にする機能を提供します。
これはトランザクションコミットで提供される永続性の標準レベルを拡張します。
この保護レベルはコンピュータ科学理論では2-safeレプリケーションと呼ばれます。
   </p><p><span class="original">
    When requesting synchronous replication, each commit of a
    write transaction will wait until confirmation is
    received that the commit has been written to the transaction log on disk
    of both the primary and standby server. The only possibility that data
    can be lost is if both the primary and the standby suffer crashes at the
    same time. This can provide a much higher level of durability, though only
    if the sysadmin is cautious about the placement and management of the two
    servers.  Waiting for confirmation increases the user's confidence that the
    changes will not be lost in the event of server crashes but it also
    necessarily increases the response time for the requesting transaction.
    The minimum wait time is the roundtrip time between primary to standby.
</span>同期レプリケーションを要求する時、書き込みトランザクションのコミットはそれぞれ、そのコミットがプライマリサーバおよびスタンバイサーバの両方で、ディスク上のトランザクションログに書き込まれたという確認を受けとるまで待機します。
データ損失が起こる可能性は、プライマリサーバとスタンバイサーバが同時にクラッシュしてしまった場合のみです。
これは非常に高い永続性を提供することができますが、それはシステム管理者が２つのサーバの設置と管理に関して注意を払っている場合のみです。
確認のための待機は、サーバがクラッシュした場合でも変更が失われないということでユーザからの信頼性が大きくなりますが、同時に要求するトランザクションの応答時間も必ず大きくなります。
最小待機時間はプライマリとスタンバイの間の往復遅延時間です。
   </p><p><span class="original">
    Read only transactions and transaction rollbacks need not wait for
    replies from standby servers. Subtransaction commits do not wait for
    responses from standby servers, only top-level commits. Long
    running actions such as data loading or index building do not wait
    until the very final commit message. All two-phase commit actions
    require commit waits, including both prepare and commit.
</span>読み取り専用のトランザクションおよびトランザクションのロールバックはスタンバイサーバからの応答を待つ必要はありません。
副トランザクションのコミットもスタンバイサーバからの応答を待つことはなく、最上位レベルのコミットのみ待機します。
データロード処理やインデックス構築など長時間実行される操作は、最終コミットメッセージまで待機しません。
準備およびコミットの両方を含め、二相コミット動作はすべてコミット待機を必要とします。
   </p><div class="sect3" id="synchronous-replication-config"><div class="titlepage"><div><div><h4 class="title">25.2.8.1. 基本設定</h4></div></div></div><span class="original">
    &lt;title&gt;Basic Configuration&lt;/title&gt;
</span><p><span class="original">
    Once streaming replication has been configured, configuring synchronous
    replication requires only one additional configuration step:
    &lt;xref linkend="guc-synchronous-standby-names"&gt; must be set to
    a non-empty value.  &lt;varname&gt;synchronous_commit&lt;/&gt; must also be set to
    &lt;literal&gt;on&lt;/&gt;, but since this is the default value, typically no change is
    required.  (See &lt;xref linkend="runtime-config-wal-settings"&gt; and
    &lt;xref linkend="runtime-config-replication-master"&gt;.)
    This configuration will cause each commit to wait for
    confirmation that the standby has written the commit record to durable
    storage.
    &lt;varname&gt;synchronous_commit&lt;/&gt; can be set by individual
    users, so it can be configured in the configuration file, for particular
    users or databases, or dynamically by applications, in order to control
    the durability guarantee on a per-transaction basis.
</span>一度、ストリーミングレプリケーションが設定されている場合、同期レプリケーションの設定には必要な追加設定は１つだけ：<a class="xref" href="runtime-config-replication.html#guc-synchronous-standby-names">synchronous_standby_names</a>を空でない値に設定することです。
また<code class="varname">synchronous_commit</code>は<code class="literal">on</code>に設定されていなければなりませんが、これはデフォルト値ですので、通常は変更する必要はありません。(<a class="xref" href="runtime-config-wal.html#runtime-config-wal-settings" title="18.5.1. 諸設定">18.5.1. 諸設定</a> および<a class="xref" href="runtime-config-replication.html#runtime-config-replication-master" title="18.6.2. マスターサーバ">18.6.2. マスターサーバ</a>を参照してください)
この設定によりスタンバイがそのコミットレコードを信頼できるストレージに書き込んだことが確認できるまで、各コミットが待たされるようになります。
<code class="varname">synchronous_commit</code>は個々のユーザによって設定することができます。
このため、トランザクション単位を基準とした永続性の保証を制御するために、設定ファイルの中で特定のユーザまたはデータベースについて設定することも、アプリケーションによって動的に設定することもできます。
   </p><p><span class="original">
    After a commit record has been written to disk on the primary, the
    WAL record is then sent to the standby. The standby sends reply
    messages each time a new batch of WAL data is written to disk, unless
    &lt;varname&gt;wal_receiver_status_interval&lt;/&gt; is set to zero on the standby.
    If the standby is the first matching standby, as specified in
    &lt;varname&gt;synchronous_standby_names&lt;/&gt; on the primary, the reply
    messages from that standby will be used to wake users waiting for
    confirmation that the commit record has been received. These parameters
    allow the administrator to specify which standby servers should be
    synchronous standbys. Note that the configuration of synchronous
    replication is mainly on the master. Named standbys must be directly
    connected to the master; the master knows nothing about downstream
    standby servers using cascaded replication.
</span>コミットレコードがプライマリ上のディスクに書き出された後、WALレコードがスタンバイに送信されます。
スタンバイにて<code class="varname">wal_receiver_status_interval</code>がゼロに設定されていない限り、スタンバイは新しいWALデータのバッチがディスクに書き出す度にメッセージを返します。
スタンバイが、プライマリ上の<code class="varname">synchronous_standby_names</code>で指定したものと最初に一致するスタンバイである場合、そのスタンバイからの応答メッセージがコミットレコードの受領を確認するまでの待機を解除するために使用されます。
これらのパラメータにより管理者はどのスタンバイサーバが同期スタンバイとすべきかを指定することができます。
同期レプリケーションの設定は主にマスタでなされることに注意してください。
指名されたスタンバイは直接マスターサーバに接続される必要があります。つまり、マスターサーバは下流サーバがカスケードレプリケーションで使用されているかについて何も知りません。
   </p><p><span class="original">
    Setting &lt;varname&gt;synchronous_commit&lt;/&gt; to &lt;literal&gt;remote_write&lt;/&gt; will
    cause each commit to wait for confirmation that the standby has received
    the commit record and written it out to its own operating system, but not
    for the data to be flushed to disk on the standby.  This
    setting provides a weaker guarantee of durability than &lt;literal&gt;on&lt;/&gt;
    does: the standby could lose the data in the event of an operating system
    crash, though not a &lt;productname&gt;PostgreSQL&lt;/&gt; crash.
    However, it's a useful setting in practice
    because it can decrease the response time for the transaction.
    Data loss could only occur if both the primary and the standby crash and
    the database of the primary gets corrupted at the same time.
</span><code class="varname">synchronous_commit</code>を<code class="literal">remote_write</code>に設定することで、スタンバイサーバはコミットされたレコードをスタンバイサーバがメモリ上に受け取ったことを確認するまでコミットを待つようになります。しかし、これはスタンバイサーバのディスクへ書きこまれたことを待つわけではありません。
これは、<code class="literal">on</code>と設定するより、提供される永続性は弱くなります。具体的には、スタンバイサーバは(<span class="productname">PostgreSQL</span> ではなく)オペレーティングシステムがクラッシュした場合にデータを失う可能性があります。
しかし、この設定はトランザクションの応答時間を短くすることができます。データの損失は、プライマリサーバとスタンバイサーバが同時にクラッシュし、かつ、プライマリのデータベースが同時に壊れた場合にのみ発生します。
   </p><p><span class="original">
    Users will stop waiting if a fast shutdown is requested.  However, as
    when using asynchronous replication, the server will not fully
    shutdown until all outstanding WAL records are transferred to the currently
    connected standby servers.
</span>高速シャットダウンが要求された場合、ユーザは待機を停止します。
しかし非同期レプリケーションを使用している時、送信中のWALレコードが現在接続しているスタンバイサーバに転送されるまで、サーバは完全に停止しません。
   </p></div><div class="sect3" id="synchronous-replication-performance"><div class="titlepage"><div><div><h4 class="title">25.2.8.2. 性能に関する考慮</h4></div></div></div><span class="original">
    &lt;title&gt;Planning for Performance&lt;/title&gt;
</span><p><span class="original">
    Synchronous replication usually requires carefully planned and placed
    standby servers to ensure applications perform acceptably. Waiting
    doesn't utilize system resources, but transaction locks continue to be
    held until the transfer is confirmed. As a result, incautious use of
    synchronous replication will reduce performance for database
    applications because of increased response times and higher contention.
</span>通常、同期レプリケーションは、アプリケーションが満足できる程度に実行されることを確実にするために、注意深くスタンバイサーバを計画し設置しなければなりません。
待機のためにシステムリソースを使用することはありませんが、トランザクションロックは転送が確認されるまで継続して保持されます。
結果として同期レプリケーションを注意せずに使用すると、応答時間が増加する、および競合がより高くなるため、データベースアプリケーションの性能は低下します。
   </p><p><span class="original">
    &lt;productname&gt;PostgreSQL&lt;/&gt; allows the application developer
    to specify the durability level required via replication. This can be
    specified for the system overall, though it can also be specified for
    specific users or connections, or even individual transactions.
</span><span class="productname">PostgreSQL</span>ではアプリケーション開発者がレプリケーション経由で必要とする永続性レベルを指定することができます。
これをシステム全体に対して指定することができますし、特定のユーザ、接続、個々のトランザクションに対してさえ指定することもできます。
   </p><p><span class="original">
    For example, an application workload might consist of:
    10% of changes are important customer details, while
    90% of changes are less important data that the business can more
    easily survive if it is lost, such as chat messages between users.
</span>例えばアプリケーションの作業量が、重要な顧客詳細の変更が10%、ユーザ間のチャットメッセージなど、あまり重要ではなく、失ったとしても業務をより簡単に戻すことができるようなデータの変更が90% という構成を考えてみます。
   </p><p><span class="original">
    With synchronous replication options specified at the application level
    (on the primary) we can offer synchronous replication for the most
    important changes, without slowing down the bulk of the total workload.
    Application level options are an important and practical tool for allowing
    the benefits of synchronous replication for high performance applications.
</span>（プライマリ上で）アプリケーションレベルで指定する同期レプリケーションオプションを使用して、作業全体を低速化させることなく、最も重要な変更に対して同期レプリケーションを企てることができます。
アプリケーションレベルのオプションは、高い性能が求められるアプリケーションで同期レプリケーションの利点が得られる、重要かつ現実的な手段です。
   </p><p><span class="original">
    You should consider that the network bandwidth must be higher than
    the rate of generation of WAL data.
</span>生成されるWALデータの割合よりネットワーク帯域幅が大きくなければならないことを考慮しなければなりません。
   </p></div><div class="sect3" id="synchronous-replication-ha"><div class="titlepage"><div><div><h4 class="title">25.2.8.3. 高可用性に関する検討</h4></div></div></div><span class="original">
    &lt;title&gt;Planning for High Availability&lt;/title&gt;
</span><p><span class="original">
    Commits made when &lt;varname&gt;synchronous_commit&lt;/&gt; is set to &lt;literal&gt;on&lt;/&gt;
    or &lt;literal&gt;remote_write&lt;/&gt; will wait until the synchronous standby responds. The response
    may never occur if the last, or only, standby should crash.
</span><code class="varname">synchronous_commit</code>が<code class="literal">on</code>もしくは<code class="literal">remote_write</code>に設定された場合、なされたコミットは同期スタンバイの応答まで待機されます。
応答は最後のまたは唯一のスタンバイがクラッシュした場合には決して返されません。
   </p><p><span class="original">
    The best solution for avoiding data loss is to ensure you don't lose
    your last remaining synchronous standby. This can be achieved by naming multiple
    potential synchronous standbys using &lt;varname&gt;synchronous_standby_names&lt;/&gt;.
    The first named standby will be used as the synchronous standby. Standbys
    listed after this will take over the role of synchronous standby if the
    first one should fail.
</span>データ損失を防止するための最善の解法は、最後に残る同期スタンバイを失わないことを確実にすることです。
<code class="varname">synchronous_standby_names</code>を使用して複数の潜在的な同期スタンバイを指名することで実現することができます。
最初に指名されたスタンバイは同期スタンバイとして使用されます。
この後に列挙されたスタンバイは、最初のスタンバイが失敗した場合に同期スタンバイの役割を引き継ぎます。
   </p><p><span class="original">
    When a standby first attaches to the primary, it will not yet be properly
    synchronized. This is described as &lt;literal&gt;catchup&lt;/&gt; mode. Once
    the lag between standby and primary reaches zero for the first time
    we move to real-time &lt;literal&gt;streaming&lt;/&gt; state.
    The catch-up duration may be long immediately after the standby has
    been created. If the standby is shut down, then the catch-up period
    will increase according to the length of time the standby has been down.
    The standby is only able to become a synchronous standby
    once it has reached &lt;literal&gt;streaming&lt;/&gt; state.
</span>スタンバイが最初にプライマリに付与された時、それはまだ適切に同期されていません。
これは<code class="literal">catchup</code>モードと呼ばれます。
最初にスタンバイとプライマリ間の遅延がゼロになった時に、実時間<code class="literal">streaming</code>状態に移ります。
追従（catchup）期間はスタンバイが作成された直後は長くなるかもしれません。
スタンバイが停止している場合、追従期間はスタンバイの停止期間にしたがって長くなります。
スタンバイは、<code class="literal">streaming</code>状態に達した後でのみ、同期スタンバイになることができます。
   </p><p><span class="original">
    If primary restarts while commits are waiting for acknowledgement, those
    waiting transactions will be marked fully committed once the primary
    database recovers.
    There is no way to be certain that all standbys have received all
    outstanding WAL data at time of the crash of the primary. Some
    transactions may not show as committed on the standby, even though
    they show as committed on the primary. The guarantee we offer is that
    the application will not receive explicit acknowledgement of the
    successful commit of a transaction until the WAL data is known to be
    safely received by the standby.
</span>コミットが受領通知を待機している間にプライマリが再起動した場合、プライマリデータベースが復旧した後、待機中のトランザクションは完全にコミットされたものと記録されます。
すべてのスタンバイがプライマリのクラッシュ時点で送信中のWALデータのすべてを受信したかどうかを確認する方法はありません。
トランザクションの一部は、プライマリではコミットされたものと表示されていたとしても、スタンバイではコミットされていないと表示されるかもしれません。
PostgreSQLは、WALデータをスタンバイが安全に受信したことが分かるまで、アプリケーションは明示的なトランザクションコミットの成功に関する受領通知を受けとらないことを保証しています。
   </p><p><span class="original">
    If you really do lose your last standby server then you should disable
    &lt;varname&gt;synchronous_standby_names&lt;/&gt; and reload the configuration file
    on the primary server.
</span>最終スタンバイサーバを本当に失った場合、<code class="varname">synchronous_standby_names</code>を無効にし、プライマリサーバの設定ファイルを再読み込みしなければなりません。
   </p><p><span class="original">
    If the primary is isolated from remaining standby servers you should
    fail over to the best candidate of those other remaining standby servers.
</span>プライマリが既存のスタンバイサーバから切り離された場合は、スタンバイサーバの中から最善と思われる候補にフェールオーバしてください。
   </p><p><span class="original">
    If you need to re-create a standby server while transactions are
    waiting, make sure that the commands pg_start_backup() and
    pg_stop_backup() are run in a session with
    &lt;varname&gt;synchronous_commit&lt;/&gt; = &lt;literal&gt;off&lt;/&gt;, otherwise those
    requests will wait forever for the standby to appear.
</span>トランザクションの待機中にスタンバイサーバを再作成する必要がある場合、pg_start_backup()およびpg_stop_backup()を実行するコマンドを<code class="varname">synchronous_commit</code> = <code class="literal">off</code>であるセッション内で確実に実行してください。
さもないとこれらの要求はスタンバイに現れるまで永遠に待機します。
   </p></div></div><div class="sect2" id="continuous-archiving-in-standby"><div class="titlepage"><div><div><h3 class="title">25.2.9. スタンバイにおける継続的アーカイビング</h3></div></div></div><span class="original">
   &lt;title&gt;Continuous archiving in standby&lt;/title&gt;
</span><a id="idp78068128" class="indexterm"></a><p><span class="original">
     When continuous WAL archiving is used in a standby, there are two
     different scenarios: the WAL archive can be shared between the primary
     and the standby, or the standby can have its own WAL archive. When
     the standby has its own WAL archive, set &lt;varname&gt;archive_mode&lt;/varname&gt;
     to &lt;literal&gt;always&lt;/literal&gt;, and the standby will call the archive
     command for every WAL segment it receives, whether it's by restoring
     from the archive or by streaming replication. The shared archive can
     be handled similarly, but the &lt;varname&gt;archive_command&lt;/varname&gt; must
     test if the file being archived exists already, and if the existing file
     has identical contents. This requires more care in the
     &lt;varname&gt;archive_command&lt;/varname&gt;, as it must
     be careful to not overwrite an existing file with different contents,
     but return success if the exactly same file is archived twice. And
     all that must be done free of race conditions, if two servers attempt
     to archive the same file at the same time.
</span>スタンバイにおいてWALの継続的アーカイビングが行われる場合、2つのシナリオが考えられます。
WALアーカイブがプライマリとスタンバイで共有されるケースと、スタンバイが自分のWALアーカイブを持つケースです。
スタンバイが自分のWALアーカイブを持つケースでは、<code class="varname">archive_mode</code>を<code class="literal">always</code>に設定しておくことにより、アーカイブからリストアされたWALセグメントであろうと、ストリーミングレプリケーション由来のWALセグメントであろうと、WALセグメントを受信する度にスタンバイはアーカイブコマンドを呼び出します。
共有アーカイブのケースも同じように扱えますが、<code class="varname">archive_command</code>はアーカイブしようとしているファイルがすでに存在していて、それが同一内容かどうかのチェックを行う必要があります。
このため、<code class="varname">archive_command</code>はより工夫が必要です。
というのも、<code class="varname">archive_command</code>は既存のファイルを異なる内容で置き換えてはいけませんし、またまったく同じ内容のファイルを置き換えた場合には成功したと報告しなければならないからです。
更に、2つのサーバが同時に同じファイルをアーカイブしようとした時に、競合状態が起きないようにしなければなりません。
   </p><p><span class="original">
     If &lt;varname&gt;archive_mode&lt;/varname&gt; is set to &lt;literal&gt;on&lt;/&gt;, the
     archiver is not enabled during recovery or standby mode. If the standby
     server is promoted, it will start archiving after the promotion, but
     will not archive any WAL it did not generate itself. To get a complete
     series of WAL files in the archive, you must ensure that all WAL is
     archived, before it reaches the standby. This is inherently true with
     file-based log shipping, as the standby can only restore files that
     are found in the archive, but not if streaming replication is enabled.
     When a server is not in recovery mode, there is no difference between
     &lt;literal&gt;on&lt;/literal&gt; and &lt;literal&gt;always&lt;/literal&gt; modes.
</span><code class="varname">archive_mode</code>が<code class="literal">on</code>の場合には、リカバリモードあるいはスタンバイモードではアーカイブは有効になりません。
スタンバイサーバが昇格すると、昇格後にスタンバイサーバはアーカイブを開始します。
しかし、自分が生成しなかったWALは一切アーカイブしません。
完全な一連のWALファイルをアーカイブから取り出すためには、WALがスタンバイに到着する前に、すべてのWALがアーカイブされていることを保証しなければなりません。
ファイルベースのログシッピングにおいても本質的にはこの通りです。
というのも、スタンバイはアーカイブにあるファイルだけをリストアできるからです。
ストリーミングレプリケーションが有効ならば、この限りではありません。
サーバがリカバリモーでない場合には、<code class="literal">on</code>と<code class="literal">always</code>のモードの間には違いはありません。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="different-replication-solutions.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="high-availability.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="warm-standby-failover.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">25.1. 様々な解法の比較 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 25.3. フェールオーバ</td></tr></table></div></body></html>