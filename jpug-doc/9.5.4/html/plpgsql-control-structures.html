<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>40.6. 制御構造</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.5.4文書" /><link rel="up" href="plpgsql.html" title="第40章 PL/pgSQL - SQL手続き言語" /><link rel="prev" href="plpgsql-statements.html" title="40.5. 基本的な文" /><link rel="next" href="plpgsql-cursors.html" title="40.7. カーソル" /><link rel="copyright" href="legalnotice.html" title="法的告知" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.5.4文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.5.4 plpgsql-control-structures.html">誤訳等の報告</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="plpgsql-statements.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="plpgsql.html">上へ</a></td><td width="60%" align="center">40.6. 制御構造</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="plpgsql-cursors.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="plpgsql-control-structures"><div class="titlepage"><div><div><h2 class="title" style="clear: both">40.6. 制御構造</h2></div></div></div><span class="original">
   &lt;title&gt;Control Structures&lt;/title&gt;
</span><p><span class="original">
    Control structures are probably the most useful (and
    important) part of &lt;application&gt;PL/pgSQL&lt;/&gt;. With
    &lt;application&gt;PL/pgSQL&lt;/&gt;'s control structures,
    you can manipulate &lt;productname&gt;PostgreSQL&lt;/&gt; data in a very
    flexible and powerful way.
</span>制御構造はおそらく<span class="application">PL/pgSQL</span>の最も有用（かつ重要）な部分です。
<span class="application">PL/pgSQL</span>の制御構造を使用して、<span class="productname">PostgreSQL</span>のデータを非常に柔軟、強力に操作することができます。
   </p><div class="sect2" id="plpgsql-statements-returning"><div class="titlepage"><div><div><h3 class="title">40.6.1. 関数からの復帰</h3></div></div></div><span class="original">
    &lt;title&gt;Returning From a Function&lt;/title&gt;
</span><p><span class="original">
     There are two commands available that allow you to return data
     from a function: &lt;command&gt;RETURN&lt;/command&gt; and &lt;command&gt;RETURN
     NEXT&lt;/command&gt;.
</span>関数からデータを返すために使用できるコマンドが2つあります。
<code class="command">RETURN</code>および<code class="command">RETURN NEXT</code>です。
    </p><div class="sect3" id="idp91446432"><div class="titlepage"><div><div><h4 class="title">40.6.1.1. <code class="command">RETURN</code></h4></div></div></div><pre class="synopsis">RETURN <em class="replaceable"><code>expression</code></em>;</pre><p><span class="original">
      &lt;command&gt;RETURN&lt;/command&gt; with an expression terminates the
      function and returns the value of
      &lt;replaceable&gt;expression&lt;/replaceable&gt; to the caller.  This form
      is used for &lt;application&gt;PL/pgSQL&lt;/&gt; functions that do
      not return a set.
</span>式を持つ<code class="command">RETURN</code>は関数を終了し、<em class="replaceable"><code>expression</code></em>の値を呼び出し元に返します。
この形式は集合を返さない<span class="application">PL/pgSQL</span>関数で使用されます。
     </p><p><span class="original">
      In a function that returns a scalar type, the expression's result will
      automatically be cast into the function's return type as described for
      assignments.  But to return a composite (row) value, you must write an
      expression delivering exactly the requested column set.  This may
      require use of explicit casting.
</span>スカラ型を返す関数において、代入のところで説明したように、式の結果は自動的に関数の戻り値の型にキャストされます。
しかし、複合（行）値を返すためには、要求された列集合を正確に導出する式を記述しなければなりません。
これにより、明示的なキャストの使用が必要となることがあります。
     </p><p><span class="original">
      If you declared the function with output parameters, write just
      &lt;command&gt;RETURN&lt;/command&gt; with no expression.  The current values
      of the output parameter variables will be returned.
</span>出力パラメータを持った関数を宣言した時は、式の無い<code class="command">RETURN</code>を記述してください。
その時点における出力パラメータの値が返されます。
     </p><p><span class="original">
      If you declared the function to return &lt;type&gt;void&lt;/type&gt;, a
      &lt;command&gt;RETURN&lt;/command&gt; statement can be used to exit the function
      early; but do not write an expression following
      &lt;command&gt;RETURN&lt;/command&gt;.
</span><code class="type">void</code>を返すように関数を宣言した場合でも、関数を直ちに抜け出すために<code class="command">RETURN</code>を使用できますが、<code class="command">RETURN</code>の後に式を記述しないでください。
     </p><p><span class="original">
      The return value of a function cannot be left undefined. If
      control reaches the end of the top-level block of the function
      without hitting a &lt;command&gt;RETURN&lt;/command&gt; statement, a run-time
      error will occur.  This restriction does not apply to functions
      with output parameters and functions returning &lt;type&gt;void&lt;/type&gt;,
      however.  In those cases a &lt;command&gt;RETURN&lt;/command&gt; statement is
      automatically executed if the top-level block finishes.
</span>関数の戻り値は未定義とさせたままにすることはできません。
制御が、<code class="command">RETURN</code>文が見つからない状態で関数の最上位のブロックの終わりまで達した時、実行時エラーが発生します。
しかし、この制限は出力パラメータを持った関数及び<code class="type">void</code>を返す関数には当てはまりません。
このような場合は最上位のブロックが終わった時、<code class="command">RETURN</code>文が自動的に実行されます。
     </p><p><span class="original">
      Some examples:
</span>例を示します。

</p><pre class="programlisting"><span class="original">
&amp;#045;- functions returning a scalar type
</span>-- スカラ型を返す関数
RETURN 1 + 2;
RETURN scalar_var;
<span class="original">
&amp;#045;- functions returning a composite type
</span>
-- 複合型を返す関数
RETURN composite_type_var;<span class="original">
RETURN (1, 2, 'three'::text);  &amp;#045;- must cast columns to correct types
</span>
RETURN (1, 2, 'three'::text);  -- 正しい型の列にキャストしなければなりません</pre><p>
     </p></div><div class="sect3" id="idp91462096"><div class="titlepage"><div><div><h4 class="title">40.6.1.2. <code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code></h4></div></div></div><span class="original">
     &lt;title&gt;&lt;command&gt;RETURN NEXT&lt;/&gt; and &lt;command&gt;RETURN QUERY&lt;/command&gt;&lt;/title&gt;
</span><a id="idp91463920" class="indexterm"></a><a id="idp91465184" class="indexterm"></a><pre class="synopsis">RETURN NEXT <em class="replaceable"><code>expression</code></em>;
RETURN QUERY <em class="replaceable"><code>query</code></em>;
RETURN QUERY EXECUTE <em class="replaceable"><code>command-string</code></em> [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>];</pre><p><span class="original">
      When a &lt;application&gt;PL/pgSQL&lt;/&gt; function is declared to return
      &lt;literal&gt;SETOF &lt;replaceable&gt;sometype&lt;/&gt;&lt;/literal&gt;, the procedure
      to follow is slightly different.  In that case, the individual
      items to return are specified by a sequence of &lt;command&gt;RETURN
      NEXT&lt;/command&gt; or &lt;command&gt;RETURN QUERY&lt;/command&gt; commands, and
      then a final &lt;command&gt;RETURN&lt;/command&gt; command with no argument
      is used to indicate that the function has finished executing.
      &lt;command&gt;RETURN NEXT&lt;/command&gt; can be used with both scalar and
      composite data types; with a composite result type, an entire
      &lt;quote&gt;table&lt;/quote&gt; of results will be returned.
      &lt;command&gt;RETURN QUERY&lt;/command&gt; appends the results of executing
      a query to the function's result set. &lt;command&gt;RETURN
      NEXT&lt;/command&gt; and &lt;command&gt;RETURN QUERY&lt;/command&gt; can be freely
      intermixed in a single set-returning function, in which case
      their results will be concatenated.
</span><span class="application">PL/pgSQL</span>関数が<code class="literal">SETOF <em class="replaceable"><code>sometype</code></em></code>を返すように宣言した場合、後続の処理が多少違います。
この場合、戻り値の個々の項目は、<code class="command">RETURN NEXT</code>コマンドまたは<code class="command">RETURN QUERY</code>コマンドで指定されます。
そして、引数のない最後の<code class="command">RETURN</code>コマンドにより、関数が実行を終了したことが示されます。
<code class="command">RETURN NEXT</code>は、スカラ型および複合型の両方で使用することができます。
複合型の場合、結果の<span class="quote">「<span class="quote">テーブル</span>」</span>全体が返されます。
<code class="command">RETURN QUERY</code>は、問い合わせを実行した結果を関数の結果集合に追加します。
<code class="command">RETURN NEXT</code>と<code class="command">RETURN QUERY</code>は、単一の集合を返す関数の中で自由に混合できます。
この場合、連結されたものが結果となります。
     </p><p><span class="original">
      &lt;command&gt;RETURN NEXT&lt;/command&gt; and &lt;command&gt;RETURN
      QUERY&lt;/command&gt; do not actually return from the function &amp;mdash;
      they simply append zero or more rows to the function's result
      set.  Execution then continues with the next statement in the
      &lt;application&gt;PL/pgSQL&lt;/&gt; function.  As successive
      &lt;command&gt;RETURN NEXT&lt;/command&gt; or &lt;command&gt;RETURN
      QUERY&lt;/command&gt; commands are executed, the result set is built
      up.  A final &lt;command&gt;RETURN&lt;/command&gt;, which should have no
      argument, causes control to exit the function (or you can just
      let control reach the end of the function).
</span>実際には、<code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code>は関数から戻りません。
単に関数の結果集合に行を追加しているだけです。
そして、その実行は<span class="application">PL/pgSQL</span>関数内の次の文に継続します。
<code class="command">RETURN NEXT</code>または<code class="command">RETURN QUERY</code>コマンドが連続して実行されると、結果集合が作成されます。
最後の、引数を持ってはならない<code class="command">RETURN</code>により、関数の終了を制御します
(または制御を関数の最後に移すことができます)。
     </p><p><span class="original">
      &lt;command&gt;RETURN QUERY&lt;/command&gt; has a variant
      &lt;command&gt;RETURN QUERY EXECUTE&lt;/command&gt;, which specifies the
      query to be executed dynamically.  Parameter expressions can
      be inserted into the computed query string via &lt;literal&gt;USING&lt;/&gt;,
      in just the same way as in the &lt;command&gt;EXECUTE&lt;/&gt; command.
</span><code class="command">RETURN QUERY</code>には<code class="command">RETURN QUERY EXECUTE</code>という亜種があり、それは問い合わせが動的に実行されることを指定します。
パラメータ式を、<code class="command">EXECUTE</code>コマンド内と全く同じように、<code class="literal">USING</code>によって演算された問い合わせ文字列に挿入することができます。
     </p><p><span class="original">
      If you declared the function with output parameters, write just
      &lt;command&gt;RETURN NEXT&lt;/command&gt; with no expression.  On each
      execution, the current values of the output parameter
      variable(s) will be saved for eventual return as a row of the
      result.  Note that you must declare the function as returning
      &lt;literal&gt;SETOF record&lt;/literal&gt; when there are multiple output
      parameters, or &lt;literal&gt;SETOF &lt;replaceable&gt;sometype&lt;/&gt;&lt;/literal&gt;
      when there is just one output parameter of type
      &lt;replaceable&gt;sometype&lt;/&gt;, in order to create a set-returning
      function with output parameters.
</span>出力パラメータを持つ関数を宣言した時は、式の無い<code class="command">RETURN NEXT</code>だけを記述してください。
実行の度に、その時点における出力パラメータの値が、関数からの戻り値のために結果の行として保存されます。
出力パラメータを持つ集合を返す関数を作成するためには、出力パラメータが複数の時は<code class="literal">SETOF record</code>を返すように関数を宣言し、単一の<em class="replaceable"><code>sometype</code></em>型の出力パラメータの時は<code class="literal">SETOF <em class="replaceable"><code>sometype</code></em></code>を返すように関数を宣言しなければならないことに注意してください。
     </p><p><span class="original">
      Here is an example of a function using &lt;command&gt;RETURN
      NEXT&lt;/command&gt;:
</span><code class="command">RETURN NEXT</code>を使用する関数の例を以下に示します。

</p><pre class="programlisting">CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP<span class="original">
        &amp;#045;- can do some processing here
        RETURN NEXT r; &amp;#045;- return current row of SELECT
</span>
        -- ここで処理を実行できます
        RETURN NEXT r; -- SELECTの現在の行を返します
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();</pre><p>
     </p><p><span class="original">
      Here is an example of a function using &lt;command&gt;RETURN
      QUERY&lt;/command&gt;:
</span><code class="command">RETURN QUERY</code>を使用する関数の例を以下に示します。

</p><pre class="programlisting">CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate &gt;= $1
                    AND flightdate &lt; ($1 + 1);
<span class="original">
    &amp;#045;- Since execution is not finished, we can check whether rows were returned
    &amp;#045;- and raise exception if not.
</span>
-- 実行が終わっていないので、行が返されたか検査して、行がなければ例外を発生させます。
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No flight at %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;
<span class="original">
&amp;#045;- Returns available flights or raises exception if there are no
&amp;#045;- available flights.
</span>
-- 利用できるフライトを返し、フライトがない場合は例外を発生させます。
SELECT * FROM get_available_flightid(CURRENT_DATE);</pre><p>
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><span class="original">
       The current implementation of &lt;command&gt;RETURN NEXT&lt;/command&gt;
       and &lt;command&gt;RETURN QUERY&lt;/command&gt; stores the entire result set
       before returning from the function, as discussed above.  That
       means that if a &lt;application&gt;PL/pgSQL&lt;/&gt; function produces a
       very large result set, performance might be poor: data will be
       written to disk to avoid memory exhaustion, but the function
       itself will not return until the entire result set has been
       generated.  A future version of &lt;application&gt;PL/pgSQL&lt;/&gt; might
       allow users to define set-returning functions
       that do not have this limitation.  Currently, the point at
       which data begins being written to disk is controlled by the
       &lt;xref linkend="guc-work-mem"&gt;
       configuration variable.  Administrators who have sufficient
       memory to store larger result sets in memory should consider
       increasing this parameter.
</span>上記のように、<code class="command">RETURN NEXT</code>および<code class="command">RETURN QUERY</code>の現在の実装では、関数から返される前に結果集合全体を保管します。
これにより、<span class="application">PL/pgSQL</span>関数が非常に大量の結果集合を返した場合、性能が低下する可能性があります。
メモリの枯渇を避けるため、データはディスクに書き込まれます。
しかし、関数自体は結果集合全体が生成されるまでは戻りません。
将来の<span class="application">PL/pgSQL</span>のバージョンでは、この制限を受けずに集合を返す関数をユーザが定義できるようになるかもしれません。
現在、データがディスクに書き込まれ始まる時点は<a class="xref" href="runtime-config-resource.html#guc-work-mem">work_mem</a>設定変数によって制御されています。
大量の結果集合を保管するのに十分なメモリがある場合、管理者はこのパラメータの値を大きくすることを考慮すべきです。
      </p></div></div></div><div class="sect2" id="plpgsql-conditionals"><div class="titlepage"><div><div><h3 class="title">40.6.2. 条件分岐</h3></div></div></div><span class="original">
    &lt;title&gt;Conditionals&lt;/title&gt;
</span><p><span class="original">
     &lt;command&gt;IF&lt;/&gt; and &lt;command&gt;CASE&lt;/&gt; statements let you execute
     alternative commands based on certain conditions.
     &lt;application&gt;PL/pgSQL&lt;/&gt; has three forms of &lt;command&gt;IF&lt;/&gt;:
</span><code class="command">IF</code>と<code class="command">CASE</code>文はある条件に基づいて代わりのコマンドを実行させます。
<span class="application">PL/pgSQL</span>には、以下のような３つの<code class="command">IF</code>の形式があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">IF ... THEN ... END IF</code></p></li><li class="listitem"><p><code class="literal">IF ... THEN ... ELSE ... END IF</code></p></li><li class="listitem"><p><code class="literal">IF ... THEN ... ELSIF ... THEN ... ELSE ... END IF</code></p></li></ul></div><p>
<span class="original">
    and two forms of &lt;command&gt;CASE&lt;/&gt;:
</span>
また、以下のような２つの<code class="command">CASE</code>の形式があります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">CASE ... WHEN ... THEN ... ELSE ... END CASE</code></p></li><li class="listitem"><p><code class="literal">CASE WHEN ... THEN ... ELSE ... END CASE</code></p></li></ul></div><p>
    </p><div class="sect3" id="idp91516240"><div class="titlepage"><div><div><h4 class="title">40.6.2.1. <code class="literal">IF-THEN</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
END IF;</pre><p><span class="original">
        &lt;literal&gt;IF-THEN&lt;/literal&gt; statements are the simplest form of
        &lt;literal&gt;IF&lt;/literal&gt;. The statements between
        &lt;literal&gt;THEN&lt;/literal&gt; and &lt;literal&gt;END IF&lt;/literal&gt; will be
        executed if the condition is true. Otherwise, they are
        skipped.
</span><code class="literal">IF-THEN</code>文は最も単純な<code class="literal">IF</code>の形式です。
<code class="literal">THEN</code>と<code class="literal">END IF</code>の間の文が条件が真の場合に実行されます。
さもなければそれらは飛ばされます。
       </p><p><span class="original">
        Example:
</span>例：
</p><pre class="programlisting">IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;</pre><p>
       </p></div><div class="sect3" id="idp91523344"><div class="titlepage"><div><div><h4 class="title">40.6.2.2. <code class="literal">IF-THEN-ELSE</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
ELSE
    <em class="replaceable"><code>statements</code></em>
END IF;</pre><p><span class="original">
        &lt;literal&gt;IF-THEN-ELSE&lt;/literal&gt; statements add to
        &lt;literal&gt;IF-THEN&lt;/literal&gt; by letting you specify an
        alternative set of statements that should be executed if the
        condition is not true.  (Note this includes the case where the
        condition evaluates to NULL.)
</span><code class="literal">IF-THEN-ELSE</code>文は<code class="literal">IF-THEN</code>に加え、条件評価が偽の場合に実行すべき代替となる文の集合を指定することができます。
（これには条件がNULLと評価した場合も含まれることに注意してください。）
       </p><p><span class="original">
        Examples:
</span>例：
</p><pre class="programlisting">IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;</pre><p>

</p><pre class="programlisting">IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;</pre><p>
     </p></div><div class="sect3" id="idp91530448"><div class="titlepage"><div><div><h4 class="title">40.6.2.3. <code class="literal">IF-THEN-ELSIF</code></h4></div></div></div><pre class="synopsis">IF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
[<span class="optional"> ELSIF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
[<span class="optional"> ELSIF <em class="replaceable"><code>boolean-expression</code></em> THEN
    <em class="replaceable"><code>statements</code></em>
    ...</span>]</span>]
[<span class="optional"> ELSE
    <em class="replaceable"><code>statements</code></em> </span>]
END IF;</pre><p><span class="original">
        Sometimes there are more than just two alternatives.
        &lt;literal&gt;IF-THEN-ELSIF&lt;/&gt; provides a convenient
        method of checking several alternatives in turn.
        The &lt;literal&gt;IF&lt;/&gt; conditions are tested successively
        until the first one that is true is found.  Then the
        associated statement(s) are executed, after which control
        passes to the next statement after &lt;literal&gt;END IF&lt;/&gt;.
        (Any subsequent &lt;literal&gt;IF&lt;/&gt; conditions are &lt;emphasis&gt;not&lt;/&gt;
        tested.)  If none of the &lt;literal&gt;IF&lt;/&gt; conditions is true,
        then the &lt;literal&gt;ELSE&lt;/&gt; block (if any) is executed.
</span>選択肢が２つだけではなくより多くになる場合があります。
<code class="literal">IF-THEN-ELSIF</code>は、順番に複数の代替手段を検査する、より便利な方法を提供します。
<code class="literal">IF</code>条件は最初の真である結果が見つかるまで連続して検査されます。
そして関連した文が実行され、その後<code class="literal">END IF</code>以降の次の文に制御が渡されます。
（以降にある<code class="literal">IF</code>条件の検査はすべて実行<span class="emphasis"><em>されません</em></span>。）
全ての<code class="literal">IF</code>条件が真でない場合、<code class="literal">ELSE</code>ブロックが（もし存在すれば）実行されます。
機能的には、<code class="literal">IF-THEN-ELSE-IF-THEN</code>コマンドを入れ子にしたものと同じですが、必要な<code class="literal">END IF</code>は1つだけです。
       </p><p><span class="original">
        Here is an example:
</span>以下に例を示します。

</p><pre class="programlisting">IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE<span class="original">
    &amp;#045;&amp;#045; hmm, the only other possibility is that number is null
</span>
    -- ふうむ、残る唯一の可能性はその値がNULLであることだ
    result := 'NULL';
END IF;</pre><p>
       </p><p><span class="original">
        The key word &lt;literal&gt;ELSIF&lt;/&gt; can also be spelled
        &lt;literal&gt;ELSEIF&lt;/&gt;.
</span><code class="literal">ELSIF</code>キーワードは<code class="literal">ELSEIF</code>のように書くことができます。
       </p><p><span class="original">
        An alternative way of accomplishing the same task is to nest
        &lt;literal&gt;IF-THEN-ELSE&lt;/literal&gt; statements, as in the
        following example:
</span>同じ作業を遂行する別の方法は、以下の例のように<code class="literal">IF-THEN-ELSE</code>文を入れ子にすることです。

</p><pre class="programlisting">IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;</pre><p>
       </p><p><span class="original">
        However, this method requires writing a matching &lt;literal&gt;END IF&lt;/&gt;
        for each &lt;literal&gt;IF&lt;/&gt;, so it is much more cumbersome than
        using &lt;literal&gt;ELSIF&lt;/&gt; when there are many alternatives.
</span>しかし、この方法はそれぞれの<code class="literal">IF</code>に対応する<code class="literal">END IF</code>の記述が必要です。
従って、多くの選択肢がある場合<code class="literal">ELSIF</code>を使用するよりも厄介です。
       </p></div><div class="sect3" id="idp91552640"><div class="titlepage"><div><div><h4 class="title">40.6.2.4. 単純な<code class="literal">CASE</code></h4></div></div></div><span class="original">
      &lt;title&gt;Simple &lt;literal&gt;CASE&lt;/&gt;&lt;/title&gt;
</span><pre class="synopsis">CASE <em class="replaceable"><code>search-expression</code></em>
    WHEN <em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> [<span class="optional"> ... </span>]</span>] THEN
      <em class="replaceable"><code>statements</code></em>
  [<span class="optional"> WHEN <em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> [<span class="optional"> ... </span>]</span>] THEN
      <em class="replaceable"><code>statements</code></em>
    ... </span>]
  [<span class="optional"> ELSE
      <em class="replaceable"><code>statements</code></em> </span>]
END CASE;</pre><p><span class="original">
       The simple form of &lt;command&gt;CASE&lt;/&gt; provides conditional execution
       based on equality of operands.  The &lt;replaceable&gt;search-expression&lt;/&gt;
       is evaluated (once) and successively compared to each
       &lt;replaceable&gt;expression&lt;/&gt; in the &lt;literal&gt;WHEN&lt;/&gt; clauses.
       If a match is found, then the corresponding
       &lt;replaceable&gt;statements&lt;/replaceable&gt; are executed, and then control
       passes to the next statement after &lt;literal&gt;END CASE&lt;/&gt;.  (Subsequent
       &lt;literal&gt;WHEN&lt;/&gt; expressions are not evaluated.)  If no match is
       found, the &lt;literal&gt;ELSE&lt;/&gt; &lt;replaceable&gt;statements&lt;/replaceable&gt; are
       executed; but if &lt;literal&gt;ELSE&lt;/&gt; is not present, then a
       &lt;literal&gt;CASE_NOT_FOUND&lt;/literal&gt; exception is raised.
</span><code class="command">CASE</code>の単純な形式はオペランドの等価性にもとづく条件的実行を提供します。
<em class="replaceable"><code>search-expression</code></em>は（一度だけ）評価され、その後<code class="literal">WHEN</code>句内のそれぞれの<em class="replaceable"><code>expression</code></em>と比較されます。
一致するものが見つかると、関連した<em class="replaceable"><code>statements</code></em>が実行され、<code class="literal">END CASE</code>の次の文に制御が渡されます。
（以降の<code class="literal">WHEN</code>式は評価されません。）
一致するものが見つからない場合、<code class="literal">ELSE</code> <em class="replaceable"><code>statements</code></em>が実行されますが、<code class="literal">ELSE</code>が無いときは<code class="literal">CASE_NOT_FOUND</code>例外を引き起こします。
      </p><p><span class="original">
       Here is a simple example:
</span>以下は簡単な例です。

</p><pre class="programlisting">CASE x
    WHEN 1, 2 THEN
        msg := 'one or two';
    ELSE
        msg := 'other value than one or two';
END CASE;</pre><p>
      </p></div><div class="sect3" id="idp91569472"><div class="titlepage"><div><div><h4 class="title">40.6.2.5. 検索付き<code class="literal">CASE</code></h4></div></div></div><span class="original">
      &lt;title&gt;Searched &lt;literal&gt;CASE&lt;/&gt;&lt;/title&gt;
</span><pre class="synopsis">CASE
    WHEN <em class="replaceable"><code>boolean-expression</code></em> THEN
      <em class="replaceable"><code>statements</code></em>
  [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> THEN
      <em class="replaceable"><code>statements</code></em>
    ... </span>]
  [<span class="optional"> ELSE
      <em class="replaceable"><code>statements</code></em> </span>]
END CASE;</pre><p><span class="original">
       The searched form of &lt;command&gt;CASE&lt;/&gt; provides conditional execution
       based on truth of Boolean expressions.  Each &lt;literal&gt;WHEN&lt;/&gt; clause's
       &lt;replaceable&gt;boolean-expression&lt;/replaceable&gt; is evaluated in turn,
       until one is found that yields &lt;literal&gt;true&lt;/&gt;.  Then the
       corresponding &lt;replaceable&gt;statements&lt;/replaceable&gt; are executed, and
       then control passes to the next statement after &lt;literal&gt;END CASE&lt;/&gt;.
       (Subsequent &lt;literal&gt;WHEN&lt;/&gt; expressions are not evaluated.)
       If no true result is found, the &lt;literal&gt;ELSE&lt;/&gt;
       &lt;replaceable&gt;statements&lt;/replaceable&gt; are executed;
       but if &lt;literal&gt;ELSE&lt;/&gt; is not present, then a
       &lt;literal&gt;CASE_NOT_FOUND&lt;/literal&gt; exception is raised.
</span><code class="command">CASE</code>の検索された形式は論理値式の真の結果に基づく条件付き実行を提供します。
それぞれの<code class="literal">WHEN</code>句の<em class="replaceable"><code>boolean-expression</code></em>は<code class="literal">true</code>となる１つが見つかるまで順番に評価されます。
その後、関連する<em class="replaceable"><code>statements</code></em>が実行され、その結果<code class="literal">END CASE</code>の次の文に制御が渡されます。
（以降の<code class="literal">WHEN</code>式は評価されません。）
真となる結果が見つからない場合、<code class="literal">ELSE</code> <em class="replaceable"><code>statements</code></em>が実行されますが、<code class="literal">ELSE</code>が存在しないときは<code class="literal">CASE_NOT_FOUND</code>例外を引き起こします。
      </p><p><span class="original">
       Here is an example:
</span>以下は簡単な例です。

</p><pre class="programlisting">CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'value is between zero and ten';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'value is between eleven and twenty';
END CASE;</pre><p>
      </p><p><span class="original">
       This form of &lt;command&gt;CASE&lt;/&gt; is entirely equivalent to
       &lt;literal&gt;IF-THEN-ELSIF&lt;/&gt;, except for the rule that reaching
       an omitted &lt;literal&gt;ELSE&lt;/&gt; clause results in an error rather
       than doing nothing.
</span>この形式の<code class="command">CASE</code>は、判定基準が省略された<code class="literal">ELSE</code>句に達した場合に何もしないのではなくエラーなる点を除き、<code class="literal">IF-THEN-ELSIF</code>と全く同一です。
      </p></div></div><div class="sect2" id="plpgsql-control-structures-loops"><div class="titlepage"><div><div><h3 class="title">40.6.3. 単純なループ</h3></div></div></div><span class="original">
    &lt;title&gt;Simple Loops&lt;/title&gt;
</span><a id="idp91588048" class="indexterm"></a><p><span class="original">
     With the &lt;literal&gt;LOOP&lt;/&gt;, &lt;literal&gt;EXIT&lt;/&gt;,
     &lt;literal&gt;CONTINUE&lt;/&gt;, &lt;literal&gt;WHILE&lt;/&gt;, &lt;literal&gt;FOR&lt;/&gt;,
     and &lt;literal&gt;FOREACH&lt;/&gt; statements, you can arrange for your
     &lt;application&gt;PL/pgSQL&lt;/&gt; function to repeat a series of commands.
</span><code class="literal">LOOP</code>、<code class="literal">EXIT</code>、<code class="literal">CONTINUE</code>、<code class="literal">WHILE</code>、<code class="literal">FOR</code>、<code class="literal">FOREACH</code>文を使用して、<span class="application">PL/pgSQL</span>関数で、一連のコマンドを繰り返すことができます。
    </p><div class="sect3" id="idp91595488"><div class="titlepage"><div><div><h4 class="title">40.6.3.1. <code class="literal">LOOP</code></h4></div></div></div><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><span class="original">
      &lt;literal&gt;LOOP&lt;/&gt; defines an unconditional loop that is repeated
      indefinitely until terminated by an &lt;literal&gt;EXIT&lt;/&gt; or
      &lt;command&gt;RETURN&lt;/command&gt; statement.  The optional
      &lt;replaceable&gt;label&lt;/replaceable&gt; can be used by &lt;literal&gt;EXIT&lt;/&gt;
      and &lt;literal&gt;CONTINUE&lt;/literal&gt; statements within nested loops to
      specify which loop those statements refer to.
</span><code class="literal">LOOP</code>は、<code class="literal">EXIT</code>文または<code class="command">RETURN</code>文によって終了されるまで無限に繰り返される、条件なしのループを定義します。
省略可能な<em class="replaceable"><code>label</code></em>は、入れ子状になったループにおいて<code class="literal">EXIT</code>および<code class="literal">CONTINUE</code>文がどのレベルの入れ子を参照するかを指定するために使用されます。
     </p></div><div class="sect3" id="idp91603776"><div class="titlepage"><div><div><h4 class="title">40.6.3.2. <code class="literal">EXIT</code></h4></div></div></div><a id="idp91604592" class="indexterm"></a><pre class="synopsis">EXIT [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>] [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> </span>];</pre><p><span class="original">
        If no &lt;replaceable&gt;label&lt;/replaceable&gt; is given, the innermost
        loop is terminated and the statement following &lt;literal&gt;END
        LOOP&lt;/&gt; is executed next.  If &lt;replaceable&gt;label&lt;/replaceable&gt;
        is given, it must be the label of the current or some outer
        level of nested loop or block. Then the named loop or block is
        terminated and control continues with the statement after the
        loop's/block's corresponding &lt;literal&gt;END&lt;/&gt;.
</span><em class="replaceable"><code>label</code></em>が指定されない場合、最も内側のループを終わらせ、<code class="literal">END LOOP</code>の次の文がその後に実行されます。
<em class="replaceable"><code>label</code></em>が指定された場合、それは現在またはその上位の入れ子になったループやブロックのラベルである必要があります。
その後、指名されたループまたはブロックを終わらせ、そのループまたはブロックの対応する<code class="literal">END</code>の次の文に制御を移します。
       </p><p><span class="original">
        If &lt;literal&gt;WHEN&lt;/&gt; is specified, the loop exit occurs only if
        &lt;replaceable&gt;boolean-expression&lt;/&gt; is true. Otherwise, control passes
        to the statement after &lt;literal&gt;EXIT&lt;/&gt;.
</span><code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>boolean-expression</code></em>が真の場合のみループの終了が起こります。
さもなければ、<code class="literal">EXIT</code>の後の行に制御が移ります。
       </p><p><span class="original">
        &lt;literal&gt;EXIT&lt;/&gt; can be used with all types of loops; it is
        not limited to use with unconditional loops.
</span><code class="literal">EXIT</code>は、すべての種類のループと共に使用できます。
条件なしのループでの使用に限定されません。
       </p><p><span class="original">
        When used with a
        &lt;literal&gt;BEGIN&lt;/literal&gt; block, &lt;literal&gt;EXIT&lt;/literal&gt; passes
        control to the next statement after the end of the block.
        Note that a label must be used for this purpose; an unlabeled
        &lt;literal&gt;EXIT&lt;/literal&gt; is never considered to match a
        &lt;literal&gt;BEGIN&lt;/literal&gt; block.  (This is a change from
        pre-8.4 releases of &lt;productname&gt;PostgreSQL&lt;/productname&gt;, which
        would allow an unlabeled &lt;literal&gt;EXIT&lt;/literal&gt; to match
        a &lt;literal&gt;BEGIN&lt;/literal&gt; block.)
</span><code class="literal">BEGIN</code>ブロックと共に使用した時、<code class="literal">EXIT</code>によりブロックの次の文に制御が移ります。
この目的のためにラベルが使用されなければならないことに注意してください。
ラベル無しの<code class="literal">EXIT</code>は<code class="literal">BEGIN</code>ブロックに対応するとは決して考えられません。
（これは、ラベル無しの<code class="literal">EXIT</code>が<code class="literal">BEGIN</code>ブロックに対応することを許容する<span class="productname">PostgreSQL</span>の8.4より前のリリースからの変更です。）
       </p><p><span class="original">
        Examples:
</span>例：
</p><pre class="programlisting">LOOP<span class="original">
    &amp;#045;&amp;#045; some computations
</span>
    -- 何らかの演算
    IF count &gt; 0 THEN<span class="original">
        EXIT;  &amp;#045;&amp;#045; exit loop
</span>
        EXIT;  -- ループを抜け出す
    END IF;
END LOOP;

LOOP<span class="original">
    &amp;#045;&amp;#045; some computations
    EXIT WHEN count &amp;gt; 0;  &amp;#045;&amp;#045; same result as previous example
</span>
-- 何らかの演算
    EXIT WHEN count &gt; 0;  -- 上例と同じ結果
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN<span class="original">
    &amp;#045;&amp;#045; some computations
</span>
    -- 何らかの演算
    IF stocks &gt; 100000 THEN<span class="original">
        EXIT ablock;  &amp;#045;&amp;#045; causes exit from the BEGIN block
</span>
        EXIT ablock;  -- これによりBEGINブロックを抜け出す
    END IF;<span class="original">
    &amp;#045;&amp;#045; computations here will be skipped when stocks &amp;gt; 100000
</span>
    -- stokcs &gt; 100000 であればここでの演算は省略
END;</pre><p>
       </p></div><div class="sect3" id="idp91625552"><div class="titlepage"><div><div><h4 class="title">40.6.3.3. <code class="literal">CONTINUE</code></h4></div></div></div><a id="idp91626368" class="indexterm"></a><pre class="synopsis">CONTINUE [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>] [<span class="optional"> WHEN <em class="replaceable"><code>boolean-expression</code></em> </span>];</pre><p><span class="original">
        If no &lt;replaceable&gt;label&lt;/&gt; is given, the next iteration of
        the innermost loop is begun. That is, all statements remaining
        in the loop body are skipped, and control returns
        to the loop control expression (if any) to determine whether
        another loop iteration is needed.
        If &lt;replaceable&gt;label&lt;/&gt; is present, it
        specifies the label of the loop whose execution will be
        continued.
</span><em class="replaceable"><code>label</code></em>が無い場合、すぐ外側のループの次の繰り返しが開始されます。
すなわち、ループ本体の残りの文は飛ばされて、他のループの繰り返しが必要かどうかを決めるため、制御がループ制御式(もし存在すれば)に戻ります。
<em class="replaceable"><code>label</code></em>が存在する場合、実行を継続するループのラベルを指定します。
       </p><p><span class="original">
        If &lt;literal&gt;WHEN&lt;/&gt; is specified, the next iteration of the
        loop is begun only if &lt;replaceable&gt;boolean-expression&lt;/&gt; is
        true. Otherwise, control passes to the statement after
        &lt;literal&gt;CONTINUE&lt;/&gt;.
</span><code class="literal">WHEN</code>が指定された場合、<em class="replaceable"><code>boolean-expression</code></em>が真の場合のみループにおける次の繰り返しが始まります。
さもなければ、<code class="literal">CONTINUE</code>の後の行に制御が移ります。
       </p><p><span class="original">
        &lt;literal&gt;CONTINUE&lt;/&gt; can be used with all types of loops; it
        is not limited to use with unconditional loops.
</span><code class="literal">CONTINUE</code>は全ての種類のループで使用可能です。
条件なしのループに限定されません。
       </p><p><span class="original">
        Examples:
</span>例
</p><pre class="programlisting">LOOP<span class="original">
    &amp;#045;&amp;#045; some computations
</span>
    -- 何らかの演算
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;<span class="original">
    &amp;#045;&amp;#045; some computations for count IN [50 .. 100] 
</span>
    -- 50から100を数える、何らかの演算
END LOOP;</pre><p>
       </p></div><div class="sect3" id="idp91637520"><div class="titlepage"><div><div><h4 class="title">40.6.3.4. <code class="literal">WHILE</code></h4></div></div></div><a id="idp91638336" class="indexterm"></a><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
WHILE <em class="replaceable"><code>boolean-expression</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><span class="original">
        The &lt;literal&gt;WHILE&lt;/&gt; statement repeats a
        sequence of statements so long as the
        &lt;replaceable&gt;boolean-expression&lt;/replaceable&gt;
        evaluates to true.  The expression is checked just before
        each entry to the loop body.
</span><code class="literal">WHILE</code>文は<em class="replaceable"><code>boolean-expression</code></em>の評価が真である間、一連の文を繰り返します。
条件式は、ループ本体に入る前にのみ検査されます。
       </p><p><span class="original">
        For example:
</span>以下に例を示します。
</p><pre class="programlisting">WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP<span class="original">
    &amp;#045;&amp;#045; some computations here
</span>
    -- ここで演算をいくつか行います。
END LOOP;

WHILE NOT done LOOP<span class="original">
    &amp;#045;&amp;#045; some computations here
</span>
    -- ここで演算をいくつか行います。
END LOOP;</pre><p>
       </p></div><div class="sect3" id="plpgsql-integer-for"><div class="titlepage"><div><div><h4 class="title">40.6.3.5. 整数<code class="literal">FOR</code>ループ</h4></div></div></div><span class="original">
      &lt;title&gt;&lt;literal&gt;FOR&lt;/&gt; (Integer Variant)&lt;/title&gt;
</span><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>name</code></em> IN [<span class="optional"> REVERSE </span>] <em class="replaceable"><code>expression</code></em> .. <em class="replaceable"><code>expression</code></em> [<span class="optional"> BY <em class="replaceable"><code>expression</code></em> </span>] LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><span class="original">
        This form of &lt;literal&gt;FOR&lt;/&gt; creates a loop that iterates over a range
        of integer values. The variable
        &lt;replaceable&gt;name&lt;/replaceable&gt; is automatically defined as type
        &lt;type&gt;integer&lt;/&gt; and exists only inside the loop (any existing
        definition of the variable name is ignored within the loop).
        The two expressions giving
        the lower and upper bound of the range are evaluated once when entering
        the loop. If the &lt;literal&gt;BY&lt;/&gt; clause isn't specified the iteration
        step is 1, otherwise it's the value specified in the &lt;literal&gt;BY&lt;/&gt;
        clause, which again is evaluated once on loop entry.
        If &lt;literal&gt;REVERSE&lt;/&gt; is specified then the step value is
        subtracted, rather than added, after each iteration.
</span>この形式の<code class="literal">FOR</code>は整数値の範囲内で繰り返すループを生成します。
<em class="replaceable"><code>name</code></em>変数は<code class="type">integer</code>型として自動的に定義され、ループ内部のみで存在します
（ループ外部で定義しても、ループ内部では全て無視されます）。
範囲の下限、上限として与えられる2つの式はループに入った時に一度だけ評価されます。
<code class="literal">BY</code>句を指定しない時の繰り返し刻みは1ですが、<code class="literal">BY</code>句を用いて指定でき、ループに入った時に一度だけ評価されます。
<code class="literal">REVERSE</code>が指定された場合、繰り返し刻みの値は加算されるのではなく、繰り返しごとに減算されます。
       </p><p><span class="original">
        Some examples of integer &lt;literal&gt;FOR&lt;/&gt; loops:
</span>整数FORループの例を以下に示します。
</p><pre class="programlisting">FOR i IN 1..10 LOOP<span class="original">
    &amp;#045;&amp;#045; i will take on the values 1,2,3,4,5,6,7,8,9,10 within the loop
</span>
    -- i はループ内で 1、2、3、4、5、6、7、8、9、10 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 LOOP<span class="original">
    &amp;#045;&amp;#045; i will take on the values 10,9,8,7,6,5,4,3,2,1 within the loop
</span>
    -- i はループ内で 10、9、8、7、6、5、4、3、2、1 の値を取ります。
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP<span class="original">
    &amp;#045;&amp;#045; i will take on the values 10,8,6,4,2 within the loop
</span>
    -- i はループ内で 10、8、6、4、2 の値を取ります。
END LOOP;</pre><p>
       </p><p><span class="original">
        If the lower bound is greater than the upper bound (or less than,
        in the &lt;literal&gt;REVERSE&lt;/&gt; case), the loop body is not
        executed at all.  No error is raised.
</span>下限が上限よりも大きい（<code class="literal">REVERSE</code>の場合はより小さい）場合、ループ本体はまったく実行されません。
エラーは発生しません。
       </p><p><span class="original">
        If a &lt;replaceable&gt;label&lt;/replaceable&gt; is attached to the
        &lt;literal&gt;FOR&lt;/&gt; loop then the integer loop variable can be
        referenced with a qualified name, using that
        &lt;replaceable&gt;label&lt;/replaceable&gt;.
</span><em class="replaceable"><code>label</code></em>を<code class="literal">FOR</code>ループに付加することにより、<em class="replaceable"><code>label</code></em>を用いて修飾した名前の整数ループ変数を参照できます。
       </p></div></div><div class="sect2" id="plpgsql-records-iterating"><div class="titlepage"><div><div><h3 class="title">40.6.4. 問い合わせ結果による繰り返し</h3></div></div></div><span class="original">
    &lt;title&gt;Looping Through Query Results&lt;/title&gt;
</span><p><span class="original">
     Using a different type of &lt;literal&gt;FOR&lt;/&gt; loop, you can iterate through
     the results of a query and manipulate that data
     accordingly. The syntax is:
</span>別の種類の<code class="literal">FOR</code>ループを使用して、問い合わせの結果を繰り返し、そのデータを扱うことができます。
以下に構文を示します。
</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>target</code></em> IN <em class="replaceable"><code>query</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><span class="original">
     The &lt;replaceable&gt;target&lt;/replaceable&gt; is a record variable, row variable,
     or comma-separated list of scalar variables.
     The &lt;replaceable&gt;target&lt;/replaceable&gt; is successively assigned each row
     resulting from the &lt;replaceable&gt;query&lt;/replaceable&gt; and the loop body is
     executed for each row. Here is an example:
</span>
<em class="replaceable"><code>target</code></em>は、レコード変数、行変数またはカンマで区切ったスカラ変数のリストです。
<em class="replaceable"><code>target</code></em>には順次、<em class="replaceable"><code>query</code></em>の結果の全ての行が代入され、各行に対してループ本体が実行されます。
以下に例を示します。
</p><pre class="programlisting">CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Refreshing materialized views...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP
<span class="original">
        &amp;#045;&amp;#045; Now "mviews" has one record from cs_materialized_views
</span>
        -- ここで"mviews"はcs_materialized_viewsの1つのレコードを持ちます

        RAISE NOTICE 'Refreshing materialized view %s ...', quote_ident(mviews.mv_name);
        EXECUTE format('TRUNCATE TABLE %I', mviews.mv_name);
        EXECUTE format('INSERT INTO %I %s', mviews.mv_name, mviews.mv_query);
    END LOOP;

    RAISE NOTICE 'Done refreshing materialized views.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;</pre><p>
<span class="original">
     If the loop is terminated by an &lt;literal&gt;EXIT&lt;/&gt; statement, the last
     assigned row value is still accessible after the loop.
</span>
このループが<code class="literal">EXIT</code>文で終了した場合、最後に割り当てられた行の値はループを抜けた後でもアクセスすることができます。
    </p><p><span class="original">
     The &lt;replaceable&gt;query&lt;/replaceable&gt; used in this type of &lt;literal&gt;FOR&lt;/&gt;
     statement can be any SQL command that returns rows to the caller:
     &lt;command&gt;SELECT&lt;/&gt; is the most common case,
     but you can also use &lt;command&gt;INSERT&lt;/&gt;, &lt;command&gt;UPDATE&lt;/&gt;, or
     &lt;command&gt;DELETE&lt;/&gt; with a &lt;literal&gt;RETURNING&lt;/&gt; clause.  Some utility
     commands such as &lt;command&gt;EXPLAIN&lt;/&gt; will work too.
</span>この種類の<code class="literal">FOR</code>文の<em class="replaceable"><code>query</code></em>としては、呼び出し元に行を返すSQLコマンドをすべて使用できます。
通常は<code class="command">SELECT</code>ですが、<code class="literal">RETURNING</code>句を持つ<code class="command">INSERT</code>、<code class="command">UPDATE</code>または<code class="command">DELETE</code>も使用できます。
<code class="command">EXPLAIN</code>などのユーティリティコマンドも作動します。
    </p><p><span class="original">
     &lt;application&gt;PL/pgSQL&lt;/&gt; variables are substituted into the query text,
     and the query plan is cached for possible re-use, as discussed in
     detail in &lt;xref linkend="plpgsql-var-subst"&gt; and
     &lt;xref linkend="plpgsql-plan-caching"&gt;.
</span><span class="application">PL/pgSQL</span>変数は問い合わせテキストに置き換えられます。
問い合わせ計画は、<a class="xref" href="plpgsql-implementation.html#plpgsql-var-subst" title="40.10.1. 変数置換">40.10.1. 変数置換</a>および<a class="xref" href="plpgsql-implementation.html#plpgsql-plan-caching" title="40.10.2. 計画のキャッシュ">40.10.2. 計画のキャッシュ</a>で述べたように、再利用のためにキャッシュされます。
    </p><p><span class="original">
     The &lt;literal&gt;FOR-IN-EXECUTE&lt;/&gt; statement is another way to iterate over
     rows:
</span><code class="literal">FOR-IN-EXECUTE</code>文は行を繰り返すもう1つの方法です。
</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOR <em class="replaceable"><code>target</code></em> IN EXECUTE <em class="replaceable"><code>text_expression</code></em> [<span class="optional"> USING <em class="replaceable"><code>expression</code></em> [<span class="optional">, ... </span>] </span>] LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p><span class="original">
     This is like the previous form, except that the source query
     is specified as a string expression, which is evaluated and replanned
     on each entry to the &lt;literal&gt;FOR&lt;/&gt; loop.  This allows the programmer to
     choose the speed of a preplanned query or the flexibility of a dynamic
     query, just as with a plain &lt;command&gt;EXECUTE&lt;/command&gt; statement.
     As with &lt;command&gt;EXECUTE&lt;/command&gt;, parameter values can be inserted
     into the dynamic command via &lt;literal&gt;USING&lt;/&gt;.
</span>
この方法は、問い合わせのソースが文字列式で指定される点を除き、前の形式と似ています。
この式は<code class="literal">FOR</code>ループの各項目で評価され、再計画が行われます。
これにより、プログラマは、通常の<code class="command">EXECUTE</code>文と同じように事前に計画された問い合わせによる高速性と、動的な問い合わせの持つ柔軟性を選択することができます。
<code class="command">EXECUTE</code>の場合と同様、パラメータ値は<code class="literal">USING</code>により動的コマンドに挿入できます。
    </p><p><span class="original">
     Another way to specify the query whose results should be iterated
     through is to declare it as a cursor.  This is described in
     &lt;xref linkend="plpgsql-cursor-for-loop"&gt;.
</span>結果を通して繰り返さなければならない問い合わせを指定するもう１つの方法として、カーソルの宣言があります。
これは<a class="xref" href="plpgsql-cursors.html#plpgsql-cursor-for-loop" title="40.7.4. カーソル結果に対するループ">40.7.4. カーソル結果に対するループ</a>で説明します。
    </p></div><div class="sect2" id="plpgsql-foreach-array"><div class="titlepage"><div><div><h3 class="title">40.6.5. 配列を巡回</h3></div></div></div><span class="original">
    &lt;title&gt;Looping Through Arrays&lt;/title&gt;
</span><p><span class="original">
     The &lt;literal&gt;FOREACH&lt;/&gt; loop is much like a &lt;literal&gt;FOR&lt;/&gt; loop,
     but instead of iterating through the rows returned by a SQL query,
     it iterates through the elements of an array value.
     (In general, &lt;literal&gt;FOREACH&lt;/&gt; is meant for looping through
     components of a composite-valued expression; variants for looping
     through composites besides arrays may be added in future.)
     The &lt;literal&gt;FOREACH&lt;/&gt; statement to loop over an array is:
</span><code class="literal">FOREACH</code>ループは<code class="literal">FOR</code>ループにとてもよく似ています。
しかし、SQL 問い合わせが抽出した行を繰り返す代わりに、配列の要素を繰り返します。
（一般的に<code class="literal">FOREACH</code>は、複合値で表現される構成要素の巡回を意味しますが、配列でない複合値も巡回する亜種が将来は追加されるかもしれません。）
配列を巡回する<code class="literal">FOREACH</code>文を示します。

</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
FOREACH <em class="replaceable"><code>target</code></em> [<span class="optional"> SLICE <em class="replaceable"><code>number</code></em> </span>] IN ARRAY <em class="replaceable"><code>expression</code></em> LOOP
    <em class="replaceable"><code>statements</code></em>
END LOOP [<span class="optional"> <em class="replaceable"><code>label</code></em> </span>];</pre><p>
    </p><p><span class="original">
     Without &lt;literal&gt;SLICE&lt;/&gt;, or if &lt;literal&gt;SLICE 0&lt;/&gt; is specified,
     the loop iterates through individual elements of the array produced
     by evaluating the &lt;replaceable&gt;expression&lt;/replaceable&gt;.
     The &lt;replaceable&gt;target&lt;/replaceable&gt; variable is assigned each
     element value in sequence, and the loop body is executed for each element.
     Here is an example of looping through the elements of an integer
     array:
</span><code class="literal">SLICE</code>がない、または<code class="literal">SLICE 0</code>が指定された場合、ループは<em class="replaceable"><code>expression</code></em>によって評価されて作成された配列の各要素を繰り返します。
<em class="replaceable"><code>target</code></em>変数が各要素の値に順次割り当てられ、各要素に対してループ本体が実行されます。
整数配列の要素を巡回する例を示します。

</p><pre class="programlisting">CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;</pre><p>
<span class="original">
     The elements are visited in storage order, regardless of the number of
     array dimensions.  Although the &lt;replaceable&gt;target&lt;/replaceable&gt; is
     usually just a single variable, it can be a list of variables when
     looping through an array of composite values (records).  In that case,
     for each array element, the variables are assigned from successive
     columns of the composite value.
</span>
配列の次元数に関係なく、要素は格納した順番で処理されます。
通常<em class="replaceable"><code>target</code></em>は単一の変数ですが、複合値（レコード）の配列を巡回するときは、変数のリストも可能です。
その場合、配列の各要素に対して、変数は複合値（レコード）の列から連続的に割り当てられます。
    </p><p><span class="original">
     With a positive &lt;literal&gt;SLICE&lt;/&gt; value, &lt;literal&gt;FOREACH&lt;/&gt;
     iterates through slices of the array rather than single elements.
     The &lt;literal&gt;SLICE&lt;/&gt; value must be an integer constant not larger
     than the number of dimensions of the array.  The
     &lt;replaceable&gt;target&lt;/replaceable&gt; variable must be an array,
     and it receives successive slices of the array value, where each slice
     is of the number of dimensions specified by &lt;literal&gt;SLICE&lt;/&gt;.
     Here is an example of iterating through one-dimensional slices:
</span>正の<code class="literal">SLICE</code>値を持つ場合、<code class="literal">FOREACH</code>は単一の要素ではなく多次元配列の低次元部分配列を通して繰り返します。
<code class="literal">SLICE</code>値は、配列の次元数より小さい整数定数でなければなりません。
<em class="replaceable"><code>target</code></em>変数は配列でなければなりません。
この変数は、配列値から連続した部分配列を受けとります
ここで部分配列は<code class="literal">SLICE</code>で指定した次数となります。
以下に1次元の部分配列を通した繰り返しの例を示します。

</p><pre class="programlisting">CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}</pre><p>
    </p></div><div class="sect2" id="plpgsql-error-trapping"><div class="titlepage"><div><div><h3 class="title">40.6.6. エラーの捕捉</h3></div></div></div><span class="original">
    &lt;title&gt;Trapping Errors&lt;/title&gt;
</span><a id="idp91719696" class="indexterm"></a><p><span class="original">
     By default, any error occurring in a &lt;application&gt;PL/pgSQL&lt;/&gt;
     function aborts execution of the function, and indeed of the
     surrounding transaction as well.  You can trap errors and recover
     from them by using a &lt;command&gt;BEGIN&lt;/&gt; block with an
     &lt;literal&gt;EXCEPTION&lt;/&gt; clause.  The syntax is an extension of the
     normal syntax for a &lt;command&gt;BEGIN&lt;/&gt; block:
</span>デフォルトでは、<span class="application">PL/pgSQL</span>関数の内部で発生したエラーは関数の実行を中止し、実際に上位のトランザクションをアボートします。
<code class="command">BEGIN</code>ブロックおよび<code class="literal">EXCEPTION</code>句を使用すれば、エラーを捕捉してその状態から回復できます。
その構文は通常の<code class="command">BEGIN</code>ブロックの構文を拡張したものです。

</p><pre class="synopsis">[<span class="optional"> &lt;&lt;<em class="replaceable"><code>label</code></em>&gt;&gt; </span>]
[<span class="optional"> DECLARE
    <em class="replaceable"><code>declarations</code></em> </span>]
BEGIN
    <em class="replaceable"><code>statements</code></em>
EXCEPTION
    WHEN <em class="replaceable"><code>condition</code></em> [<span class="optional"> OR <em class="replaceable"><code>condition</code></em> ... </span>] THEN
        <em class="replaceable"><code>handler_statements</code></em>
    [<span class="optional"> WHEN <em class="replaceable"><code>condition</code></em> [<span class="optional"> OR <em class="replaceable"><code>condition</code></em> ... </span>] THEN
          <em class="replaceable"><code>handler_statements</code></em>
      ... </span>]
END;</pre><p>
    </p><p><span class="original">
     If no error occurs, this form of block simply executes all the
     &lt;replaceable&gt;statements&lt;/replaceable&gt;, and then control passes
     to the next statement after &lt;literal&gt;END&lt;/&gt;.  But if an error
     occurs within the &lt;replaceable&gt;statements&lt;/replaceable&gt;, further
     processing of the &lt;replaceable&gt;statements&lt;/replaceable&gt; is
     abandoned, and control passes to the &lt;literal&gt;EXCEPTION&lt;/&gt; list.
     The list is searched for the first &lt;replaceable&gt;condition&lt;/replaceable&gt;
     matching the error that occurred.  If a match is found, the
     corresponding &lt;replaceable&gt;handler_statements&lt;/replaceable&gt; are
     executed, and then control passes to the next statement after
     &lt;literal&gt;END&lt;/&gt;.  If no match is found, the error propagates out
     as though the &lt;literal&gt;EXCEPTION&lt;/&gt; clause were not there at all:
     the error can be caught by an enclosing block with
     &lt;literal&gt;EXCEPTION&lt;/&gt;, or if there is none it aborts processing
     of the function.
</span>エラーが発生しない時、この形式のブロックは単に全ての<em class="replaceable"><code>statements</code></em>を実行し、<code class="literal">END</code>の次の文に制御が移ります。
しかし、<em class="replaceable"><code>statements</code></em>の内部でエラーが発生すると、それ以後の<em class="replaceable"><code>statements</code></em>の処理は中断され、<code class="literal">EXCEPTION</code>リストに制御が移ります。
そしてリストの中から、発生したエラーと合致する最初の<em class="replaceable"><code>condition</code></em>を探します。
合致するものがあれば、対応する<em class="replaceable"><code>handler_statements</code></em>を実行し、<code class="literal">END</code>の次の文に制御が移ります。
合致するものがなければ、<code class="literal">EXCEPTION</code>句が存在しないのと同じで、エラーは外側に伝播します。
<code class="literal">EXCEPTION</code>を含んだ外側のブロックはエラーを捕捉できますが、失敗すると関数の処理は中断されます。
    </p><p><span class="original">
     The &lt;replaceable&gt;condition&lt;/replaceable&gt; names can be any of
     those shown in &lt;xref linkend="errcodes-appendix"&gt;.  A category
     name matches any error within its category.  The special
     condition name &lt;literal&gt;OTHERS&lt;/&gt; matches every error type except
     &lt;literal&gt;QUERY_CANCELED&lt;/&gt; and &lt;literal&gt;ASSERT_FAILURE&lt;/&gt;.
     (It is possible, but often unwise, to trap those two error types
     by name.)  Condition names are
     not case-sensitive.  Also, an error condition can be specified
     by &lt;literal&gt;SQLSTATE&lt;/&gt; code; for example these are equivalent:
</span>全ての<em class="replaceable"><code>condition</code></em>の名前は<a class="xref" href="errcodes-appendix.html" title="付録A PostgreSQLエラーコード">付録A <em><span class="productname">PostgreSQL</span>エラーコード</em></a>に示したもののいずれかを取ることができます。
分類名はそこに分類される全てのエラーに合致します。
<code class="literal">OTHERS</code>という特別の状態名は<code class="literal">QUERY_CANCELED</code>と<code class="literal">ASSERT_FAILURE</code>を除く全てのエラーに合致します。
（<code class="literal">QUERY_CANCELED</code>と<code class="literal">QUERY_CANCELED</code>を名前で捕捉することは可能ですが、賢明ではありません。）
状態名は大文字小文字を区別しません。
同時に、エラー状態は<code class="literal">SQLSTATE</code>コードで指定可能です。
例えば以下は等価です。
</p><pre class="programlisting">WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...</pre><p>
    </p><p><span class="original">
     If a new error occurs within the selected
     &lt;replaceable&gt;handler_statements&lt;/replaceable&gt;, it cannot be caught
     by this &lt;literal&gt;EXCEPTION&lt;/&gt; clause, but is propagated out.
     A surrounding &lt;literal&gt;EXCEPTION&lt;/&gt; clause could catch it.
</span>エラーが該当する<em class="replaceable"><code>handler_statements</code></em>内部で新たに発生した時、<code class="literal">EXCEPTION</code>句はそのエラーを捕捉できずエラーは外側に伝播します。
なお、上位の<code class="literal">EXCEPTION</code>句はそのエラーを捕捉できます。
    </p><p><span class="original">
     When an error is caught by an &lt;literal&gt;EXCEPTION&lt;/&gt; clause,
     the local variables of the &lt;application&gt;PL/pgSQL&lt;/&gt; function
     remain as they were when the error occurred, but all changes
     to persistent database state within the block are rolled back.
     As an example, consider this fragment:
</span><code class="literal">EXCEPTION</code>句がエラーを捕捉した時、<span class="application">PL/pgSQL</span>関数のローカル変数はエラーが起こった後の状態を保ちます。
しかし、ブロック内部における永続的なデータベースの状態は、ロールバックされます。
そのような例を以下に示します。

</p><pre class="programlisting">INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'caught division_by_zero';
        RETURN x;
END;</pre><p>
<span class="original">
     When control reaches the assignment to &lt;literal&gt;y&lt;/&gt;, it will
     fail with a &lt;literal&gt;division_by_zero&lt;/&gt; error.  This will be caught by
     the &lt;literal&gt;EXCEPTION&lt;/&gt; clause.  The value returned in the
     &lt;command&gt;RETURN&lt;/&gt; statement will be the incremented value of
     &lt;literal&gt;x&lt;/&gt;, but the effects of the &lt;command&gt;UPDATE&lt;/&gt; command will
     have been rolled back.  The &lt;command&gt;INSERT&lt;/&gt; command preceding the
     block is not rolled back, however, so the end result is that the database
     contains &lt;literal&gt;Tom Jones&lt;/&gt; not &lt;literal&gt;Joe Jones&lt;/&gt;.
</span>
制御が変数<code class="literal">y</code>の代入に移ると、<code class="literal">division_by_zero</code>エラーとなり、<code class="literal">EXCEPTION</code>句がそのエラーを捕捉します。
<code class="command">RETURN</code>文による関数の戻り値は、1を加算した後の<code class="literal">x</code>の値となりますが、<code class="command">UPDATE</code>コマンドによる結果はロールバックされます。
しかし、前のブロックの<code class="command">INSERT</code>コマンドはロールバックされません。
したがって、データベースの内容の最終結果は<code class="literal">Tom Jones</code>であり、<code class="literal">Joe Jones</code>ではありません。
    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">ヒント</h3><p><span class="original">
      A block containing an &lt;literal&gt;EXCEPTION&lt;/&gt; clause is significantly
      more expensive to enter and exit than a block without one.  Therefore,
      don't use &lt;literal&gt;EXCEPTION&lt;/&gt; without need.
</span><code class="literal">EXCEPTION</code>句を含んだブロックの実行に要する時間は、含まないブロックに比べてとても長くなります。
したがって、必要のない時に<code class="literal">EXCEPTION</code>を使用してはいけません。
     </p></div><div class="example" id="plpgsql-upsert-example"><p class="title"><strong>例40.2 <code class="command">UPDATE</code>/<code class="command">INSERT</code>の例外</strong></p><div class="example-contents"><span class="original">
    &lt;title&gt;Exceptions with &lt;command&gt;UPDATE&lt;/&gt;/&lt;command&gt;INSERT&lt;/&gt;&lt;/title&gt;
</span><p><span class="original">
    This example uses exception handling to perform either
    &lt;command&gt;UPDATE&lt;/&gt; or &lt;command&gt;INSERT&lt;/&gt;, as appropriate.  It is
    recommended that applications use &lt;command&gt;INSERT&lt;/&gt; with
    &lt;literal&gt;ON CONFLICT DO UPDATE&lt;/&gt; rather than actually using
    this pattern.  This example serves primarily to illustrate use of
    &lt;application&gt;PL/pgSQL&lt;/application&gt; control flow structures:
</span>
これは<code class="command">UPDATE</code>または<code class="command">INSERT</code>の実行における例外処理を使用した適当な例題です。
アプリケーションでは実際にこの方式を使うよりも、<code class="literal">ON CONFLICT DO UPDATE</code>を伴った<code class="command">INSERT</code>を使うことが推奨されます。本例は主として<span class="application">PL/pgSQL</span>の制御構造の使い方を示すものです。
</p><pre class="programlisting">CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP<span class="original">
        &amp;#045;&amp;#045; first try to update the key
</span>
        -- 最初にキーを更新する
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;<span class="original">
        &amp;#045;&amp;#045; not there, so try to insert the key
        &amp;#045;&amp;#045; if someone else inserts the same key concurrently,
        &amp;#045;&amp;#045; we could get a unique-key failure
</span>
        -- キーが存在しないので、キーの挿入を試行する
        -- 他者がすでに同一のキーを挿入していたならば
        -- 一意性に違反する欠陥となります
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN<span class="original">
        &amp;#045;&amp;#045; Do nothing, and loop to try the UPDATE again.
</span>
        -- 何もしないで、更新を再試行します
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');</pre><p>
<span class="original">
     This coding assumes the &lt;literal&gt;unique_violation&lt;/&gt; error is caused by
     the &lt;command&gt;INSERT&lt;/&gt;, and not by, say, an &lt;command&gt;INSERT&lt;/&gt; in a
     trigger function on the table.  It might also misbehave if there is
     more than one unique index on the table, since it will retry the
     operation regardless of which index caused the error.
     More safety could be had by using the
     features discussed next to check that the trapped error was the one
     expected.
</span>
このコーディングでは<code class="literal">unique_violation</code>エラーの原因が<code class="command">INSERT</code>によるものであり、テーブルのトリガ関数内部の<code class="command">INSERT</code>によるものでないと仮定します。
また、テーブルに2つ以上の一意インデックスが存在した場合、どちらのインデックスがエラーの原因になろうと操作を再試行するので、誤作動となります。
捕捉したエラーが予測したものであるか検証するために、次節で記述するエラー情報を利用すれば、より安全となります。
    </p></div></div><br class="example-break" /><div class="sect3" id="plpgsql-exception-diagnostics"><div class="titlepage"><div><div><h4 class="title">40.6.6.1. エラーに関する情報の取得</h4></div></div></div><span class="original">
    &lt;title&gt;Obtaining Information About an Error&lt;/title&gt;
</span><p><span class="original">
     Exception handlers frequently need to identify the specific error that
     occurred.  There are two ways to get information about the current
     exception in &lt;application&gt;PL/pgSQL&lt;/&gt;: special variables and the
     &lt;command&gt;GET STACKED DIAGNOSTICS&lt;/command&gt; command.
</span>例外ハンドラはしばしば、起こった特定のエラーを識別する必要があります。
現在の例外に関する情報を取得する方法は2つあります。
特殊な変数と<code class="command">GET STACKED DIAGNOSTICS</code>コマンドです。
    </p><p><span class="original">
     Within an exception handler, the special variable
     &lt;varname&gt;SQLSTATE&lt;/varname&gt; contains the error code that corresponds to
     the exception that was raised (refer to &lt;xref linkend="errcodes-table"&gt;
     for a list of possible error codes). The special variable
     &lt;varname&gt;SQLERRM&lt;/varname&gt; contains the error message associated with the
     exception. These variables are undefined outside exception handlers.
</span>例外ハンドラの内部では、特殊な変数<code class="varname">SQLSTATE</code>変数が起こった例外に対応したエラーコード（<a class="xref" href="errcodes-appendix.html#errcodes-table" title="表A.1 PostgreSQLエラーコード">表A.1「<span class="productname">PostgreSQL</span>エラーコード」</a>のエラーコード表を参照してください）を保有します。
特殊な変数<code class="varname">SQLERRM</code>は例外に関連したエラーメッセージを保有します。
これらの変数は、例外ハンドラの外部では定義されていません。
    </p><p><span class="original">
     Within an exception handler, one may also retrieve
     information about the current exception by using the
     &lt;command&gt;GET STACKED DIAGNOSTICS&lt;/command&gt; command, which has the form:
</span>例外ハンドラの内部では、<code class="command">GET STACKED DIAGNOSTICS</code>コマンドを使用して、現在の例外に関する情報を取り出すこともできます。
次のようなやり方となります。

</p><pre class="synopsis">GET STACKED DIAGNOSTICS <em class="replaceable"><code>variable</code></em> { = | := } <em class="replaceable"><code>item</code></em> [<span class="optional"> , ... </span>];</pre><p>
<span class="original">
     Each &lt;replaceable&gt;item&lt;/replaceable&gt; is a key word identifying a status
     value to be assigned to the specified &lt;replaceable&gt;variable&lt;/replaceable&gt;
     (which should be of the right data type to receive it).  The currently
     available status items are shown
     in &lt;xref linkend="plpgsql-exception-diagnostics-values"&gt;.
</span>
各<em class="replaceable"><code>item</code></em>は、指定された変数（これは受け取るために正しいデータ型でなければなりません）に代入される状態値を識別するキーワードです。
現在使用可能なステータス項目は<a class="xref" href="plpgsql-control-structures.html#plpgsql-exception-diagnostics-values" title="表40.2 エラーの診断値">表40.2「エラーの診断値」</a>に表示されています。
    </p><div class="table" id="plpgsql-exception-diagnostics-values"><p class="title"><strong>表40.2 エラーの診断値</strong></p><div class="table-contents"><span class="original">
      &lt;title&gt;Error Diagnostics Items&lt;/title&gt;
</span><table summary="エラーの診断値" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名前</th><th>型</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">RETURNED_SQLSTATE</code></td><td><code class="type">text</code></td><td>例外のSQLSTATEエラーコード</td></tr><tr><td><code class="literal">COLUMN_NAME</code></td><td><code class="type">text</code></td><td>例外に関する列名</td></tr><tr><td><code class="literal">CONSTRAINT_NAME</code></td><td><code class="type">text</code></td><td>例外に関する制約名</td></tr><tr><td><code class="literal">PG_DATATYPE_NAME</code></td><td><code class="type">text</code></td><td>例外に関するデータ型名</td></tr><tr><td><code class="literal">MESSAGE_TEXT</code></td><td><code class="type">text</code></td><td>例外の主要なメッセージのテキスト</td></tr><tr><td><code class="literal">TABLE_NAME</code></td><td><code class="type">text</code></td><td>例外に関するテーブル名</td></tr><tr><td><code class="literal">SCHEMA_NAME</code></td><td><code class="type">text</code></td><td>例外に関するスキーマ名</td></tr><tr><td><code class="literal">PG_EXCEPTION_DETAIL</code></td><td><code class="type">text</code></td><td>例外の詳細なメッセージのテキスト、存在する場合</td></tr><tr><td><code class="literal">PG_EXCEPTION_HINT</code></td><td><code class="type">text</code></td><td>例外のヒントとなるメッセージのテキスト、存在する場合</td></tr><tr><td><code class="literal">PG_EXCEPTION_CONTEXT</code></td><td><code class="type">text</code></td><td>呼び出しスタックを記述するテキストの行 ★変更あり</td></tr></tbody></table></div></div><br class="table-break" /><p><span class="original">
     If the exception did not set a value for an item, an empty string
     will be returned.
</span>例外が項目の値を設定しない場合、空文字列が返されます。
    </p><p><span class="original">
     Here is an example:
</span>以下に例を示します。
</p><pre class="programlisting">DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN<span class="original">
  &amp;#045;&amp;#045; some processing which might cause an exception
</span>
  -- 例外を引き起こす処理
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;</pre><p>
    </p></div></div><div class="sect2" id="plpgsql-call-stack"><div class="titlepage"><div><div><h3 class="title">40.6.7. 最新実行情報の取得 ★変更あり</h3></div></div></div><span class="original">
   &lt;title&gt;Obtaining Execution Location Information&lt;/title&gt;
</span><p><span class="original">
    The &lt;command&gt;GET DIAGNOSTICS&lt;/command&gt; command, previously described
    in &lt;xref linkend="plpgsql-statements-diagnostics"&gt;, retrieves information
    about current execution state (whereas the &lt;command&gt;GET STACKED
    DIAGNOSTICS&lt;/command&gt; command discussed above reports information about
    the execution state as of a previous error).  Its &lt;literal&gt;PG_CONTEXT&lt;/&gt;
    status item is useful for identifying the current execution
    location.  &lt;literal&gt;PG_CONTEXT&lt;/&gt; returns a text string with line(s)
    of text describing the call stack.  The first line refers to the current
    function and currently executing &lt;command&gt;GET DIAGNOSTICS&lt;/command&gt;
    command.  The second and any subsequent lines refer to calling functions
    further up the call stack.  For example:
</span>現在、1つの情報項目だけがサポートされています。
<code class="literal">PG_CONTEXT</code>ステータス項目はテキスト文字列を返し、テキストの行数が呼び出しスタックの段数となります。
最初の行は最新の関数と現在実行中の<code class="command">GET DIAGNOSTICS</code>コマンドを参照します。
次行および後の行は、呼び出しスタック上の呼び出し関数を参照します。
例を示します。 ★変更あり

</p><pre class="programlisting">CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Call Stack ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Call Stack ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)</pre><p>

   </p><p>    <code class="literal">GET STACKED DIAGNOSTICS ... PG_EXCEPTION_CONTEXT</code>
    returns the same sort of stack trace, but describing the location
    at which an error was detected, rather than the current location.
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="plpgsql-statements.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="plpgsql.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="plpgsql-cursors.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">40.5. 基本的な文 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 40.7. カーソル</td></tr></table></div></body></html>