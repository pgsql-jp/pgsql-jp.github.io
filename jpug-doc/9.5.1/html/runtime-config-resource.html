<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.4. 資源の消費</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.5.1文書" /><link rel="up" href="runtime-config.html" title="第18章 サーバの設定" /><link rel="prev" href="runtime-config-connection.html" title="18.3. 接続と認証" /><link rel="next" href="runtime-config-wal.html" title="18.5. ログ先行書き込み（WAL）" /><link rel="copyright" href="legalnotice.html" title="法的告知" /><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.5.1文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.5.1 runtime-config-resource.html">誤訳等の報告</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="runtime-config-connection.html">戻る</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="runtime-config.html">上に戻る</a></td><td width="60%" align="center">18.4. 資源の消費</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="runtime-config-wal.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="runtime-config-resource"><div class="titlepage"><div><div><h2 class="title" style="clear: both">18.4. 資源の消費</h2></div></div></div><span class="original">
    &lt;title&gt;Resource Consumption&lt;/title&gt;
    </span><div class="sect2" id="runtime-config-resource-memory"><div class="titlepage"><div><div><h3 class="title">18.4.1. メモリ</h3></div></div></div><span class="original">
     &lt;title&gt;Memory&lt;/title&gt;
     </span><div class="variablelist"><dl class="variablelist"><dt id="guc-shared-buffers"><span class="term"><code class="varname">shared_buffers</code> (<code class="type">integer</code>)
      <a id="idp73484832" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Sets the amount of memory the database server uses for shared
        memory buffers.  The default is typically 128 megabytes
        (&lt;literal&gt;128MB&lt;/&gt;), but might be less if your kernel settings will
        not support it (as determined during &lt;application&gt;initdb&lt;/&gt;).
        This setting must be at least 128 kilobytes.  (Non-default
        values of &lt;symbol&gt;BLCKSZ&lt;/symbol&gt; change the minimum.)  However,
        settings significantly higher than the minimum are usually needed
        for good performance.  This parameter can only be set at server start.
       </span>
       データベースサーバが使用する共有メモリバッファのために使用するメモリ量を設定します。
デフォルトは一般的に128メガバイト(<code class="literal">128MB</code>)です。しかし、稼働中のカーネルの設定が（<span class="application">initdb</span>の過程で決定されます）この値をサポートしていない場合、より少なくなることがあります。
この設定は最低限128キロバイトなければなりません。（デフォルト値以外の<code class="symbol">BLCKSZ</code>でこの最小値は変化します。）しかし、良い性能を引き出すためには、最小値よりかなり高い値の設定が通例必要です。このパラメータはサーバ起動時にのみ設定可能です。
       </p><p>       <span class="original">
        If you have a dedicated database server with 1GB or more of RAM, a
        reasonable starting value for &lt;varname&gt;shared_buffers&lt;/varname&gt; is 25%
        of the memory in your system.  There are some workloads where even
        large settings for &lt;varname&gt;shared_buffers&lt;/varname&gt; are effective, but
        because &lt;productname&gt;PostgreSQL&lt;/productname&gt; also relies on the
        operating system cache, it is unlikely that an allocation of more than
        40% of RAM to &lt;varname&gt;shared_buffers&lt;/varname&gt; will work better than a
        smaller amount.  Larger settings for &lt;varname&gt;shared_buffers&lt;/varname&gt;
        usually require a corresponding increase in
        &lt;varname&gt;max_wal_size&lt;/varname&gt;, in order to spread out the
        process of writing large quantities of new or changed data over a
        longer period of time.
       </span>
       1GBまたはそれより多いRAMを載せた専用データベースサーバを使用している場合、<code class="varname">shared_buffers</code>に対する妥当な初期値はシステムメモリの25%です。
       <code class="varname">shared_buffers</code>をこれよりも大きな値に設定することが有効なワークロードもあります。
       しかし、<span class="productname">PostgreSQL</span>はオペレーティングシステムキャッシュにも依存するため、<code class="varname">shared_buffers</code>にRAMの40%以上を割り当てても、それより小さい値の時より動作が良くなる見込みはありません。
        <code class="varname">shared_buffers</code>をより大きく設定する場合は、大抵<code class="varname">max_wal_size</code>も合わせて増やす必要があります。これは、新規または変更された多量のデータを書き出す処理をより長い時間に渡って分散させるためです。
       </p><p>       <span class="original">
        On systems with less than 1GB of RAM, a smaller percentage of RAM is
        appropriate, so as to leave adequate space for the operating system.
        Also, on Windows, large values for &lt;varname&gt;shared_buffers&lt;/varname&gt;
        aren't as effective.  You may find better results keeping the setting
        relatively low and using the operating system cache more instead.  The
        useful range for &lt;varname&gt;shared_buffers&lt;/varname&gt; on Windows systems
        is generally from 64MB to 512MB.
       </span>
       1GB以下のRAMのシステムでは、オペレーティングシステムに十分な余裕を残すために、RAMに対してより小さい割合を設定することが適切です。同様に、Windowsでは<code class="varname">shared_buffers</code>に対し大きな値を設定することは有効でありません。設定値を比較的小さく保ち、代わりにオペレーティングシステムのキャッシュを使用することが、より良い結果になるでしょう。Windowsシステムでの<code class="varname">shared_buffers</code>の範囲は一般的に64MBから512MBです。
       </p></dd><dt id="guc-huge-pages"><span class="term"><code class="varname">huge_pages</code> (<code class="type">enum</code>)
      <a id="idp73500016" class="indexterm"></a>
      </span></dt><dd><p><span class="original">
        Enables/disables the use of huge memory pages. Valid values are
        &lt;literal&gt;try&lt;/literal&gt; (the default), &lt;literal&gt;on&lt;/literal&gt;,
        and &lt;literal&gt;off&lt;/literal&gt;.
</span>        huge memoryページの利用を有効/無効にします。
        可能な値は
        <code class="literal">try</code> (デフォルト), <code class="literal">on</code>,
         <code class="literal">off</code>です。
       </p><p><span class="original">
        At present, this feature is supported only on Linux. The setting is
        ignored on other systems when set to &lt;literal&gt;try&lt;/literal&gt;.
</span>        今のところこの機能はLinuxでのみサポートされています。
        他のシステムでは<code class="literal">try</code>と設定しても無視されます。
       </p><p><span class="original">
        The use of huge pages results in smaller page tables and less CPU time
        spent on memory management, increasing performance. For more details,
        see &lt;xref linkend="linux-huge-pages"&gt;.
</span>        huge pageを使うと、ページテーブルが小さくなり、メモリ管理に使用されるCPU時間が少なくなり、性能が向上します。詳細は、<a class="xref" href="kernel-resources.html#linux-huge-pages" title="17.4.4. Linux huge pages">「Linux huge pages」</a>を見てください。
       </p><p><span class="original">
        With &lt;varname&gt;huge_pages&lt;/varname&gt; set to &lt;literal&gt;try&lt;/literal&gt;,
        the server will try to use huge pages, but fall back to using
        normal allocation if that fails. With &lt;literal&gt;on&lt;/literal&gt;, failure
        to use huge pages will prevent the server from starting up. With
        &lt;literal&gt;off&lt;/literal&gt;, huge pages will not be used.
</span>        <code class="varname">huge_pages</code>を<code class="literal">try</code>に設定すると、サーバはhuge pageの利用を試み、失敗すると通常のアロケーションを行います。
        <code class="literal">on</code>にすると、huge pageの利用に失敗した場合サーバは起動しなくなります。
        <code class="literal">off</code>にすると、huge pageは使用されません。
       </p></dd><dt id="guc-temp-buffers"><span class="term"><code class="varname">temp_buffers</code> (<code class="type">integer</code>)
      <a id="idp73513136" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Sets the maximum number of temporary buffers used by each database
        session.  These are session-local buffers used only for access to
        temporary tables.  The default is eight megabytes
        (&lt;literal&gt;8MB&lt;/&gt;).  The setting can be changed within individual
        sessions, but only before the first use of temporary tables
        within the session; subsequent attempts to change the value will
        have no effect on that session.
       </span>
       それぞれのデータベースセッションが使用する一時バッファの最大数を設定します。
        一時バッファは、一時テーブルにアクセスする時にのみ使用されるセッションローカルのバッファです。
        デフォルトは8メガバイト（<code class="literal">8MB</code>）です。
        設定はそれぞれのセッション内で変更できますが、そのセッション内の一時テーブルが最初に使用するまでになります。引き続いて値の変更を試みても、そのセッションでは効果がありません。
       </p><p>       <span class="original">
        A session will allocate temporary buffers as needed up to the limit
        given by &lt;varname&gt;temp_buffers&lt;/&gt;.  The cost of setting a large
        value in sessions that do not actually need many temporary
        buffers is only a buffer descriptor, or about 64 bytes, per
        increment in &lt;varname&gt;temp_buffers&lt;/&gt;.  However if a buffer is
        actually used an additional 8192 bytes will be consumed for it
        (or in general, &lt;symbol&gt;BLCKSZ&lt;/symbol&gt; bytes).
       </span>
        セッションは、<code class="varname">temp_buffers</code>を上限として、必要に応じて一時バッファを確保します。
        多くの一時バッファを実際に必要としないセッションで大きな値を設定するコストとは、<code class="varname">temp_buffers</code>の増分毎に、バッファ記述子分、バイトで言うと64バイトです。
        しかし、バッファが実際に使用されると、それに対して追加の8192バイト（または、通常<code class="symbol">BLCKSZ</code>バイト）が消費されます。
       </p></dd><dt id="guc-max-prepared-transactions"><span class="term"><code class="varname">max_prepared_transactions</code> (<code class="type">integer</code>)
      <a id="idp73522064" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Sets the maximum number of transactions that can be in the
        &lt;quote&gt;prepared&lt;/&gt; state simultaneously (see &lt;xref
        linkend="sql-prepare-transaction"&gt;).
        Setting this parameter to zero (which is the default)
        disables the prepared-transaction feature.
        This parameter can only be set at server start.
       </span>
       <span class="quote">「<span class="quote">プリペアド</span>」</span>状態におけるトランザクションの最大数を同時に設定します（<a class="xref" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION"><span class="refentrytitle">PREPARE TRANSACTION</span></a>を参照してください）。
このパラメータをゼロ（これがデフォルトです）に設定すると、プリペアドトランザクション機能を無効にします。
このパラメータはサーバ起動時にのみ設定可能です。
       </p><p>       <span class="original">
        If you are not planning to use prepared transactions, this parameter
        should be set to zero to prevent accidental creation of prepared
        transactions.  If you are using prepared transactions, you will
        probably want &lt;varname&gt;max_prepared_transactions&lt;/varname&gt; to be at
        least as large as &lt;xref linkend="guc-max-connections"&gt;, so that every
        session can have a prepared transaction pending.
       </span>
        プリペアドトランザクションの使用を意図しないのであれば、このパラメータはプリペアドトランザクションが偶然に作成されないようゼロに設定されなければなりません。プリペアドトランザクションを使用する場合、全てのセッションがプリペアドトランザクションを保留できるように、<code class="varname">max_prepared_transactions</code>を最低<a class="xref" href="runtime-config-connection.html#guc-max-connections">max_connections</a>と同じ大きさに設定しても構いません。
       </p><p>       <span class="original">
        When running a standby server, you must set this parameter to the
        same or higher value than on the master server. Otherwise, queries
        will not be allowed in the standby server.
       </span>
       スタンバイサーバを運用している場合、このパラメータはマスターサーバ上の設定よりも同等かもしくはより高水準に設定しなければなりません。そうしないと問い合わせがスタンバイサーバ内で受け入れられません。
       </p></dd><dt id="guc-work-mem"><span class="term"><code class="varname">work_mem</code> (<code class="type">integer</code>)
      <a id="idp73531888" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Specifies the amount of memory to be used by internal sort operations
        and hash tables before writing to temporary disk files. The value
        defaults to four megabytes (&lt;literal&gt;4MB&lt;/&gt;).
        Note that for a complex query, several sort or hash operations might be
        running in parallel; each operation will be allowed to use as much memory
        as this value specifies before it starts to write data into temporary
        files. Also, several running sessions could be doing such operations
        concurrently.  Therefore, the total memory used could be many
        times the value of &lt;varname&gt;work_mem&lt;/varname&gt;; it is necessary to
        keep this fact in mind when choosing the value. Sort operations are
        used for &lt;literal&gt;ORDER BY&lt;/&gt;, &lt;literal&gt;DISTINCT&lt;/&gt;, and
        merge joins.
        Hash tables are used in hash joins, hash-based aggregation, and
        hash-based processing of &lt;literal&gt;IN&lt;/&gt; subqueries.
       </span>
       一時ディスクファイルに書き込む前に、内部並べ替えとハッシュテーブル操作が使用するメモリ容量を指定します。
デフォルト値は4メガバイト（<code class="literal">4MB</code>）です。
        複雑な問い合わせの場合、いくつかの並び替えもしくはハッシュ操作が並行して実行されることに注意してください。
        それぞれの操作による一時メモリへの書き込み開始の前に、この値が指定するのと同じメモリ容量の使用をそれらの操作に許容します。さらに、いくつかの実行中のセッションはこれらの動作を同時に行います。したがって、使用されるメモリの合計は、<code class="varname">work_mem</code>の数倍になります。値を選択する時には、この事実に留意することが必要です。並び替え操作は<code class="literal">ORDER BY</code>、<code class="literal">DISTINCT</code>、およびマージ結合に対して使われます。ハッシュテーブルはハッシュ結合、ハッシュに基づいた集約、および<code class="literal">IN</code>副問い合わせのハッシュに基づいた処理で使用されます。
       </p></dd><dt id="guc-maintenance-work-mem"><span class="term"><code class="varname">maintenance_work_mem</code> (<code class="type">integer</code>)
      <a id="idp73541872" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Specifies the maximum amount of memory to be used by maintenance
        operations, such as &lt;command&gt;VACUUM&lt;/command&gt;, &lt;command&gt;CREATE
        INDEX&lt;/&gt;, and &lt;command&gt;ALTER TABLE ADD FOREIGN KEY&lt;/&gt;.  It defaults
        to 64 megabytes (&lt;literal&gt;64MB&lt;/&gt;).  Since only one of these
        operations can be executed at a time by a database session, and
        an installation normally doesn't have many of them running
        concurrently, it's safe to set this value significantly larger
        than &lt;varname&gt;work_mem&lt;/varname&gt;.  Larger settings might improve
        performance for vacuuming and for restoring database dumps.
       </span>
       <code class="command">VACUUM</code>、<code class="command">CREATE INDEX</code>、および<code class="command">ALTER TABLE ADD FOREIGN KEY</code>の様な保守操作で使用されるメモリの最大容量を指定します。
デフォルト値は16メガバイト（<code class="literal">16MB</code>）です。
1つのデータベースセッションでは、一度に1つしか上記操作はできませんし、通常インストレーションでこうした操作が同時に非常に多く発生することはありませんので、これを<code class="varname">work_mem</code>よりもかなり多めの値にしても安全です。
大きい値を設定することでvacuum処理と、ダンプしたデータベースのリストア性能が向上します。
       </p><p>       <span class="original">
        Note that when autovacuum runs, up to
        &lt;xref linkend="guc-autovacuum-max-workers"&gt; times this memory
        may be allocated, so be careful not to set the default value
        too high.  It may be useful to control for this by separately
        setting &lt;xref linkend="guc-autovacuum-work-mem"&gt;.
</span>
       オートバキュームを稼動させると、最大<a class="xref" href="runtime-config-autovacuum.html#guc-autovacuum-max-workers">autovacuum_max_workers</a>倍ほどこのメモリーが配分されるので、デフォルトの値をあまり高く設定しないよう注意することを覚えておいてください。
       別の設定項目<a class="xref" href="runtime-config-resource.html#guc-autovacuum-work-mem">autovacuum_work_mem</a>で制御するのが良いかもしれません。
       </p></dd><dt id="guc-autovacuum-work-mem"><span class="term"><code class="varname">autovacuum_work_mem</code> (<code class="type">integer</code>)
      <a id="idp73552912" class="indexterm"></a>
      </span></dt><dd><p><span class="original">
        Specifies the maximum amount of memory to be used by each
        autovacuum worker process.  It defaults to -1, indicating that
        the value of &lt;xref linkend="guc-maintenance-work-mem"&gt; should
        be used instead.  The setting has no effect on the behavior of
        &lt;command&gt;VACUUM&lt;/command&gt; when run in other contexts.
       </span>        個々の自動バキュームワーカプロセスが使用する最大のメモリ量を指定します。
デフォルトは-1で、<a class="xref" href="runtime-config-resource.html#guc-maintenance-work-mem">maintenance_work_mem</a>が代わりに使われる設定になります。
       別の文脈で実行される<code class="command">VACUUM</code>にはこの設定は影響しません。
       </p></dd><dt id="guc-max-stack-depth"><span class="term"><code class="varname">max_stack_depth</code> (<code class="type">integer</code>)
      <a id="idp73558944" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Specifies the maximum safe depth of the server's execution stack.
        The ideal setting for this parameter is the actual stack size limit
        enforced by the kernel (as set by &lt;literal&gt;ulimit -s&lt;/&gt; or local
        equivalent), less a safety margin of a megabyte or so.  The safety
        margin is needed because the stack depth is not checked in every
        routine in the server, but only in key potentially-recursive routines
        such as expression evaluation.  The default setting is two
        megabytes (&lt;literal&gt;2MB&lt;/&gt;), which is conservatively small and
        unlikely to risk crashes.  However, it might be too small to allow
        execution of complex functions.  Only superusers can change this
        setting.
       </span>
       サーバの実行スタックの最大安全深度を指定します。
このパラメータの理想的な設定はカーネルにより強要される実際のスタック容量の（<code class="literal">ulimit -s</code>もしくは局所での同等の値で設定された）限界から、1メガバイト程度の安全余地を差し引いたものです。
安全余地は、サーバが各ルーチンでスタック深度を検査をせず、式評価などの主要な潜在的に再帰的なルーチンの場合のみ必要となるものです。
デフォルト設定は2メガバイト（<code class="literal">2MB</code>）で、かなり控え目で、クラッシュの危険はなさそうです。
しかし、複雑な関数の実行を許容するには小さ過ぎるかも知れません。
スーパーユーザのみがこの設定を変更することができます。
       </p><p>       <span class="original">
        Setting &lt;varname&gt;max_stack_depth&lt;/&gt; higher than
        the actual kernel limit will mean that a runaway recursive function
        can crash an individual backend process.  On platforms where
        &lt;productname&gt;PostgreSQL&lt;/productname&gt; can determine the kernel limit,
        the server will not allow this variable to be set to an unsafe
        value.  However, not all platforms provide the information,
        so caution is recommended in selecting a value.
       </span>
       <code class="varname">max_stack_depth</code>を実際のカーネルの制限よりも高い値に設定した場合、暴走した再帰関数により、個々のバックエンドプロセスがクラッシュするかもしれません。
<span class="productname">PostgreSQL</span>がカーネルの制限を決定することができるプラットフォームでは、この変数を危険な値に設定させません。
しかし、すべてのプラットフォームがこの情報を提供できるわけではありません。
このため、値を選ぶ時には注意が必要です。
       </p></dd><dt id="guc-dynamic-shared-memory-type"><span class="term"><code class="varname">dynamic_shared_memory_type</code> (<code class="type">enum</code>)
      <a id="idp73569488" class="indexterm"></a>
      </span></dt><dd><p><span class="original">
        Specifies the dynamic shared memory implementation that the server
        should use.  Possible values are &lt;literal&gt;posix&lt;/&gt; (for POSIX shared
        memory allocated using &lt;literal&gt;shm_open&lt;/&gt;), &lt;literal&gt;sysv&lt;/literal&gt;
        (for System V shared memory allocated via &lt;literal&gt;shmget&lt;/&gt;),
        &lt;literal&gt;windows&lt;/&gt; (for Windows shared memory), &lt;literal&gt;mmap&lt;/&gt;
        (to simulate shared memory using memory-mapped files stored in the
        data directory), and &lt;literal&gt;none&lt;/&gt; (to disable this feature).
        Not all values are supported on all platforms; the first supported
        option is the default for that platform.  The use of the
        &lt;literal&gt;mmap&lt;/&gt; option, which is not the default on any platform,
        is generally discouraged because the operating system may write
        modified pages back to disk repeatedly, increasing system I/O load;
        however, it may be useful for debugging, when the
        &lt;literal&gt;pg_dynshmem&lt;/&gt; directory is stored on a RAM disk, or when
        other shared memory facilities are not available.
</span>        サーバが使う動的共有メモリの実装を指定します。可能な値は
        <code class="literal">posix</code> (<code class="literal">shm_open</code>で獲得するPOSIX共有メモリ)、
         <code class="literal">sysv</code>
        (<code class="literal">shmget</code>で獲得するSystem V共有メモリ)、
        <code class="literal">windows</code> (Windows共有メモリ)、 <code class="literal">mmap</code>
        (データディレクトリ内のメモリマップファイルを使ってシミュレートする共有メモリ)、
<code class="literal">none</code> (この機能を使用しない)です。
       すべての値がすべてのプラットフォームでサポートされているわけではありません。
       そのプラットフォームでの推奨実装がデフォルトになります。
       どのプラットフォームでもデフォルトになっていない<code class="literal">mmap</code>は、オペレーティングシステムが変更されたページをディスクに継続的に書き込み、I/O負荷を増加させるので一般的には利用が推奨されていません。
       しかし、デバッグ目的のために<code class="literal">pg_dynshmem</code>ディスクがRAMディスク上にある場合や、他の共有メモリ機能が使えない場合は有用かもしれません。
       </p></dd></dl></div></div><div class="sect2" id="runtime-config-resource-disk"><div class="titlepage"><div><div><h3 class="title">18.4.2. ディスク</h3></div></div></div><span class="original">
     &lt;title&gt;Disk&lt;/title&gt;
     </span><div class="variablelist"><dl class="variablelist"><dt id="guc-temp-file-limit"><span class="term"><code class="varname">temp_file_limit</code> (<code class="type">integer</code>)
      <a id="idp73583440" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Specifies the maximum amount of disk space that a session can use
        for temporary files, such as sort and hash temporary files, or the
        storage file for a held cursor.  A transaction attempting to exceed
        this limit will be canceled.
        The value is specified in kilobytes, and &lt;literal&gt;-1&lt;/&gt; (the
        default) means no limit.
        Only superusers can change this setting.
       </span>
       あるセッションが暫定ファイルとして使用できるディスクの最大容量を設定します。
       例えば、ソートやハッシュの一時ファイルであったり、カーソルを保持する格納ファイルです。
       この値を超えようとするトランザクションは無視されます。値はキロバイト単位で指定され、（デフォルトである） <code class="literal">-1</code> の場合は制限がありません。この設定はスーパユーザのみ可能です。
       </p><p>       <span class="original">
        This setting constrains the total space used at any instant by all
        temporary files used by a given &lt;productname&gt;PostgreSQL&lt;/&gt; session.
        It should be noted that disk space used for explicit temporary
        tables, as opposed to temporary files used behind-the-scenes in query
        execution, does &lt;emphasis&gt;not&lt;/emphasis&gt; count against this limit.
       </span>
       この設定により、ある与えられた <span class="productname">PostgreSQL</span> セッションにより使用される暫定ファイルの容量がいかなる場合にも制約されます。
       問い合わせの実行に裏舞台で使用される暫定ファイルとは対抗するように、明示的暫定テーブルに使用されるディスク容量はこの制限に不利に作用することは<span class="emphasis"><em>ありません</em></span>。
       
       </p></dd></dl></div></div><div class="sect2" id="runtime-config-resource-kernel"><div class="titlepage"><div><div><h3 class="title">18.4.3. カーネル資源使用</h3></div></div></div><span class="original">
     &lt;title&gt;Kernel Resource Usage&lt;/title&gt;
     </span><div class="variablelist"><dl class="variablelist"><dt id="guc-max-files-per-process"><span class="term"><code class="varname">max_files_per_process</code> (<code class="type">integer</code>)
      <a id="idp73593488" class="indexterm"></a>
      </span></dt><dd><p>       <span class="original">
        Sets the maximum number of simultaneously open files allowed to each
        server subprocess. The default is one thousand files. If the kernel is enforcing
        a safe per-process limit, you don't need to worry about this setting.
        But on some platforms (notably, most BSD systems), the kernel will
        allow individual processes to open many more files than the system
        can actually support if many processes all try to open
        that many files. If you find yourself seeing &lt;quote&gt;Too many open
        files&lt;/&gt; failures, try reducing this setting.
        This parameter can only be set at server start.
       </span>
       それぞれのサーバ子プロセスが同時にオープンできるファイル数の最大値をセットします。
デフォルトは1000ファイルです。
もしもカーネルがプロセス毎の安全制限を強要している場合、この設定を気にかける必要はありません。
しかし、いくつかのプラットフォーム（特にほとんどのBSDシステム）では、もし多くのプロセス全てがそれだけ多くのファイルを開くことを試みたとした場合、実際にサポートできるファイル数より多くのファイルを開くことを許しています。もしも<span class="quote">「<span class="quote">Too many open files</span>」</span>エラーが発生した場合、この設定を削減してみてください。
このパラメータはサーバ起動時にのみ設定可能です。
       </p></dd></dl></div></div><div class="sect2" id="runtime-config-resource-vacuum-cost"><div class="titlepage"><div><div><h3 class="title">18.4.4. コストに基づくVacuum遅延</h3></div></div></div><span class="original">
     &lt;title&gt;Cost-based Vacuum Delay&lt;/title&gt;
     </span><p>     <span class="original">
      During the execution of &lt;xref linkend="sql-vacuum"&gt;
      and &lt;xref linkend="sql-analyze"&gt;
      commands, the system maintains an
      internal counter that keeps track of the estimated cost of the
      various I/O operations that are performed.  When the accumulated
      cost reaches a limit (specified by
      &lt;varname&gt;vacuum_cost_limit&lt;/varname&gt;), the process performing
      the operation will sleep for a short period of time, as specified by
      &lt;varname&gt;vacuum_cost_delay&lt;/varname&gt;. Then it will reset the
      counter and continue execution.
      </span>
      <a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a> および <a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a> コマンドの実行中、実行される各種I/O操作の予測コストを追跡し続ける内部カウンタをシステムが保守します。
      累積されたコストが（<code class="varname">vacuum_cost_limit</code>で指定された）限度に達すると、操作を実行しているプロセスは<code class="varname">vacuum_cost_delay</code>で指定されたちょっとの間スリープします。その後、カウンタをリセットし、実行を継続します。
     </p><p>     <span class="original">
      The intent of this feature is to allow administrators to reduce
      the I/O impact of these commands on concurrent database
      activity. There are many situations where it is not
      important that maintenance commands like
      &lt;command&gt;VACUUM&lt;/command&gt; and &lt;command&gt;ANALYZE&lt;/command&gt; finish
      quickly; however, it is usually very important that these
      commands do not significantly interfere with the ability of the
      system to perform other database operations. Cost-based vacuum
      delay provides a way for administrators to achieve this.
      </span>
      この機能の目的は、同時実行的データベース活動上のこれらコマンドのI/Oに対する影響を管理者から軽減させます。
      <code class="command">VACUUM</code> および <code class="command">ANALYZE</code>の様な保守用コマンドが即座に終了することが重要ではない事態が数多くあります。
      しかし、他のデータベースの操作を行うに当たって、これらのコマンドがシステムの能力に多大な阻害を与えないことは通常とても重要です。
      コストに基づいたvacuum遅延はこれを実現するための方法を管理者に提供します。
     </p><p>     <span class="original">
      This feature is disabled by default for manually issued
      &lt;command&gt;VACUUM&lt;/command&gt; commands. To enable it, set the
      &lt;varname&gt;vacuum_cost_delay&lt;/varname&gt; variable to a nonzero
      value.
      </span>
      手動で<code class="command">VACUUM</code>コマンドを実行することができるように、デフォルトでこの機能は無効になっています。
      有効にするには、<code class="varname">vacuum_cost_delay</code>変数をゼロでない値に設定します。
     </p><div class="variablelist"><dl class="variablelist"><dt id="guc-vacuum-cost-delay"><span class="term"><code class="varname">vacuum_cost_delay</code> (<code class="type">integer</code>)
       <a id="idp73611088" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The length of time, in milliseconds, that the process will sleep
         when the cost limit has been exceeded.
         The default value is zero, which disables the cost-based vacuum
         delay feature.  Positive values enable cost-based vacuuming.
         Note that on many systems, the effective resolution
         of sleep delays is 10 milliseconds; setting
         &lt;varname&gt;vacuum_cost_delay&lt;/varname&gt; to a value that is
         not a multiple of 10 might have the same results as setting it
         to the next higher multiple of 10.
        </span>
        コストの限度を越えた場合、プロセスがスリープするミリ秒単位の時間の長さです。
デフォルトの値は0で、コストに基づいたvacuum遅延機能を無効にします。
正の整数はコストに基づいたvacuumを有効にします。
多くのシステムで、スリープ遅延の有効な分解能は10ミリ秒です。
<code class="varname">vacuum_cost_delay</code>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
        </p><p>       <span class="original">
         When using cost-based vacuuming, appropriate values for
         &lt;varname&gt;vacuum_cost_delay&lt;/&gt; are usually quite small, perhaps
         10 or 20 milliseconds.  Adjusting vacuum's resource consumption
         is best done by changing the other vacuum cost parameters.
        </span>
        コストに基づいたバキューム処理を使用する場合、<code class="varname">vacuum_cost_delay</code>の適切な値は通常かなり小さくなり、たいていは10または20ミリ秒になります。
        バキュームによるリソース消費の調整は、他のバキュームのコストパラメータを変更して行うことが最善です。
        </p></dd><dt id="guc-vacuum-cost-page-hit"><span class="term"><code class="varname">vacuum_cost_page_hit</code> (<code class="type">integer</code>)
       <a id="idp73618608" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The estimated cost for vacuuming a buffer found in the shared buffer
         cache. It represents the cost to lock the buffer pool, lookup
         the shared hash table and scan the content of the page. The
         default value is one.
        </span>
        共有バッファキャッシュの中のバッファにvacuumを掛ける予測コストです。バッファプールのロック、共有ハッシュテーブルの検索、およびページ内容走査のコストを示します。デフォルトの値は1です。
        </p></dd><dt id="guc-vacuum-cost-page-miss"><span class="term"><code class="varname">vacuum_cost_page_miss</code> (<code class="type">integer</code>)
       <a id="idp73623344" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The estimated cost for vacuuming a buffer that has to be read from
         disk.  This represents the effort to lock the buffer pool,
         lookup the shared hash table, read the desired block in from
         the disk and scan its content. The default value is 10.
        </span>
        ディスクから読み込まれなければならないバッファにvacuumを掛ける予測コストです。これが示すものは、バッファプールロックの試み、共有ハッシュテーブルの参照、ディスクから目的ブロックの読み込み、そしてその内容走査です。デフォルトの値は10です。
        </p></dd><dt id="guc-vacuum-cost-page-dirty"><span class="term"><code class="varname">vacuum_cost_page_dirty</code> (<code class="type">integer</code>)
       <a id="idp73628224" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The estimated cost charged when vacuum modifies a block that was
         previously clean. It represents the extra I/O required to
         flush the dirty block out to disk again. The default value is
         20.
        </span>
        vacuumが、先だって掃除したブロックを変更する時に果たされた予測コストです。
        ダーティブロックを再度ディスクに吐き出すのに必要な余分なI/Oを表します。デフォルトの値は20です。
        </p></dd><dt id="guc-vacuum-cost-limit"><span class="term"><code class="varname">vacuum_cost_limit</code> (<code class="type">integer</code>)
       <a id="idp73632880" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The accumulated cost that will cause the vacuuming process to sleep.
         The default value is 200.
        </span>
        vacuumを掛けるプロセスをスリープさせることになる累計されたコストです。
        デフォルトの値は200です。
        </p></dd></dl></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>      <span class="original">
       There are certain operations that hold critical locks and should
       therefore complete as quickly as possible.  Cost-based vacuum
       delays do not occur during such operations.  Therefore it is
       possible that the cost accumulates far higher than the specified
       limit.  To avoid uselessly long delays in such cases, the actual
       delay is calculated as &lt;varname&gt;vacuum_cost_delay&lt;/varname&gt; *
       &lt;varname&gt;accumulated_balance&lt;/varname&gt; /
       &lt;varname&gt;vacuum_cost_limit&lt;/varname&gt; with a maximum of
       &lt;varname&gt;vacuum_cost_delay&lt;/varname&gt; * 4.
       </span>
重要なロックを保有し可能なかぎり早急に完了しなければならないある種の操作があります。コストに基づいたvacuum遅延はこの様な操作では起こりません。
したがって、コストの累計が指定された限度をかなり高く越える可能性があります。
このような場合無駄な長い遅延を防止するため、実際の遅延は<code class="varname">vacuum_cost_delay</code> * 4 を上限として、以下のように計算されます。
       <code class="varname">vacuum_cost_delay</code> * <code class="varname">accumulated_balance</code> / <code class="varname">vacuum_cost_limit</code>
      </p></div></div><div class="sect2" id="runtime-config-resource-background-writer"><div class="titlepage"><div><div><h3 class="title">18.4.5. バックグラウンドライタ</h3></div></div></div><span class="original">
     &lt;title&gt;Background Writer&lt;/title&gt;
     </span><p>     <span class="original">
      There is a separate server
      process called the &lt;firstterm&gt;background writer&lt;/&gt;, whose function
      is to issue writes of &lt;quote&gt;dirty&lt;/&gt; (new or modified) shared
      buffers.  It writes shared buffers so server processes handling
      user queries seldom or never need to wait for a write to occur.
      However, the background writer does cause a net overall
      increase in I/O load, because while a repeatedly-dirtied page might
      otherwise be written only once per checkpoint interval, the
      background writer might write it several times as it is dirtied
      in the same interval.  The parameters discussed in this subsection
      can be used to tune the behavior for local needs.
      </span>
      <em class="firstterm">バックグラウンドライタ</em>と呼ばれる個別のサーバプロセスがあり、その機能は（新規または更新された）<span class="quote">「<span class="quote">ダーティ</span>」</span>な共有バッファの書き込みを行うことです。
それは共有バッファを書き込むため、ユーザの問い合わせを処理するサーバプロセスは書き込みが発生するまでごくたまに、あるいは決して待ち状態になりません。
しかし、バックグラウンドライタはI/O読み込みに対し正味の全体的増加の原因になります。その理由は、繰り返しダーティ化されるページはチェックポイント間隔で一度だけ書き出される可能性がある一方、バックグラウンドライタは同じ間隔内でダーティ化されるごとにそれを複数回書き出します。
本節で説明したこのパラメータはサイト独自の必要に応じて動作を調整することに使用できます。
     </p><div class="variablelist"><dl class="variablelist"><dt id="guc-bgwriter-delay"><span class="term"><code class="varname">bgwriter_delay</code> (<code class="type">integer</code>)
       <a id="idp73645808" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         Specifies the delay between activity rounds for the
         background writer.  In each round the writer issues writes
         for some number of dirty buffers (controllable by the
         following parameters).  It then sleeps for &lt;varname&gt;bgwriter_delay&lt;/&gt;
         milliseconds, and repeats.  When there are no dirty buffers in the
         buffer pool, though, it goes into a longer sleep regardless of
         &lt;varname&gt;bgwriter_delay&lt;/&gt;.  The default value is 200
         milliseconds (&lt;literal&gt;200ms&lt;/&gt;). Note that on many systems, the
         effective resolution of sleep delays is 10 milliseconds; setting
         &lt;varname&gt;bgwriter_delay&lt;/&gt; to a value that is not a multiple of 10
         might have the same results as setting it to the next higher multiple
         of 10.  This parameter can only be set in the
         &lt;filename&gt;postgresql.conf&lt;/&gt; file or on the server command line.
        </span>
        バックグラウンドライタの動作周期間の遅延を指定します。
それぞれの周期でライタは、（以下のパラメータで管理される）一部のダーティバッファの書き込みを行います。
そして<code class="varname">bgwriter_delay</code>ミリ秒スリープした後、これを繰りかえします。
しかし、バッファプールにダーティバッファが存在しない場合、<code class="varname">bgwriter_delay</code>に係わらずより長くスリープします。
デフォルトの値は200ミリ秒（<code class="literal">200ms</code>）です。
多くのシステムで、スリープ遅延の実精度は10ミリ秒です。
<code class="varname">bgwriter_delay</code>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインで設定可能です。

        </p></dd><dt id="guc-bgwriter-lru-maxpages"><span class="term"><code class="varname">bgwriter_lru_maxpages</code> (<code class="type">integer</code>)
       <a id="idp73654624" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         In each round, no more than this many buffers will be written
         by the background writer.  Setting this to zero disables
         background writing.  (Note that checkpoints, which are managed by
         a separate, dedicated auxiliary process, are unaffected.)
         The default value is 100 buffers.
         This parameter can only be set in the &lt;filename&gt;postgresql.conf&lt;/&gt;
         file or on the server command line.
        </span>
        それぞれの周期で、この数以上のバッファはバックグラウンドライタにより書き込まれません。
         ゼロに設定することでバックグラウンド書き込みは無効になります。
        （分離し、そして専用の補助プロセスにより管理されるチェックポイントは影響を受けません。）
         デフォルト値は100バッファです。
         このパラメータは<code class="filename">postgresql.conf</code>ファイル内、または、サーバのコマンドラインでのみで設定可能です。
        </p></dd><dt id="guc-bgwriter-lru-multiplier"><span class="term"><code class="varname">bgwriter_lru_multiplier</code> (<code class="type">floating point</code>)
       <a id="idp73660448" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         The number of dirty buffers written in each round is based on the
         number of new buffers that have been needed by server processes
         during recent rounds.  The average recent need is multiplied by
         &lt;varname&gt;bgwriter_lru_multiplier&lt;/&gt; to arrive at an estimate of the
         number of buffers that will be needed during the next round.  Dirty
         buffers are written until there are that many clean, reusable buffers
         available.  (However, no more than &lt;varname&gt;bgwriter_lru_maxpages&lt;/&gt;
         buffers will be written per round.)
         Thus, a setting of 1.0 represents a &lt;quote&gt;just in time&lt;/&gt; policy
         of writing exactly the number of buffers predicted to be needed.
         Larger values provide some cushion against spikes in demand,
         while smaller values intentionally leave writes to be done by
         server processes.
         The default is 2.0.
         This parameter can only be set in the &lt;filename&gt;postgresql.conf&lt;/&gt;
         file or on the server command line.
        </span>
        各周期で書き出されるダーティバッファ数は、最近の周期でサーバプロセスが必要とした新しいバッファ数を基にします。
次の周期で必要となるバッファ数を推定するために、最近必要とされた平均が<code class="varname">bgwriter_lru_multiplier</code>と掛け合わせられます。
ダーティバッファの書き出しは、同数の整理済み、再利用可能なバッファが利用できるようになるまで行われます。
（しかし1周期に<code class="varname">bgwriter_lru_maxpages</code>を越えるバッファ数を書き出しません。）
したがって、1.0と設定することは、必要と予想されるバッファ数の書き込みについて<span class="quote">「<span class="quote">必要なときに必要なだけ</span>」</span>というポリシーを表します。
より大きな値は突発的な要求に対する多少の緩衝材を提供します。
より小さな値はサーバプロセスでなされる書き込みを意図的に残します。
デフォルトは2.0です。
このパラメータは<code class="filename">postgresql.conf</code>ファイル、または、サーバのコマンドラインでのみで設定可能です。
        </p></dd></dl></div><p>     <span class="original">
      Smaller values of &lt;varname&gt;bgwriter_lru_maxpages&lt;/varname&gt; and
      &lt;varname&gt;bgwriter_lru_multiplier&lt;/varname&gt; reduce the extra I/O load
      caused by the background writer, but make it more likely that server
      processes will have to issue writes for themselves, delaying interactive
      queries.
      </span>
      <code class="varname">bgwriter_lru_maxpages</code>および<code class="varname">bgwriter_lru_multiplier</code>の値がより少ないと、バックグラウンドライタで引き起こされる追加のI/O負荷を軽減しますが、サーバプロセスが自分自身で行わなければならない書き込みが増加することになり、会話型問い合わせを遅らせることになります。
     </p></div><div class="sect2" id="runtime-config-resource-async-behavior"><div class="titlepage"><div><div><h3 class="title">18.4.6. 非同期動作</h3></div></div></div><span class="original">
     &lt;title&gt;Asynchronous Behavior&lt;/title&gt;
     </span><div class="variablelist"><dl class="variablelist"><dt id="guc-effective-io-concurrency"><span class="term"><code class="varname">effective_io_concurrency</code> (<code class="type">integer</code>)
       <a id="idp73672352" class="indexterm"></a>
       </span></dt><dd><p>       <span class="original">
         Sets the number of concurrent disk I/O operations that
         &lt;productname&gt;PostgreSQL&lt;/&gt; expects can be executed
         simultaneously.  Raising this value will increase the number of I/O
         operations that any individual &lt;productname&gt;PostgreSQL&lt;/&gt; session
         attempts to initiate in parallel.  The allowed range is 1 to 1000,
         or zero to disable issuance of asynchronous I/O requests. Currently,
         this setting only affects bitmap heap scans.
        </span>
        <span class="productname">PostgreSQL</span>が同時処理を予定している同時実行ディスクI/O作業の数を設定します。この値を大きくすると、あらゆる個別の<span class="productname">PostgreSQL</span>セッションが並行して開始を試みるI/O作業数が増加します。許容範囲は1から1000まで、または非同期I/Oリクエストの発行を無効にするゼロです。
        現在、この設定はビットマップヒープスキャンのみに有効です。
        </p><p>       <span class="original">
         A good starting point for this setting is the number of separate
         drives comprising a RAID 0 stripe or RAID 1 mirror being used for the
         database.  (For RAID 5 the parity drive should not be counted.)
         However, if the database is often busy with multiple queries issued in
         concurrent sessions, lower values may be sufficient to keep the disk
         array busy.  A value higher than needed to keep the disks busy will
         only result in extra CPU overhead.
        </span>
        この設定の開始点として優れた値は、データベースに使用されるRAID 0ストライプ、RAID 1ミラーを構成する個々のドライブ数です。
        （RAID 5ではパリティ用のドライブを数に含めてはなりません。）
        しかし、同時実行セッションで発行される複数の問い合わせでデータベースが頻繁にビジーとなる場合、ディスクアレイのビジー率を抑えるために、より小さな値で十分であるかもしれません。
        ディスクをビジーにするのに必要な値より大きな値を設定しても、余計なCPUオーバーヘッドを発生させるだけです。
        </p><p>       <span class="original">
         For more exotic systems, such as memory-based storage or a RAID array
         that is limited by bus bandwidth, the correct value might be the
         number of I/O paths available.  Some experimentation may be needed
         to find the best value.
        </span>
        メモリベースのストレージやバス帯域幅で制限されたRAIDアレイなどの、より斬新なシステムにおける正しい値は利用できるI/Oパスの数となるかもしれません。
        最善の値を見つけ出すには、何らかの実験が必要かもしれません。
        </p><p>       <span class="original">
         Asynchronous I/O depends on an effective &lt;function&gt;posix_fadvise&lt;/&gt;
         function, which some operating systems lack.  If the function is not
         present then setting this parameter to anything but zero will result
         in an error.  On some operating systems (e.g., Solaris), the function
         is present but does not actually do anything.
        </span>
        非同期I/Oは実質的に<code class="function">posix_fadvise</code>関数に依存します。
        これは一部のオペレーティングシステムには存在しません。
        この関数が存在しない場合、この値をゼロ以外に設定するとエラーとなります。
        一部のオペレーティングシステム（例えばSolaris）では存在するけれども、実際何も行わないものもあります。
        </p><p><span class="original">
         The default is 1 on supported systems, otherwise 0.
</span>デフォルトは、サポートされているシステムでは1、そうでなければ0です。
        </p></dd><dt id="guc-max-worker-processes"><span class="term"><code class="varname">max_worker_processes</code> (<code class="type">integer</code>)
       <a id="idp73685968" class="indexterm"></a>
       </span></dt><dd><p><span class="original">
         Sets the maximum number of background processes that the system
         can support.  This parameter can only be set at server start.
</span>         システムがサポートするバックグラウンドプロセスの最大数を指定します。
         このパラメータはサーバ起動時にのみ設定できます。
        </p><p><span class="original">
         When running a standby server, you must set this parameter to the
         same or higher value than on the master server. Otherwise, queries
         will not be allowed in the standby server.
</span>         スタンバイサーバを起動しているときは、このパラメータを、マスタサーバの設定値と同じかそれ以上にしなければなりません。さもなければ、スタンバイサーバで問い合わせの実行ができなくなります。
        </p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-connection.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-wal.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">18.3. 接続と認証 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 18.5. ログ先行書き込み（WAL）</td></tr></table></div></body></html>