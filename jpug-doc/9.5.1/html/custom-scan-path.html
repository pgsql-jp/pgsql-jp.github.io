<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>56.1. カスタムスキャンパスの作成</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.5.1文書" /><link rel="up" href="custom-scan.html" title="第56章 カスタムスキャンプロバイダの作成" /><link rel="prev" href="custom-scan.html" title="第56章 カスタムスキャンプロバイダの作成" /><link rel="next" href="custom-scan-plan.html" title="56.2. カスタムスキャン計画の作成" /><link rel="copyright" href="legalnotice.html" title="法的告知" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">PostgreSQL 9.5.1文書</a></th><td width="20%" align="right"><div class="actions"><a class="issue" href="https://github.com/pgsql-jp/jpug-doc/issues/new?title=version 9.5.1 custom-scan-path.html">New Issue</a></div></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="custom-scan.html">戻る</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="custom-scan.html">上に戻る</a></td><td width="60%" align="center">56.1. カスタムスキャンパスの作成</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="custom-scan-plan.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="custom-scan-path"><div class="titlepage"><div><div><h2 class="title" style="clear: both">56.1. カスタムスキャンパスの作成</h2></div></div></div><span class="original">
  &lt;title&gt;Creating Custom Scan Paths&lt;/title&gt;
</span><p><span class="original">
    A custom scan provider will typically add paths for a base relation by
    setting the following hook, which is called after the core code has
    generated what it believes to be the complete and correct set of access
    paths for the relation.
</span>カスタムスキャンプロバイダは、典型的には、以下のフックを設定することでベースのリレーションのためのパスを追加します。
このフックはコアのコードがリレーションへの完全で正しいアクセスパスの集合であると信じるものを生成した後で呼び出されます。
</p><pre class="programlisting">typedef void (*set_rel_pathlist_hook_type) (PlannerInfo *root,
                                            RelOptInfo *rel,
                                            Index rti,
                                            RangeTblEntry *rte);
extern PGDLLIMPORT set_rel_pathlist_hook_type set_rel_pathlist_hook;</pre><p>
  </p><p><span class="original">
    Although this hook function can be used to examine, modify, or remove
    paths generated by the core system, a custom scan provider will typically
    confine itself to generating &lt;structname&gt;CustomPath&lt;/&gt; objects and adding
    them to &lt;literal&gt;rel&lt;/&gt; using &lt;function&gt;add_path&lt;/&gt;.  The custom scan
    provider is responsible for initializing the &lt;structname&gt;CustomPath&lt;/&gt;
    object, which is declared like this:
</span>このフックはコアシステムが生成したパスを検査し、修正し、あるいは削除するために使うことができますが、カスタムスキャンプロバイダは、典型的には<code class="structname">CustomPath</code>オブジェクトを生成し、<code class="function">add_path</code>を使ってそれを<code class="literal">rel</code>に追加することのみを行います。
カスタムスキャンプロバイダは<code class="structname">CustomPath</code>オブジェクトの初期化を担当します。
このオブジェクトは以下のように宣言されています。
</p><pre class="programlisting">typedef struct CustomPath
{
    Path      path;
    uint32    flags;
    List     *custom_paths;
    List     *custom_private;
    const CustomPathMethods *methods;
} CustomPath;</pre><p>
  </p><p><span class="original">
    &lt;structfield&gt;path&lt;/&gt; must be initialized as for any other path, including
    the row-count estimate, start and total cost, and sort ordering provided
    by this path.  &lt;structfield&gt;flags&lt;/&gt; is a bit mask, which should include
    &lt;literal&gt;CUSTOMPATH_SUPPORT_BACKWARD_SCAN&lt;/&gt; if the custom path can support
    a backward scan and &lt;literal&gt;CUSTOMPATH_SUPPORT_MARK_RESTORE&lt;/&gt; if it
    can support mark and restore.  Both capabilities are optional.
    An optional &lt;structfield&gt;custom_paths&lt;/&gt; is a list of &lt;structname&gt;Path&lt;/&gt;
    nodes used by this custom-path node; these will be transformed into
    &lt;structname&gt;Plan&lt;/&gt; nodes by planner.
    &lt;structfield&gt;custom_private&lt;/&gt; can be used to store the custom path's
    private data.  Private data should be stored in a form that can be handled
    by &lt;literal&gt;nodeToString&lt;/&gt;, so that debugging routines that attempt to
    print the custom path will work as designed.  &lt;structfield&gt;methods&lt;/&gt; must
    point to a (usually statically allocated) object implementing the required
    custom path methods, of which there are currently only two, as further
    detailed below.
</span><code class="structfield">path</code>は、他のすべてのパスと同じく、行数の推定値、開始とトータルのコスト、このパスで提供されるソート順を含めて初期化される必要があります。
<code class="structfield">flags</code>はビットマスクで、カスタムパスが逆向きスキャンをサポートできるなら<code class="literal">CUSTOMPATH_SUPPORT_BACKWARD_SCAN</code>を、マークとリストアがサポートできるなら<code class="literal">CUSTOMPATH_SUPPORT_MARK_RESTORE</code>を含めます。
いずれの機能も必須ではありません。
オプションの<code class="structfield">custom_paths</code>はこのカスタムパスのノードで使用される<code class="structname">Path</code>のノードのリストです。
プランナがこれを<code class="structname">Plan</code>のノードに変換します。
<code class="structfield">custom_private</code>はカスタムパスのプライベートデータを格納するために使うことができます。
プライベートデータは<code class="literal">nodeToString</code>が処理できるような形式で格納してください。
そうすることで、カスタムパスを出力するデバッグルーチンが設計通りに動作します。
<code class="structfield">methods</code>は要求されるカスタムパスのメソッドのオブジェクト（通常は静的に割り当てられる）を指している必要があります。
メソッドは以下で詳細に説明する通り、現在は2つだけあるうちの1つとなります。
  </p><p><span class="original">
   A custom scan provider can also provide join paths.  Just as for base
   relations, such a path must produce the same output as would normally be
   produced by the join it replaces.  To do this, the join provider should
   set the following hook, and then within the hook function,
   create &lt;structname&gt;CustomPath&lt;/&gt; path(s) for the join relation.
</span>カスタムスキャンプロバイダは結合(join)のパスを提供することもできます。
ベースのリレーションの場合と同様、そのようなパスは置換される結合が普通に生成したであろうものと同じ結果を生成しなければなりません。
そのために、結合のプロバイダは以下のフックをセットし、フック関数内で結合リレーション用に<code class="structname">CustomPath</code>のパスを作成します。
</p><pre class="programlisting">typedef void (*set_join_pathlist_hook_type) (PlannerInfo *root,
                                             RelOptInfo *joinrel,
                                             RelOptInfo *outerrel,
                                             RelOptInfo *innerrel,
                                             JoinType jointype,
                                             JoinPathExtraData *extra);
extern PGDLLIMPORT set_join_pathlist_hook_type set_join_pathlist_hook;</pre><p>
<span class="original">
   This hook will be invoked repeatedly for the same join relation, with
   different combinations of inner and outer relations; it is the
   responsibility of the hook to minimize duplicated work.
</span>
このフックは、同じ結合リレーションについて、内側あるいは外側のリレーションとの様々な組み合わせで繰り返し呼び出されます。
繰り返しの作業を最小化するのはフック側の責任です。
  </p><div class="sect2" id="custom-scan-path-callbacks"><div class="titlepage"><div><div><h3 class="title">56.1.1. カスタムスキャンパスのコールバック</h3></div></div></div><span class="original">
  &lt;title&gt;Custom Scan Path Callbacks&lt;/title&gt;
</span><pre class="programlisting">Plan *(*PlanCustomPath) (PlannerInfo *root,
                         RelOptInfo *rel,
                         CustomPath *best_path,
                         List *tlist,
                         List *clauses,
                         List *custom_plans);</pre><p><span class="original">
    Convert a custom path to a finished plan.  The return value will generally
    be a &lt;literal&gt;CustomScan&lt;/&gt; object, which the callback must allocate and
    initialize.  See &lt;xref linkend="custom-scan-plan"&gt; for more details.
</span>
カスタムパスを完成した計画に変換します。
戻り値は一般的には<code class="literal">CustomScan</code>オブジェクトで、その領域はコールバックが割り当てて初期化しなければなりません。
詳しくは<a class="xref" href="custom-scan-plan.html" title="56.2. カスタムスキャン計画の作成">「カスタムスキャン計画の作成」</a>を参照してください。
   </p><pre class="programlisting">void (*TextOutCustomPath) (StringInfo str,
                           const CustomPath *node);</pre><p><span class="original">
    Generate additional output when &lt;function&gt;nodeToString&lt;/&gt; is invoked on
    this custom path.  This callback is optional.  Since
    &lt;function&gt;nodeToString&lt;/&gt; will automatically dump all fields in the
    structure that it can see, including &lt;structfield&gt;custom_private&lt;/&gt;, this
    is only useful if the &lt;structname&gt;CustomPath&lt;/&gt; is actually embedded in a
    larger struct containing additional fields.
</span>
<code class="function">nodeToString</code>がこのカスタムパス上で呼び出されたときに、追加の出力を生成します。
このコールバックは必須ではありません。
<code class="function">nodeToString</code>は、<code class="structfield">custom_private</code>を含め、それが見ることができる構造体のすべてのフィールドを自動的にダンプするため、これは<code class="structname">CustomPath</code>が、追加フィールドを含むより大きな構造体に組み込まれている時にのみ役に立ちます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="custom-scan.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="custom-scan.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="custom-scan-plan.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第56章 カスタムスキャンプロバイダの作成 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 56.2. カスタムスキャン計画の作成</td></tr></table></div></body></html>