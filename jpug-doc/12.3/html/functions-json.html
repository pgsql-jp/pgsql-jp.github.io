<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.15. JSON関数と演算子</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-xml.html" title="9.14. XML関数" /><link rel="next" href="functions-sequence.html" title="9.16. シーケンス操作関数" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 12.3文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="functions.html" title="第9章 関数と演算子">第9章 関数と演算子</a></td><td width="20%" align="right"></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-xml.html" title="9.14. XML関数">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第9章 関数と演算子">上へ</a></td><td width="60%" align="center">9.15. JSON関数と演算子</td><td width="20%" align="right"> <a accesskey="n" href="functions-sequence.html" title="9.16. シーケンス操作関数">次へ</a></td></tr></table><hr /></div><div class="sect1" id="FUNCTIONS-JSON"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.15. JSON関数と演算子</h2></div></div></div><!--
  <title>JSON Functions and Operators</title>
--><a id="id-1.5.8.20.2" class="indexterm"></a><p>
<!--
   This section describes:
-->
この節では次のことを説明します。

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
      functions and operators for processing and creating JSON data
-->
JSONデータを処理、生成する関数と演算子
     </p></li><li class="listitem"><p>
<!--
      the SQL/JSON path language
-->
SQL/JSONパス言語
     </p></li></ul></div><p>
  </p><p>
<!--
   To learn more about the SQL/JSON standard, see
   <xref linkend="sqltr-19075-6"/>. For details on JSON types
   supported in <productname>PostgreSQL</productname>,
   see <xref linkend="datatype-json"/>.
-->
SQL/JSON標準を更に学ぶためには、<a class="xref" href="biblio.html#SQLTR-19075-6" title="SQL Technical Report">[sqltr-19075-6]</a>をご覧ください。
<span class="productname">PostgreSQL</span>でサポートされているJSON型の詳細に関しては、<a class="xref" href="datatype-json.html" title="8.14. JSONデータ型">8.14</a>をご覧ください。
  </p><div class="sect2" id="FUNCTIONS-JSON-PROCESSING"><div class="titlepage"><div><div><h3 class="title">9.15.1. JSONデータの処理と生成</h3></div></div></div><!--
   <title>Processing and Creating JSON Data</title>
--><p>
<!--
   <xref linkend="functions-json-op-table"/> shows the operators that
   are available for use with JSON data types (see <xref
   linkend="datatype-json"/>).
-->
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-OP-TABLE" title="表9.44 jsonとjsonb演算子">表 9.44</a>にJSONデータ型(<a class="xref" href="datatype-json.html" title="8.14. JSONデータ型">8.14</a>を参照)で使用可能な演算子を示します。
  </p><div class="table" id="FUNCTIONS-JSON-OP-TABLE"><p class="title"><strong>表9.44 <code class="type">json</code>と<code class="type">jsonb</code>演算子</strong></p><div class="table-contents"><!--
     <title><type>json</type> and <type>jsonb</type> Operators</title>
--><table class="table" summary="jsonとjsonb演算子" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>演算子</th><th>右オペランド型</th><th>戻り値型</th><th>説明</th><th>例</th><th>例の結果</th></tr></thead><tbody><tr><td><code class="literal">-&gt;</code></td><td><code class="type">int</code></td><td><code class="type">json</code> or <code class="type">jsonb</code></td><td>JSON配列要素を取得（添字はゼロから、負数なら後ろから数える）</td><td><code class="literal">'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</code></td><td><code class="literal">{"c":"baz"}</code></td></tr><tr><td><code class="literal">-&gt;</code></td><td><code class="type">text</code></td><td><code class="type">json</code> or <code class="type">jsonb</code></td><td>キーに依るJSONオブジェクトフィールド取得</td><td><code class="literal">'{"a": {"b":"foo"}}'::json-&gt;'a'</code></td><td><code class="literal">{"b":"foo"}</code></td></tr><tr><td><code class="literal">-&gt;&gt;</code></td><td><code class="type">int</code></td><td><code class="type">text</code></td><td>JSON 配列要素を<code class="type">text</code>として取得</td><td><code class="literal">'[1,2,3]'::json-&gt;&gt;2</code></td><td><code class="literal">3</code></td></tr><tr><td><code class="literal">-&gt;&gt;</code></td><td><code class="type">text</code></td><td><code class="type">text</code></td><td>JSON オブジェクトフィールドを<code class="type">text</code>として取得</td><td><code class="literal">'{"a":1,"b":2}'::json-&gt;&gt;'b'</code></td><td><code class="literal">2</code></td></tr><tr><td><code class="literal">#&gt;</code></td><td><code class="type">text[]</code></td><td><code class="type">json</code> or <code class="type">jsonb</code></td><td>指定されたパスにあるJSONオブジェクトを取得</td><td><code class="literal">'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</code></td><td><code class="literal">{"c": "foo"}</code></td></tr><tr><td><code class="literal">#&gt;&gt;</code></td><td><code class="type">text[]</code></td><td><code class="type">text</code></td><td>指定されたパスにあるJSONオブジェクトを<code class="type">text</code>として取得</td><td><code class="literal">'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</code></td><td><code class="literal">3</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<!--
    There are parallel variants of these operators for both the
    <type>json</type> and <type>jsonb</type> types.
    The field/element/path extraction operators
    return the same type as their left-hand input (either <type>json</type>
    or <type>jsonb</type>), except for those specified as
    returning <type>text</type>, which coerce the value to text.
    The field/element/path extraction operators return NULL, rather than
    failing, if the JSON input does not have the right structure to match
    the request; for example if no such element exists.  The
    field/element/path extraction operators that accept integer JSON
    array subscripts all support negative subscripting from the end of
    arrays.
-->
<code class="type">json</code>と<code class="type">jsonb</code>型の両方に対して、以上の演算子の対応するものがあります。
フィールド/要素/パス抽出演算子は左辺の入力と同じ型（<code class="type">json</code>または<code class="type">jsonb</code>）を返します。
ただし、<code class="type">text</code>を返すと明示してあるものは、値をテキストに変換して返します。
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
JSON配列の添字を整数で受け取り、フィールド、要素、パスを返す演算子はすべて、配列の終わりから数える負の添字をサポートします。
   </p></div><p>
<!--
   The standard comparison operators shown in  <xref
   linkend="functions-comparison-op-table"/> are available for
   <type>jsonb</type>, but not for <type>json</type>. They follow the
   ordering rules for B-tree operations outlined at <xref
   linkend="json-indexing"/>.
-->
<a class="xref" href="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE" title="表9.1 比較演算子">表 9.1</a>に示されている標準の比較演算子が<code class="type">jsonb</code>で利用可能ですが、<code class="type">json</code>ではそうではありません。
それらは<a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb インデックス">8.14.4</a>で概略を述べたB-tree演算子の順序規則に従います。
  </p><p>
<!--
   Some further operators also exist only for <type>jsonb</type>, as shown
   in <xref linkend="functions-jsonb-op-table"/>.
   Many of these operators can be indexed by
   <type>jsonb</type> operator classes.  For a full description of
   <type>jsonb</type> containment and existence semantics, see <xref
   linkend="json-containment"/>.  <xref linkend="json-indexing"/>
   describes how these operators can be used to effectively index
   <type>jsonb</type> data.
-->
ほかに<code class="type">jsonb</code>だけで利用可能な演算子もいくつか存在します。
それらを<a class="xref" href="functions-json.html#FUNCTIONS-JSONB-OP-TABLE" title="表9.45 追加jsonb演算子">表 9.45</a>に示します。
これらのうち多くの演算子は<code class="type">jsonb</code>演算子クラスでインデックス付けすることが可能です。
<code class="type">jsonb</code>の包含と存在の意味に関する完全な記述は<a class="xref" href="datatype-json.html#JSON-CONTAINMENT" title="8.14.3. jsonb型用包含演算子と存在演算子">8.14.3</a>を参照してください。
<a class="xref" href="datatype-json.html#JSON-INDEXING" title="8.14.4. jsonb インデックス">8.14.4</a>には、<code class="type">jsonb</code>データを効率的にインデックス付けするためにこれらの演算子をどのように利用できるかについて書いてあります。
  </p><div class="table" id="FUNCTIONS-JSONB-OP-TABLE"><p class="title"><strong>表9.45 追加<code class="type">jsonb</code>演算子</strong></p><div class="table-contents"><!--
     <title>Additional <type>jsonb</type> Operators</title>
--><table class="table" summary="追加jsonb演算子" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>演算子</th><th>右オペランド型</th><th>説明</th><th>例</th></tr></thead><tbody><tr><td><code class="literal">@&gt;</code></td><td><code class="type">jsonb</code></td><td>左のJSON値はトップレベルにおいて右のJSONパスまたは値を包含するか</td><td><code class="literal">'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</code></td></tr><tr><td><code class="literal">&lt;@</code></td><td><code class="type">jsonb</code></td><td>左のJSONパスまたは値は右のJSON値にトップレベルで包含されるか</td><td><code class="literal">'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</code></td></tr><tr><td><code class="literal">?</code></td><td><code class="type">text</code></td><td><span class="emphasis"><em>文字列</em></span>はJSON値のトップレベルのキーとして存在するか</td><td><code class="literal">'{"a":1, "b":2}'::jsonb ? 'b'</code></td></tr><tr><td><code class="literal">?|</code></td><td><code class="type">text[]</code></td><td>配列の<span class="emphasis"><em>文字列</em></span>のいずれかがトップレベルのキーとして存在するか。</td><td><code class="literal">'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</code></td></tr><tr><td><code class="literal">?&amp;</code></td><td><code class="type">text[]</code></td><td>配列の<span class="emphasis"><em>文字列</em></span>のすべてがトップレベルのキーとして存在するか。</td><td><code class="literal">'["a", "b"]'::jsonb ?&amp; array['a', 'b']</code></td></tr><tr><td><code class="literal">||</code></td><td><code class="type">jsonb</code></td><td>2つの<code class="type">jsonb</code>値を結合して、新しい<code class="type">jsonb</code>値を作る</td><td><code class="literal">'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</code></td></tr><tr><td><code class="literal">-</code></td><td><code class="type">text</code></td><td>左のオペランドからキー／値のペア、あるいは<span class="emphasis"><em>文字列</em></span>要素を削除する。
キー／値のペアはキーの値に基づいてマッチされる。</td><td><code class="literal">'{"a": "b"}'::jsonb - 'a' </code></td></tr><tr><td><code class="literal">-</code></td><td><code class="type">text[]</code></td><td>左のオペランドから複数のキー／値のペア、あるいは<span class="emphasis"><em>文字列</em></span>要素を削除する。
キー／値のペアはキーの値に基づいてマッチされる。</td><td><code class="literal">'{"a": "b", "c": "d"}'::jsonb - '{a,c}'::text[] </code></td></tr><tr><td><code class="literal">-</code></td><td><code class="type">integer</code></td><td>指定した添字の配列要素を削除する（負数の場合は後ろから数えます）。
トップレベルのコンテナが配列でないときはエラーが発生する。</td><td><code class="literal">'["a", "b"]'::jsonb - 1 </code></td></tr><tr><td><code class="literal">#-</code></td><td><code class="type">text[]</code></td><td>指定したパスのフィールドまたは要素を削除する（JSON配列では、負数は後ろから数えます）</td><td><code class="literal">'["a", {"b":1}]'::jsonb #- '{1,b}'</code></td></tr><tr><td><code class="literal">@?</code></td><td><code class="type">jsonpath</code></td><td>JSONパスが指定したJSON値に対応する要素を返すか？</td><td><code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @? '$.a[*] ? (@ &gt; 2)'</code></td></tr><tr><td><code class="literal">@@</code></td><td><code class="type">jsonpath</code></td><td>指定したJSON値のJSONパス述語チェックの結果を返す。
        結果の最初の項目だけが考慮されます。
        結果がBooleanでないなら、<code class="literal">null</code>が返ります。</td><td><code class="literal">'{"a":[1,2,3,4,5]}'::jsonb @@ '$.a[*] &gt; 2'</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<!--
    The <literal>||</literal> operator concatenates the elements at the top level of
    each of its operands. It does not operate recursively. For example, if
    both operands are objects with a common key field name, the value of the
    field in the result will just be the value from the right hand operand.
-->
<code class="literal">||</code>演算子は、両オペランドのトップレベルで要素を結合します。
再帰的には作用しません。
例えば、両方のオペランドが同じキーフィールド名のオブジェクトの場合、そのフィールドの値は、単に右側のオペランドの値になります。
   </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
    The <literal>@?</literal> and <literal>@@</literal> operators suppress
    the following errors: lacking object field or array element, unexpected
    JSON item type, and numeric errors.
    This behavior might be helpful while searching over JSON document
    collections of varying structure.
-->
<code class="literal">@?</code>および<code class="literal">@@</code>演算子は以下のエラーを抑止します。
オブジェクトフィールドあるいは配列要素の欠如、期待しないJSON要素型、数値エラー。
この振る舞いは、異なる構造のJSON文書集合を検索する際に役に立つかも知れません。
   </p></div><p>
<!--
   <xref linkend="functions-json-creation-table"/> shows the functions that are
   available for creating <type>json</type> and <type>jsonb</type> values.
   (There are no equivalent functions for <type>jsonb</type>, of the <literal>row_to_json</literal>
   and <literal>array_to_json</literal> functions. However, the <literal>to_jsonb</literal>
   function supplies much the same functionality as these functions would.)
-->
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE" title="表9.46 JSON作成関数">表 9.46</a>に、JSON値および<code class="type">jsonb</code>値を作成するために利用可能な関数を示します。
（<code class="literal">row_to_json</code>関数および<code class="literal">array_to_json</code>関数と同等な<code class="type">jsonb</code>の関数はありません。
しかし、<code class="literal">to_jsonb</code>を使えば、これらの関数と同じ機能を提供できるでしょう。）
  </p><a id="id-1.5.8.20.5.11" class="indexterm"></a><a id="id-1.5.8.20.5.12" class="indexterm"></a><a id="id-1.5.8.20.5.13" class="indexterm"></a><a id="id-1.5.8.20.5.14" class="indexterm"></a><a id="id-1.5.8.20.5.15" class="indexterm"></a><a id="id-1.5.8.20.5.16" class="indexterm"></a><a id="id-1.5.8.20.5.17" class="indexterm"></a><a id="id-1.5.8.20.5.18" class="indexterm"></a><a id="id-1.5.8.20.5.19" class="indexterm"></a><a id="id-1.5.8.20.5.20" class="indexterm"></a><div class="table" id="FUNCTIONS-JSON-CREATION-TABLE"><p class="title"><strong>表9.46 JSON作成関数</strong></p><div class="table-contents"><!--
    <title>JSON Creation Functions</title>
--><table class="table" summary="JSON作成関数" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>説明</th><th>例</th><th>例の結果</th></tr></thead><tbody><tr><td><p><code class="literal">to_json(anyelement)</code>
          </p><p><code class="literal">to_jsonb(anyelement)</code>
       </p></td><td>
<!--
         Returns the value as <type>json</type> or <type>jsonb</type>.
         Arrays and composites are converted
         (recursively) to arrays and objects; otherwise, if there is a cast
         from the type to <type>json</type>, the cast function will be used to
         perform the conversion; otherwise, a scalar value is produced.
         For any scalar type other than a number, a Boolean, or a null value,
         the text representation will be used, in such a fashion that it is a
         valid <type>json</type> or <type>jsonb</type> value.
-->
<code class="type">json</code>あるいは<code class="type">jsonb</code>として値を返す。
配列と複合型は（再帰的に）配列とオブジェクトに変換される。
あるいは、その型から<code class="type">json</code>にキャストがあれば、キャスト関数が変換のために用いられる。
そうでなければ、スカラ値が生成される。
数値、論理値、またはNULL値以外のスカラ型に対しては、有効な<code class="type">json</code>値あるいは<code class="type">jsonb</code>値となる形式の文字列表現が使用される。
       </td><td><code class="literal">to_json('Fred said "Hi."'::text)</code></td><td><code class="literal">"Fred said \"Hi.\""</code></td></tr><tr><td>
         <code class="literal">array_to_json(anyarray [, pretty_bool])</code>
       </td><td>
<!--
         Returns the array as a JSON array. A PostgreSQL multidimensional array
         becomes a JSON array of arrays. Line feeds will be added between
         dimension-1 elements if <parameter>pretty_bool</parameter> is true.
-->
配列をJSON配列として返す。
PostgreSQLの多次元配列はJSON配列の配列となる。
<em class="parameter"><code>pretty_bool</code></em>が真の場合、次元数-1の要素の間に改行が加えられる。
       </td><td><code class="literal">array_to_json('{{1,5},{99,100}}'::int[])</code></td><td><code class="literal">[[1,5],[99,100]]</code></td></tr><tr><td>
         <code class="literal">row_to_json(record [, pretty_bool])</code>
       </td><td>
<!--
         Returns the row as a JSON object. Line feeds will be added between
         level-1 elements if <parameter>pretty_bool</parameter> is true.
-->
行をJSONオブジェクトとして返す。
<em class="parameter"><code>pretty_bool</code></em>が真の場合、レベル-1の要素の間に改行が加えられる。
       </td><td><code class="literal">row_to_json(row(1,'foo'))</code></td><td><code class="literal">{"f1":1,"f2":"foo"}</code></td></tr><tr><td><p><code class="literal">json_build_array(VARIADIC "any")</code>
          </p><p><code class="literal">jsonb_build_array(VARIADIC "any")</code>
       </p></td><td>
<!--
         Builds a possibly-heterogeneously-typed JSON array out of a variadic
         argument list.
-->
異なる型から構成される可能性のあるJSON配列をvariadic引数リストから作成。
       </td><td><code class="literal">json_build_array(1,2,'3',4,5)</code></td><td><code class="literal">[1, 2, "3", 4, 5]</code></td></tr><tr><td><p><code class="literal">json_build_object(VARIADIC "any")</code>
          </p><p><code class="literal">jsonb_build_object(VARIADIC "any")</code>
       </p></td><td>
<!--
         Builds a JSON object out of a variadic argument list.  By
         convention, the argument list consists of alternating
         keys and values.
-->
variadic引数リストからJSONオブジェクトを作成。
慣例により引数リストはキーと値が交互に並んだもの。
       </td><td><code class="literal">json_build_object('foo',1,'bar',2)</code></td><td><code class="literal">{"foo": 1, "bar": 2}</code></td></tr><tr><td><p><code class="literal">json_object(text[])</code>
          </p><p><code class="literal">jsonb_object(text[])</code>
       </p></td><td>
<!--
         Builds a JSON object out of a text array.  The array must have either
         exactly one dimension with an even number of members, in which case
         they are taken as alternating key/value pairs, or two dimensions
         such that each inner array has exactly two elements, which
         are taken as a key/value pair.
-->
テキスト配列からJSONオブジェクトを作成。
配列は、偶数個の要素からなる1次元（キー／値の対が交互に並んでいるものと扱われる)）あるいは内側の配列が2つの要素を持つ2次元（2つの要素がキー／値の対として扱われる）のいずれかでなければならない。
       </td><td><p><code class="literal">json_object('{a, 1, b, "def", c, 3.5}')</code></p>
        <p><code class="literal">json_object('{{a, 1},{b, "def"},{c, 3.5}}')</code></p></td><td><code class="literal">{"a": "1", "b": "def", "c": "3.5"}</code></td></tr><tr><td><p><code class="literal">json_object(keys text[], values text[])</code>
          </p><p><code class="literal">jsonb_object(keys text[], values text[])</code>
       </p></td><td>
<!--
         This form of <function>json_object</function> takes keys and values pairwise from two separate
         arrays. In all other respects it is identical to the one-argument form.
-->
この形の<code class="function">json_object</code>は2つの別々の配列からキーと値の対を取る。
他の点ではすべて、引数1つの形と同じ。
       </td><td><code class="literal">json_object('{a, b}', '{1,2}')</code></td><td><code class="literal">{"a": "1", "b": "2"}</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<!--
     <function>array_to_json</function> and <function>row_to_json</function> have the same
     behavior as <function>to_json</function> except for offering a pretty-printing
     option.  The behavior described for <function>to_json</function> likewise applies
     to each individual value converted by the other JSON creation functions.
-->
<code class="function">array_to_json</code>と<code class="function">row_to_json</code>は表示を整えるオプションを提供する以外は<code class="function">to_json</code>と同様の振舞いをします。
同様に<code class="function">to_json</code>に書かれた振舞いはJSON作成関数により変換された個々の値に適用されます。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
     The <xref linkend="hstore"/> extension has a cast
     from <type>hstore</type> to <type>json</type>, so that
     <type>hstore</type> values converted via the JSON creation functions
     will be represented as JSON objects, not as primitive string values.
-->
<a class="xref" href="hstore.html" title="F.16. hstore">hstore</a>拡張は<code class="type">hstore</code>から<code class="type">json</code>へのキャストを含みます。従って、JSON作成関数で変換された<code class="type">hstore</code>値は元の文字列値ではなくJSONオブジェクトとして示されます。
    </p></div><p>
<!--
   <xref linkend="functions-json-processing-table"/> shows the functions that
   are available for processing <type>json</type> and <type>jsonb</type> values.
-->
<a class="xref" href="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE" title="表9.47 JSON処理関数">表 9.47</a>に<code class="type">json</code>と<code class="type">jsonb</code>値を処理するのに使える関数を示します。
  </p><a id="id-1.5.8.20.5.25" class="indexterm"></a><a id="id-1.5.8.20.5.26" class="indexterm"></a><a id="id-1.5.8.20.5.27" class="indexterm"></a><a id="id-1.5.8.20.5.28" class="indexterm"></a><a id="id-1.5.8.20.5.29" class="indexterm"></a><a id="id-1.5.8.20.5.30" class="indexterm"></a><a id="id-1.5.8.20.5.31" class="indexterm"></a><a id="id-1.5.8.20.5.32" class="indexterm"></a><a id="id-1.5.8.20.5.33" class="indexterm"></a><a id="id-1.5.8.20.5.34" class="indexterm"></a><a id="id-1.5.8.20.5.35" class="indexterm"></a><a id="id-1.5.8.20.5.36" class="indexterm"></a><a id="id-1.5.8.20.5.37" class="indexterm"></a><a id="id-1.5.8.20.5.38" class="indexterm"></a><a id="id-1.5.8.20.5.39" class="indexterm"></a><a id="id-1.5.8.20.5.40" class="indexterm"></a><a id="id-1.5.8.20.5.41" class="indexterm"></a><a id="id-1.5.8.20.5.42" class="indexterm"></a><a id="id-1.5.8.20.5.43" class="indexterm"></a><a id="id-1.5.8.20.5.44" class="indexterm"></a><a id="id-1.5.8.20.5.45" class="indexterm"></a><a id="id-1.5.8.20.5.46" class="indexterm"></a><a id="id-1.5.8.20.5.47" class="indexterm"></a><a id="id-1.5.8.20.5.48" class="indexterm"></a><a id="id-1.5.8.20.5.49" class="indexterm"></a><a id="id-1.5.8.20.5.50" class="indexterm"></a><a id="id-1.5.8.20.5.51" class="indexterm"></a><a id="id-1.5.8.20.5.52" class="indexterm"></a><a id="id-1.5.8.20.5.53" class="indexterm"></a><a id="id-1.5.8.20.5.54" class="indexterm"></a><a id="id-1.5.8.20.5.55" class="indexterm"></a><a id="id-1.5.8.20.5.56" class="indexterm"></a><a id="id-1.5.8.20.5.57" class="indexterm"></a><a id="id-1.5.8.20.5.58" class="indexterm"></a><a id="id-1.5.8.20.5.59" class="indexterm"></a><a id="id-1.5.8.20.5.60" class="indexterm"></a><div class="table" id="FUNCTIONS-JSON-PROCESSING-TABLE"><p class="title"><strong>表9.47 JSON処理関数</strong></p><div class="table-contents"><!--
    <title>JSON Processing Functions</title>
--><table class="table" summary="JSON処理関数" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>関数</th><th>戻り値型</th><th>説明</th><th>例</th><th>例の結果</th></tr></thead><tbody><tr><td><p><code class="literal">json_array_length(json)</code>
         </p><p><code class="literal">jsonb_array_length(jsonb)</code>
       </p></td><td><code class="type">int</code></td><td>
<!--
         Returns the number of elements in the outermost JSON array.
-->
         JSON配列の最も外側の要素の数を返す。
       </td><td><code class="literal">json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</code></td><td><code class="literal">5</code></td></tr><tr><td><p><code class="literal">json_each(json)</code>
         </p><p><code class="literal">jsonb_each(jsonb)</code>
       </p></td><td><p><code class="literal">setof key text, value json</code>
         </p><p><code class="literal">setof key text, value jsonb</code>
       </p></td><td>
<!--
         Expands the outermost JSON object into a set of key/value pairs.
-->
         JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。
       </td><td><code class="literal">select * from json_each('{"a":"foo", "b":"bar"}')</code></td><td>
<pre class="programlisting">
 key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre>
       </td></tr><tr><td><p><code class="literal">json_each_text(json)</code>
         </p><p><code class="literal">jsonb_each_text(jsonb)</code>
       </p></td><td><code class="type">setof key text, value text</code></td><td>
<!--
         Expands the outermost JSON object into a set of key/value pairs. The
         returned values will be of type <type>text</type>.
-->
        JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。返り値は型<code class="type">text</code>。
       </td><td><code class="literal">select * from json_each_text('{"a":"foo", "b":"bar"}')</code></td><td>
<pre class="programlisting">
 key | value
-----+-------
 a   | foo
 b   | bar
</pre>
       </td></tr><tr><td><p><code class="literal">json_extract_path(from_json json, VARIADIC path_elems text[])</code>
        </p><p><code class="literal">jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</code>
       </p></td><td><p><code class="type">json</code></p><p><code class="type">jsonb</code>
       </p></td><td>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         (equivalent to <literal>#&gt;</literal> operator).
-->
        <em class="replaceable"><code>path_elems</code></em>で示されたJSONオブジェクトを返す(<code class="literal">#&gt;</code>と同じ)。
       </td><td><code class="literal">json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</code></td><td><code class="literal">{"f5":99,"f6":"foo"}</code></td></tr><tr><td><p><code class="literal">json_extract_path_text(from_json json, VARIADIC path_elems text[])</code>
         </p><p><code class="literal">jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</code>
       </p></td><td><code class="type">text</code></td><td>
<!--
         Returns JSON value pointed to by <replaceable>path_elems</replaceable>
         as <type>text</type>
         (equivalent to <literal>#&gt;&gt;</literal> operator).
-->
        <em class="replaceable"><code>path_elems</code></em>で示されたJSONオブジェクトを<code class="type">text</code>として返す(<code class="literal">#&gt;&gt;</code>演算子と同じ)。
       </td><td><code class="literal">json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</code></td><td><code class="literal">foo</code></td></tr><tr><td><p><code class="literal">json_object_keys(json)</code>
         </p><p><code class="literal">jsonb_object_keys(jsonb)</code>
       </p></td><td><code class="type">setof text</code></td><td>
<!--
          Returns set of keys in the outermost JSON object.
-->
        最も外側のJSONオブジェクトの中のキーの集合を返す。
       </td><td><code class="literal">json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</code></td><td>
<pre class="programlisting">
 json_object_keys
------------------
 f1
 f2
</pre>
       </td></tr><tr><td><p><code class="literal">json_populate_record(base anyelement, from_json json)</code>
         </p><p><code class="literal">jsonb_populate_record(base anyelement, from_json jsonb)</code>
       </p></td><td><code class="type">anyelement</code></td><td>
<!--
         Expands the object in <replaceable>from_json</replaceable> to a row
         whose columns match the record type defined by <replaceable>base</replaceable>
         (see note below).
-->
<em class="replaceable"><code>from_json</code></em>内のオブジェクト行を<em class="replaceable"><code>base</code></em>で定義されたレコード型に一致する列に拡張する(以下の注意書きを参照)。
       </td><td><code class="literal">select * from json_populate_record(null::myrowtype, '{"a": 1, "b": ["2", "a b"], "c": {"d": 4, "e": "a  b c"}}')</code></td><td>
<pre class="programlisting">
 a |   b       |      c
---+-----------+-------------
 1 | {2,"a b"} | (4,"a b c")
</pre>
       </td></tr><tr><td><p><code class="literal">json_populate_recordset(base anyelement, from_json json)</code>
         </p><p><code class="literal">jsonb_populate_recordset(base anyelement, from_json jsonb)</code>
       </p></td><td><code class="type">setof anyelement</code></td><td>
<!--
         Expands the outermost array of objects
         in <replaceable>from_json</replaceable> to a set of rows whose
         columns match the record type defined by <replaceable>base</replaceable> (see
         note below).
-->
<em class="replaceable"><code>from_json</code></em>におけるオブジェクトの最も外側の配列を<em class="replaceable"><code>base</code></em>で定義されたレコード型に一致する列を持つ行の集合に展開する(以下の注意書き参照)。
       </td><td><code class="literal">select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</code></td><td>
<pre class="programlisting">
 a | b
---+---
 1 | 2
 3 | 4
</pre>
       </td></tr><tr><td><p><code class="literal">json_array_elements(json)</code>
         </p><p><code class="literal">jsonb_array_elements(jsonb)</code>
       </p></td><td><p><code class="type">setof json</code>
         </p><p><code class="type">setof jsonb</code>
       </p></td><td>
<!--
         Expands a JSON array to a set of JSON values.
-->
JSON配列をJSON値の集合に展開する。
       </td><td><code class="literal">select * from json_array_elements('[1,true, [2,false]]')</code></td><td>
<pre class="programlisting">
   value
-----------
 1
 true
 [2,false]
</pre>
       </td></tr><tr><td><p><code class="literal">json_array_elements_text(json)</code>
         </p><p><code class="literal">jsonb_array_elements_text(jsonb)</code>
       </p></td><td><code class="type">setof text</code></td><td>
<!--
         Expands a JSON array to a set of <type>text</type> values.
-->
JSON配列を<code class="type">text</code>値の集合に展開する。
       </td><td><code class="literal">select * from json_array_elements_text('["foo", "bar"]')</code></td><td>
<pre class="programlisting">
   value
-----------
 foo
 bar
</pre>
       </td></tr><tr><td><p><code class="literal">json_typeof(json)</code>
         </p><p><code class="literal">jsonb_typeof(jsonb)</code>
       </p></td><td><code class="type">text</code></td><td>
<!--
         Returns the type of the outermost JSON value as a text string.
         Possible types are
         <literal>object</literal>, <literal>array</literal>, <literal>string</literal>, <literal>number</literal>,
         <literal>boolean</literal>, and <literal>null</literal>.
-->
最も外側のJSON値の型をテキスト文字列として返す。
取りうる型は<code class="literal">object</code>、 <code class="literal">array</code>、 <code class="literal">string</code>、 <code class="literal">number</code>、<code class="literal">boolean</code>、<code class="literal">null</code>である。
       </td><td><code class="literal">json_typeof('-123.4')</code></td><td><code class="literal">number</code></td></tr><tr><td><p><code class="literal">json_to_record(json)</code>
          </p><p><code class="literal">jsonb_to_record(jsonb)</code>
       </p></td><td><code class="type">record</code></td><td>
<!--
         Builds an arbitrary record from a JSON object (see note below).  As
         with all functions returning <type>record</type>, the caller must
         explicitly define the structure of the record with an <literal>AS</literal>
         clause.
-->
JSONオブジェクトから任意のレコードを作成する（下記の注釈を参照）。
<code class="type">record</code>を返す関数すべてと同様、呼び出し側が<code class="literal">AS</code>句でレコードの構造を明示的に決める必要がある。
       </td><td><code class="literal">select * from json_to_record('{"a":1,"b":[1,2,3],"c":[1,2,3],"e":"bar","r": {"a": 123, "b": "a b c"}}') as x(a int, b text, c int[], d text, r myrowtype) </code></td><td>
<pre class="programlisting">
 a |    b    |    c    | d |       r
---+---------+---------+---+---------------
 1 | [1,2,3] | {1,2,3} |   | (123,"a b c")
</pre>
       </td></tr><tr><td><p><code class="literal">json_to_recordset(json)</code>
         </p><p><code class="literal">jsonb_to_recordset(jsonb)</code>
       </p></td><td><code class="type">setof record</code></td><td>
<!--
         Builds an arbitrary set of records from a JSON array of objects (see
         note below).  As with all functions returning <type>record</type>, the
         caller must explicitly define the structure of the record with
         an <literal>AS</literal> clause.
-->
オブジェクトの配列のJSONから任意のレコードの集合を作成する（下記の注釈を参照）。
<code class="type">record</code>を返す関数すべてと同様、呼び出し側が<code class="literal">AS</code>句でレコードの構造を明示的に決める必要がある。
       </td><td><code class="literal">select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</code></td><td>
<pre class="programlisting">
 a |  b
---+-----
 1 | foo
 2 |
</pre>
       </td></tr><tr><td><p><code class="literal">json_strip_nulls(from_json json)</code>
         </p><p><code class="literal">jsonb_strip_nulls(from_json jsonb)</code>
       </p></td><td><p><code class="type">json</code></p><p><code class="type">jsonb</code></p></td><td>
<!--
         Returns <replaceable>from_json</replaceable>
         with all object fields that have null values omitted. Other null values
         are untouched.
-->
NULL値を持つオブジェクトフィールドを削除した<em class="replaceable"><code>from_json</code></em>を返す。
他のNULL値はそのまま残る。
       </td><td><code class="literal">json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</code></td><td><code class="literal">[{"f1":1},2,null,3]</code></td></tr><tr><td><p><code class="literal">jsonb_set(target jsonb, path text[], new_value jsonb [<span class="optional">, create_missing boolean</span>])</code>
         </p></td><td><p><code class="type">jsonb</code></p></td><td>
<!--
         Returns <replaceable>target</replaceable>
         with the section designated by <replaceable>path</replaceable>
         replaced by <replaceable>new_value</replaceable>, or with
         <replaceable>new_value</replaceable> added if
         <replaceable>create_missing</replaceable> is true (default is
         <literal>true</literal>) and the item
         designated by <replaceable>path</replaceable> does not exist.
         As with the path oriented operators, negative integers that
         appear in <replaceable>path</replaceable> count from the end
         of JSON arrays.
-->
<em class="replaceable"><code>path</code></em>で指定した部分を<em class="replaceable"><code>new_value</code></em>で置換、
あるいは<em class="replaceable"><code>create_missing</code></em>が真（デフォルトは<code class="literal">true</code>）で<em class="replaceable"><code>path</code></em>で指定した項目が存在しないなら<em class="replaceable"><code>new_value</code></em>を追加して、
<em class="replaceable"><code>target</code></em>を返す。
パスの位置についての演算子について、<em class="replaceable"><code>path</code></em>の中にある負の整数はJSON配列の終わりから数える。
       </td><td><p><code class="literal">jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</code>
         </p><p><code class="literal">jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</code>
         </p></td><td><p><code class="literal">[{"f1":[2,3,4],"f2":null},2,null,3]</code>
         </p><p><code class="literal">[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</code>
        </p></td></tr><tr><td>
           <p><code class="literal">
           jsonb_insert(target jsonb, path text[], new_value jsonb [<span class="optional">, insert_after boolean</span>])
           </code></p>
       </td><td><p><code class="type">jsonb</code></p></td><td>
<!--
         Returns <replaceable>target</replaceable> with
         <replaceable>new_value</replaceable> inserted. If
         <replaceable>target</replaceable> section designated by
         <replaceable>path</replaceable> is in a JSONB array,
         <replaceable>new_value</replaceable> will be inserted before target or
         after if <replaceable>insert_after</replaceable> is true (default is
         <literal>false</literal>). If <replaceable>target</replaceable> section
         designated by <replaceable>path</replaceable> is in JSONB object,
         <replaceable>new_value</replaceable> will be inserted only if
         <replaceable>target</replaceable> does not exist. As with the path
         oriented operators, negative integers that appear in
         <replaceable>path</replaceable> count from the end of JSON arrays.
-->
<em class="replaceable"><code>new_value</code></em>を挿入して<em class="replaceable"><code>target</code></em>を返す。
<em class="replaceable"><code>path</code></em>で指定した<em class="replaceable"><code>target</code></em>の部分がJSONB配列内にある場合は、<em class="replaceable"><code>new_value</code></em>はtargetの前に挿入されるか、あるいは、<em class="replaceable"><code>insert_after</code></em>が真であれば（デフォルトは<code class="literal">false</code>）、後に挿入される。
<em class="replaceable"><code>path</code></em>で指定した<em class="replaceable"><code>target</code></em>の部分がJSONBオブジェクト内にある場合は、<em class="replaceable"><code>new_value</code></em>は<em class="replaceable"><code>target</code></em>が存在しない場合にのみ挿入される。
pathについての演算子について言うと、<em class="replaceable"><code>new_value</code></em>内の負の整数はJSON配列の終わりから数える。
       </td><td>
           <p><code class="literal">
               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')
           </code></p>
           <p><code class="literal">
               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)
           </code></p>
       </td><td><p><code class="literal">{"a": [0, "new_value", 1, 2]}</code>
         </p><p><code class="literal">{"a": [0, 1, "new_value", 2]}</code>
        </p></td></tr><tr><td><p><code class="literal">jsonb_pretty(from_json jsonb)</code>
         </p></td><td><p><code class="type">text</code></p></td><td>
<!--
         Returns <replaceable>from_json</replaceable>
         as indented JSON text.
-->
<em class="replaceable"><code>from_json</code></em>をインデントしたJSON文字列にして返す。
       </td><td><code class="literal">jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</code></td><td>
<pre class="programlisting">
[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]
</pre>
        </td></tr><tr><td>
         <p><code class="literal">
           jsonb_path_exists(target jsonb, path jsonpath [<span class="optional">, vars jsonb [<span class="optional">, silent bool</span>]</span>])
         </code></p>
        </td><td><code class="type">boolean</code></td><td>
<!--
          Checks whether JSON path returns any item for the specified JSON
          value.
-->
JSONパスが指定したJSON値に対して項目を返すかどうかをチェックする。
        </td><td>
         <p><code class="literal">
           jsonb_path_exists('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </code></p>
        </td><td>
          <p><code class="literal">true</code></p>
        </td></tr><tr><td>
         <p><code class="literal">
           jsonb_path_match(target jsonb, path jsonpath [<span class="optional">, vars jsonb [<span class="optional">, silent bool</span>]</span>])
         </code></p>
        </td><td><code class="type">boolean</code></td><td>
<!--
          Returns the result of JSON path predicate check for the specified JSON value.
          Only the first item of the result is taken into account.  If the
          result is not Boolean, then <literal>null</literal> is returned.
-->
        指定したJSON値のJSONパス述語チェックの結果を返す。
        結果の最初の項目だけが考慮されます。
        結果がBooleanでないなら、<code class="literal">null</code>が返ります。
        </td><td>
         <p><code class="literal">
           jsonb_path_match('{"a":[1,2,3,4,5]}', 'exists($.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max))', '{"min":2,"max":4}')
        </code></p>
        </td><td>
          <p><code class="literal">true</code></p>
        </td></tr><tr><td>
         <p><code class="literal">
           jsonb_path_query(target jsonb, path jsonpath [<span class="optional">, vars jsonb [<span class="optional">, silent bool</span>]</span>])
         </code></p>
        </td><td><code class="type">setof jsonb</code></td><td>
<!--
          Gets all JSON items returned by JSON path for the specified JSON
          value.
-->
指定したJSON値に対してJSONパスが返すすべてのJSON項目を得る。
        </td><td>
         <p><code class="literal">
           select * from jsonb_path_query('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}');
         </code></p>
        </td><td>
         <p>
</p><pre class="programlisting">
 jsonb_path_query
------------------
 2
 3
 4
</pre><p>
         </p>
        </td></tr><tr><td>
         <p><code class="literal">
           jsonb_path_query_array(target jsonb, path jsonpath [<span class="optional">, vars jsonb [<span class="optional">, silent bool</span>]</span>])
         </code></p>
        </td><td><code class="type">jsonb</code></td><td>
<!--
          Gets all JSON items returned by JSON path for the specified JSON
          value and wraps result into an array.
-->
指定したJSON値に対してJSONパスが返すすべてのJSON項目を得て配列に格納する。
        </td><td>
         <p><code class="literal">
           jsonb_path_query_array('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </code></p>
        </td><td>
          <p><code class="literal">[2, 3, 4]</code></p>
        </td></tr><tr><td>
         <p><code class="literal">
           jsonb_path_query_first(target jsonb, path jsonpath [<span class="optional">, vars jsonb [<span class="optional">, silent bool</span>]</span>])
         </code></p>
        </td><td><code class="type">jsonb</code></td><td>
<!--
          Gets the first JSON item returned by JSON path for the specified JSON
          value.  Returns <literal>NULL</literal> on no results.
-->
指定したJSON値に対するJSONパスが返す最初のJSON項目を得る。
結果がなければ<code class="literal">NULL</code>を返す。
        </td><td>
         <p><code class="literal">
           jsonb_path_query_first('{"a":[1,2,3,4,5]}', '$.a[*] ? (@ &gt;= $min &amp;&amp; @ &lt;= $max)', '{"min":2,"max":4}')
         </code></p>
        </td><td>
          <p><code class="literal">2</code></p>
        </td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注記</h3><p>
<!--
      Many of these functions and operators will convert Unicode escapes in
      JSON strings to the appropriate single character.  This is a non-issue
      if the input is type <type>jsonb</type>, because the conversion was already
      done; but for <type>json</type> input, this may result in throwing an error,
      as noted in <xref linkend="datatype-json"/>.
-->
これらの関数や演算子の多くは、JSON文字列のUnicodeのエスケープを適切な一文字に変換します。
これは入力が<code class="type">jsonb</code>型であれば、変換は既に行なわれていますので、重要な問題ではありません。しかし、<code class="type">json</code>の入力に対しては、<a class="xref" href="datatype-json.html" title="8.14. JSONデータ型">8.14</a>で言及したようにこれはエラーを発生させる結果になるかもしれません。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
    The functions
    <function>json[b]_populate_record</function>,
    <function>json[b]_populate_recordset</function>,
    <function>json[b]_to_record</function> and
    <function>json[b]_to_recordset</function>
    operate on a JSON object, or array of objects, and extract the values
    associated with keys whose names match column names of the output row
    type.
    Object fields that do not correspond to any output column name are
    ignored, and output columns that do not match any object field will be
    filled with nulls.
    To convert a JSON value to the SQL type of an output column, the
    following rules are applied in sequence:
-->
関数<code class="function">json[b]_populate_record</code>、<code class="function">json[b]_populate_recordset</code>、<code class="function">json[b]_to_record</code>、<code class="function">json[b]_to_recordset</code>はJSONオブジェクトあるいはJSONオブジェクトの配列を操作し、出力行型の列名と一致する名前を持つキーに関連付けられた値を取り出します。
出力列名と関連付けられないオブジェクトのフィールドは無視され、どのオブジェクトフィールドとも一致しない出力列はNULLで満たされます。
JSON値を出力列のSQL型に変換する際に以下のルールが順番に適用されます。
    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
<!--
       A JSON null value is converted to a SQL null in all cases.
-->
すべての場合にJSONのNULL値はSQLのNULLに変換されます。
      </p></li><li class="listitem"><p>
<!--
       If the output column is of type <type>json</type>
       or <type>jsonb</type>, the JSON value is just reproduced exactly.
-->
出力列が<code class="type">json</code>型あるいは<code class="type">jsonb</code>型なら、JSON値は単にそのまま複製されます。
      </p></li><li class="listitem"><p>
<!--
       If the output column is a composite (row) type, and the JSON value is
       a JSON object, the fields of the object are converted to columns of
       the output row type by recursive application of these rules.
-->
出力行が複合(行)型でJSON値がJSONオブジェクトなら、これらのルールを再帰的に適用することによって、オブジェクトのフィールドが出力行型の列に変換されます。
      </p></li><li class="listitem"><p>
<!--
       Likewise, if the output column is an array type and the JSON value is
       a JSON array, the elements of the JSON array are converted to elements
       of the output array by recursive application of these rules.
-->
同様に、出力行が配列型でJSON値がJSON配列なら、これらのルールを再帰的に適用することによって、JSON配列の要素が出力配列の要素に変換されます。
      </p></li><li class="listitem"><p>
<!--
       Otherwise, if the JSON value is a string literal, the contents of the
       string are fed to the input conversion function for the column's data
       type.
-->
それ以外の場合で、JSON値が文字列リテラルなら、その文字列の内容が列のデータ型に対応する入力変換関数に送られます。
      </p></li><li class="listitem"><p>
<!--
       Otherwise, the ordinary text representation of the JSON value is fed
       to the input conversion function for the column's data type.
-->
さもなければ、通常のJSON値のテキスト表現が列のデータ型に対応する入力変換関数に送られます。
      </p></li></ul></div><p>
   </p><p>
<!--
    While the examples for these functions use constants, the typical use
    would be to reference a table in the <literal>FROM</literal> clause
    and use one of its <type>json</type> or <type>jsonb</type> columns
    as an argument to the function.  Extracted key values can then be
    referenced in other parts of the query, like <literal>WHERE</literal>
    clauses and target lists.  Extracting multiple values in this
    way can improve performance over extracting them separately with
    per-key operators.
  -->
これらの関数の例では定数を使用していますが、典型的な使用法は<code class="literal">FROM</code>句でテーブルを参照し、その<code class="type">json</code>または<code class="type">jsonb</code>列を関数の引数として使用することです。
<code class="literal">WHERE</code>句やターゲットリストのように、抽出されたキー値はクエリの他の部分で参照することができます。
この方法で複数の値を抽出すると、キー単位の演算子で個別に抽出するよりもパフォーマンスが向上します。
   </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
      All the items of the <literal>path</literal> parameter of <literal>jsonb_set</literal>
      as well as <literal>jsonb_insert</literal> except the last item must be present
      in the <literal>target</literal>. If <literal>create_missing</literal> is false, all
      items of the <literal>path</literal> parameter of <literal>jsonb_set</literal> must be
      present. If these conditions are not met the <literal>target</literal> is
      returned unchanged.
-->
<code class="literal">jsonb_set</code>および<code class="literal">jsonb_insert</code>の<code class="literal">path</code>パラメータは、最後の項目を除き、すべての項目が<code class="literal">target</code>内に存在しなければなりません。
<code class="literal">create_missing</code>が偽なら、<code class="literal">jsonb_set</code>の<code class="literal">path</code>パラメータのすべての項目が存在しなければなりません。
これらの条件が満たされなければ、<code class="literal">target</code>が変更されずに返されます。
    </p><p>
<!--
      If the last path item is an object key, it will be created if it
      is absent and given the new value. If the last path item is an array
      index, if it is positive the item to set is found by counting from
      the left, and if negative by counting from the right - <literal>-1</literal>
      designates the rightmost element, and so on.
      If the item is out of the range -array_length .. array_length -1,
      and create_missing is true, the new value is added at the beginning
      of the array if the item is negative, and at the end of the array if
      it is positive.
-->
パスの最後の要素がオブジェクトのキーの場合、それが存在しなければ作成されて、新しい値が与えられます。
パスの最後の項目が配列の添字の場合、それが正ならセットすべき項目は左から数えられ、負なら右から数えられます（<code class="literal">-1</code>は最も右側の要素を指す、という具合です）。
項目が[-array_length .. array_length -1]の範囲外にあり、かつcreate_missingが真なら、新しい値が配列の先頭（項目が負数のとき）あるいは配列の終わり（項目が正数のとき）に追加されます。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
      The <literal>json_typeof</literal> function's <literal>null</literal> return value
      should not be confused with a SQL NULL.  While
      calling <literal>json_typeof('null'::json)</literal> will
      return <literal>null</literal>, calling <literal>json_typeof(NULL::json)</literal>
      will return a SQL NULL.
-->
<code class="literal">json_typeof</code>の<code class="literal">null</code>戻り値をSQLのNULLと混同してはいけません。
<code class="literal">json_typeof('null'::json)</code>を呼び出すと<code class="literal">null</code>が返りますが、<code class="literal">json_typeof(NULL::json)</code>を呼び出すとSQLのNULLが返ります。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
      If the argument to <literal>json_strip_nulls</literal> contains duplicate
      field names in any object, the result could be semantically somewhat
      different, depending on the order in which they occur. This is not an
      issue for <literal>jsonb_strip_nulls</literal> since <type>jsonb</type> values never have
      duplicate object field names.
-->
<code class="literal">json_strip_nulls</code>の引数で、オブジェクト内にフィールド名が重複しているものがある場合、それが発生している順序によって、結果は意味的にやや異なるものになることがあります。
<code class="type">jsonb</code>値はオブジェクトのフィールド名が重複することがないので、<code class="literal">jsonb_strip_nulls</code>にはこのような問題はありません。
    </p></div><div class="note"><h3 class="title">注記</h3><p>
<!--
    The <literal>jsonb_path_exists</literal>, <literal>jsonb_path_match</literal>,
    <literal>jsonb_path_query</literal>, <literal>jsonb_path_query_array</literal>, and
    <literal>jsonb_path_query_first</literal>
    functions have optional <literal>vars</literal> and <literal>silent</literal>
    arguments.
-->
<code class="literal">jsonb_path_exists</code>、<code class="literal">jsonb_path_match</code>、<code class="literal">jsonb_path_query</code>, <code class="literal">jsonb_path_query_array</code>、<code class="literal">jsonb_path_query_first</code>関数はオプションの<code class="literal">vars</code>と<code class="literal">silent</code>引数を持ちます。
   </p><p>
<!--
    If the <parameter>vars</parameter> argument is specified, it provides an
    object containing named variables to be substituted into a
    <literal>jsonpath</literal> expression.
-->
<em class="parameter"><code>vars</code></em>引数が指定されると、<code class="literal">jsonpath</code>式に変換できる名前付きの変数を含むオブジェクトを関数は返します。
   </p><p>
<!--
    If the <parameter>silent</parameter> argument is specified and has the
    <literal>true</literal> value, these functions suppress the same errors
    as the <literal>@?</literal> and <literal>@@</literal> operators.
-->
<em class="parameter"><code>silent</code></em>引数が指定され、それが値<code class="literal">true</code>なら、これらの関数は<code class="literal">@?</code>と<code class="literal">@@</code>演算子と同じエラーを抑止します。
   </p></div><p>
<!--
    See also <xref linkend="functions-aggregate"/> for the aggregate
    function <function>json_agg</function> which aggregates record
    values as JSON, and the aggregate function
    <function>json_object_agg</function> which aggregates pairs of values
    into a JSON object, and their <type>jsonb</type> equivalents,
    <function>jsonb_agg</function> and <function>jsonb_object_agg</function>.
-->
レコードの値をJSONに集約する<code class="function">json_agg</code>集約関数、値の対をJSONオブジェクトに集約する<code class="function">json_object_agg</code>集約関数、およびそれらの<code class="type">jsonb</code>版の<code class="function">jsonb_agg</code>と<code class="function">jsonb_object_agg</code>については<a class="xref" href="functions-aggregate.html" title="9.20. 集約関数">9.20</a>を参照して下さい。
  </p></div><div class="sect2" id="FUNCTIONS-SQLJSON-PATH"><div class="titlepage"><div><div><h3 class="title">9.15.2. SQL/JSONパス言語</h3></div></div></div><!--
  <title>The SQL/JSON Path Language</title>
--><a id="id-1.5.8.20.6.2" class="indexterm"></a><p>
<!--
   SQL/JSON path expressions specify the items to be retrieved
   from the JSON data, similar to XPath expressions used
   for SQL access to XML. In <productname>PostgreSQL</productname>,
   path expressions are implemented as the <type>jsonpath</type>
   data type and can use any elements described in
   <xref linkend="datatype-jsonpath"/>.
-->
SQL/JSONパス式は、XMLへのSQLアクセスで使用されるXPath同様、JSONデータから取り出す項目を指定します。
<span class="productname">PostgreSQL</span>ではパス式は<code class="type">jsonpath</code>データ型として実装されており、<a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.6. jsonpath型">8.14.6</a>で説明されているすべての要素を使うことができます。
  </p><!--
  <para>JSON query functions and operators
   pass the provided path expression to the <firstterm>path engine</firstterm>
   for evaluation. If the expression matches the queried JSON data,
   the corresponding SQL/JSON item is returned.
   Path expressions are written in the SQL/JSON path language
   and can also include arithmetic expressions and functions.
   Query functions treat the provided expression as a
   text string, so it must be enclosed in single quotes.
--><p>
JSON問い合わせ関数と演算子は与えられたパス式を<em class="firstterm">path engine</em>に渡して評価します。
式が問い合わせ対象のJSONデータにマッチすれば、関連するSQL/JSON項目が返却されます。
パス式はSQL/JSONパス言語で書かれ、算術式と関数を含むことができます。
問い合わせ関数は与えられた式をテキスト文字列として扱うので、単一引用符で括らなければなりません。
  </p><p>
<!--
   A path expression consists of a sequence of elements allowed
   by the <type>jsonpath</type> data type.
   The path expression is evaluated from left to right, but
   you can use parentheses to change the order of operations.
   If the evaluation is successful, a sequence of SQL/JSON items
   (<firstterm>SQL/JSON sequence</firstterm>) is produced,
   and the evaluation result is returned to the JSON query function
   that completes the specified computation.
-->
パス式は<code class="type">jsonpath</code>データ型で認められた一連の要素からなります。
パス式は左から右へと評価されますが、括弧を使って演算の順序を変更することができます。
評価が成功すれば、一連のSQL/JSON項目（<em class="firstterm">SQL/JSON sequence</em>）が生成され、評価結果が指定した計算を完了したJSON問い合わせ関数に戻されます。
  </p><p>
<!--
   To refer to the JSON data to be queried (the
   <firstterm>context item</firstterm>), use the <literal>$</literal> sign
   in the path expression. It can be followed by one or more
   <link linkend="type-jsonpath-accessors">accessor operators</link>,
   which go down the JSON structure level by level to retrieve the
   content of context item. Each operator that follows deals with the
   result of the previous evaluation step.
-->
問い合わせ対象（<em class="firstterm">context item</em>）のJSONデータを参照するには、パス式内で<code class="literal">$</code>記号を使います。
複数の<a class="link" href="datatype-json.html#TYPE-JSONPATH-ACCESSORS" title="表8.25 jsonpath Accessors">アクセサ演算子</a>をその後に記述することもできます。
それによってJSON構造をレベル順に訪れて文脈の項目の内容を取り出します。
後続の個々の演算子はその前の評価段階の結果を処理します。
  </p><p>
<!--
   For example, suppose you have some JSON data from a GPS tracker that you
   would like to parse, such as:
-->
たとえば、次のようなパースしたいGPSトラッカーからのJSONデータがあるとします。
</p><pre class="programlisting">
{
  "track": {
    "segments": [
      {
        "location":   [ 47.763, 13.4034 ],
        "start time": "2018-10-14 10:05:14",
        "HR": 73
      },
      {
        "location":   [ 47.706, 13.2635 ],
        "start time": "2018-10-14 10:39:21",
        "HR": 135
      }
    ]
  }
}
</pre><p>
  </p><p>
<!--
   To retrieve the available track segments, you need to use the
   <literal>.<replaceable>key</replaceable></literal> accessor
   operator for all the preceding JSON objects:
-->
存在するトラックセグメントを取り出すには、<code class="literal">.<em class="replaceable"><code>key</code></em></code>アクセサ演算子をすべての先行するJSONオブジェクトに使用する必要があります。
</p><pre class="programlisting">
'$.track.segments'
</pre><p>
  </p><p>
<!--
   If the item to retrieve is an element of an array, you have
   to unnest this array using the <literal>[*]</literal> operator. For example,
   the following path will return location coordinates for all
   the available track segments:
-->
取得したい項目が配列要素なら、<code class="literal">[*]</code>演算子を使って非配列化（unnest）する必要があります。
たとえば次のパスはすべての存在するトラックセグメントの位置座標を返します。
</p><pre class="programlisting">
'$.track.segments[*].location'
</pre><p>
  </p><p>
<!--
   To return the coordinates of the first segment only, you can
   specify the corresponding subscript in the <literal>[]</literal>
   accessor operator. Note that the SQL/JSON arrays are 0-relative:
-->
最初のセグメントの座標だけを返すには、<code class="literal">[]</code>アクセサ演算子の中で対応する添え字を指定することができます。
SQL/JSON配列は0スタートであることに注意してください。
</p><pre class="programlisting">
'$.track.segments[0].location'
</pre><p>
  </p><p>
<!--
   The result of each path evaluation step can be processed
   by one or more <type>jsonpath</type> operators and methods
   listed in <xref linkend="functions-sqljson-path-operators"/>.
   Each method name must be preceded by a dot. For example,
   you can get an array size:
-->
各段階でのパス評価結果は<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.15.2.3. SQL/JSONパス演算子とメソッド">9.15.2.3</a>に列挙されている一つ以上の<code class="type">jsonpath</code>演算子とメソッドで処理することができます。
各々のメソッド名の前にピリオドを付けなければなりません。
たとえば配列の大きさを得ることができます。
</p><pre class="programlisting">
'$.track.segments.size()'
</pre><p>
<!--
   For more examples of using <type>jsonpath</type> operators
   and methods within path expressions, see
   <xref linkend="functions-sqljson-path-operators"/>.
-->
パス式内の<code class="type">jsonpath</code>演算子とメソッドについては<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-PATH-OPERATORS" title="9.15.2.3. SQL/JSONパス演算子とメソッド">9.15.2.3</a>を参照してください。
  </p><p>
<!--
   When defining the path, you can also use one or more
   <firstterm>filter expressions</firstterm> that work similar to the
   <literal>WHERE</literal> clause in SQL. A filter expression begins with
   a question mark and provides a condition in parentheses:
-->
パスを定義する際にはSQLの<code class="literal">WHERE</code>節のように働く一つ以上の<em class="firstterm">フィルター式</em>が利用できます。
フィルター式はクェスチョンマークで始まり、カッコ内に条件を記述します。

</p><pre class="programlisting">
? (<em class="replaceable"><code>condition</code></em>)
</pre><p>
  </p><p>
<!--
   Filter expressions must be specified right after the path evaluation step
   to which they are applied. The result of this step is filtered to include
   only those items that satisfy the provided condition. SQL/JSON defines
   three-valued logic, so the condition can be <literal>true</literal>, <literal>false</literal>,
   or <literal>unknown</literal>. The <literal>unknown</literal> value
   plays the same role as SQL <literal>NULL</literal> and can be tested
   for with the <literal>is unknown</literal> predicate. Further path
   evaluation steps use only those items for which filter expressions
   return <literal>true</literal>.
-->
フィルター式はそれを適用するパス評価段階の直後に指定しなければなりません。
この段階の結果は、指定した条件を満たす項目だけが含まれるようにフィルターされます。
SQL/JSONは3値論理を定義しており、条件は<code class="literal">true</code>、<code class="literal">false</code>、<code class="literal">unknown</code>のどれかです。
<code class="literal">unknown</code>は値はSQLの<code class="literal">NULL</code>と同じ役割を果たし、<code class="literal">is unknown</code>述語で評価できます。
その後の評価段階では<code class="literal">true</code>を返すフィルター式に対応する項目だけが使われます。
  </p><p>
<!--
   Functions and operators that can be used in filter expressions are listed
   in <xref linkend="functions-sqljson-filter-ex-table"/>. The path
   evaluation result to be filtered is denoted by the <literal>@</literal>
   variable. To refer to a JSON element stored at a lower nesting level,
   add one or more accessor operators after <literal>@</literal>.
-->
フィルター式内で利用できる関数と演算子は<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="表9.49 jsonpathフィルター式要素">表 9.49</a>にリストされています。
フィルターする必要のあるパス評価結果は<code class="literal">@</code>変数で示します。
下位の入れ子レベルに格納されているJSON要素を参照するには、一つ以上のアクセサ演算子を<code class="literal">@</code>の後に追加してください。
  </p><p>
<!--
   Suppose you would like to retrieve all heart rate values higher
   than 130. You can achieve this using the following expression:
-->
130より高い心拍数を取り出したいとします。次の式を使ってそれを得ることができます。
</p><pre class="programlisting">
'$.track.segments[*].HR ? (@ &gt; 130)'
</pre><p>
  </p><p>
<!--
   To get the start time of segments with such values instead, you have to
   filter out irrelevant segments before returning the start time, so the
   filter expression is applied to the previous step, and the path used
   in the condition is different:
-->
代わりにそうした値を持つセグメントの開始時刻を得たい場合は、開始時刻を返す前に無関係のセグメントを取り除く必要があります。
そうすることにより前の段階にフィルター式が適用されるので、その条件で適用されるパスは異なります。
</p><pre class="programlisting">
'$.track.segments[*] ? (@.HR &gt; 130)."start time"'
</pre><p>
  </p><p>
<!--
   You can use several filter expressions on the same nesting level, if
   required. For example, the following expression selects all segments
   that contain locations with relevant coordinates and high heart rate values:
-->
必要なら同じ入れ子レベルに対して複数のフィルター式を使用することができます。
たとえば次の式は指定した座標と高い心拍数値を持つ位置を持つすべてのセグメントを選択します。
</p><pre class="programlisting">
'$.track.segments[*] ? (@.location[1] &lt; 13.4) ? (@.HR &gt; 130)."start time"'
</pre><p>
  </p><p>
<!--
   Using filter expressions at different nesting levels is also allowed.
   The following example first filters all segments by location, and then
   returns high heart rate values for these segments, if available:
-->
異なる入れ子レベルに対してフィルター式を適用することもできます。
次の例では、まず位置ですべてのセグメントをフィルターし、もしあれば高い心拍数値を返します。
</p><pre class="programlisting">
'$.track.segments[*] ? (@.location[1] &lt; 13.4).HR ? (@ &gt; 130)'
</pre><p>
  </p><p>
<!--
   You can also nest filter expressions within each other:
-->
フィルター式をお互いに入れ子にすることもできます。
</p><pre class="programlisting">
'$.track ? (exists(@.segments[*] ? (@.HR &gt; 130))).segments.size()'
</pre><p>
<!--
   This expression returns the size of the track if it contains any
   segments with high heart rate values, or an empty sequence otherwise.
-->
この式は高い心拍数値を含むトラックがあればそのすべてのサイズを返します。もしなければ空のシーケンスが返ります。
  </p><p>
<!--
   <productname>PostgreSQL</productname>'s implementation of SQL/JSON path
   language has the following deviations from the SQL/JSON standard:
-->
<span class="productname">PostgreSQL</span>のSQL/JSONパス言語の実装はSQL/JSON標準と次の点が異なります。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
     <literal>.datetime()</literal> item method is not implemented yet
     mainly because immutable <type>jsonpath</type> functions and operators
     cannot reference session timezone, which is used in some datetime
     operations.  Datetime support will be added to <type>jsonpath</type>
     in future versions of <productname>PostgreSQL</productname>.
-->
<code class="literal">.datetime()</code>項目メソッドは、主に不揮発性<code class="type">jsonpath</code>関数と演算子が日付時刻操作で使用されているセッション時間帯を参照できないという理由でまだ実装されていません。
将来の<span class="productname">PostgreSQL</span>バージョンでは<code class="type">jsonpath</code>のサポートが追加される予定です。
    </p></li><li class="listitem"><p>
<!--
     A path expression can be a Boolean predicate, although the SQL/JSON
     standard allows predicates only in filters.  This is necessary for
     implementation of the <literal>@@</literal> operator. For example,
     the following <type>jsonpath</type> expression is valid in
     <productname>PostgreSQL</productname>:
-->
SQL/JSON標準ではフィルター内でのみ述語が使えますが、パス式はBoolean述語でも構いません。
これは<code class="literal">@@</code>演算子を実装するために必要です。
たとえば、次の<code class="type">jsonpath</code>式は<span class="productname">PostgreSQL</span>では有効です。
</p><pre class="programlisting">
'$.track.segments[*].HR &lt; 70'
</pre><p>
    </p></li><li class="listitem"><p>
<!--
     There are minor differences in the interpretation of regular
     expression patterns used in <literal>like_regex</literal> filters, as
     described in <xref linkend="jsonpath-regular-expressions"/>.
-->
<a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.15.2.2. 正規表現">9.15.2.2</a>で述べるように、<code class="literal">like_regex</code>フィルターで使用される正規表現パターンの解釈には些細な違いがあります。
    </p></li></ul></div><div class="sect3" id="STRICT-AND-LAX-MODES"><div class="titlepage"><div><div><h4 class="title">9.15.2.1. 厳密モードと非厳密モード</h4></div></div></div><!--
   <title>Strict and Lax Modes</title>
--><p>
<!--
     When you query JSON data, the path expression may not match the
     actual JSON data structure. An attempt to access a non-existent
     member of an object or element of an array results in a
     structural error. SQL/JSON path expressions have two modes
     of handling structural errors:
-->
JSONデータを問い合わせる際、パス式は実際のJSONデータ構造に一致しないかも知れません。
存在しないオブジェクトのメンバーあるいは配列要素にアクセスしようとすると、構造上のエラーとなります。
SQL/JSONパス式には構造上のエラーを扱うための2つのモードがあります。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
      lax (default) &mdash; the path engine implicitly adapts
      the queried data to the specified path.
      Any remaining structural errors are suppressed and converted
      to empty SQL/JSON sequences.
-->
非厳密(lax)モード（デフォルト）— パスエンジンは指定したパスを問い合わせデータに暗黙的に適合させます。
構造上のエラーは抑止され、空のSQL/JSONシーケンスへと変換されます。
     </p></li><li class="listitem"><p>
<!--
      strict &mdash; if a structural error occurs, an error is raised.
-->
厳密(strict)モード — 構造上のエラーがあるとエラーが発生します。
     </p></li></ul></div><p>
<!--
    The lax mode facilitates matching of a JSON document structure and path
    expression if the JSON data does not conform to the expected schema.
    If an operand does not match the requirements of a particular operation,
    it can be automatically wrapped as an SQL/JSON array or unwrapped by
    converting its elements into an SQL/JSON sequence before performing
    this operation. Besides, comparison operators automatically unwrap their
    operands in the lax mode, so you can compare SQL/JSON arrays
    out-of-the-box. An array of size 1 is considered equal to its sole element.
    Automatic unwrapping is not performed only when:
-->
非厳密モードは、JSONデータが期待されるスキーマに沿わないときにJSON文書構造とパス式のマッチングを助けます。
あるオペランドが操作の要件に合わないときにはそれをSQL/JSON配列にまとめたり、あるいは操作を行う前にそれをSQL/JSONシーケンスに展開することもできます。
また非厳密モードにおいては、比較演算子は自動的にオペランドを展開し、SQL/JSON配列をそのまま比較することができます。
大きさ1の配列はその単独要素と同じものとして扱われます。
自動展開は以下の場合にのみ行われません。
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<!--
       The path expression contains <literal>type()</literal> or
       <literal>size()</literal> methods that return the type
       and the number of elements in the array, respectively.
-->
それぞれ配列の型、要素数を返す<code class="literal">type()</code>、<code class="literal">size()</code>をパス式が含む。
      </p></li><li class="listitem"><p>
<!--
       The queried JSON data contain nested arrays. In this case, only
       the outermost array is unwrapped, while all the inner arrays
       remain unchanged. Thus, implicit unwrapping can only go one
       level down within each path evaluation step.
-->
問い合わせ対象のJSONデータが入れ子の配列を含む。
この場合はもっとも外側の配列のみが展開され、内側の配列は変わりません。
ですから、それぞれの評価段階において1レベルのみに暗黙的な展開が行われます。
      </p></li></ul></div><p>
   </p><p>
<!--
    For example, when querying the GPS data listed above, you can
    abstract from the fact that it stores an array of segments
    when using the lax mode:
-->
たとえば、上述のGPSデータに問い合わせする際、非厳密モードでは配列のセグメントを含んでいることを抽象化できます。
</p><pre class="programlisting">
'lax $.track.segments.location'
</pre><p>
   </p><p>
<!--
    In the strict mode, the specified path must exactly match the structure of
    the queried JSON document to return an SQL/JSON item, so using this
    path expression will cause an error. To get the same result as in
    the lax mode, you have to explicitly unwrap the
    <literal>segments</literal> array:
-->
厳密モードでは、指定したパスはSQL/JSON項目を返す問い合わせ対象のJSON文書の構造に正確に一致していなければなりません。ですから、このパス式を使うとエラーになります。
非厳密モードと同じ結果を得るためには、<code class="literal">segments</code>配列を明示的に展開する必要があります。
</p><pre class="programlisting">
'strict $.track.segments[*].location'
</pre><p>
   </p></div><div class="sect3" id="JSONPATH-REGULAR-EXPRESSIONS"><div class="titlepage"><div><div><h4 class="title">9.15.2.2. 正規表現</h4></div></div></div><!--
    <title>Regular Expressions</title>
--><a id="id-1.5.8.20.6.23.2" class="indexterm"></a><p>
<!--
     SQL/JSON path expressions allow matching text to a regular expression
     with the <literal>like_regex</literal> filter.  For example, the
     following SQL/JSON path query would case-insensitively match all
     strings in an array that start with an English vowel:
-->
SQL/JSONパス式では<code class="literal">like_regex</code>フィルターを使ってテキストを正規表現にマッチさせることができます。
たとえば、次のSQL/JSONパス式問い合わせは、英語の母音で始まる配列内のすべての文字列に大文字小文字を無視してマッチするでしょう。
</p><pre class="programlisting">
'$[*] ? (@ like_regex "^[aeiou]" flag "i")'
</pre><p>
    </p><p>
<!--
     The optional <literal>flag</literal> string may include one or more of
     the characters
     <literal>i</literal> for case-insensitive match,
     <literal>m</literal> to allow <literal>^</literal>
     and <literal>$</literal> to match at newlines,
     <literal>s</literal> to allow <literal>.</literal> to match a newline,
     and <literal>q</literal> to quote the whole pattern (reducing the
     behavior to a simple substring match).
-->
オプションの<code class="literal">flag</code>文字列は一つ以上の文字を含むことができます。
<code class="literal">i</code>は大文字小文字を無視したマッチ、<code class="literal">m</code>は<code class="literal">^</code>と<code class="literal">$</code>で改行にマッチ、<code class="literal">s</code>は<code class="literal">.</code>が改行にマッチ、<code class="literal">q</code>はパターン全体を参照します。（振る舞いを単純な部分文字列マッチとします）
    </p><p>
<!--
     The SQL/JSON standard borrows its definition for regular expressions
     from the <literal>LIKE_REGEX</literal> operator, which in turn uses the
     XQuery standard.  PostgreSQL does not currently support the
     <literal>LIKE_REGEX</literal> operator.  Therefore,
     the <literal>like_regex</literal> filter is implemented using the
     POSIX regular expression engine described in
     <xref linkend="functions-posix-regexp"/>.  This leads to various minor
     discrepancies from standard SQL/JSON behavior, which are cataloged in
     <xref linkend="posix-vs-xquery"/>.
     Note, however, that the flag-letter incompatibilities described there
     do not apply to SQL/JSON, as it translates the XQuery flag letters to
     match what the POSIX engine expects.
-->
SQL/JSON標準は正規表現の定義を、XQuery標準を使用する<code class="literal">LIKE_REGEX</code>演算子から借りています。
PostgreSQLは今の所<code class="literal">LIKE_REGEX</code>演算子をサポートしていません。
ですから、<code class="literal">like_regex</code>フィルターは<a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. POSIX正規表現">9.7.3</a>で説明されているPOSIX正規表現で実装されています。
このことにより、<a class="xref" href="functions-matching.html#POSIX-VS-XQUERY" title="9.7.3.8. XQueryとの違い(LIKE_REGEX)">9.7.3.8</a>で列挙されているSQL/JSON標準の振る舞いとの小さな違いが生じます。
しかし、ここで述べているフラグ文字の非互換性はSQL/JSONには適用されないことに注意してください。SQL/JSONは、XQueryのフラグ文字をPOSIXエンジンが期待するのと一致するように解釈するからです。
    </p><p>
<!--
     Keep in mind that the pattern argument of <literal>like_regex</literal>
     is a JSON path string literal, written according to the rules given in
     <xref linkend="datatype-jsonpath"/>.  This means in particular that any
     backslashes you want to use in the regular expression must be doubled.
     For example, to match strings that contain only digits:
-->
<code class="literal">like_regex</code>のパターン引数は<a class="xref" href="datatype-json.html#DATATYPE-JSONPATH" title="8.14.6. jsonpath型">8.14.6</a>で説明されているルールにしたがって書かれたJSONパス文字列リテラルであることに注意してください。
これは、正規表現で使用するすべてのバックスラッシュを二重に書かなければならないことを意味します。
たとえば、数字のみを含む文字列にマッチさせるには以下のようにします。
</p><pre class="programlisting">
'$ ? (@ like_regex "^\\d+$")'
</pre><p>
    </p></div><div class="sect3" id="FUNCTIONS-SQLJSON-PATH-OPERATORS"><div class="titlepage"><div><div><h4 class="title">9.15.2.3. SQL/JSONパス演算子とメソッド</h4></div></div></div><!--
   <title>SQL/JSON Path Operators and Methods</title>
--><p>
<!--
    <xref linkend="functions-sqljson-op-table"/> shows the operators and
    methods available in <type>jsonpath</type>.  <xref
    linkend="functions-sqljson-filter-ex-table"/> shows the available filter
    expression elements.
-->
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-OP-TABLE" title="表9.48 jsonpath演算子とメソッド">表 9.48</a>に<code class="type">jsonpath</code>で利用可能な演算子とメソッドを示します。
<a class="xref" href="functions-json.html#FUNCTIONS-SQLJSON-FILTER-EX-TABLE" title="表9.49 jsonpathフィルター式要素">表 9.49</a>には利用可能なフィルター式要素が示されています。
   </p><div class="table" id="FUNCTIONS-SQLJSON-OP-TABLE"><p class="title"><strong>表9.48 <code class="type">jsonpath</code>演算子とメソッド</strong></p><div class="table-contents"><!--
    <title><type>jsonpath</type> Operators and Methods</title>
--><table class="table" summary="jsonpath演算子とメソッド" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>演算子/メソッド</th><th>説明</th><th>JSONの例</th><th>問い合わせ例</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">+</code>（単項）</td><td>SQL/JSONシーケンスに繰り返し適用される加算演算子</td><td><code class="literal">{"x": [2.85, -14.7, -9.4]}</code></td><td><code class="literal">+ $.x.floor()</code></td><td><code class="literal">2, -15, -10</code></td></tr><tr><td><code class="literal">-</code>（単項）</td><td>SQL/JSONシーケンスに繰り返し適用される減算演算子</td><td><code class="literal">{"x": [2.85, -14.7, -9.4]}</code></td><td><code class="literal">- $.x.floor()</code></td><td><code class="literal">-2, 15, 10</code></td></tr><tr><td><code class="literal">+</code>（二項）</td><td>加算</td><td><code class="literal">[2]</code></td><td><code class="literal">2 + $[0]</code></td><td><code class="literal">4</code></td></tr><tr><td><code class="literal">-</code>（二項）</td><td>減算</td><td><code class="literal">[2]</code></td><td><code class="literal">4 - $[0]</code></td><td><code class="literal">2</code></td></tr><tr><td><code class="literal">*</code></td><td>積算</td><td><code class="literal">[4]</code></td><td><code class="literal">2 * $[0]</code></td><td><code class="literal">8</code></td></tr><tr><td><code class="literal">/</code></td><td>除算</td><td><code class="literal">[8]</code></td><td><code class="literal">$[0] / 2</code></td><td><code class="literal">4</code></td></tr><tr><td><code class="literal">%</code></td><td>剰余</td><td><code class="literal">[32]</code></td><td><code class="literal">$[0] % 10</code></td><td><code class="literal">2</code></td></tr><tr><td><code class="literal">type()</code></td><td>SQL/JSON項目の型</td><td><code class="literal">[1, "2", {}]</code></td><td><code class="literal">$[*].type()</code></td><td><code class="literal">"number", "string", "object"</code></td></tr><tr><td><code class="literal">size()</code></td><td>SQL/JSON項目の大きさ</td><td><code class="literal">{"m": [11, 15]}</code></td><td><code class="literal">$.m.size()</code></td><td><code class="literal">2</code></td></tr><tr><td><code class="literal">double()</code></td><td>SQL/JSONの数字あるいは文字列から変換されたおおよその浮動小数点数</td><td><code class="literal">{"len": "1.9"}</code></td><td><code class="literal">$.len.double() * 2</code></td><td><code class="literal">3.8</code></td></tr><tr><td><code class="literal">ceiling()</code></td><td>SQL/JSON数字以上でもっとも近い整数</td><td><code class="literal">{"h": 1.3}</code></td><td><code class="literal">$.h.ceiling()</code></td><td><code class="literal">2</code></td></tr><tr><td><code class="literal">floor()</code></td><td>SQL/JSON数字以下でもっとも近い整数</td><td><code class="literal">{"h": 1.3}</code></td><td><code class="literal">$.h.floor()</code></td><td><code class="literal">1</code></td></tr><tr><td><code class="literal">abs()</code></td><td>SQL/JSON数字の絶対値</td><td><code class="literal">{"z": -0.3}</code></td><td><code class="literal">$.z.abs()</code></td><td><code class="literal">0.3</code></td></tr><tr><td><code class="literal">keyvalue()</code></td><td>
<!--
          Sequence of object's key-value pairs represented as array of items
          containing three fields (<literal>"key"</literal>,
          <literal>"value"</literal>, and <literal>"id"</literal>).
          <literal>"id"</literal> is a unique identifier of the object
          key-value pair belongs to.
-->
3つのフィールド（<code class="literal">"key"</code>、<code class="literal">"value"</code>、<code class="literal">"id"</code>）を含む項目の配列で表現されたオブジェクトのキーバリューペアのシーケンス。
<code class="literal">"id"</code>はキーバリューペアが所属するオブジェクトのユニーク識別子です。
        </td><td><code class="literal">{"x": "20", "y": 32}</code></td><td><code class="literal">$.keyvalue()</code></td><td><code class="literal">{"key": "x", "value": "20", "id": 0}, {"key": "y", "value": 32, "id": 0}</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="FUNCTIONS-SQLJSON-FILTER-EX-TABLE"><p class="title"><strong>表9.49 <code class="type">jsonpath</code>フィルター式要素</strong></p><div class="table-contents"><!--
     <title><type>jsonpath</type> Filter Expression Elements</title>
--><table class="table" summary="jsonpathフィルター式要素" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>値/述語</th><th>説明</th><th>JSONの例</th><th>問い合わせ例</th><th>結果</th></tr></thead><tbody><tr><td><code class="literal">==</code></td><td>等値演算子</td><td><code class="literal">[1, 2, 1, 3]</code></td><td><code class="literal">$[*] ? (@ == 1)</code></td><td><code class="literal">1, 1</code></td></tr><tr><td><code class="literal">!=</code></td><td>非等値演算子</td><td><code class="literal">[1, 2, 1, 3]</code></td><td><code class="literal">$[*] ? (@ != 1)</code></td><td><code class="literal">2, 3</code></td></tr><tr><td><code class="literal">&lt;&gt;</code></td><td>非等値演算子（<code class="literal">!=</code>と同じ）</td><td><code class="literal">[1, 2, 1, 3]</code></td><td><code class="literal">$[*] ? (@ &lt;&gt; 1)</code></td><td><code class="literal">2, 3</code></td></tr><tr><td><code class="literal">&lt;</code></td><td>未満演算子</td><td><code class="literal">[1, 2, 3]</code></td><td><code class="literal">$[*] ? (@ &lt; 2)</code></td><td><code class="literal">1</code></td></tr><tr><td><code class="literal">&lt;=</code></td><td>以下演算子</td><td><code class="literal">[1, 2, 3]</code></td><td><code class="literal">$[*] ? (@ &lt;= 2)</code></td><td><code class="literal">1, 2</code></td></tr><tr><td><code class="literal">&gt;</code></td><td>より大きい演算子</td><td><code class="literal">[1, 2, 3]</code></td><td><code class="literal">$[*] ? (@ &gt; 2)</code></td><td><code class="literal">3</code></td></tr><tr><td><code class="literal">&gt;=</code></td><td>以上演算子</td><td><code class="literal">[1, 2, 3]</code></td><td><code class="literal">$[*] ? (@ &gt;= 2)</code></td><td><code class="literal">2, 3</code></td></tr><tr><td><code class="literal">true</code></td><td>JSONの<code class="literal">true</code>リテラルとの比較に用いられる値</td><td><code class="literal">[{"name": "John", "parent": false},
                           {"name": "Chris", "parent": true}]</code></td><td><code class="literal">$[*] ? (@.parent == true)</code></td><td><code class="literal">{"name": "Chris", "parent": true}</code></td></tr><tr><td><code class="literal">false</code></td><td>JSONの<code class="literal">false</code>リテラルとの比較に用いられる値</td><td><code class="literal">[{"name": "John", "parent": false},
                           {"name": "Chris", "parent": true}]</code></td><td><code class="literal">$[*] ? (@.parent == false)</code></td><td><code class="literal">{"name": "John", "parent": false}</code></td></tr><tr><td><code class="literal">null</code></td><td>JSONの<code class="literal">null</code>値との比較に用いられる値</td><td><code class="literal">[{"name": "Mary", "job": null},
                         {"name": "Michael", "job": "driver"}]</code></td><td><code class="literal">$[*] ? (@.job == null) .name</code></td><td><code class="literal">"Mary"</code></td></tr><tr><td><code class="literal">&amp;&amp;</code></td><td>論理AND</td><td><code class="literal">[1, 3, 7]</code></td><td><code class="literal">$[*] ? (@ &gt; 1 &amp;&amp; @ &lt; 5)</code></td><td><code class="literal">3</code></td></tr><tr><td><code class="literal">||</code></td><td>論理OR</td><td><code class="literal">[1, 3, 7]</code></td><td><code class="literal">$[*] ? (@ &lt; 1 || @ &gt; 5)</code></td><td><code class="literal">7</code></td></tr><tr><td><code class="literal">!</code></td><td>論理NOT</td><td><code class="literal">[1, 3, 7]</code></td><td><code class="literal">$[*] ? (!(@ &lt; 5))</code></td><td><code class="literal">7</code></td></tr><tr><td><code class="literal">like_regex</code></td><td>
<!--
          Tests whether the first operand matches the regular expression
          given by the second operand, optionally with modifications
          described by a string of <literal>flag</literal> characters (see
          <xref linkend="jsonpath-regular-expressions"/>)
-->
最初のオペランドが2番目のオペランドで与えられる正規表現にマッチするかどうかテストする。
オプションで<code class="literal">flag</code>文字列で記述される変更を伴う。（<a class="xref" href="functions-json.html#JSONPATH-REGULAR-EXPRESSIONS" title="9.15.2.2. 正規表現">9.15.2.2</a>参照）
        </td><td><code class="literal">["abc", "abd", "aBdC", "abdacb", "babc"]</code></td><td><code class="literal">$[*] ? (@ like_regex "^ab.*c" flag "i")</code></td><td><code class="literal">"abc", "aBdC", "abdacb"</code></td></tr><tr><td><code class="literal">starts with</code></td><td>2番目の文字列が1番目のオペランドの最初の部分文字列かどうかをテストする</td><td><code class="literal">["John Smith", "Mary Stone", "Bob Johnson"]</code></td><td><code class="literal">$[*] ? (@ starts with "John")</code></td><td><code class="literal">"John Smith"</code></td></tr><tr><td><code class="literal">exists</code></td><td>パス式が少なくとも一つのSQL/JSON項目とマッチするかどうかをテストする</td><td><code class="literal">{"x": [1, 2], "y": [2, 4]}</code></td><td><code class="literal">strict $.* ? (exists (@ ? (@[*] &gt; 2)))</code></td><td><code class="literal">2, 4</code></td></tr><tr><td><code class="literal">is unknown</code></td><td>論理条件が<code class="literal">unknown</code>かどうかをテストする</td><td><code class="literal">[-1, 2, 7, "infinity"]</code></td><td><code class="literal">$[*] ? ((@ &gt; 0) is unknown)</code></td><td><code class="literal">"infinity"</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-xml.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-sequence.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">9.14. XML関数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 9.16. シーケンス操作関数</td></tr></table></div></body></html>