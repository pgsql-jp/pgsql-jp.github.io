<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.1. EXPLAINの利用</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets Vsnapshot" /><link rel="prev" href="performance-tips.html" title="第14章 性能に関するヒント" /><link rel="next" href="planner-stats.html" title="14.2. プランナで使用される統計情報" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body id="docContent" class="container-fluid col-10"><div class="other_version"><a href="https://www.postgresql.jp/document/">バージョンごとのドキュメント一覧</a></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="4" align="center"><a accesskey="h" href="index.html">PostgreSQL 17devel文書</a></th></tr><tr><td width="10%" align="left"></td><td width="10%" align="left"></td><td width="60%" align="center"><a href="performance-tips.html" title="第14章 性能に関するヒント">第14章 性能に関するヒント</a></td><td width="20%" align="right"><div class="actions"><a class="issue" title="github" href="https://github.com/pgsql-jp/jpug-doc/issues/new?template=bug_report.yml&amp;what-happened=version 17devel : using-explain.html">誤訳等の報告
                    </a></div></td></tr><tr><td width="10%" align="left"><a accesskey="p" href="performance-tips.html" title="第14章 性能に関するヒント">前へ</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="第14章 性能に関するヒント">上へ</a></td><td width="60%" align="center">14.1. <code class="command">EXPLAIN</code>の利用</td><td width="20%" align="right"> <a accesskey="n" href="planner-stats.html" title="14.2. プランナで使用される統計情報">次へ</a></td></tr></table><hr /></div><div class="sect1" id="USING-EXPLAIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.1. <code class="command">EXPLAIN</code>の利用 <a href="#USING-EXPLAIN" class="id_link">#</a></h2></div></div></div><span class="original">
  &lt;title&gt;Using &lt;command&gt;EXPLAIN&lt;/command&gt;&lt;/title&gt;
</span><a id="id-1.5.13.5.2" class="indexterm"></a><a id="id-1.5.13.5.3" class="indexterm"></a><a id="id-1.5.13.5.4" class="indexterm"></a><p>
<span class="original">
    &lt;productname&gt;PostgreSQL&lt;/productname&gt; devises a &lt;firstterm&gt;query
    plan&lt;/firstterm&gt; for each query it receives.  Choosing the right
    plan to match the query structure and the properties of the data
    is absolutely critical for good performance, so the system includes
    a complex &lt;firstterm&gt;planner&lt;/firstterm&gt; that tries to choose good plans.
    You can use the &lt;link linkend="sql-explain"&gt;&lt;command&gt;EXPLAIN&lt;/command&gt;&lt;/link&gt; command
    to see what query plan the planner creates for any query.
    Plan-reading is an art that requires some experience to master,
    but this section attempts to cover the basics.
</span>
<span class="productname">PostgreSQL</span>は受理した問い合わせから<em class="firstterm">問い合わせ計画</em>を作り出します。
問い合わせの構造と含まれるデータの性質に適した正しい問い合わせ計画を選択することが、良い性能を得るために非常に重要になります。
ですので、システムには優れた計画の選択を試みる複雑な<em class="firstterm">プランナ</em>が存在します。
<a class="link" href="sql-explain.html" title="EXPLAIN"><code class="command">EXPLAIN</code></a>コマンドを使えば、任意の問い合わせに対してプランナがどのような問い合わせ計画を作ったのかわかります。
問い合わせ計画を読みこなすには、ある程度の経験が必要です。
本節ではその基本を提供しようと考えます。
   </p><p>
<span class="original">
    Examples in this section are drawn from the regression test database
    after doing a &lt;command&gt;VACUUM ANALYZE&lt;/command&gt;, using v17 development sources.
    You should be able to get similar results if you try the examples
    yourself, but your estimated costs and row counts might vary slightly
    because &lt;command&gt;ANALYZE&lt;/command&gt;'s statistics are random samples rather
    than exact, and because costs are inherently somewhat platform-dependent.
</span>
《マッチ度[93.750000]》本節の例は、9.3の開発版ソースを用いて<code class="command">VACUUM ANALYZE</code>を実行した後でリグレッションテストデータベースから取り出したものです。
実際にこの例を試すと、似たような結果になるはずですが、おそらく推定コストや行数は多少異なることになるでしょう。
<code class="command">ANALYZE</code>による統計情報は厳密なものではなくランダムなサンプリングを行った結果であり、また、コストは本質的にプラットフォームに何かしら依存するためです。
   </p><p>
<span class="original">
    The examples use &lt;command&gt;EXPLAIN&lt;/command&gt;'s default &lt;quote&gt;text&lt;/quote&gt; output
    format, which is compact and convenient for humans to read.
    If you want to feed &lt;command&gt;EXPLAIN&lt;/command&gt;'s output to a program for further
    analysis, you should use one of its machine-readable output formats
    (XML, JSON, or YAML) instead.
</span>
例では、簡潔で人が読みやすい<code class="command">EXPLAIN</code>のデフォルトの<span class="quote">「<span class="quote">text</span>」</span>出力書式を使用します。
今後の解析で<code class="command">EXPLAIN</code>の出力をプログラムに渡すことを考えているのであれば、代わりに機械読み取りが容易な出力書式（XML、JSON、YAML）のいずれかを使用する必要があります。
   </p><div class="sect2" id="USING-EXPLAIN-BASICS"><div class="titlepage"><div><div><h3 class="title">14.1.1. <code class="command">EXPLAIN</code>の基本 <a href="#USING-EXPLAIN-BASICS" class="id_link">#</a></h3></div></div></div><span class="original">
   &lt;title&gt;&lt;command&gt;EXPLAIN&lt;/command&gt; Basics&lt;/title&gt;
</span><p>
<span class="original">
    The structure of a query plan is a tree of &lt;firstterm&gt;plan nodes&lt;/firstterm&gt;.
    Nodes at the bottom level of the tree are scan nodes: they return raw rows
    from a table.  There are different types of scan nodes for different
    table access methods: sequential scans, index scans, and bitmap index
    scans.  There are also non-table row sources, such as &lt;literal&gt;VALUES&lt;/literal&gt;
    clauses and set-returning functions in &lt;literal&gt;FROM&lt;/literal&gt;, which have their
    own scan node types.
    If the query requires joining, aggregation, sorting, or other
    operations on the raw rows, then there will be additional nodes
    above the scan nodes to perform these operations.  Again,
    there is usually more than one possible way to do these operations,
    so different node types can appear here too.  The output
    of &lt;command&gt;EXPLAIN&lt;/command&gt; has one line for each node in the plan
    tree, showing the basic node type plus the cost estimates that the planner
    made for the execution of that plan node.  Additional lines might appear,
    indented from the node's summary line,
    to show additional properties of the node.
    The very first line (the summary line for the topmost
    node) has the estimated total execution cost for the plan; it is this
    number that the planner seeks to minimize.
</span>
問い合わせ計画は<em class="firstterm">計画ノード</em>のツリー構造です。
ツリー構造の最下層ノードはスキャンノードで、テーブルから行そのものを返します。
シーケンシャルスキャン、インデックススキャン、ビットマップインデックススキャンといったテーブルアクセス方法の違いに応じ、スキャンノードの種類に違いがあります。
また、<code class="literal">VALUES</code>句や<code class="literal">FROM</code>内の集合を返す関数など独自のスキャンノード種類を持つ、テーブル行を元にしないものがあります。
問い合わせが結合、集約、ソートなど、行そのものに対する操作を必要としている場合、スキャンノードの上位に更に、これらの操作を行うためのノードが追加されます。
これらの操作の実現方法にも通常複数の方法がありますので、異なった種類のノードがここに出現することもあり得ます。
<code class="command">EXPLAIN</code>には計画ツリー内の各ノードにつき1行の出力があり、基本ノード種類とプランナが生成したその計画ノードの実行に要するコスト推定値を示します。
さらに、ノードの追加属性を表示するためにノードの要約行からインデント付けされた行が出力される可能性があります。
最初の1行目（最上位ノード）には、計画全体の実行コスト推定値が含まれます。
プランナはこの値が最小になるように動作します。
   </p><p>
<span class="original">
    Here is a trivial example, just to show what the output looks like:
</span>
どのような出力となるのかを示すためだけに、ここで簡単な例を示します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..445.00 rows=10000 width=244)
</pre><p>
   </p><p>
<span class="original">
    Since this query has no &lt;literal&gt;WHERE&lt;/literal&gt; clause, it must scan all the
    rows of the table, so the planner has chosen to use a simple sequential
    scan plan.  The numbers that are quoted in parentheses are (left
    to right):
</span>
この問い合わせには<code class="literal">WHERE</code>句がありませんので、テーブル行をすべてスキャンしなければなりません。
このためプランナは単純なシーケンシャルスキャン計画を使用することを選びました。
（左から右に）括弧で囲まれた数値には以下のものがあります。

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
<span class="original">
       Estimated start-up cost.  This is the time expended before the output
       phase can begin, e.g., time to do the sorting in a sort node.
</span>
初期処理の推定コスト。
出力段階が開始できるようになる前に消費される時間、例えば、SORTノードで実行されるソート処理の時間です。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated total cost.  This is stated on the assumption that the plan
       node is run to completion, i.e., all available rows are retrieved.
       In practice a node's parent node might stop short of reading all
       available rows (see the &lt;literal&gt;LIMIT&lt;/literal&gt; example below).
</span>
全体推定コスト。
これは計画ノードが実行完了である、つまりすべての利用可能な行を受け取ることを前提として示されます。
実際には、ノードの親ノードはすべての利用可能な行を読む前に停止する可能性があります（以下の<code class="literal">LIMIT</code>の例を参照）。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated number of rows output by this plan node.  Again, the node
       is assumed to be run to completion.
</span>
この計画ノードが出力する行の推定数。ここでも、ノードが実行を完了することを前提としています。
      </p></li><li class="listitem"><p>
<span class="original">
       Estimated average width of rows output by this plan node (in bytes).
</span>
この計画ノードが出力する行の（バイト単位での）推定平均幅。
      </p></li></ul></div><p>
   </p><p>
<span class="original">
    The costs are measured in arbitrary units determined by the planner's
    cost parameters (see &lt;xref linkend="runtime-config-query-constants"/&gt;).
    Traditional practice is to measure the costs in units of disk page
    fetches; that is, &lt;xref linkend="guc-seq-page-cost"/&gt; is conventionally
    set to &lt;literal&gt;1.0&lt;/literal&gt; and the other cost parameters are set relative
    to that.  The examples in this section are run with the default cost
    parameters.
</span>
コストはプランナのコストパラメータ（<a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-CONSTANTS" title="19.7.2. プランナコスト定数">19.7.2</a>参照）によって決まる任意の単位で測定されます。
取り出すディスクページ単位でコストを測定することが、伝統的な方式です。
つまり、<a class="xref" href="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</a>を慣習的に<code class="literal">1.0</code>に設定し、他のコストパラメータを相対的に設定します。
本節の例では、デフォルトのコストパラメータで実行しています。
   </p><p>
<span class="original">
    It's important to understand that the cost of an upper-level node includes
    the cost of all its child nodes.  It's also important to realize that
    the cost only reflects things that the planner cares about.
    In particular, the cost does not consider the time spent to convert
    output values to text form or to transmit them to the client, which
    could be important factors in the real elapsed time; but the planner
    ignores those costs because it cannot change them by altering the
    plan.  (Every correct plan will output the same row set, we trust.)
</span>
《マッチ度[82.994455]》上位ノードのコストには、すべての子ノードのコストもその中に含まれていることを理解することは重要です。
このコストはプランナが関与するコストのみ反映する点もまた重要です。
とりわけ、結果の行をクライアントに転送するコストは、実際の処理時間の重要な要因となる可能性があるにもかかわらず、考慮されません。
プランナは、計画をいかに変更しようと、転送コストを変えることはできないため、これを無視します。
（正しい計画はどんなものであれ、すべて同じ行を結果として出力すると信じています。）
《機械翻訳》上位レベルのノードのコストには、そのすべての子ノードのコストが含まれることを理解することが重要です。
また、コストはプランナーが気にするものだけを反映していることを認識することも重要です。
特に、コストは、出力値をテキスト形式に変換したり、それらをクライアントに送信したりするために費やされる時間を考慮していない。
これは、実際の経過時間において重要な要素である可能性があるが、プランナは、プランを変更することによってそれらのコストを変更することができないため、それらのコストを無視する。
（正しい計画はすべて同じ行セットを出力すると信じています）。
   </p><p>
<span class="original">
    The &lt;literal&gt;rows&lt;/literal&gt; value is a little tricky because it is
    not the number of rows processed or scanned by the
    plan node, but rather the number emitted by the node.  This is often
    less than the number scanned, as a result of filtering by any
    &lt;literal&gt;WHERE&lt;/literal&gt;-clause conditions that are being applied at the node.
    Ideally the top-level rows estimate will approximate the number of rows
    actually returned, updated, or deleted by the query.
</span>
<code class="literal">rows</code>の値は、計画ノードによって処理あるいはスキャンされた行数を表しておらず、ノードによって発行された行数を表すので、多少扱いにくくなっています。
該当ノードに適用されるすべての<code class="literal">WHERE</code>句条件によるフィルタ処理の結果、スキャンされる行より少ない行数になることがよくあります。
理想的には、最上位の行数の推定値は、実際に問い合わせによって返され、更新され、あるいは削除された概算の行数となります。
   </p><p>
<span class="original">
    Returning to our example:
</span>
例に戻ります。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1;

                         QUERY PLAN
-------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..445.00 rows=10000 width=244)
</pre><p>
   </p><p>
<span class="original">
    These numbers are derived very straightforwardly.  If you do:
</span>
これらの数値はとても素直に導かれます。以下を実行すると、

</p><pre class="programlisting">
SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';
</pre><p>

<span class="original">
    you will find that &lt;classname&gt;tenk1&lt;/classname&gt; has 345 disk
    pages and 10000 rows.  The estimated cost is computed as (disk pages read *
    &lt;xref linkend="guc-seq-page-cost"/&gt;) + (rows scanned *
    &lt;xref linkend="guc-cpu-tuple-cost"/&gt;).  By default,
    &lt;varname&gt;seq_page_cost&lt;/varname&gt; is 1.0 and &lt;varname&gt;cpu_tuple_cost&lt;/varname&gt; is 0.01,
    so the estimated cost is (345 * 1.0) + (10000 * 0.01) = 445.
</span>
《マッチ度[91.773779]》<code class="classname">tenk1</code>には358のディスクページと10000の行があることがわかります。
推定コストは（ディスクページ読み取り * <a class="xref" href="runtime-config-query.html#GUC-SEQ-PAGE-COST">seq_page_cost</a>）+（スキャンした行 * <a class="xref" href="runtime-config-query.html#GUC-CPU-TUPLE-COST">cpu_tuple_cost</a>）と計算されます。
デフォルトでは、<code class="varname">seq_page_cost</code>は1.0、<code class="varname">cpu_tuple_cost</code>は0.01です。
ですから、推定コストは(358 * 1.0) + (10000 * 0.01) = 458となります。
   </p><p>
<span class="original">
    Now let's modify the query to add a &lt;literal&gt;WHERE&lt;/literal&gt; condition:
</span>
では、<code class="literal">WHERE</code>条件を加えて、問い合わせを変更してみます。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 7000;

                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on tenk1  (cost=0.00..470.00 rows=7000 width=244)
   Filter: (unique1 &lt; 7000)
</pre><p>

<span class="original">
    Notice that the &lt;command&gt;EXPLAIN&lt;/command&gt; output shows the &lt;literal&gt;WHERE&lt;/literal&gt;
    clause being applied as a &lt;quote&gt;filter&lt;/quote&gt; condition attached to the Seq
    Scan plan node.  This means that
    the plan node checks the condition for each row it scans, and outputs
    only the ones that pass the condition.
    The estimate of output rows has been reduced because of the
    &lt;literal&gt;WHERE&lt;/literal&gt; clause.
    However, the scan will still have to visit all 10000 rows, so the cost
    hasn't decreased; in fact it has gone up a bit (by 10000 * &lt;xref
    linkend="guc-cpu-operator-cost"/&gt;, to be exact) to reflect the extra CPU
    time spent checking the &lt;literal&gt;WHERE&lt;/literal&gt; condition.
</span>
<code class="command">EXPLAIN</code>の出力が、Seq Scan計画ノードに付随する<span class="quote">「<span class="quote">フィルタ</span>」</span>条件として適用される<code class="literal">WHERE</code>句を表示していることに注意してください。
これは、この計画ノードがスキャンした各行に対してその条件を検査することを意味し、その条件を通過したもののみが出力されます。
<code class="literal">WHERE</code>句があるため、推定出力行数が小さくなっています。
しかし、依然として10000行すべてをスキャンする必要があるため、コストは小さくなっていません。
実際には、<code class="literal">WHERE</code>条件を検査するためにCPU時間が余計にかかることを反映して、ほんの少し（正確には10000 * <a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>）ですがコストが上昇しています。
   </p><p>
<span class="original">
    The actual number of rows this query would select is 7000, but the &lt;literal&gt;rows&lt;/literal&gt;
    estimate is only approximate.  If you try to duplicate this experiment,
    you may well get a slightly different estimate; moreover, it can
    change after each &lt;command&gt;ANALYZE&lt;/command&gt; command, because the
    statistics produced by &lt;command&gt;ANALYZE&lt;/command&gt; are taken from a
    randomized sample of the table.
</span>
《マッチ度[90.792839]》この問い合わせが選択する実際の行数は7000です。
しかし、<code class="literal">rows</code>の推定行数は概算値に過ぎません。
この実験を2回実行した場合、おそらく多少異なる推定値を得るでしょう。
もっと言うと、これは<code class="command">ANALYZE</code>コマンドを行う度に変化することがあり得ます。
なぜなら、<code class="command">ANALYZE</code>で生成される統計情報は、テーブルのランダムな標本から取り出されるからです。
   </p><p>
<span class="original">
    Now, let's make the condition more restrictive:
</span>
では、条件をより強く制限してみます。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100;

                                  QUERY PLAN
-------------------------------------------------------------------​-----------
 Bitmap Heap Scan on tenk1  (cost=5.06..224.98 rows=100 width=244)
   Recheck Cond: (unique1 &lt; 100)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><p>

<span class="original">
    Here the planner has decided to use a two-step plan: the child plan
    node visits an index to find the locations of rows matching the index
    condition, and then the upper plan node actually fetches those rows
    from the table itself.  Fetching rows separately is much more
    expensive than reading them sequentially, but because not all the pages
    of the table have to be visited, this is still cheaper than a sequential
    scan.  (The reason for using two plan levels is that the upper plan
    node sorts the row locations identified by the index into physical order
    before reading them, to minimize the cost of separate fetches.
    The &lt;quote&gt;bitmap&lt;/quote&gt; mentioned in the node names is the mechanism that
    does the sorting.)
</span>
ここでは、プランナは2段階の計画を使用することを決定しました。
子の計画ノードは、インデックスを使用して、インデックス条件(index condition)に合う行の場所を検索します。
そして、上位計画ノードが実際にテーブル自体からこれらの行を取り出します。
行を別々に取り出すことは、シーケンシャルな読み取りに比べ非常に高価です。
しかし、テーブルのすべてのページを読み取る必要はありませんので、シーケンシャルスキャンより安価になります。
（2段階の計画を使用する理由は、別々に行を取り出すコストを最小にするために、上位の計画ノードがインデックスにより識別された行の位置を読み取る前に物理的な順序でソートすることです。
ノードで記載されている<span class="quote">「<span class="quote">bitmap</span>」</span>は、ソートを行う機構の名前です。）
   </p><p>
<span class="original">
    Now let's add another condition to the &lt;literal&gt;WHERE&lt;/literal&gt; clause:
</span>
ここで<code class="literal">WHERE</code>句に別の条件を付与してみましょう。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND stringu1 = 'xxx';

                                  QUERY PLAN
-------------------------------------------------------------------​-----------
 Bitmap Heap Scan on tenk1  (cost=5.04..225.20 rows=1 width=244)
   Recheck Cond: (unique1 &lt; 100)
   Filter: (stringu1 = 'xxx'::name)
   -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
         Index Cond: (unique1 &lt; 100)
</pre><p>

<span class="original">
    The added condition &lt;literal&gt;stringu1 = 'xxx'&lt;/literal&gt; reduces the
    output row count estimate, but not the cost because we still have to visit
    the same set of rows.  That's because the &lt;literal&gt;stringu1&lt;/literal&gt; clause
    cannot be applied as an index condition, since this index is only on
    the &lt;literal&gt;unique1&lt;/literal&gt; column.  Instead it is applied as a filter on
    the rows retrieved using the index.  Thus the cost has actually gone up
    slightly to reflect this extra checking.
</span>
《マッチ度[90.105263]》追加された<code class="literal">stringu1 = 'xxx'</code>条件は出力行数推定値を減らしますが、同じ行集合にアクセスしなければなりませんので、コストは減りません。
このインデックスが<code class="literal">unique1</code>列に対してのみ存在するため、<code class="literal">stringu1</code>句をインデックス条件として適用できないことに注意してください。
代わりに、インデックスによって取り出される行に対するフィルタとして適用されます。
これにより、追加の検査分を反映するため、コストは実際には少し上がります。
   </p><p>
<span class="original">
    In some cases the planner will prefer a &lt;quote&gt;simple&lt;/quote&gt; index scan plan:
</span>
場合によってはプランナは<span class="quote">「<span class="quote">単純な</span>」</span>インデックススキャン計画を選択します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 = 42;

                                 QUERY PLAN
-------------------------------------------------------------------​----------
 Index Scan using tenk1_unique1 on tenk1  (cost=0.29..8.30 rows=1 width=244)
   Index Cond: (unique1 = 42)
</pre><p>

<span class="original">
    In this type of plan the table rows are fetched in index order, which
    makes them even more expensive to read, but there are so few that the
    extra cost of sorting the row locations is not worth it.  You'll most
    often see this plan type for queries that fetch just a single row.  It's
    also often used for queries that have an &lt;literal&gt;ORDER BY&lt;/literal&gt; condition
    that matches the index order, because then no extra sorting step is needed
    to satisfy the &lt;literal&gt;ORDER BY&lt;/literal&gt;.  In this example, adding
    &lt;literal&gt;ORDER BY unique1&lt;/literal&gt; would use the same plan because the
    index already implicitly provides the requested ordering.
</span>
この種の計画では、テーブル行はインデックス順で取り出されます。
このため読み取りがより高価になりますが、この場合取り出す行数が少ないため、改めて行位置をソートし直すための追加コストは割に合いません。
単一の行のみを取り出す問い合わせでは、この計画種類がよく現れます。
また、<code class="literal">ORDER BY</code>を満たすために必要となる余分な必要なソート処理がないため、インデックスの順序に一致する<code class="literal">ORDER BY</code>条件を持つ問い合わせでよく使用されます。
この例では、<code class="literal">ORDER BY unique1</code>を追加すると、要求された順序がインデックスによってすでに暗黙的に提供されているため、同じ計画が使用されます。
   </p><p>
<span class="original">
     The planner may implement an &lt;literal&gt;ORDER BY&lt;/literal&gt; clause in several
     ways.  The above example shows that such an ordering clause may be
     implemented implicitly.  The planner may also add an explicit
     &lt;literal&gt;Sort&lt;/literal&gt; step:
</span>
《マッチ度[90.043290]》プランナは<code class="literal">ORDER BY</code>句をいくつかの方法で実装できます。
上の例ではこのような<code class="literal">ORDER BY</code>句を暗黙的に実装できることを示しています。
プランナは明示的な<code class="literal">sort</code>ステップを追加もします。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 ORDER BY unique1;

                            QUERY PLAN
-------------------------------------------------------------------
 Sort  (cost=1109.39..1134.39 rows=10000 width=244)
   Sort Key: unique1
   -&gt;  Seq Scan on tenk1  (cost=0.00..445.00 rows=10000 width=244)
</pre><p>

<span class="original">
    If a part of the plan guarantees an ordering on a prefix of the
    required sort keys, then the planner may instead decide to use an
    &lt;literal&gt;Incremental Sort&lt;/literal&gt; step:
</span>
《マッチ度[91.812865]》ソートキーで必要な接頭辞の順序がプランの一部で保証されている場合、<code class="literal">インクリメンタルソート(incremental sort)</code>ステップを使用することを決定できます。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 ORDER BY hundred, ten LIMIT 100;

                                              QUERY PLAN
-------------------------------------------------------------------​-----------------------------
 Limit  (cost=19.35..39.49 rows=100 width=244)
   -&gt;  Incremental Sort  (cost=19.35..2033.39 rows=10000 width=244)
         Sort Key: hundred, ten
         Presorted Key: hundred
         -&gt;  Index Scan using tenk1_hundred on tenk1  (cost=0.29..1574.20 rows=10000 width=244)
-------------------------------------------------------------------​-----------------------------------
 Limit  (cost=521.06..538.05 rows=100 width=244)
   -&gt;  Incremental Sort  (cost=521.06..2220.95 rows=10000 width=244)
         Sort Key: four, ten
         Presorted Key: four
         -&gt;  Index Scan using index_tenk1_on_four on tenk1  (cost=0.29..1510.08 rows=10000 width=244)
</pre><p>

<span class="original">
    Compared to regular sorts, sorting incrementally allows returning tuples
    before the entire result set has been sorted, which particularly enables
    optimizations with &lt;literal&gt;LIMIT&lt;/literal&gt; queries.  It may also reduce
    memory usage and the likelihood of spilling sorts to disk, but it comes at
    the cost of the increased overhead of splitting the result set into multiple
    sorting batches.
</span>
通常のソートと比較して、インクリメンタルソートは、結果セット全体がソートされる前にタプルを戻すことができます。
これにより、特に<code class="literal">LIMIT</code>がある問い合わせで最適化が可能になります。
また、メモリ使用量が削減され、ソートがディスクにオーバーフローする可能性が減少しますが、結果セットを複数のソートバッチに分割するオーバーヘッドが増加という代償を払うことになります。
   </p><p>
<span class="original">
    If there are separate indexes on several of the columns referenced
    in &lt;literal&gt;WHERE&lt;/literal&gt;, the planner might choose to use an AND or OR
    combination of the indexes:
</span>
<code class="literal">WHERE</code>句で参照される複数の列に対して別々のインデックスが存在する場合、プランナはインデックスをANDやORで組み合わせて使用することを選択する可能性があります。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                     QUERY PLAN
-------------------------------------------------------------------​------------------
 Bitmap Heap Scan on tenk1  (cost=25.07..60.11 rows=10 width=244)
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   -&gt;  BitmapAnd  (cost=25.07..25.07 rows=10 width=0)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
               Index Cond: (unique1 &lt; 100)
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0)
               Index Cond: (unique2 &gt; 9000)
</pre><p>

<span class="original">
    But this requires visiting both indexes, so it's not necessarily a win
    compared to using just one index and treating the other condition as
    a filter.  If you vary the ranges involved you'll see the plan change
    accordingly.
</span>
しかし、これは両方のインデックスを参照する必要があります。
そのため、インデックスを1つ使用し、他の条件についてはフィルタとして扱う方法と比べて常に勝るとは限りません。
含まれる範囲を変更すると、それに伴い計画も変わることが分かるでしょう。
   </p><p>
<span class="original">
    Here is an example showing the effects of &lt;literal&gt;LIMIT&lt;/literal&gt;:
</span>
以下に<code class="literal">LIMIT</code>の影響を示す例を示します。

</p><pre class="screen">
EXPLAIN SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                     QUERY PLAN
-------------------------------------------------------------------​------------------
 Limit  (cost=0.29..14.28 rows=2 width=244)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..70.27 rows=10 width=244)
 Limit  (cost=0.29..14.48 rows=2 width=244)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..71.27 rows=10 width=244)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
</pre><p>
   </p><p>
<span class="original">
    This is the same query as above, but we added a &lt;literal&gt;LIMIT&lt;/literal&gt; so that
    not all the rows need be retrieved, and the planner changed its mind about
    what to do.  Notice that the total cost and row count of the Index Scan
    node are shown as if it were run to completion.  However, the Limit node
    is expected to stop after retrieving only a fifth of those rows, so its
    total cost is only a fifth as much, and that's the actual estimated cost
    of the query.  This plan is preferred over adding a Limit node to the
    previous plan because the Limit could not avoid paying the startup cost
    of the bitmap scan, so the total cost would be something over 25 units
    with that approach.
</span>
これは上と同じ問い合わせですが、すべての行を取り出す必要がないため<code class="literal">LIMIT</code>を付けています。
プランナはどうすべきかについて考えを変えました。
インデックススキャンノードの総コストと総行数があたかも実行完了したかのように表示されていることに注意してください。
しかしLimitノードが、これらの行の1/5だけを取り出した後で停止することが想定されています。
そのため総コストは1/5程度のみとなり、これが問い合わせの実際の推定コストとなります。
この計画は、以前の計画にLimitノードを追加することより好まれます。
以前の計画へのLimit追加でのLimitはビットマップスキャンの起動コストを払うことを避けることができないため、総コストは25単位を超えてしまうからです。
   </p><p>
<span class="original">
    Let's try joining two tables, using the columns we have been discussing:
</span>
今まで説明に使ってきたフィールドを使って2つのテーブルを結合してみましょう。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                      QUERY PLAN
-------------------------------------------------------------------​-------------------
 Nested Loop  (cost=4.65..118.50 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.38 rows=10 width=244)
 Nested Loop  (cost=4.65..118.62 rows=10 width=488)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.90 rows=1 width=244)
         Index Cond: (unique2 = t1.unique2)
</pre><p>
   </p><p>
<span class="original">
    In this plan, we have a nested-loop join node with two table scans as
    inputs, or children.  The indentation of the node summary lines reflects
    the plan tree structure.  The join's first, or &lt;quote&gt;outer&lt;/quote&gt;, child
    is a bitmap scan similar to those we saw before.  Its cost and row count
    are the same as we'd get from &lt;literal&gt;SELECT ... WHERE unique1 &amp;lt; 10&lt;/literal&gt;
    because we are
    applying the &lt;literal&gt;WHERE&lt;/literal&gt; clause &lt;literal&gt;unique1 &amp;lt; 10&lt;/literal&gt;
    at that node.
    The &lt;literal&gt;t1.unique2 = t2.unique2&lt;/literal&gt; clause is not relevant yet,
    so it doesn't affect the row count of the outer scan.  The nested-loop
    join node will run its second,
    or &lt;quote&gt;inner&lt;/quote&gt; child once for each row obtained from the outer child.
    Column values from the current outer row can be plugged into the inner
    scan; here, the &lt;literal&gt;t1.unique2&lt;/literal&gt; value from the outer row is available,
    so we get a plan and costs similar to what we saw above for a simple
    &lt;literal&gt;SELECT ... WHERE t2.unique2 = &lt;replaceable&gt;constant&lt;/replaceable&gt;&lt;/literal&gt; case.
    (The estimated cost is actually a bit lower than what was seen above,
    as a result of caching that's expected to occur during the repeated
    index scans on &lt;literal&gt;t2&lt;/literal&gt;.)  The
    costs of the loop node are then set on the basis of the cost of the outer
    scan, plus one repetition of the inner scan for each outer row (10 * 7.90,
    here), plus a little CPU time for join processing.
</span>
《マッチ度[93.426573]》この計画では、入力または子として２つのテーブルスキャンを持つネステッドループ結合ノードがあります。
計画のツリー構造を反映して、ノード要約行はインデント付けされます。
結合の先頭、<span class="quote">「<span class="quote">外部</span>」</span>、子は以前に説明したものと似たビットマップスキャンです。
そのコストと行数は、該当ノードに<code class="literal">unique1 &lt; 10</code> <code class="literal">WHERE</code>句が適用されるため、<code class="literal">SELECT ... WHERE unique1 &lt; 10</code>で得られたものと同じです。
この段階では<code class="literal">t1.unique2 = t2.unique2</code>句は関係しておらず、外部スキャンにおける出力行数に影響していません。
ネステッドループ結合ノードは、外部の子から得られた行毎に、その２番目または<span class="quote">「<span class="quote">内部の</span>」</span>子を一回実行します。
現在の外部の行からの列の値は内部スキャンに組み込まれます。
ここで、外部行からの<code class="literal">t1.unique2</code>の値が利用できますので、上述の単純な<code class="literal">SELECT ... WHERE t2.unique2 = <em class="replaceable"><code>constant</code></em></code>の場合に示したものと似た計画とコストが得られます。
（実際、推定コストは、<code class="literal">t2</code>に対するインデックススキャンが繰り返される間に発生することが想定されるキャッシュの結果、上で示した値よりわずかに低くなります。）
ループノードのコストは、外部スキャンのコストと、各々の外部の行に対して内部スキャンが繰り返されることによるコスト（ここでは10 * 7.91）を加え、さらに結合処理を行うための少々のCPU時間を加えたものになります。
   </p><p>
<span class="original">
    In this example the join's output row count is the same as the product
    of the two scans' row counts, but that's not true in all cases because
    there can be additional &lt;literal&gt;WHERE&lt;/literal&gt; clauses that mention both tables
    and so can only be applied at the join point, not to either input scan.
    Here's an example:
</span>
この例では、結合の出力行数は2つのスキャンの出力行数の積に等しくなっていますが、いつもそうなるわけではありません。
2つのテーブルに関係する<code class="literal">WHERE</code>句は、入力スキャン時ではなく、結合を行う際に適用されるからです。
以下が例です。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t2.unique2 &lt; 10 AND t1.hundred &lt; t2.hundred;

                                         QUERY PLAN
-------------------------------------------------------------------​--------------------------
 Nested Loop  (cost=4.65..49.36 rows=33 width=488)
 Nested Loop  (cost=4.65..49.46 rows=33 width=488)
   Join Filter: (t1.hundred &lt; t2.hundred)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.38 rows=10 width=244)
         Recheck Cond: (unique1 &lt; 10)
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Materialize  (cost=0.29..8.51 rows=10 width=244)
         -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..8.46 rows=10 width=244)
               Index Cond: (unique2 &lt; 10)
</pre><p>

<span class="original">
    The condition &lt;literal&gt;t1.hundred &amp;lt; t2.hundred&lt;/literal&gt; can't be
    tested in the &lt;literal&gt;tenk2_unique2&lt;/literal&gt; index, so it's applied at the
    join node.  This reduces the estimated output row count of the join node,
    but does not change either input scan.
</span>
条件<code class="literal">t1.hundred &lt; t2.hundred</code>は<code class="literal">tenk2_unique2</code>インデックスの中では試験されません。
このため結合ノードで適用されます。
これは結合ノードの推定出力行数を減らしはしますが、入力スキャンには影響しません。
   </p><p>
<span class="original">
    Notice that here the planner has chosen to &lt;quote&gt;materialize&lt;/quote&gt; the inner
    relation of the join, by putting a Materialize plan node atop it.  This
    means that the &lt;literal&gt;t2&lt;/literal&gt; index scan will be done just once, even
    though the nested-loop join node needs to read that data ten times, once
    for each row from the outer relation.  The Materialize node saves the data
    in memory as it's read, and then returns the data from memory on each
    subsequent pass.
</span>
ここではプランナが、具体化計画ノードをその上に挿入することで、結合の内部リレーションの<span class="quote">「<span class="quote">具体化</span>」</span>を選択していることに注意してください。
これは、たとえネステッドループ結合ノードが外部リレーションから各行につき一度、そのデータを10回読む必要があったとしても、<code class="literal">t2</code>インデックススキャンが一度だけ行なわれることを意味します。
具体化ノードはそのデータを読んだときにメモリに保存し、その後の読み出しではそのデータをメモリから返します。
   </p><p>
<span class="original">
    When dealing with outer joins, you might see join plan nodes with both
    &lt;quote&gt;Join Filter&lt;/quote&gt; and plain &lt;quote&gt;Filter&lt;/quote&gt; conditions attached.
    Join Filter conditions come from the outer join's &lt;literal&gt;ON&lt;/literal&gt; clause,
    so a row that fails the Join Filter condition could still get emitted as
    a null-extended row.  But a plain Filter condition is applied after the
    outer-join rules and so acts to remove rows unconditionally.  In an inner
    join there is no semantic difference between these types of filters.
</span>
外部結合を扱う時、<span class="quote">「<span class="quote">結合フィルタ</span>」</span>および通常の<span class="quote">「<span class="quote">フィルタ</span>」</span>の両方が付随する結合計画ノードが現れる可能性があります。
結合フィルタ条件は外部結合の<code class="literal">ON</code>句を元にしますので、結合フィルタ条件に合わない行がNULLで展開された行として発行され続けます。
しかし通常のフィルタ条件が外部結合規則の後に適用され、条件に合わない行は削除されます。
内部結合では、これらのフィルタ種類の間に意味的な違いはありません。
   </p><p>
<span class="original">
    If we change the query's selectivity a bit, we might get a very different
    join plan:
</span>
問い合わせの選択性を少し変更すると、非常に異なる結合計画が得られるかもしれません。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
-------------------------------------------------------------------​-----------------------
 Hash Join  (cost=226.23..709.73 rows=100 width=488)
 Hash Join  (cost=230.47..713.98 rows=101 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244)
   -&gt;  Hash  (cost=224.98..224.98 rows=100 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.06..224.98 rows=100 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
                     Index Cond: (unique1 &lt; 100)
</pre><p>
   </p><p>
<span class="original">
    Here, the planner has chosen to use a hash join, in which rows of one
    table are entered into an in-memory hash table, after which the other
    table is scanned and the hash table is probed for matches to each row.
    Again note how the indentation reflects the plan structure: the bitmap
    scan on &lt;literal&gt;tenk1&lt;/literal&gt; is the input to the Hash node, which constructs
    the hash table.  That's then returned to the Hash Join node, which reads
    rows from its outer child plan and searches the hash table for each one.
</span>
ここでプランナはハッシュ結合の使用を選択しました。
片方のテーブルの行がメモリ内のハッシュテーブルに格納され、もう片方のテーブルがスキャンされた後、各行に対して一致するかどうかハッシュテーブルを探索します。
繰り返しますが、インデント付けにより計画の構造が表されます。
<code class="literal">tenk1</code>に対するビットマップスキャンはハッシュノードへの入力です。
外部の子計画から行を読み取り、各行に対してハッシュテーブルを検索します。
   </p><p>
<span class="original">
    Another possible type of join is a merge join, illustrated here:
</span>
他にも、以下に示すようなマージ結合という結合があり得ます。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
-------------------------------------------------------------------​-----------------------
 Merge Join  (cost=0.56..233.49 rows=10 width=488)
 Merge Join  (cost=198.11..268.19 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..643.28 rows=100 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..166.28 rows=1000 width=244)
</pre><p>
   </p><p>
<span class="original">
    Merge join requires its input data to be sorted on the join keys.  In this
    example each input is sorted by using an index scan to visit the rows
    in the correct order; but a sequential scan and sort could also be used.
    (Sequential-scan-and-sort frequently beats an index scan for sorting many rows,
    because of the nonsequential disk access required by the index scan.)
</span>
《マッチ度[59.016393]》マージ結合は、結合キーでソートされる入力データを必要とします。
この計画では、正確な順序で行をアクセスするために<code class="literal">tenk1</code>データがインデックススキャンを用いてソートされます。
しかし、このテーブルの中でより多くの行がアクセスされるため、<code class="literal">onek</code>ではシーケンシャルスキャンとソートが好まれています。
（多くの行をソートする場合、インデックススキャンでは非シーケンシャルなディスクアクセスが必要となるため、シーケンシャルスキャンとソートの方がインデックススキャンより優れています。）
《機械翻訳》マージ結合では、結合キーでソートする入力データが必要です。
この例では、各入力はインデックス・スキャンを使用して適切な順序で行われますが、シーケンシャル・スキャンとソートも使用できます（シーケンシャル・スキャンとソートは、多くの行をソートするためにインデックス・スキャンに必要なディスク・アクセスが非シーケンシャルであるため、しばしばインデックス・スキャンより優れています）。
   </p><p>
<span class="original">
    One way to look at variant plans is to force the planner to disregard
    whatever strategy it thought was the cheapest, using the enable/disable
    flags described in &lt;xref linkend="runtime-config-query-enable"/&gt;.
    (This is a crude tool, but useful.  See
    also &lt;xref linkend="explicit-joins"/&gt;.)
    For example, if we're unconvinced that merge join is the best join
    type for the previous example, we could try
</span>
《マッチ度[77.078086]》<a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE" title="19.7.1. プランナメソッド設定">19.7.1</a>に記載したenable/disableフラグを使用して、プランナが最も良いと考えている戦略を強制的に無視させる方法により、異なった計画を観察することができます。
（非常に原始的なツールですが、利用価値があります。
<a class="xref" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する">14.3</a>も参照してください。）
例えば、前の例にて<code class="literal">onek</code>テーブルを扱う最善の方法がシーケンシャルスキャンとソートであると納得できなければ、以下を試みることができます。
《機械翻訳》バリアント計画を見る一つの方法は、<a class="xref" href="runtime-config-query.html#RUNTIME-CONFIG-QUERY-ENABLE" title="19.7.1. プランナメソッド設定">19.7.1</a>で説明したイネーブル/ディスエーブルフラグを使用して、プランナに最も安価と思われる戦略を無視させることです。
（これは粗雑なツールですが、有用です。
<a class="xref" href="explicit-joins.html" title="14.3. 明示的なJOIN句でプランナを制御する">14.3</a>も参照してください。
例えば、前の例でマージ結合が最良の結合タイプであると確信できない場合は、試してみることができます。

</p><pre class="screen">
SET enable_mergejoin = off;
SET enable_sort = off;

EXPLAIN SELECT *
FROM tenk1 t1, onek t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2;

                                        QUERY PLAN
-------------------------------------------------------------------​-----------------------
 Hash Join  (cost=226.23..344.08 rows=10 width=488)
   Hash Cond: (t2.unique2 = t1.unique2)
   -&gt;  Seq Scan on onek t2  (cost=0.00..114.00 rows=1000 width=244)
   -&gt;  Hash  (cost=224.98..224.98 rows=100 width=244)
         -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.06..224.98 rows=100 width=244)
               Recheck Cond: (unique1 &lt; 100)
               -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0)
                     Index Cond: (unique1 &lt; 100)
 Merge Join  (cost=0.56..292.65 rows=10 width=488)
   Merge Cond: (t1.unique2 = t2.unique2)
   -&gt;  Index Scan using tenk1_unique2 on tenk1 t1  (cost=0.29..656.28 rows=101 width=244)
         Filter: (unique1 &lt; 100)
   -&gt;  Index Scan using onek_unique2 on onek t2  (cost=0.28..224.79 rows=1000 width=244)
</pre><p>

<span class="original">
    which shows that the planner thinks that hash join would be nearly 50%
    more expensive than merge join for this case.
    Of course, the next question is whether it's right about that.
    We can investigate that using &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt;, as
    discussed &lt;link linkend="using-explain-analyze"&gt;below&lt;/link&gt;.
</span>
《機械翻訳》これは、プランナが、この場合のハッシュ結合はマージ結合よりも50%近く高価であると考えていることを示しています。
もちろん、次の疑問は、それが正しいかどうかです。
<a class="link" href="using-explain.html#USING-EXPLAIN-ANALYZE" title="14.1.2. EXPLAIN ANALYZE">下記</a>で説明するように、<code class="command">EXPLAIN ANALYZE</code>を使用して調査できます。
   </p><p>
    <a id="id-1.5.13.5.8.29.1" class="indexterm"></a>
<span class="original">
    Some query plans involve &lt;firstterm&gt;subplans&lt;/firstterm&gt;, which arise
    from sub-&lt;literal&gt;SELECT&lt;/literal&gt;s in the original query.  Such
    queries can sometimes be transformed into ordinary join plans, but
    when they cannot be, we get plans like:
</span>
《機械翻訳》いくつかの問い合わせ計画は、元の問い合わせの<code class="literal">SELECT</code>の副問い合わせから生じる<em class="firstterm">副計画</em>を含みます。
このような問い合わせは、時々通常の結合計画に変換できますが、変換できない場合、次のような計画になります。

</p><pre class="screen">
EXPLAIN VERBOSE SELECT unique1
FROM tenk1 t
WHERE t.ten &lt; ALL (SELECT o.ten FROM onek o WHERE o.four = t.four);

                               QUERY PLAN
-------------------------------------------------------------------​------
 Seq Scan on public.tenk1 t  (cost=0.00..586095.00 rows=5000 width=4)
   Output: t.unique1
   Filter: (ALL (t.ten &lt; (SubPlan 1).col1))
   SubPlan 1
     -&gt;  Seq Scan on public.onek o  (cost=0.00..116.50 rows=250 width=4)
           Output: o.ten
           Filter: (o.four = t.four)
</pre><p>

<span class="original">
    This rather artificial example serves to illustrate a couple of
    points: values from the outer plan level can be passed down into a
    subplan (here, &lt;literal&gt;t.four&lt;/literal&gt; is passed down) and the
    results of the sub-select are available to the outer plan.  Those
    result values are shown by &lt;command&gt;EXPLAIN&lt;/command&gt; with notations
    like
    &lt;literal&gt;(&lt;replaceable&gt;subplan_name&lt;/replaceable&gt;).col&lt;replaceable&gt;N&lt;/replaceable&gt;&lt;/literal&gt;,
    which refers to the &lt;replaceable&gt;N&lt;/replaceable&gt;'th output column of
    the sub-&lt;literal&gt;SELECT&lt;/literal&gt;.
</span>
《機械翻訳》この人工的な例は、いくつかの点を説明するのに役立ちます。
外部プランレベルからの値は、サブプラン（<code class="literal">t.four</code>がここで渡されます）に渡すことができ、サブ選択の結果は外部プランで使用できます。
これらの結果値は<code class="literal">((<em class="replaceable"><code>subplan_name</code></em>)</code>のような表記で<code class="command">EXPLAIN</code>に示されます。
これは<em class="replaceable"><code>N</code></em>番目の出力列を参照します。
   </p><p>
    <a id="id-1.5.13.5.8.30.1" class="indexterm"></a>
<span class="original">
    In the example above, the &lt;literal&gt;ALL&lt;/literal&gt; operator runs the
    subplan again for each row of the outer query (which accounts for the
    high estimated cost).  Some queries can use a &lt;firstterm&gt;hashed
    subplan&lt;/firstterm&gt; to avoid that:
</span>
《機械翻訳》上の例では、<code class="literal">ALL</code>演算子は外部問い合わせの各行に対して再度副計画を実行します（これが高い見積りコストの原因です）。
いくつかの問い合わせでは、<em class="firstterm">ハッシュ化された副計画</em>を使用して、以下を回避できます。

</p><pre class="screen">
EXPLAIN SELECT *
FROM tenk1 t
WHERE t.unique1 NOT IN (SELECT o.unique1 FROM onek o);

                                         QUERY PLAN
-------------------------------------------------------------------​-------------------------
 Seq Scan on tenk1 t  (cost=61.77..531.77 rows=5000 width=244)
   Filter: (NOT (ANY (unique1 = (hashed SubPlan 1).col1)))
   SubPlan 1
     -&gt;  Index Only Scan using onek_unique1 on onek o  (cost=0.28..59.27 rows=1000 width=4)
(4 rows)
</pre><p>

<span class="original">
    Here, the subplan is run a single time and its output is loaded into
    an in-memory hash table, which is then probed by the
    outer &lt;literal&gt;ANY&lt;/literal&gt; operator.  This requires that the
    sub-&lt;literal&gt;SELECT&lt;/literal&gt; not reference any variables of the outer
    query, and that the &lt;literal&gt;ANY&lt;/literal&gt;'s comparison operator be
    amenable to hashing.
</span>
《機械翻訳》ここでは、サブプランは1回だけ実行され、その出力はインメモリのハッシュテーブルにロードされ、その後、外部の<code class="literal">ANY</code>演算子によってプローブされます。
これには、サブ<code class="literal">SELECT</code>が外部クエリの変数を参照しないことと、<code class="literal">ANY</code>の比較演算子がハッシュ可能であることが必要です。
   </p><p>
    <a id="id-1.5.13.5.8.31.1" class="indexterm"></a>
<span class="original">
    If, in addition to not referencing any variables of the outer query,
    the sub-&lt;literal&gt;SELECT&lt;/literal&gt; cannot return more than one row,
    it may instead be implemented as an &lt;firstterm&gt;initplan&lt;/firstterm&gt;:
</span>
《機械翻訳》外部問い合わせの変数を参照しないことに加えて、副<code class="literal">SELECT</code>が複数行を返せない場合、代わりに<em class="firstterm">initplan</em>として実装されるかもしれません。

</p><pre class="screen">
EXPLAIN VERBOSE SELECT unique1
FROM tenk1 t1 WHERE t1.ten = (SELECT (random() * 10)::integer);

                             QUERY PLAN
------------------------------------------------------------​--------
 Seq Scan on public.tenk1 t1  (cost=0.02..470.02 rows=1000 width=4)
   Output: t1.unique1
   Filter: (t1.ten = (InitPlan 1).col1)
   InitPlan 1
     -&gt;  Result  (cost=0.00..0.02 rows=1 width=4)
           Output: ((random() * '10'::double precision))::integer
</pre><p>

<span class="original">
    An initplan is run only once per execution of the outer plan, and its
    results are saved for re-use in later rows of the outer plan.  So in
    this example &lt;literal&gt;random()&lt;/literal&gt; is evaluated only once and
    all the values of &lt;literal&gt;t1.ten&lt;/literal&gt; are compared to the same
    randomly-chosen integer.  That's quite different from what would
    happen without the sub-&lt;literal&gt;SELECT&lt;/literal&gt; construct.
</span>
《機械翻訳》初期計画は外部計画の実行ごとに一度だけ実行され、その結果は後の外部計画の行で再利用するために保存されます。
したがって、この例では<code class="literal">random()</code>は一度だけ評価され、<code class="literal">t1.ten</code>のすべての値は同じランダムに選択された整数と比較されます。
これは、副<code class="literal">SELECT</code>構文がない場合とはまったく異なります。
   </p></div><div class="sect2" id="USING-EXPLAIN-ANALYZE"><div class="titlepage"><div><div><h3 class="title">14.1.2. <code class="command">EXPLAIN ANALYZE</code> <a href="#USING-EXPLAIN-ANALYZE" class="id_link">#</a></h3></div></div></div><p>
<span class="original">
    It is possible to check the accuracy of the planner's estimates
    by using &lt;command&gt;EXPLAIN&lt;/command&gt;'s &lt;literal&gt;ANALYZE&lt;/literal&gt; option.  With this
    option, &lt;command&gt;EXPLAIN&lt;/command&gt; actually executes the query, and then displays
    the true row counts and true run time accumulated within each plan node,
    along with the same estimates that a plain &lt;command&gt;EXPLAIN&lt;/command&gt;
    shows.  For example, we might get a result like this:
</span>
<code class="command">EXPLAIN</code>の<code class="literal">ANALYZE</code>オプションを使用して、プランナが推定するコストの精度を点検することができます。
このオプションを付けると<code class="command">EXPLAIN</code>は実際にその問い合わせを実行し、計画ノードごとに実際の行数と要した実際の実行時間を、普通の<code class="command">EXPLAIN</code>が示すものと同じ推定値と一緒に表示します。
例えば、以下のような結果を得ることができます。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 10 AND t1.unique2 = t2.unique2;

                                                           QUERY PLAN
-------------------------------------------------------------------​--------------------------------------------------------------
 Nested Loop  (cost=4.65..118.50 rows=10 width=488) (actual time=0.017..0.051 rows=10 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.38 rows=10 width=244) (actual time=0.009..0.017 rows=10 loops=1)
 Nested Loop  (cost=4.65..118.62 rows=10 width=488) (actual time=0.128..0.377 rows=10 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=4.36..39.47 rows=10 width=244) (actual time=0.057..0.121 rows=10 loops=1)
         Recheck Cond: (unique1 &lt; 10)
         Heap Blocks: exact=10
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..4.36 rows=10 width=0) (actual time=0.004..0.004 rows=10 loops=1)
               Index Cond: (unique1 &lt; 10)
   -&gt;  Index Scan using tenk2_unique2 on tenk2 t2  (cost=0.29..7.90 rows=1 width=244) (actual time=0.003..0.003 rows=1 loops=10)
         Index Cond: (unique2 = t1.unique2)
 Planning Time: 0.485 ms
 Execution Time: 0.073 ms
</pre><p>

<span class="original">
    Note that the &lt;quote&gt;actual time&lt;/quote&gt; values are in milliseconds of
    real time, whereas the &lt;literal&gt;cost&lt;/literal&gt; estimates are expressed in
    arbitrary units; so they are unlikely to match up.
    The thing that's usually most important to look for is whether the
    estimated row counts are reasonably close to reality.  In this example
    the estimates were all dead-on, but that's quite unusual in practice.
</span>
<span class="quote">「<span class="quote">actual time</span>」</span>値は実時間をミリ秒単位で表されていること、<code class="literal">cost</code>推定値は何らかの単位で表されていることに注意してください。
ですからそのまま比較することはできません。
注目すべきもっとも重要な点は通常、推定行数が実際の値と合理的に近いかどうかです。
この例では、推定はすべて正確ですが、現実的にはあまりありません。
   </p><p>
<span class="original">
    In some query plans, it is possible for a subplan node to be executed more
    than once.  For example, the inner index scan will be executed once per
    outer row in the above nested-loop plan.  In such cases, the
    &lt;literal&gt;loops&lt;/literal&gt; value reports the
    total number of executions of the node, and the actual time and rows
    values shown are averages per-execution.  This is done to make the numbers
    comparable with the way that the cost estimates are shown.  Multiply by
    the &lt;literal&gt;loops&lt;/literal&gt; value to get the total time actually spent in
    the node.  In the above example, we spent a total of 0.030 milliseconds
    executing the index scans on &lt;literal&gt;tenk2&lt;/literal&gt;.
</span>
《マッチ度[92.911011]》問い合わせ計画の中には、何回も副計画ノードを実行する可能性のあるものがあります。
例えば、上述のネステッドループの計画では、内部インデックススキャンは外部の行ごとに一度行われます。
このような場合、<code class="literal">loops</code>値はそのノードを実行する総回数を報告し、表示される実際の時間と行数は1実行当たりの平均です。
これで値を表示された推定コストと比較できるようになります。
<code class="literal">loops</code>値をかけることで、そのノードで実際に費やされた総時間を得ることができます。
上の例では、<code class="literal">tenk2</code>に対するインデックススキャンの実行のために合計0.220ミリ秒要しています。
   </p><p>
<span class="original">
    In some cases &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; shows additional execution
    statistics beyond the plan node execution times and row counts.
    For example, Sort and Hash nodes provide extra information:
</span>
場合によっては、<code class="command">EXPLAIN ANALYZE</code>は計画ノードの実行時間と行数以上の実行統計情報をさらに表示します。
例えば、ソートとハッシュノードでは以下のような追加情報を提供します。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT *
FROM tenk1 t1, tenk2 t2
WHERE t1.unique1 &lt; 100 AND t1.unique2 = t2.unique2 ORDER BY t1.fivethous;

                                                                 QUERY PLAN
-------------------------------------------------------------------​-------------------------------------------------------------------​------
 Sort  (cost=713.05..713.30 rows=100 width=488) (actual time=2.995..3.002 rows=100 loops=1)
 Sort  (cost=717.34..717.59 rows=101 width=488) (actual time=7.761..7.774 rows=100 loops=1)
   Sort Key: t1.fivethous
   Sort Method: quicksort  Memory: 74kB
   -&gt;  Hash Join  (cost=226.23..709.73 rows=100 width=488) (actual time=0.515..2.920 rows=100 loops=1)
         Hash Cond: (t2.unique2 = t1.unique2)
         -&gt;  Seq Scan on tenk2 t2  (cost=0.00..445.00 rows=10000 width=244) (actual time=0.026..1.790 rows=10000 loops=1)
         -&gt;  Hash  (cost=224.98..224.98 rows=100 width=244) (actual time=0.476..0.477 rows=100 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 35kB
               -&gt;  Bitmap Heap Scan on tenk1 t1  (cost=5.06..224.98 rows=100 width=244) (actual time=0.030..0.450 rows=100 loops=1)
                     Recheck Cond: (unique1 &lt; 100)
                     Heap Blocks: exact=90
                     -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0) (actual time=0.013..0.013 rows=100 loops=1)
                     -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=101 width=0) (actual time=0.049..0.049 rows=100 loops=1)
                           Index Cond: (unique1 &lt; 100)
 Planning Time: 0.187 ms
 Execution Time: 3.036 ms
</pre><p>

<span class="original">
    The Sort node shows the sort method used (in particular, whether the sort
    was in-memory or on-disk) and the amount of memory or disk space needed.
    The Hash node shows the number of hash buckets and batches as well as the
    peak amount of memory used for the hash table.  (If the number of batches
    exceeds one, there will also be disk space usage involved, but that is not
    shown.)
</span>
ソートノードは使用されるソート方式（具体的にはソートがメモリ内かディスク上か）および必要なメモリまたはディスクの容量を表示します。
ハッシュノードでは、ハッシュバケット数とバッチ数、ハッシュテーブルで使用されるメモリのピーク容量が表示されます。
（バッチ数が１を超える場合、同時にディスクの使用容量も含まれますが、表示はされません。）
   </p><p>
<span class="original">
    Another type of extra information is the number of rows removed by a
    filter condition:
</span>
他の種類の追加情報はフィルタ条件によって除外される行数があります。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE ten &lt; 7;

                                               QUERY PLAN
-------------------------------------------------------------------​--------------------------------------
 Seq Scan on tenk1  (cost=0.00..470.00 rows=7000 width=244) (actual time=0.030..1.995 rows=7000 loops=1)
 Seq Scan on tenk1  (cost=0.00..483.00 rows=7000 width=244) (actual time=0.016..5.107 rows=7000 loops=1)
   Filter: (ten &lt; 7)
   Rows Removed by Filter: 3000
 Planning Time: 0.102 ms
 Execution Time: 2.145 ms
</pre><p>

<span class="original">
    These counts can be particularly valuable for filter conditions applied at
    join nodes.  The &lt;quote&gt;Rows Removed&lt;/quote&gt; line only appears when at least
    one scanned row, or potential join pair in the case of a join node,
    is rejected by the filter condition.
</span>
特に結合ノードで適用されるフィルタ条件ではこれらの数が有用です。
<span class="quote">「<span class="quote">Rows Removed</span>」</span>行は、少なくともスキャンされた１行、結合ノードにおける結合組み合わせの可能性がフィルタ条件によって拒絶された時にのみ現れます。
   </p><p>
<span class="original">
    A case similar to filter conditions occurs with &lt;quote&gt;lossy&lt;/quote&gt;
    index scans.  For example, consider this search for polygons containing a
    specific point:
</span>
<span class="quote">「<span class="quote">非可逆</span>」</span>インデックススキャンはフィルタ条件に似た状況です。
例えば、特定の点を含有する多角形の検索を考えてみます。

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                              QUERY PLAN
-------------------------------------------------------------------​-----------------------------------
 Seq Scan on polygon_tbl  (cost=0.00..1.09 rows=1 width=85) (actual time=0.023..0.023 rows=0 loops=1)
 Seq Scan on polygon_tbl  (cost=0.00..1.05 rows=1 width=32) (actual time=0.044..0.044 rows=0 loops=1)
   Filter: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Filter: 7
 Planning Time: 0.039 ms
 Execution Time: 0.033 ms
</pre><p>

<span class="original">
    The planner thinks (quite correctly) that this sample table is too small
    to bother with an index scan, so we have a plain sequential scan in which
    all the rows got rejected by the filter condition.  But if we force an
    index scan to be used, we see:
</span>
プランナは（ほぼ正確に）、インデックススキャンを考慮するには例のテーブルが小さ過ぎるとみなします。
このため、フィルタ条件によってすべての行が拒絶される、普通のシーケンシャルスキャンとなります。
しかしインデックススキャンの使用を強制するのであれば、以下のようにします。

</p><pre class="screen">
SET enable_seqscan TO off;

EXPLAIN ANALYZE SELECT * FROM polygon_tbl WHERE f1 @&gt; polygon '(0.5,2.0)';

                                                        QUERY PLAN
-------------------------------------------------------------------​-------------------------------------------------------
 Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 width=85) (actual time=0.074..0.074 rows=0 loops=1)
 Index Scan using gpolygonind on polygon_tbl  (cost=0.13..8.15 rows=1 width=32) (actual time=0.062..0.062 rows=0 loops=1)
   Index Cond: (f1 @&gt; '((0.5,2))'::polygon)
   Rows Removed by Index Recheck: 1
 Planning Time: 0.039 ms
 Execution Time: 0.098 ms
</pre><p>

<span class="original">
    Here we can see that the index returned one candidate row, which was
    then rejected by a recheck of the index condition.  This happens because a
    GiST index is &lt;quote&gt;lossy&lt;/quote&gt; for polygon containment tests: it actually
    returns the rows with polygons that overlap the target, and then we have
    to do the exact containment test on those rows.
</span>
ここで、インデックスが１つの候補行を返し、それがインデックス条件の再検査により拒絶されることが分かります。
多角形の含有試験ではGiSTインデックスが<span class="quote">「<span class="quote">非可逆</span>」</span>であるため、これは発生します。
実際には対象と重なる多角形を持つ行を返し、そしてこれらの行が正確に含有関係であることを試験しなければなりません。
   </p><p>
<span class="original">
    &lt;command&gt;EXPLAIN&lt;/command&gt; has a &lt;literal&gt;BUFFERS&lt;/literal&gt; option that can be used with
    &lt;literal&gt;ANALYZE&lt;/literal&gt; to get even more run time statistics:
</span>
<code class="command">EXPLAIN</code>には、より多くの実行時統計情報を取り出すために、<code class="literal">ANALYZE</code>に付与できる<code class="literal">BUFFERS</code>オプションがあります。

</p><pre class="screen">
EXPLAIN (ANALYZE, BUFFERS) SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000;

                                                           QUERY PLAN
-------------------------------------------------------------------​--------------------------------------------------------------
 Bitmap Heap Scan on tenk1  (cost=25.07..60.11 rows=10 width=244) (actual time=0.105..0.114 rows=10 loops=1)
 Bitmap Heap Scan on tenk1  (cost=25.08..60.21 rows=10 width=244) (actual time=0.323..0.342 rows=10 loops=1)
   Recheck Cond: ((unique1 &lt; 100) AND (unique2 &gt; 9000))
   Heap Blocks: exact=10
   Buffers: shared hit=14 read=3
   -&gt;  BitmapAnd  (cost=25.07..25.07 rows=10 width=0) (actual time=0.100..0.101 rows=0 loops=1)
         Buffers: shared hit=4 read=3
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0) (actual time=0.027..0.027 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
               Buffers: shared hit=2
         -&gt;  Bitmap Index Scan on tenk1_unique2  (cost=0.00..19.78 rows=999 width=0) (actual time=0.070..0.070 rows=999 loops=1)
               Index Cond: (unique2 &gt; 9000)
               Buffers: shared hit=2 read=3
 Planning:
   Buffers: shared hit=3
 Planning Time: 0.162 ms
 Execution Time: 0.143 ms
               Buffers: shared hit=5
 Planning time: 0.088 ms
 Execution time: 0.423 ms
</pre><p>

<span class="original">
    The numbers provided by &lt;literal&gt;BUFFERS&lt;/literal&gt; help to identify which parts
    of the query are the most I/O-intensive.
</span>
<code class="literal">BUFFERS</code>により提供される数は、問い合わせのどの部分がもっとも大きいI/Oであるかを識別する役に立ちます。
   </p><p>
<span class="original">
    Keep in mind that because &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; actually
    runs the query, any side-effects will happen as usual, even though
    whatever results the query might output are discarded in favor of
    printing the &lt;command&gt;EXPLAIN&lt;/command&gt; data.  If you want to analyze a
    data-modifying query without changing your tables, you can
    roll the command back afterwards, for example:
</span>
<code class="command">EXPLAIN ANALYZE</code>が実際に問い合わせを実行しますので、<code class="command">EXPLAIN</code>のデータを出力することを優先して問い合わせの出力が破棄されたとしても、何らかの副作用が通常通り発生することに注意してください。
テーブルを変更すること無くデータ変更問い合わせの解析を行いたければ、以下の例のように、実行後コマンドをロールバックしてください。

</p><pre class="screen">
BEGIN;

EXPLAIN ANALYZE UPDATE tenk1 SET hundred = hundred + 1 WHERE unique1 &lt; 100;

                                                           QUERY PLAN
-------------------------------------------------------------------​-------------------------------------------------------------
 Update on tenk1  (cost=5.06..225.23 rows=0 width=0) (actual time=1.634..1.635 rows=0 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.06..225.23 rows=100 width=10) (actual time=0.065..0.141 rows=100 loops=1)
 Update on tenk1  (cost=5.08..230.08 rows=0 width=0) (actual time=3.791..3.792 rows=0 loops=1)
   -&gt;  Bitmap Heap Scan on tenk1  (cost=5.08..230.08 rows=102 width=10) (actual time=0.069..0.513 rows=100 loops=1)
         Recheck Cond: (unique1 &lt; 100)
         Heap Blocks: exact=90
         -&gt;  Bitmap Index Scan on tenk1_unique1  (cost=0.00..5.04 rows=100 width=0) (actual time=0.031..0.031 rows=100 loops=1)
               Index Cond: (unique1 &lt; 100)
 Planning Time: 0.151 ms
 Execution Time: 1.856 ms

ROLLBACK;
</pre><p>
   </p><p>
<span class="original">
    As seen in this example, when the query is an &lt;command&gt;INSERT&lt;/command&gt;,
    &lt;command&gt;UPDATE&lt;/command&gt;, &lt;command&gt;DELETE&lt;/command&gt;, or
    &lt;command&gt;MERGE&lt;/command&gt; command, the actual work of
    applying the table changes is done by a top-level Insert, Update,
    Delete, or Merge plan node.  The plan nodes underneath this node perform
    the work of locating the old rows and/or computing the new data.
    So above, we see the same sort of bitmap table scan we've seen already,
    and its output is fed to an Update node that stores the updated rows.
    It's worth noting that although the data-modifying node can take a
    considerable amount of run time (here, it's consuming the lion's share
    of the time), the planner does not currently add anything to the cost
    estimates to account for that work.  That's because the work to be done is
    the same for every correct query plan, so it doesn't affect planning
    decisions.
</span>
この例で分かるように、問い合わせが<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">MERGE</code>である場合、テーブル変更を行うための実作業は最上位のInsert、Update、Delete、Merge計画ノードで行われます。
このノード以下にある計画ノードは、古い行の検索、新しいデータの計算、あるいはその両方を行います。
このため、前に述べたものと同じ種類のビットマップテーブルスキャンがあり、その出力が更新される行を格納するUpdateノードに渡されることが分かります。
データ変更ノードが実行時間の多くを費やす可能性があります（現在これが一番多くの時間を費やしています）が、プランナは現在その作業を考慮してコスト推定に何も加えません。
これは、行われる作業がすべての正確な問い合わせ計画の作業と同一であるためであり、このため計画の決定に影響を与えません。
   </p><p>
<span class="original">
    When an &lt;command&gt;UPDATE&lt;/command&gt;, &lt;command&gt;DELETE&lt;/command&gt;, or
    &lt;command&gt;MERGE&lt;/command&gt; command affects a partitioned table or
    inheritance hierarchy, the output might look like this:
</span>
《マッチ度[85.869565]》<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">MERGE</code>コマンドが継承階層に影響する場合には、出力は以下のようになるでしょう。
《機械翻訳》<code class="command">UPDATE</code>、<code class="command">DELETE</code>、または<code class="command">MERGE</code>コマンドがパーティションテーブルや継承階層に影響を与える場合、出力は次のようになります。

</p><pre class="screen">
EXPLAIN UPDATE gtest_parent SET f1 = CURRENT_DATE WHERE f2 = 101;

                                       QUERY PLAN
-------------------------------------------------------------------​---------------------
 Update on gtest_parent  (cost=0.00..3.06 rows=0 width=0)
   Update on gtest_child gtest_parent_1
   Update on gtest_child2 gtest_parent_2
   Update on gtest_child3 gtest_parent_3
   -&gt;  Append  (cost=0.00..3.06 rows=3 width=14)
         -&gt;  Seq Scan on gtest_child gtest_parent_1  (cost=0.00..1.01 rows=1 width=14)
               Filter: (f2 = 101)
         -&gt;  Seq Scan on gtest_child2 gtest_parent_2  (cost=0.00..1.01 rows=1 width=14)
               Filter: (f2 = 101)
         -&gt;  Seq Scan on gtest_child3 gtest_parent_3  (cost=0.00..1.01 rows=1 width=14)
               Filter: (f2 = 101)
EXPLAIN UPDATE parent SET f2 = f2 + 1 WHERE f1 = 101;
                                              QUERY PLAN
-------------------------------------------------------------------​-----------------------------------
 Update on parent  (cost=0.00..24.59 rows=0 width=0)
   Update on parent parent_1
   Update on child1 parent_2
   Update on child2 parent_3
   Update on child3 parent_4
   -&gt;  Result  (cost=0.00..24.59 rows=4 width=14)
         -&gt;  Append  (cost=0.00..24.54 rows=4 width=14)
               -&gt;  Seq Scan on parent parent_1  (cost=0.00..0.00 rows=1 width=14)
                     Filter: (f1 = 101)
               -&gt;  Index Scan using child1_pkey on child1 parent_2  (cost=0.15..8.17 rows=1 width=14)
                     Index Cond: (f1 = 101)
               -&gt;  Index Scan using child2_pkey on child2 parent_3  (cost=0.15..8.17 rows=1 width=14)
                     Index Cond: (f1 = 101)
               -&gt;  Index Scan using child3_pkey on child3 parent_4  (cost=0.15..8.17 rows=1 width=14)
                     Index Cond: (f1 = 101)
</pre><p>

<span class="original">
    In this example the Update node needs to consider three child tables,
    but not the originally-mentioned partitioned table (since that never
    stores any data).  So there are three input
    scanning subplans, one per table.  For clarity, the Update node is
    annotated to show the specific target tables that will be updated, in the
    same order as the corresponding subplans.
</span>
《マッチ度[78.512397]》この例では、Updateノードは元々言及されている親テーブルに加えて3つの子テーブルを考慮することが必要です。
そのため、テーブル毎に1つ、4つの入力スキャン副計画があります。
明確にするため、Updateノードには対応する副計画と同じ順に更新される特定の対象テーブルを示す注釈が付けられています。
《機械翻訳》この例では、更新ノードは3つの子表を考慮する必要がありますが、最初に言及したパーティション表（データを格納しないため）は考慮する必要がありません。
したがって、3つの入力スキャン・サブプランがあり、各表に1つずつあります。
明確にするために、更新ノードには、対応するサブプランと同じ順序で更新される特定のターゲット表が表示されます。
   </p><p>
<span class="original">
    The &lt;literal&gt;Planning time&lt;/literal&gt; shown by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; is the time it took to generate the query plan from the
    parsed query and optimize it. It does not include parsing or rewriting.
</span>
<code class="command">EXPLAIN ANALYZE</code>で表示される<code class="literal">Planning time</code>は、解析された問い合わせから問い合わせ計画を生成し最適化するのに掛かった時間です。
解析と書き換えは含みません。
   </p><p>
<span class="original">
    The &lt;literal&gt;Execution time&lt;/literal&gt; shown by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; includes executor start-up and shut-down time, as well
    as the time to run any triggers that are fired, but it does not include
    parsing, rewriting, or planning time.
    Time spent executing &lt;literal&gt;BEFORE&lt;/literal&gt; triggers, if any, is included in
    the time for the related Insert, Update, or Delete node; but time
    spent executing &lt;literal&gt;AFTER&lt;/literal&gt; triggers is not counted there because
    &lt;literal&gt;AFTER&lt;/literal&gt; triggers are fired after completion of the whole plan.
    The total time spent in each trigger
    (either &lt;literal&gt;BEFORE&lt;/literal&gt; or &lt;literal&gt;AFTER&lt;/literal&gt;) is also shown separately.
    Note that deferred constraint triggers will not be executed
    until end of transaction and are thus not considered at all by
    &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt;.
</span>
<code class="command">EXPLAIN ANALYZE</code>で表示される<code class="literal">Execution time</code>（実行時間）にはエグゼキュータの起動、停止時間、発行される何らかのトリガの実行時間も含まれますが、解析や書き換え、計画作成の時間は含まれません。
<code class="literal">BEFORE</code>トリガがあればその実行時間は関連するInsert、Update、Deleteノード用の時間に含まれます。
しかし、<code class="literal">AFTER</code>トリガは計画全体が完了した後に発行されますので、<code class="literal">AFTER</code>トリガの実行時間は計上されません。
また、各トリガ（<code class="literal">BEFORE</code>、<code class="literal">AFTER</code>のいずれか）で費やされる総時間は別々に表示されます。
しかし、遅延制約トリガはトランザクションが終わるまで実行されませんので、<code class="command">EXPLAIN ANALYZE</code>では考慮されないことに注意してください。
   </p><p>
<span class="original">
    The time shown for the top-level node does not include any time needed
    to convert the query's output data into displayable form or to send it
    to the client.  While &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; will never
    send the data to the client, it can be told to convert the query's
    output data to displayable form and measure the time needed for that,
    by specifying the &lt;literal&gt;SERIALIZE&lt;/literal&gt; option.  That time will
    be shown separately, and it's also included in the
    total &lt;literal&gt;Execution time&lt;/literal&gt;.
</span>
《機械翻訳》最上位ノードに対して表示される時間には、問合せの出力データを表示可能な形式に変換したり、クライアントに送信したりするために必要な時間は含まれません。
<code class="command">EXPLAIN ANALYZE</code>はデータをクライアントに送信することはありませんが、<code class="literal">SERIALIZE</code>オプションを指定することで、問い合わせの出力データを表示可能な形式に変換し、そのために必要な時間を測定するように指示することができます。
その時間は別々に表示され、<code class="literal">Execution time</code>の合計にも含まれます。
   </p></div><div class="sect2" id="USING-EXPLAIN-CAVEATS"><div class="titlepage"><div><div><h3 class="title">14.1.3. 警告 <a href="#USING-EXPLAIN-CAVEATS" class="id_link">#</a></h3></div></div></div><span class="original">
   &lt;title&gt;Caveats&lt;/title&gt;
</span><p>
<span class="original">
    There are two significant ways in which run times measured by
    &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; can deviate from normal execution of
    the same query.  First, since no output rows are delivered to the client,
    network transmission costs are not included.  I/O conversion costs are
    not included either unless &lt;literal&gt;SERIALIZE&lt;/literal&gt; is specified.
    Second, the measurement overhead added by &lt;command&gt;EXPLAIN
    ANALYZE&lt;/command&gt; can be significant, especially on machines with slow
    &lt;function&gt;gettimeofday()&lt;/function&gt; operating-system calls. You can use the
    &lt;xref linkend="pgtesttiming"/&gt; tool to measure the overhead of timing
    on your system.
</span>
《マッチ度[84.169279]》<code class="command">EXPLAIN ANALYZE</code>により測定される実行時間が同じ問い合わせを普通に実行する場合と大きくそれる可能性がある、２つの重大な点があります。
１つ目は、出力行がクライアントに配信されませんので、ネットワーク転送コストとI/O変換に関するコストが含まれないことです。
２つ目は、<code class="command">EXPLAIN ANALYZE</code>によって加わる測定オーバーヘッドが大きくなることが、特に<code class="function">gettimeofday()</code>オペレーティングシステムコールが低速なマシンであり得ることです。
<a class="xref" href="pgtesttiming.html" title="pg_test_timing"><span class="refentrytitle"><span class="application">pg_test_timing</span></span></a>を用いて、使用中のシステムの時間測定にかかるオーバーヘッドを測ることができます。
《機械翻訳》<code class="command">EXPLAIN ANALYZE</code>で測定される実行時間が、同じ問い合わせの通常の実行と異なる2つの重要な方法があります。
まず、出力行がクライアントに配信されないため、ネットワーク転送コストが含まれません。
<code class="literal">SERIALIZE</code>が指定されていない場合、入出力変換コストは含まれません。
第二に、<code class="command">EXPLAIN ANALYZE</code>によって追加される測定オーバーヘッドは、特に<code class="function">gettimeofday()</code>オペレーティングシステムコールが遅いマシンでは、かなり大きくなる可能性があります。
システム上のタイミングのオーバーヘッドを測定するには、<a class="xref" href="pgtesttiming.html" title="pg_test_timing"><span class="refentrytitle"><span class="application">pg_test_timing</span></span></a>ツールを使用します。
   </p><p>
<span class="original">
    &lt;command&gt;EXPLAIN&lt;/command&gt; results should not be extrapolated to situations
    much different from the one you are actually testing; for example,
    results on a toy-sized table cannot be assumed to apply to large tables.
    The planner's cost estimates are not linear and so it might choose
    a different plan for a larger or smaller table.  An extreme example
    is that on a table that only occupies one disk page, you'll nearly
    always get a sequential scan plan whether indexes are available or not.
    The planner realizes that it's going to take one disk page read to
    process the table in any case, so there's no value in expending additional
    page reads to look at an index.  (We saw this happening in the
    &lt;literal&gt;polygon_tbl&lt;/literal&gt; example above.)
</span>
<code class="command">EXPLAIN</code>の結果を試験を行ったものと大きく異なる状況の推定に使ってはいけません。
例えば、小さなテーブルの結果は、巨大なテーブルに適用できるとは仮定できません。
プランナの推定コストは線形ではなく、そのため、テーブルの大小によって異なる計画を選択する可能性があります。
極端な例ですが、テーブルが1ディスクページしか占めない場合、インデックスが使用できる、できないに関係なく、ほとんど常にシーケンシャルスキャン計画を得ることになります。
プランナは、どのような場合でもテーブルを処理するために1ディスクページ読み取りを行うので、インデックスを参照するための追加的ページ読み取りを行う価値がないことを知っています。
（上述の<code class="literal">polygon_tbl</code>の例でこれが起こることを示しています。）
   </p><p>
<span class="original">
    There are cases in which the actual and estimated values won't match up
    well, but nothing is really wrong.  One such case occurs when
    plan node execution is stopped short by a &lt;literal&gt;LIMIT&lt;/literal&gt; or similar
    effect.  For example, in the &lt;literal&gt;LIMIT&lt;/literal&gt; query we used before,
</span>
実際の値と推定値がうまく合わないが本当は間違ったものがない場合があります。
こうした状況の１つは、<code class="literal">LIMIT</code>や同様な効果により計画ノードの実行が短時間で終わる時に起こります。
例えば、以前に使用した<code class="literal">LIMIT</code>問い合わせでは

</p><pre class="screen">
EXPLAIN ANALYZE SELECT * FROM tenk1 WHERE unique1 &lt; 100 AND unique2 &gt; 9000 LIMIT 2;

                                                          QUERY PLAN
-------------------------------------------------------------------​------------------------------------------------------------
 Limit  (cost=0.29..14.33 rows=2 width=244) (actual time=0.051..0.071 rows=2 loops=1)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..70.50 rows=10 width=244) (actual time=0.051..0.070 rows=2 loops=1)
 Limit  (cost=0.29..14.71 rows=2 width=244) (actual time=0.177..0.249 rows=2 loops=1)
   -&gt;  Index Scan using tenk1_unique2 on tenk1  (cost=0.29..72.42 rows=10 width=244) (actual time=0.174..0.244 rows=2 loops=1)
         Index Cond: (unique2 &gt; 9000)
         Filter: (unique1 &lt; 100)
         Rows Removed by Filter: 287
 Planning Time: 0.077 ms
 Execution Time: 0.086 ms
</pre><p>

<span class="original">
    the estimated cost and row count for the Index Scan node are shown as
    though it were run to completion.  But in reality the Limit node stopped
    requesting rows after it got two, so the actual row count is only 2 and
    the run time is less than the cost estimate would suggest.  This is not
    an estimation error, only a discrepancy in the way the estimates and true
    values are displayed.
</span>
インデックススキャンノードの推定コストと行数が実行完了したかのように表示されます。
しかし現実では、Limitノードが２行を取り出した後に行の要求を停止します。
このため実際の行数は２行のみであり、実行時間は提示された推定コストより小さくなります。
これは推定間違いではなく、単なる推定値と本当の値を表示する方法における矛盾です。
   </p><p>
<span class="original">
    Merge joins also have measurement artifacts that can confuse the unwary.
    A merge join will stop reading one input if it's exhausted the other input
    and the next key value in the one input is greater than the last key value
    of the other input; in such a case there can be no more matches and so no
    need to scan the rest of the first input.  This results in not reading all
    of one child, with results like those mentioned for &lt;literal&gt;LIMIT&lt;/literal&gt;.
    Also, if the outer (first) child contains rows with duplicate key values,
    the inner (second) child is backed up and rescanned for the portion of its
    rows matching that key value.  &lt;command&gt;EXPLAIN ANALYZE&lt;/command&gt; counts these
    repeated emissions of the same inner rows as if they were real additional
    rows.  When there are many outer duplicates, the reported actual row count
    for the inner child plan node can be significantly larger than the number
    of rows that are actually in the inner relation.
</span>
またマージ結合には、注意しないと混乱を招く測定上の乱れがあります。
マージ結合は他の入力が使い尽くされ、ある入力の次のキー値が他の入力の最後のキー値より大きい場合、その入力の読み取りを停止します。
このような場合、これ以上一致することはあり得ず、最初の入力の残りをスキャンする必要がありません。
この結果、子のすべては読み取られず、<code class="literal">LIMIT</code>の説明のようになります。
また、外部（最初）の子が重複するキー値を持つ行を含む場合、内部（２番目）の子はバックアップされ、そのキー値が一致する行部分を再度スキャンされます。
<code class="command">EXPLAIN ANALYZE</code>はこうした繰り返される同じ内部行の排出を実際の追加される行と同様に計上します。
外部で多くの重複がある場合、内部の子計画ノードで繰り返される実際の行数は、内部リレーションにおける実際の行数より非常に多くなることがあり得ます。
   </p><p>
<span class="original">
    BitmapAnd and BitmapOr nodes always report their actual row counts as zero,
    due to implementation limitations.
</span>
実装上の制限のため、BitmapAndおよびBitmapOrノードは常に実際の行数をゼロと報告します。
   </p><p>
<span class="original">
    Normally, &lt;command&gt;EXPLAIN&lt;/command&gt; will display every plan node
    created by the planner.  However, there are cases where the executor
    can determine that certain nodes need not be executed because they
    cannot produce any rows, based on parameter values that were not
    available at planning time.  (Currently this can only happen for child
    nodes of an Append or MergeAppend node that is scanning a partitioned
    table.)  When this happens, those plan nodes are omitted from
    the &lt;command&gt;EXPLAIN&lt;/command&gt; output and a &lt;literal&gt;Subplans
    Removed: &lt;replaceable&gt;N&lt;/replaceable&gt;&lt;/literal&gt; annotation appears
    instead.
</span>
通常<code class="command">EXPLAIN</code>はプランナが生成したすべてのプランノードを表示します。
しかし、プラン時にパラメータ値が入手できずそのノードが行を生成できないために、エグゼキューターがあるノードが実行不要であると判断できるケースがあります。
（今の所、これはパーティションテーブルを走査しているAppendあるいはMergeAppendノードの子ノードでのみ起きることがあります。）
これが起きると、これらのプランノードは<code class="command">EXPLAIN</code>の出力から削除され、<code class="literal">Subplans Removed: <em class="replaceable"><code>N</code></em></code>という注釈が代わりに表示されます。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="performance-tips.html" title="第14章 性能に関するヒント">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html" title="第14章 性能に関するヒント">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="planner-stats.html" title="14.2. プランナで使用される統計情報">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">第14章 性能に関するヒント </td><td width="20%" align="center"><a accesskey="h" href="index.html" title="PostgreSQL 17devel文書">ホーム</a></td><td width="40%" align="right" valign="top"> 14.2. プランナで使用される統計情報</td></tr></table></div></body></html>